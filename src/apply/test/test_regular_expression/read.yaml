1、正则仅仅就是用来处理字符串的：匹配、捕获
  匹配：验证当前的字符串是否符合我们的规则（每一个正则都是一个规则）
  捕获：在整个字符串当中，把符合规则的字符都依次的获取到--->exec、match、replace

2、正则的组成：元字符、修饰符
  元字符：
    特殊意义的元字符：
      \d匹配一个0-9的数字相当于[0-9]，和它相反的
      \D匹配一个除了0-9的任意字符相当于【】  
      \w匹配一个0-9、a-z、A-Z_ 的数字或字符，相当于[0-9a-zA-Z_]  、
      \s匹配一个空白字符（空格、制表符。。。）
      \b匹配一个单词的边界 “w100 w000”
      \t匹配一个制表符
      \n匹配一个换行
      . 匹配一个除了\n以外的任意字符
      ^ 以某一个元字符开头
      $ 以某一个元字符结尾
      \ 转译字符
      x|y  x或者y的一个
      [xyz] x、y、z、中的任意一个
      [^xyz]除了x、y、z、中的任意一个
      [a-z] -> 匹配a-z中的任意一个字符
      [^a-z] -> 匹配除了a-z中的任意一个字符
    () 正则中的分组
    量词：
      *  0到多个
      +  1到多个
      ?  0到1个
      ？在正则中的意义比较多
          放在一个非量词元字符后面代表出现0-1次  例如/^\d?$/出现0-9直接的数0到1次
          放在一个量词元字符后面，取消捕获时候的贪婪性  /^\d+?$/捕获的时候只是把第一个捕获的数字获取 "2015"--->2
          (?:)分组值匹配不捕获
          (?=)正向预查
          (?!)负向预查
    ()的作用
      1)改变默认的优先级
      2)可以进行分组捕获
      3)分组引用
        {n}出现n次
        {n,}出现n到多次
        {n,m}出现n到m次
    
    普通元字符
      任何字符在正则中除了以上有特殊意义的，其他的都是代表本身意思的普通元字符
  修饰符：
    i：忽略字母的大小写
    m：multiline 多行匹配
    g：global全局匹配


[]里面出现的任何字符都是代表本身意义的，例如：[.]中的”.“就是代表一个小数点而不是除了\n以外的任意字符
[]里面出现18不是数字18而是1或者8，例如[18-65]是1或者8-6或者5中任选一个

var reg =/^[+-]?(\d|[1-9]\d+)(\.\d+)?$/;
