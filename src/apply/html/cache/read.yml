
缓存过程:
    1. 查本地缓存
    2. 命中强缓存,未过期,直接使用;
    3. 命中协商缓存,发送请求(last-modified,etag); 304- 使用缓存; 200- 使用返回数据,更新资源 
    4. 没有缓存,从服务端获取资源
参考:
    浏览器页面缓存 - Cache【性能篇】: https://blog.csdn.net/weixin_38080573/article/details/130047364
    从chrome源码解读cache缓存策略: https://zhuanlan.zhihu.com/p/265008027
    浏览器缓存看这一篇就够了: https://segmentfault.com/a/1190000018717463

缓存header:
    Vary: HTTP/1.0; 如果response header里有Vary字段，那么Vary里的每个header遍历一遍，要求本次request和cache里上次request的这些header的值一样，否则cache里的资源无效。
    pragma: HTTP/1.0; Request中, 表明不想获取缓存
    Expires: HTTP/1.0; 如果客户端的时间小于Expires的值时，直接使用缓存结果;

    cache-control(HTTP/1.1;):
        Request中:
            Cache-control:no-cache 浏览器不使用缓存
        Response中:
            Cache-Control:public        客户端和代理服务器都可缓存; 配合Expires??
            Cache-Control:private       客户端可以缓存; 默认值; 配合Expires??
            Cache-Control:s-maxage=xxx  代理服务器缓存; 如果在其有效期内，不去访问CDN等。s-maxage会覆盖 max-age 和 Expires
            Cache-Control:max-age=xxx   缓存内容将在xxx秒后失效; 根据本地时间Date?? 优先级高于 Expires
            Cache-Control:max-age=60,must-revalidate	告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验
            Cache-Control:no-cache      客户端缓存; 协商验证
            Cache-Control:no-store      不缓存
    If-None-Match: 协商缓存; 请求时携带 Etag的值; 优先级高于if-modified-since; 缓存有效服务器响应304;
    if-modified-since: 协商缓存; 请求时携带Last-modified的值; 缓存有效服务器响应304;

备注:
    1. 强缓存: 不会向服务器发送请求，直接从缓存中读取资源。
    2. 弱缓存: 验证后使用

chrome 大小字段:
    from memory cache: 不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中; 浏览器自行优化的
    from disk cache: 不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如css等
    报文大小(304): 请求服务端发现资源没有更新，使用本地资源
    资源大小数值(200): 从服务器下载最新资源

用户行为对浏览器缓存的影响:
    打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
    普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
    强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容。

nginx配置:
    expires 1d;
    Cache-Control: max-age=172800
    Expires: Sat, 28 Oct 2023 13:37:58 GMT
    add_header cache control: no cache
        304
