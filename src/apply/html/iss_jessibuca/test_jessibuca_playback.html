<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>录像</title>

    <script src="../js/vue.2.6.12.js"></script>
    <script src="../js/element-ui.index.js"></script>
    <link href="../css/element.index.css" rel="stylesheet">

    <script src="./vconsole.js"></script>
    <script src="./jessibuca-pro-demo.js"></script>
    <script src="./util.js"></script>
    <script src="../js/axios.js"></script>
    <script src="gb28181.js"></script>
</head>
<body>
<div id="app">
    <div style="width: 70%">
        <div id="container"></div>
        <div style="display: flex">
            <el-date-picker v-model="videoInfo.startTime" format="yyyy-MM-dd HH:mm:ss"
                            value-format="yyyy-MM-dd HH:mm:ss"></el-date-picker>
            <div id="id1" @mouseup="log('mouseup')" @mousemove="mousemove" @mouseover="log"
                 @mouseenter="log('mouseenter')"
                 @click="seek" style="width: 50%">
                <el-progress :percentage="percentage"></el-progress>
            </div>
            <el-date-picker v-model="videoInfo.endTime" format="yyyy-MM-dd HH:mm:ss"
                            value-format="yyyy-MM-dd HH:mm:ss"></el-date-picker>
        </div>
        <el-date-picker v-model="seekTime" format="yyyy-MM-dd HH:mm:ss"
                        value-format="yyyy-MM-dd HH:mm:ss"></el-date-picker>
        <el-form>
            <el-form-item label="播放地址:" style="width: 30rem">
                <el-input v-model="playUrl">
                    <el-select v-model="playUrl" slot="prepend">
                        <el-option v-for="item in playUrlConfig" :key="item.value" :label="item.label"
                                   :value="item.value">
                        </el-option>
                    </el-select>
                    <el-button slot="append" icon="el-icon-search">
                    </el-button>
                </el-input>
            </el-form-item>
            <el-button @click="play">播放</el-button>
            <el-button @click="replay">重播</el-button>
            <el-button @click="pause">停止(流会断开)</el-button>
            <el-button @click="playbackPause">停止(流不断开)</el-button>
            <el-button @click="destroy">销毁</el-button>
            <el-button @click="currentTimeScroll">滚动到当前时间</el-button>
            <el-form-item label="倍速:" style="width: 30rem">
                <el-select v-model="rate" @change="ratePlay">
                    <el-option v-for="item in rateConfig" :key="item.value" :label="item.label" :value="item.value">
                    </el-option>
                </el-select>
            </el-form-item>
            <el-form-item>
                <el-button @click="startFinsh">结束事件</el-button>
            </el-form-item>
            <el-form-item label="时间戳:" style="width: 30rem">
                <el-button @click="startTimeRecord">录制时间戳数据</el-button>
                <el-table :data="statsArr">
                    <el-table-column prop="ts" label="ts">
                        <template slot-scope="scope">
                            {{Math.floor(scope.row.ts/1000)}}
                        </template>
                    </el-table-column>
                    <el-table-column prop="dts" label="dts"></el-table-column>
                    <el-table-column prop="pTs" label="pTs"></el-table-column>
                    <el-table-column prop="delayTs" label="delayTs"></el-table-column>
                    <el-table-column prop="totalDelayTs" label="totalDelayTs"></el-table-column>
                    <el-table-column prop="buf" label="buf"></el-table-column>
                    <el-table-column prop="videoCurrentTime" label="videoCurrentTime"></el-table-column>
                    <el-table-column prop="videoCurrentTimeDiff" label="videoCurrentTimeDiff"></el-table-column>
                </el-table>
            </el-form-item>
        </el-form>
        <pre>{{JSON.stringify(videoInfo, null, 2)}}</pre>
    </div>
    <el-form ref="form" :model="form" style="width: 30%; display: flex; flex-wrap: wrap">
        <el-form-item label="缓冲(秒):" style="width: 30rem">
            <el-input type="number" v-model="jessiConf.videoBuffer" style="width: 5rem" @change="replay"></el-input>
        </el-form-item>
        <el-form-item label="缓存延迟(延迟超过会触发丢帧):" style="width: 30rem">
            <el-input placeholder="单位:秒" type="text" v-model="jessiConf.videoBufferDelay"
                      style="width: 5rem"></el-input>
        </el-form-item>
        <el-form-item label="解码(录像流暂只支持SIMD解码):" style="width: 30rem">
            <el-checkbox v-model="jessiConf.useMSE" @change="replay" disabled>MediaSource</el-checkbox>
            <el-checkbox v-model="jessiConf.useWCS" @change="replay" disabled>webcodecs</el-checkbox>
            <el-checkbox v-model="jessiConf.useWASM" @change="replay" disabled>wasm</el-checkbox>
            <el-checkbox v-model="jessiConf.useSIMD" @change="replay" disabled>wasm(simd)</el-checkbox>
        </el-form-item>
        <el-form-item label="渲染标签(录像流暂只支持canvas):" style="width: 30rem">
            <el-checkbox @click="replay" v-model="jessiConf.useVideoRender" disabled>video</el-checkbox>
            <el-checkbox @click="replay" v-model="jessiConf.useCanvasRender">canvas(性能更好)</el-checkbox>
        </el-form-item>
        <el-form-item label="canvas渲染技术(自动降级webgl):" style="width: 30rem">
            <el-checkbox @click="replay" v-model="jessiConf.useWebGPU" :disabled="!isSupportGpu">webgpu</el-checkbox>
            <el-checkbox @click="replay" disabled>webgl(pro 支持 webgl2)</el-checkbox>
        </el-form-item>
        <el-form-item label="是否使用离屏模式:" style="width: 30rem">
            <el-radio v-model="jessiConf.forceNoOffscreen" label="true">是(提升渲染能力)</el-radio>
            <el-radio v-model="jessiConf.forceNoOffscreen" label="false">否</el-radio>
        </el-form-item>
        <el-form-item label="worker解封装(硬解码MSE,WCS):" style="width: 30rem">
            <el-checkbox @click="replay" v-model="jessiConf.demuxUseWorker">使用</el-checkbox>
        </el-form-item>
        <el-form-item label="是否使用硬解码(https支持):" style="width: 30rem">
            <el-select v-model="jessiConf.playbackUseWCS">
                <el-option label="是" :value="true"></el-option>
                <el-option label="否" :value="false" selected></el-option>
            </el-select>
        </el-form-item>
        <el-form-item label="FPS设置:" style="width: 30rem">
            <el-select v-model="jessiConf.isUseFpsRender" style="width: 140px;">
                <el-option label="动态(根据流)" :value="false" selected label=""></el-option>
                <el-option label="定频(本地设置)" :value="true" label=""></el-option>
            </el-select>
        </el-form-item>
        <el-form-item label="是否解码前缓冲数据(定频生效):" style="width: 30rem">
            <el-select v-model="jessiConf.isCacheBeforeDecodeForFpsRender">
                <el-option label="是" :value="true"></el-option>
                <el-option label="否" :value="false" selected></el-option>
            </el-select>
        </el-form-item>
        <el-form-item label="FPS(定频(本地设置)生效):" style="width: 30rem">
            <el-input v-model="jessiConf.playbackFps" style="width: 5rem"></el-input>
        </el-form-item>
        <el-form-item label="不断流暂停是否清除缓存数据:" style="width: 30rem">
            <el-select v-model="isPlaybackPauseClearCache">
                <el-option label="是" :value="true" selected></el-option>
                <el-option label="否" :value="false"></el-option>
            </el-select>
        </el-form-item>
        <el-form-item label="ui是否使用playbackPause:" style="width: 30rem">
            <el-select v-model="uiUsePlaybackPause">
                <el-option label="是" :value="true"></el-option>
                <el-option label="否" :value="false"></el-option>
            </el-select>
        </el-form-item>
        <el-form-item label="日志:" style="width: 30rem">
            <el-select v-model="jessiConf.debug">
                <el-option label="是" :value="true"></el-option>
                <el-option label="否" :value="false"></el-option>
            </el-select>
            <el-select v-model="jessiConf.debugLevel">
                <el-option value="debug"></el-option>
                <el-option value="warn"></el-option>
            </el-select>
            <el-checkbox v-model="isSupportMSEH264" disabled>操作按钮</el-checkbox>
            <el-checkbox v-model="isSupportMSEH264" disabled>网速</el-checkbox>
            <el-checkbox v-model="isSupportMSEH264" disabled>键盘快捷键</el-checkbox>
            <el-checkbox v-model="isSupportMSEH264" disabled>性能面板</el-checkbox>
            <el-input v-model="jessiConf.timeout" style="width: 10rem">
                <template slot="prepend">
                    timeout:
                </template>
            </el-input>
            <el-input v-model="jessiConf.loadingTimeout" style="width: 15rem">
                <template slot="prepend">
                    loadingTimeout:
                </template>
            </el-input>
            <el-input v-model="jessiConf.heartTimeout" style="width: 15rem">
                <template slot="prepend">
                    heartTimeout:
                </template>
            </el-input>
        </el-form-item>
        <el-form-item label="时间:" style="width: 30rem">
            <div>{{ playTimesArray }}</div>
        </el-form-item>
        <el-form-item label="浏览器配置:" style="width: 30rem">
            <div>
                <el-checkbox v-model="isSupportMSEH264" disabled>支持MSE H264解码；</el-checkbox>
                <el-checkbox value="false" disabled> 支持MSE H265解码；(会自动切换成wasm解码)</el-checkbox>
                <el-checkbox v-model="isSupportWCS" disabled> 支持Webcodecs H264解码；</el-checkbox>
                <el-checkbox value="false" disabled> 支持Webcodecs H265解码(不一定准确)；</el-checkbox>
                <el-checkbox v-model="isSupportWasm" disabled> 支持WASM解码</el-checkbox>
                <el-checkbox v-model="isSupportSIMD" disabled> 支持WASM SIMD解码;(会自动切换成wasm解码)</el-checkbox>
            </div>
        </el-form-item>
    </el-form>
</div>
<script>
    let t = new Vue(
        {
            el: '#app',
            data() {
                return {
                    jessiConf: {
                        // 基础, 调试
                        debug: true,
                        debugLevel: 'debug',
                        container: document.getElementById('container'),
                        videoBuffer: 0.2, // 缓存时长
                        videoBufferDelay: 10, // 10s 缓存延迟(延迟超过会触发丢帧)
                        // decoder: 'decoder-pro.js', // 1 默认引用的是根目录下面的decoder-pro.js文件 ，decoder-pro.js 与 decoder-pro.wasm文件必须是放在同一个目录下面

                        timeout: 10, //设置超时时长, 单位秒,在连接成功之前(loading)和播放中途(heart),如果超过设定时长无数据返回,则回调timeout事件
                        loadingTimeout: 10,//设置超时时长, 单位秒,在连接成功之前,如果超过设定时长无数据返回,则回调timeout事件
                        loadingTimeoutReplay: true,//loadingTimeout 心跳超时之后自动再播放,不再抛出异常，而直接重新播放视频地址。
                        loadingTimeoutReplayTimes: -1,// loadingTimeoutReplay 重试失败之后，不再重新播放视频地址。如果想无限次重试，可以设置为-1
                        heartTimeout: 10, //设置超时时长, 单位秒,播放中途,如果超过设定时长无数据返回,则回调timeout事件
                        heartTimeoutReplay: true,//heartTimeout 心跳超时之后自动再播放,不再抛出异常，而直接重新播放视频地址。
                        heartTimeoutReplayTimes: -1,//heartTimeoutReplay 重试失败之后，不再重新播放视频地址。是整个生命周期中重试的次数。如果想无限次重试，可以设置为-1
                        heartTimeoutReplayUseLastFrameShow: true,
                        // 性能, 解码, useMSE 等 互斥??
                        // videoBuffer
                        // decoder
                        useMSE: false, //是否开启MediaSource硬解码;视频编码只支持H.264视频(Safari on iOS不支持); 不支持 forceNoOffscreen 为 false (开启离屏渲染);优先级高于useWCS:true
                        useWCS: false, //是否开启Webcodecs硬解码;视频编码只支持H.264视频 (需在chrome 94版本以上，需要https或者localhost环境);支持 forceNoOffscreen 为 false (开启离屏渲染)
                        useWASM: false,
                        useSIMD: true,

                        useVideoRender: false,
                        useCanvasRender: true,
                        wcsUseVideoRender: false, //webcodecs硬解码是否通过video标签渲染;forceNoOffscreen 设置为false之后(通过OffscreenCanvas渲染之)，wcsUseVideoRender不会生效;现在默认 video标签渲染，提升渲染性能。

                        forceNoOffscreen: true,//不离渲染, 是否不使用离屏模式(提升渲染能力)
                        useWebGPU: true, // 使用WebGPU

                        // demuxUseWorker: false, // work 多线程解封装
                        // audioEngine: "worklet", // 多路 ??

                        isNotMute: false,// 是否开启声音，默认是关闭声音播放的。
                        hasAudio: false, // 是否有音频，如果设置false，则不对音频数据解码，提升性能。
                        playbackForwardMaxRateDecodeIFrame: 4, // 只解码I帧(点击重播按钮生效)

                        autoWasm: true, //在使用MSE或者Webcodecs 播放H265的时候，是否自动降级到wasm模式。设置为false 则直接关闭播放，抛出Error 异常，设置为true 则会自动切换成wasm模式播放。
                        wasmDecodeErrorReplay: true,//是否开启解码失败重新播放;wasm解码报错之后，不再抛出异常，而是直接重新播放视频地址。
                        // UI 配置
                        isResize: false,//当为true的时候:视频画面做等比缩放后,高或宽对齐canvas区域,画面不被拉伸,但有黑边。 等同于 setScaleMode(1) 当为false的时候:视频画面完全填充canvas区域,画面会被拉伸。等同于 setScaleMode(0)
                        controlAutoHide: true,//只有鼠标聚焦到播放器内部才会显示，移除之后，会消失。
                        text: "text 1111",
                        loadingText: "疯狂加载中...",//加载过程中文案。
                        showBandwidth: true, // 显示网速
                        showPerformance: true, // 显示性能
                        hiddenAutoPause: false, //是否开启当页面的'visibilityState'变为'hidden'的时候，自动暂停播放。
                        rotate: 0, //设置旋转角度，只支持，0(默认) ，180，270 三个值。
                        isFullResize: false,// 当为true的时候:视频画面做等比缩放后,完全填充canvas区域,画面不被拉伸,没有黑边,但画面显示不全。等同于 setScaleMode(2)
                        supportDblclickFullscreen: true,//是否支持屏幕的双击事件，触发全屏，取消全屏事件。点击底部的 controls UI条(里面元素)不会触发全屏事件。
                        operateBtns: {
                            fullscreen: false, //fullscreen 是否显示全屏按钮
                            screenshot: false, //是否显示截图按钮
                            play: true,//是否显示播放暂停按钮
                            audio: false,//是否显示声音按钮
                            record: false,//record 是否显示录制按钮
                            ptz: false,
                            quality: false,
                            zoom: false,
                            close: false,
                            scale: false,
                            performance: false,
                            logSave: false,
                            aiFace: false,
                            aiObject: false,
                            fullscreenFn: null,
                            fullscreenExitFn: null,
                            screenshotFn: null,
                            playFn: null,
                            pauseFn: null,
                            recordFn: null,
                            recordStopFn: null
                        },
                        keepScreenOn: true,// 开启屏幕常亮
                        background: "", //背景图片。

                        // 其他
                        isFlv: false, //当为true的时候:ws协议不检验是否以.flv为依据，进行协议解析。
                        hotKey: false,//是否开启键盘快捷键; esc -> 退出全屏；arrowUp -> 声音增加；arrowDown -> 声音减少；
                        recordType: 'mp4',//默认录制的视频格式;支持 webm,mp4 参数
                        useWebFullScreen: false,// 是否使用web全屏(旋转90度)(只会在移动端生效)。
                    },

                    percentage: 0,
                    seekTime: null,
                    videoInfo: {},
                    statsArr: [],

                    form: {},

                    playUrl: '',
                    playUrlConfig: [
                        {
                            label: 12,
                            // value: getUrl2()
                        }
                    ],

                    isUseFpsRender: false,
                    isCacheBeforeDecodeForFpsRender: true,
                    playbackFps: 25,
                    isPlaybackPauseClearCache: true, // 不断流暂停是否清除缓存数据
                    uiUsePlaybackPause: false,
                    playbackUseWCS: false,
                    playTimesArray: [{"start": 1653840000, "end": 1653841624}],

                    jessibuca: null,

                    rate: 1,
                    rateConfig: [
                        {label: '0.25X', value: 0.25},
                        {label: '0.5X', value: 0.5},
                        {label: '1X', value: 1},
                        {label: '2X', value: 2},
                        {label: '4X', value: 4},
                        {label: '8X', value: 8},
                        {label: '16X', value: 16},
                        {label: '-1X', value: -1},
                        {label: '-2X', value: -2},
                        {label: '-4X', value: -4},
                        {label: '-8X', value: -8},
                    ],

                    isSupportMSEH264: checkSupportMSEH264(),
                    isSupportWCS: checkSupportWCS(),
                    isSupportWasm: checkSupportWasm(),
                    isSupportSIMD: checkSupportSIMD(),
                    isSupportGpu: 'gpu' in navigator,

                };
            },
            mounted() {
                this.create();
            },
            unmounted() {
                this.jessibuca.destroy();
            },
            methods: {
                create() {
                    this.jessiConf.container = document.getElementById('container');
                    this.jessibuca = new JessibucaPro(this.jessiConf);

                    // -----------事件-----------------------
                    let _this = this;
                    let _ts = 0;

                    this.jessibuca.on("play", () => {
                        console.log("listenerEvent", "on play");
                    });
                    this.jessibuca.on("pause", function () {
                        console.log("listenerEvent", "on pause");
                    });
                    this.jessibuca.on("playbackPreRateChange", function (rate) { // 点击自带变倍按钮,触发
                        console.log("listenerEvent", 'playbackPreRateChange', rate)
                        this.jessibuca.forward(rate);
                    });
                    this.jessibuca.on('playbackSeek', (data) => {
                        console.log("listenerEvent", 'playbackSeek', data)
                        const currentTime = new Date(1653840000000).setHours(data.hour, data.min, data.second, 0);
                        this.jessibuca.setPlaybackStartTime(currentTime);
                    })
                    this.jessibuca.on("start", function () {
                        console.log("listenerEvent", 'start render')
                        // 如果有截图需求。需要延迟一下，因为代码中无法感应到画面被渲染出来了。
                        // 1s 之后截图
                        // setTimeout(function () {
                        //   this. jessibuca.screenshot('xxx')
                        // }, 1 * 1000)
                    })
                    this.jessibuca.on("load", function () {
                        console.log("listenerEvent", "on load");
                    });
                    this.jessibuca.on("timeout", function (error) {
                        //jessibuca.TIMEOUT.loadingTimeout ; 同loadingTimeout
                        //jessibuca.TIMEOUT.delayTimeout ; 同delayTimeout
                        console.log("listenerEvent", "timeout", error)
                    })
                    this.jessibuca.on("loadingTimeout", function () {
                        console.log("listenerEvent", "loadingTimeout")
                    })
                    this.jessibuca.on("delayTimeout", function () {
                        console.log("listenerEvent", "delayTimeout")
                    })
                    // 信息
                    this.jessibuca.on("buffer", function (buffer) {
                        console.log("listenerEvent", "buffer", buffer);
                    })
                    this.jessibuca.on("videoInfo", function (info) {
                        console.log("listenerEvent", "videoInfo", info);
                    });
                    this.jessibuca.on("audioInfo", function (msg) {
                        console.log("listenerEvent", "audioInfo", msg);
                    });
                    this.jessibuca.on("timeUpdate", function (ts) {// 点击自带进度条触发??
                        console.log("listenerEvent", "timeUpdate,old,new,timestamp", _ts, ts, ts - _ts);
                        _ts = ts;
                    });
                    this.jessibuca.on("playToRenderTimes", function (times) { // 监听调用play方法 经过 初始化-> 网络请求-> 解封装 -> 解码 -> 渲染 一系列过程的时间消耗
                        console.log("listenerEvent", "playToRenderTimes is", times)
                    })
                    this.jessibuca.on("stats", function (stats) {
                        // buf: 当前缓冲区时长，单位毫秒,
                        // fps: 当前视频帧率,
                        // abps: 当前音频码率，单位byte,
                        // vbps: 当前视频码率，单位byte，
                        // ts:当前视频帧pts，单位毫秒
                        if (_this.statsArr.length !== 0) {
                            _this.statsArr.push(Object.assign({}, stats))
                            if (_this.statsArr.length > 500) {
                                _this.statsArr.slice(400, _this.statsArr.length)
                            }
                        }
                        console.log("listenerEvent", "stats", stats, stats.dts, stats.pTs);
                    })
                    this.jessibuca.on("playbackStats", function (stats) {
                        console.log("listenerEvent", "playbackStats", stats);
                    })
                    // this.jessibuca.on("kBps", function (kBps) {
                    //     console.log("listenerEvent","kBps", kBps);
                    // });
                    // this.jessibuca.on("bps", function (bps) {
                    //     console.log("listenerEvent","bps", bps);
                    // });
                    this.jessibuca.on("performance", function (performance) { //渲染性能统计，流开始播放后回调，每秒1次。0: 表示卡顿;1: 表示流畅;2: 表示非常流程
                        console.log("listenerEvent", "performance", performance)
                    });
                    this.jessibuca.on("log", function (msg) { //信息，包含错误信息
                        console.log("listenerEvent", "on log", msg);
                    });
                    this.jessibuca.on("error", function (error) {
                        // jessibuca.ERROR.playError ;播放错误，url 为空的时候，调用play方法
                        // jessibuca.ERROR.fetchError ;http 请求失败
                        // jessibuca.ERROR.websocketError; websocket 请求失败
                        // jessibuca.ERROR.webcodecsH265NotSupport; webcodecs 解码 h265 失败
                        // jessibuca.ERROR.mediaSourceH265NotSupport; mediaSource 解码 h265 失败
                        // jessibuca.ERROR.wasmDecodeError ; wasm 解码失败
                        console.log("listenerEvent", "error", error);
                    });
                },
                async play() {
                    if (!this.playUrl) {
                        return
                    }
                    if (this.isPlaybackPause) {
                        console.log(await gbExist(this.videoInfo.stream))
                        await gbResume(this.videoInfo.stream)
                        this.jessibuca.playbackResume()
                        this.isPlaybackPause = false;
                        return
                    }
                    this.jessibuca.playback(this.playUrl, {
                        playList: this.playTimesArray,
                        fps: this.playbackFps,
                        showControl: true,
                        isUseFpsRender: this.isUseFpsRender,
                        isCacheBeforeDecodeForFpsRender: this.isCacheBeforeDecodeForFpsRender,
                        showRateBtn: true,
                        supportWheel: true,
                        uiUsePlaybackPause: this.uiUsePlaybackPause,
                        isPlaybackPauseClearCache: this.isPlaybackPauseClearCache,
                        rateConfig: this.rateConfig,
                        useWCS: this.playbackUseWCS,
                    });

                    this.isPlaybackPause = false;
                },
                async replay() {
                    await this.getUrl();
                    if (this.jessibuca) {
                        await this.jessibuca.destroy()
                    }
                    this.create();
                    setTimeout(() => {
                        this.play();
                    }, 100)
                },
                async pause() {
                    this.jessibuca.pause();
                },
                async playbackPause() {
                    await gbPause(this.videoInfo.stream)
                    this.jessibuca.playbackPause();
                    this.isPlaybackPause = true;
                },
                destroy() {
                    if (this.jessibuca) {
                        this.jessibuca.destroy();
                    }
                    this.create();
                },
                currentTimeScroll() {
                    if (this.jessibuca) {
                        this.jessibuca.playbackCurrentTimeScroll();
                    }
                },
                async ratePlay() {
                    await gbSpeed(this.videoInfo.stream, this.rate)
                    this.jessibuca.forward(this.rate);
                },

                async startTimeRecord() {
                    this.statsArr = [{}]
                    let _this = this;

                    async function record(x, total) {
                        console.log(new Date(), x)
                        if (x < total) {
                            setTimeout(record, 10000, x + 1, total)
                            let res = await gbSeek(_this.videoInfo.stream, 3600)
                            console.log(res)
                        }
                    }

                    await record(1, 20);
                },
                startFinsh() {
                    if (!this.playUrl) {
                        return
                    }
                    let interval = setInterval(async (streamId) => {
                        let res = await gbExist(streamId)
                        console.log(this.videoInfo.stream, new Date(), res.data && res.data.data, this.jessibuca.isPlaying())
                        // console.log(this.jessibuca.isLive, this.jessibuca.isEof, this.jessibuca.isEos, this.jessibuca.performance, this.jessibuca.endTime)
                    }, 1000, this.videoInfo.stream)

                    setTimeout(() => {
                        clearInterval(interval)
                    }, 60000)
                },
                log(event) {
                    console.log(event)
                },
                mousemove(event) {
                    console.log('mousemove')
                    let ele = document.getElementById("id1")
                    let startTimeStamp = this.videoInfo.startTime.getTime();
                    let endTimeStamp = this.videoInfo.endTime.getTime();
                    // console.log(event.offsetX, ele.offsetWidth, event.offsetX / ele.offsetWidth)
                    let diff = startTimeStamp + (endTimeStamp - startTimeStamp) * ((event.offsetX + 50) / ele.offsetWidth)
                    this.seekTime = new Date(diff)
                    // console.log(event, event.offsetX, event.offsetY)
                },
                async seek() {
                    if (!this.playUrl) {
                        return
                    }
                    let startTimeStamp = this.videoInfo.startTime.getTime();
                    let endTimeStamp = this.videoInfo.endTime.getTime();
                    await gbSeek(this.videoInfo.stream, Math.floor((this.seekTime.getTime() - startTimeStamp) / 1000))
                    this.percentage = (this.seekTime.getTime() - startTimeStamp) / (endTimeStamp - startTimeStamp) * 100

                },
                async getUrl() {
                    let res = await get452BanDao()
                    this.videoInfo = res.data.data
                    this.playUrl = this.videoInfo.https_ts // wss_flv, ws_flv, fmp4
                    this.videoInfo.startTime = new Date(this.videoInfo.startTime.replace(/-/g, '/') + ':000')
                    this.videoInfo.endTime = new Date(this.videoInfo.endTime.replace(/-/g, '/') + ':000')
                },
            },
        }
    );
</script>
</body>
<style>
    * {
        -webkit-user-select: text;
    }

    #app {
        height: 100vh;
        display: flex;
    }

    #container {
        background: rgba(13, 14, 27, 0.7);
        width: 640px;
        height: 398px;
    }
</style>
</html>
