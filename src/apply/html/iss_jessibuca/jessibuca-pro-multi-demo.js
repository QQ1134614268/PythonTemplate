!function (e) {
    "function" == typeof define && define.amd ? define(e) : e()
}(function () {
    "use strict";

    class e {
        on(e, t, i) {
            const r = this.e || (this.e = {});
            return (r[e] || (r[e] = [])).push({fn: t, ctx: i}), this
        }

        once(r, s, a) {
            const n = this;

            function o() {
                n.off(r, o);
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                s.apply(a, t)
            }

            return o._ = s, this.on(r, o, a)
        }

        emit(e) {
            const t = ((this.e || (this.e = {}))[e] || []).slice();
            for (var i = arguments.length, r = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) r[s - 1] = arguments[s];
            for (let e = 0; e < t.length; e += 1) t[e].fn.apply(t[e].ctx, r);
            return this
        }

        off(e, i) {
            const t = this.e || (this.e = {});
            if (!e) return Object.keys(t).forEach(e => {
                delete t[e]
            }), void delete this.e;
            const r = t[e], s = [];
            if (r && i) for (let e = 0, t = r.length; e < t; e += 1) r[e].fn !== i && r[e].fn._ !== i && s.push(r[e]);
            return s.length ? t[e] = s : delete t[e], this
        }
    }

    const t = "fetch", O = "websocket", i = "webTransport", N = "worker", n = "player", j = "playerAudio",
        A = "playbackTF", u = "mp4", z = "webm", G = "flv", H = "flv", W = "webTransport", V = "nakedFlow", K = "fmp4",
        $ = "mpeg4", q = {
            flv: "FLV",
            m7s: "m7s",
            hls: "HLS",
            fmp4: "FMP4",
            mpeg4: "MPEG4",
            webrtc: "Webrtc",
            webTransport: "WebTransport",
            nakedFlow: "裸流"
        }, Y = "canvas", J = "video", Q = "debug", X = "warn", Z = "click", ee = "mouseDownAndUp", _ = "normal",
        te = "simple", ie = "jbprov", re = 1e4, se = {
            url: "",
            playbackConfig: {},
            fullscreenWatermarkConfig: {},
            playType: n,
            playbackForwardMaxRateDecodeIFrame: 4,
            playOptions: {},
            isLive: !0,
            isMulti: !0,
            isCrypto: !1,
            playFailedUseLastFrameShow: !0
        }, ae = {
            playType: n,
            container: "",
            videoBuffer: 1e3,
            videoBufferDelay: 1e3,
            networkDelay: 1e4,
            isResize: !0,
            isFullResize: !1,
            isFlv: !1,
            isHls: !1,
            isFmp4: !1,
            isFmp4Private: !1,
            isWebrtc: !1,
            isWebrtcForZLM: !1,
            isWebrtcForSRS: !1,
            isWebrtcForOthers: !1,
            isNakedFlow: !1,
            isMpeg4: !1,
            debug: !1,
            debugLevel: X,
            debugUuid: "",
            isMulti: !0,
            multiIndex: -1,
            hotKey: !1,
            loadingTimeout: 10,
            heartTimeout: 10,
            timeout: 10,
            pageVisibilityHiddenTimeout: 300,
            loadingTimeoutReplay: !0,
            heartTimeoutReplay: !0,
            loadingTimeoutReplayTimes: 3,
            heartTimeoutReplayTimes: 3,
            heartTimeoutReplayUseLastFrameShow: !1,
            replayUseLastFrameShow: !1,
            supportDblclickFullscreen: !1,
            showBandwidth: !1,
            showPerformance: !1,
            mseCorrectTimeDuration: 20,
            keepScreenOn: !0,
            isNotMute: !1,
            hasAudio: !0,
            hasVideo: !0,
            operateBtns: {
                fullscreen: !1,
                screenshot: !1,
                play: !1,
                audio: !1,
                record: !1,
                ptz: !1,
                quality: !1,
                zoom: !1,
                close: !1,
                scale: !1,
                performance: !1,
                logSave: !1,
                aiFace: !1,
                aiObject: !1,
                fullscreenFn: null,
                fullscreenExitFn: null,
                screenshotFn: null,
                playFn: null,
                pauseFn: null,
                recordFn: null,
                recordStopFn: null
            },
            extendOperateBtns: [],
            contextmenuBtns: [],
            watermarkConfig: {},
            controlAutoHide: !1,
            hasControl: !1,
            loadingIcon: !0,
            loadingText: "",
            background: "",
            backgroundLoadingShow: !1,
            loadingBackground: "",
            loadingBackgroundWidth: 0,
            loadingBackgroundHeight: 0,
            decoder: "decoder-pro.js",
            decoderAudio: "decoder-pro-audio.js",
            decoderHard: "decoder-pro-hard.js",
            decoderWASM: "",
            isDecoderUseCDN: !1,
            url: "",
            rotate: 0,
            mirrorRotate: "none",
            aspectRatio: "default",
            playbackConfig: {
                playList: [],
                fps: "",
                showControl: !0,
                controlType: _,
                duration: 0,
                startTime: "",
                showRateBtn: !1,
                rateConfig: [],
                showPrecision: "",
                showPrecisionBtn: !0,
                isCacheBeforeDecodeForFpsRender: !1,
                uiUsePlaybackPause: !1,
                isPlaybackPauseClearCache: !0,
                isUseFpsRender: !1,
                isUseLocalCalculateTime: !1,
                localOneFrameTimestamp: 40,
                supportWheel: !1,
                useWCS: !1
            },
            qualityConfig: [],
            defaultStreamQuality: "",
            scaleConfig: ["拉伸", "缩放", "正常"],
            forceNoOffscreen: !0,
            hiddenAutoPause: !1,
            protocol: 2,
            demuxType: H,
            useWasm: !1,
            useWCS: !1,
            useSIMD: !0,
            wcsUseVideoRender: !0,
            wcsUseWebgl2Render: !0,
            wasmUseVideoRender: !0,
            mseUseCanvasRender: !1,
            hlsUseCanvasRender: !1,
            useMSE: !1,
            useOffscreen: !1,
            useWebGPU: !1,
            mseDecodeErrorReplay: !0,
            wcsDecodeErrorReplay: !0,
            wasmDecodeErrorReplay: !0,
            simdDecodeErrorReplay: !0,
            autoWasm: !0,
            webglAlignmentErrorReplay: !0,
            webglContextLostErrorReplay: !0,
            openWebglAlignment: !1,
            syncAudioAndVideo: !1,
            playbackDelayTime: 1e3,
            playbackFps: 25,
            playbackForwardMaxRateDecodeIFrame: 4,
            playbackCurrentTimeMove: !0,
            useVideoRender: !0,
            useCanvasRender: !1,
            networkDelayTimeoutReplay: !1,
            recordType: u,
            checkFirstIFrame: !0,
            nakedFlowFps: 25,
            audioEngine: null,
            isShowRecordingUI: !0,
            isShowZoomingUI: !0,
            useFaceDetector: !1,
            useObjectDetector: !1,
            ptzClickType: Z,
            ptzStopEmitDelay: .3,
            ptzZoomShow: !1,
            ptzApertureShow: !1,
            ptzFocusShow: !1,
            ptzMoreArrowShow: !1,
            weiXinInAndroidAudioBufferSize: 4800,
            isCrypto: !1,
            isSm4Crypto: !1,
            sm4CryptoKey: "",
            cryptoKey: "",
            cryptoIV: "",
            cryptoKeyUrl: "",
            autoResize: !1,
            useWebFullScreen: !1,
            ptsMaxDiff: 3600,
            aiFaceDetectWidth: 192,
            aiObjectDetectWidth: 192,
            videoRenderSupportScale: !0,
            mediaSourceTsIsMaxDiffReplay: !0,
            controlHtml: "",
            isH265: !1,
            isWebrtcH265: !1,
            supportLockScreenPlayAudio: !0,
            supportHls265: !1,
            isEmitSEI: !1,
            pauseAndNextPlayUseLastFrameShow: !1,
            demuxUseWorker: !1,
            playFailedAndPausedReplay: !1,
            videoElementPlayingFailedReplay: !0
        }, ne = "init", oe = "initVideo", le = "initAudio", de = "audioCode", he = "videoCode", ce = "videoCodec",
        ue = "workerEnd", pe = "closeEnd", w = {
            fullscreen: "fullscreen$2",
            webFullscreen: "webFullscreen",
            decoderWorkerInit: "decoderWorkerInit",
            play: "play",
            playing: "playing",
            pause: "pause",
            mute: "mute",
            load: "load",
            loading: "loading",
            zooming: "zooming",
            videoInfo: "videoInfo",
            timeUpdate: "timeUpdate",
            audioInfo: "audioInfo",
            log: "log",
            error: "error",
            kBps: "kBps",
            timeout: "timeout",
            delayTimeout: "delayTimeout",
            delayTimeoutRetryEnd: "delayTimeoutRetryEnd",
            loadingTimeout: "loadingTimeout",
            loadingTimeoutRetryEnd: "loadingTimeoutRetryEnd",
            stats: "stats",
            performance: "performance",
            videoSmooth: "videoSmooth",
            faceDetectActive: "faceDetectActive",
            objectDetectActive: "objectDetectActive",
            record: "record",
            recording: "recording",
            recordingTimestamp: "recordingTimestamp",
            recordStart: "recordStart",
            recordEnd: "recordEnd",
            recordCreateError: "recordCreateError",
            recordBlob: "recordBlob",
            buffer: "buffer",
            videoFrame: "videoFrame",
            videoSEI: "videoSEI",
            start: "start",
            metadata: "metadata",
            resize: "resize",
            volumechange: "volumechange",
            destroy: "destroy",
            beforeDestroy: "beforeDestroy",
            streamEnd: "streamEnd",
            streamRate: "streamRate",
            streamAbps: "streamAbps",
            streamVbps: "streamVbps",
            streamDts: "streamDts",
            streamSuccess: "streamSuccess",
            streamMessage: "streamMessage",
            streamError: "streamError",
            streamStats: "streamStats",
            mseSourceOpen: "mseSourceOpen",
            mseSourceClose: "mseSourceClose",
            mseSourceended: "mseSourceended",
            mseSourceBufferError: "mseSourceBufferError",
            mseAddSourceBufferError: "mseAddSourceBufferError",
            mseSourceBufferBusy: "mseSourceBufferBusy",
            mseSourceBufferFull: "mseSourceBufferFull",
            videoWaiting: "videoWaiting",
            videoTimeUpdate: "videoTimeUpdate",
            videoSyncAudio: "videoSyncAudio",
            playToRenderTimes: "playToRenderTimes",
            playbackTime: "playbackTime",
            playbackTimestamp: "playbackTimestamp",
            playbackTimeScroll: "playbackTimeScroll",
            playbackPrecision: "playbackPrecision",
            playbackShowPrecisionChange: "playbackShowPrecisionChange",
            playbackJustTime: "playbackJustTime",
            playbackStats: "playbackStats",
            playbackSeek: "playbackSeek",
            playbackPause: "playbackPause",
            playbackPauseOrResume: "playbackPauseOrResume",
            playbackRateChange: "playbackRateChange",
            playbackPreRateChange: "playbackPreRateChange",
            ptz: "ptz",
            streamQualityChange: "streamQualityChange",
            visibilityChange: "visibilityChange",
            netBuf: "netBuf",
            close: "close",
            networkDelayTimeout: "networkDelayTimeout",
            togglePerformancePanel: "togglePerformancePanel",
            viewResizeChange: "viewResizeChange",
            flvDemuxBufferSizeTooLarge: "flvDemuxBufferSizeTooLarge",
            talkGetUserMediaSuccess: "talkGetUserMediaSuccess",
            talkGetUserMediaFail: "talkGetUserMediaFail",
            talkGetUserMediaTimeout: "talkGetUserMediaTimeout",
            talkStreamStart: "talkStreamStart",
            talkStreamOpen: "talkStreamOpen",
            talkStreamClose: "talkStreamClose",
            talkStreamError: "talkStreamError",
            talkStreamInactive: "talkStreamInactive",
            webrtcDisconnect: "webrtcDisconnect",
            webrtcFailed: "webrtcFailed",
            webrtcClosed: "webrtcClosed",
            webrtcOnConnectionStateChange: "webrtcOnConnectionStateChange",
            webrtcOnIceConnectionStateChange: "webrtcOnIceConnectionStateChange",
            crashLog: "crashLog",
            focus: "focus",
            blur: "blur",
            visibilityHiddenTimeout: "visibilityHiddenTimeout",
            websocketOpen: "websocketOpen",
            websocketClose: "websocketClose",
            websocketError: "websocketError",
            websocketMessage: "websocketMessage",
            aiObjectDetectorInfo: "aiObjectDetectorInfo",
            aiFaceDetector: "aiFaceDetector",
            playFailedAndPaused: "playFailedAndPaused",
            audioResumeState: "audioResumeState",
            webrtcStreamH265: "webrtcStreamH265",
            flvMetaData: "flvMetaData",
            talkFailedAndStop: "talkFailedAndStop",
            removeLoadingBgImage: "removeLoadingBgImage",
            memoryLog: "memoryLog",
            downloadMemoryLog: "downloadMemoryLog"
        }, fe = {
            load: w.load,
            timeUpdate: w.timeUpdate,
            videoInfo: w.videoInfo,
            audioInfo: w.audioInfo,
            error: w.error,
            kBps: w.kBps,
            start: w.start,
            timeout: w.timeout,
            loadingTimeout: w.loadingTimeout,
            loadingTimeoutRetryEnd: w.loadingTimeoutRetryEnd,
            delayTimeout: w.delayTimeout,
            delayTimeoutRetryEnd: w.delayTimeoutRetryEnd,
            fullscreen: "fullscreen",
            multiFullscreen: "multiFullscreen",
            webFullscreen: w.webFullscreen,
            play: w.play,
            pause: w.pause,
            mute: w.mute,
            stats: w.stats,
            performance: w.performance,
            recordingTimestamp: w.recordingTimestamp,
            recordStart: w.recordStart,
            recordEnd: w.recordEnd,
            recordBlob: w.recordBlob,
            playToRenderTimes: w.playToRenderTimes,
            playbackSeek: w.playbackSeek,
            playbackStats: w.playbackStats,
            playbackTimestamp: w.playbackTimestamp,
            playbackPauseOrResume: w.playbackPauseOrResume,
            playbackPreRateChange: w.playbackPreRateChange,
            playbackRateChange: w.playbackRateChange,
            playbackShowPrecisionChange: w.playbackShowPrecisionChange,
            ptz: w.ptz,
            streamQualityChange: w.streamQualityChange,
            zooming: w.zooming,
            crashLog: w.crashLog,
            focus: w.focus,
            blur: w.blur,
            visibilityHiddenTimeout: w.visibilityHiddenTimeout,
            visibilityChange: w.visibilityChange,
            websocketOpen: w.websocketOpen,
            websocketClose: w.websocketClose,
            networkDelayTimeout: w.networkDelayTimeout,
            aiObjectDetectorInfo: w.aiObjectDetectorInfo,
            playFailedAndPaused: w.playFailedAndPaused,
            streamEnd: w.streamEnd,
            audioResumeState: w.audioResumeState,
            videoSEI: w.videoSEI,
            flvMetaData: w.flvMetaData,
            webrtcOnConnectionStateChange: w.webrtcOnConnectionStateChange,
            webrtcOnIceConnectionStateChange: w.webrtcOnIceConnectionStateChange
        }, me = {
            talkStreamClose: w.talkStreamClose,
            talkStreamError: w.talkStreamError,
            talkStreamInactive: w.talkStreamInactive,
            talkGetUserMediaTimeout: w.talkGetUserMediaTimeout,
            talkFailedAndStop: w.talkFailedAndStop
        }, S = {
            playError: "playIsNotPauseOrUrlIsNull",
            fetchError: "fetchError",
            websocketError: "websocketError",
            webcodecsH265NotSupport: "webcodecsH265NotSupport",
            webcodecsDecodeError: "webcodecsDecodeError",
            webcodecsUnsupportedConfigurationError: "webcodecsUnsupportedConfigurationError",
            mediaSourceH265NotSupport: "mediaSourceH265NotSupport",
            mediaSourceDecoderConfigurationError: "mediaSourceDecoderConfigurationError",
            mediaSourceFull: w.mseSourceBufferFull,
            mseSourceBufferError: w.mseSourceBufferError,
            mseAddSourceBufferError: w.mseAddSourceBufferError,
            mediaSourceAppendBufferError: "mediaSourceAppendBufferError",
            mediaSourceBufferListLarge: "mediaSourceBufferListLarge",
            mediaSourceAppendBufferEndTimeout: "mediaSourceAppendBufferEndTimeout",
            mediaSourceTsIsMaxDiff: "mediaSourceTsIsMaxDiff",
            mediaSourceUseCanvasRenderPlayFailed: "mediaSourceUseCanvasRenderPlayFailed",
            wasmDecodeError: "wasmDecodeError",
            wasmUseVideoRenderError: "wasmUseVideoRenderError",
            hlsError: "hlsError",
            webrtcError: "webrtcError",
            webrtcClosed: w.webrtcClosed,
            webrtcIceCandidateError: "webrtcIceCandidateError",
            webglAlignmentError: "webglAlignmentError",
            wasmWidthOrHeightChange: "wasmWidthOrHeightChange",
            mseWidthOrHeightChange: "mseWidthOrHeightChange",
            wcsWidthOrHeightChange: "wcsWidthOrHeightChange",
            tallWebsocketClosedByError: "tallWebsocketClosedByError",
            flvDemuxBufferSizeTooLarge: w.flvDemuxBufferSizeTooLarge,
            wasmDecodeVideoNoResponseError: "wasmDecodeVideoNoResponseError",
            audioChannelError: "audioChannelError",
            simdH264DecodeVideoWidthIsTooLarge: "simdH264DecodeVideoWidthIsTooLarge",
            simdDecodeError: "simdDecodeError",
            webglContextLostError: "webglContextLostError",
            videoElementPlayingFailed: "videoElementPlayingFailed",
            videoElementPlayingFailedForWebrtc: "videoElementPlayingFailedForWebrtc",
            decoderWorkerInitError: "decoderWorkerInitError"
        }, ge = "notConnect", ye = "open", l = {download: "download", base64: "base64", blob: "blob"}, Ae = "download",
        be = "blob", ve = {7: "H264(AVC)", 12: "H265(HEVC)", 99: "MPEG4"}, _e = "H264(AVC)", we = "H265(HEVC)",
        Se = {AAC: "AAC", ALAW: "ALAW(g711a)", MULAW: "MULAW(g711u)", MP3: "MP3"},
        Ee = {10: "AAC", 7: "ALAW", 8: "MULAW", 2: "MP3"}, Te = 6, ke = "webcodecs", xe = "webgl", Ce = "webgpu",
        Le = "offscreen", De = "mse", Ie = 'video/mp4; codecs="avc1.64002A"',
        Re = 'video/mp4; codecs="hev1.1.6.L123.b0"', Pe = "oneHour", Be = "halfHour", Ue = "fiveMin",
        Fe = {oneHour: "one-hour", halfHour: "half-hour", tenMin: "ten-min", fiveMin: "five-min"},
        Me = ["oneHour", "halfHour", "tenMin", "fiveMin"],
        Oe = ["up", "right", "down", "left", "left-up", "right-up", "left-down", "right-down"], Ne = "stop",
        je = "fiStop", ze = "zoomExpand", Ge = "zoomNarrow", He = "apertureFar", We = "apertureNear", Ve = "focusFar",
        Ke = "focusNear", $e = "g711a", qe = "g711u", d = {png: "image/png", jpeg: "image/jpeg", webp: "image/webp"},
        Ye = "canplay", Je = "waiting", Qe = "timeupdate", Xe = "ratechange", Ze = "worklet", et = {
            encType: $e,
            packetType: "rtp",
            packetTcpSendType: "tcp",
            rtpSsrc: "0000000000",
            numberChannels: 1,
            sampleRate: 8e3,
            sampleBitsWidth: 16,
            sendInterval: 20,
            debug: !1,
            debugLevel: X,
            testMicrophone: !1,
            saveRtpToFile: !1,
            audioBufferLength: 160,
            engine: Ze,
            checkGetUserMediaTimeout: !1,
            getUserMediaTimeout: 1e4,
            audioConstraints: {
                latency: !0,
                noiseSuppression: !0,
                autoGainControl: !0,
                echoCancellation: !0,
                sampleRate: 48e3,
                channelCount: 1
            }
        }, tt = "worklet", it = "script", rt = "active", st = {
            name: "",
            index: 0,
            icon: "",
            iconHover: "",
            iconTitle: "",
            activeIcon: "",
            activeIconHover: "",
            activeIconTitle: "",
            click: null,
            activeClick: null
        }, at = {content: "", click: null, index: 0}, nt = {
            container: "",
            maxSplit: 4,
            split: 1,
            supportDblclickContainerFullscreen: !0,
            style: {border: "#343434", borderSelect: "#FFCC00", background: "#000"}
        }, ot = {
            dblSelected: "multiDblSelected",
            selected: "multiSelected",
            mouseOver: "multiMouseover",
            mouseOut: "multiMouseout",
            mouseUp: "multiMouseup"
        }, lt = "3-1", dt = "4-1", ht = "load-retry", ct = "load-start";

    class ut {
        constructor(a) {
            this.log = function (e) {
                if (a._opt.debug && a._opt.debugLevel == Q) {
                    for (var t = a._opt.debugUuid ? `[${a._opt.debugUuid}]` : "", i = arguments.length, r = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) r[s - 1] = arguments[s];
                    console.log(`JbPro${t}[✅✅✅][${e}]`, ...r)
                }
            }, this.warn = function (e) {
                if (a._opt.debug && (a._opt.debugLevel == Q || a._opt.debugLevel == X)) {
                    for (var t = a._opt.debugUuid ? `[${a._opt.debugUuid}]` : "", i = arguments.length, r = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) r[s - 1] = arguments[s];
                    console.log(`JbPro${t}[❗❗❗][${e}]`, ...r)
                }
            }, this.error = function (e) {
                for (var t = a._opt.debugUuid ? `[${a._opt.debugUuid}]` : "", i = arguments.length, r = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) r[s - 1] = arguments[s];
                console.error(`JbPro${t}[❌❌❌][${e}]`, ...r)
            }
        }
    }

    var B = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

    function pt(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
    }

    function ft(e, t) {
        return e(t = {exports: {}}, t.exports), t.exports
    }

    var g = ft(function (e) {
        var n, t, o, i, r;
        n = "undefined" != typeof window && void 0 !== window.document ? window.document : {}, t = e.exports, o = function () {
            for (var e, t = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]], i = 0, r = t.length, s = {}; i < r; i++) if ((e = t[i]) && e[1] in n) {
                for (i = 0; i < e.length; i++) s[t[0][i]] = e[i];
                return s
            }
            return !1
        }(), i = {change: o.fullscreenchange, error: o.fullscreenerror}, r = {
            request: function (s, a) {
                return new Promise(function (e, t) {
                    var i = function () {
                        this.off("change", i), e()
                    }.bind(this), r = (this.on("change", i), (s = s || n.documentElement)[o.requestFullscreen](a));
                    r instanceof Promise && r.then(i).catch(t)
                }.bind(this))
            }, exit: function () {
                return new Promise(function (e, t) {
                    var i, r;
                    this.isFullscreen ? (i = function () {
                        this.off("change", i), e()
                    }.bind(this), this.on("change", i), (r = n[o.exitFullscreen]()) instanceof Promise && r.then(i).catch(t)) : e()
                }.bind(this))
            }, toggle: function (e, t) {
                return this.isFullscreen ? this.exit() : this.request(e, t)
            }, onchange: function (e) {
                this.on("change", e)
            }, onerror: function (e) {
                this.on("error", e)
            }, on: function (e, t) {
                e = i[e];
                e && n.addEventListener(e, t, !1)
            }, off: function (e, t) {
                e = i[e];
                e && n.removeEventListener(e, t, !1)
            }, raw: o
        }, o ? (Object.defineProperties(r, {
            isFullscreen: {
                get: function () {
                    return Boolean(n[o.fullscreenElement])
                }
            }, element: {
                enumerable: !0, get: function () {
                    return n[o.fullscreenElement]
                }
            }, isEnabled: {
                enumerable: !0, get: function () {
                    return Boolean(n[o.fullscreenEnabled])
                }
            }
        }), t ? e.exports = r : window.screenfull = r) : t ? e.exports = {isEnabled: !1} : window.screenfull = {isEnabled: !1}
    });

    function mt(e) {
        var {profile: e, sampleRate: t, channel: i} = e;
        return new Uint8Array([175, 0, e << 3 | (14 & t) >> 1, (1 & t) << 7 | i << 3])
    }

    g.isEnabled;
    const gt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], yt = gt;

    function At(e, t) {
        return 1024 * (1 < arguments.length && void 0 !== t ? t : 9e4) / e
    }

    const bt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];

    function o() {
    }

    function vt(e) {
        let t = null;
        var i = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
        let r = 0;
        for (; !t && r < i.length;) {
            var s = i[r];
            try {
                var a = {preserveDrawingBuffer: !0};
                t = e.getContext(s, a)
            } catch (e) {
                console.error(e), t = null
            }
            t && "function" == typeof t.getParameter || (t = null), ++r
        }
        return t
    }

    function _t(e) {
        return e.getContext("webgl2")
    }

    function wt(e) {
        let t = 0 < arguments.length && void 0 !== e ? e : "";
        const i = t.split(","), r = atob(i[1]), s = i[0].replace("data:", "").replace(";base64", "");
        let a = r.length, n = new Uint8Array(a);
        for (; a--;) n[a] = r.charCodeAt(a);
        return new File([n], "file", {type: s})
    }

    function p() {
        return (new Date).getTime()
    }

    function E(e, t, i) {
        return Math.max(Math.min(e, Math.max(t, i)), Math.min(t, i))
    }

    function T(t, i, e) {
        t && ("object" == typeof i && Object.keys(i).forEach(e => {
            T(t, e, i[e])
        }), t.style[i] = e)
    }

    function St(e, t, i) {
        i = !(2 < arguments.length && void 0 !== i) || i;
        if (!e) return 0;
        e = getComputedStyle(e, null).getPropertyValue(t);
        return i ? parseFloat(e) : e
    }

    function Et() {
        return (performance && "function" == typeof performance.now ? performance : Date).now()
    }

    function Tt(i) {
        let r = 0, s = Et();
        return e => {
            var t;
            h(e) && (r += e, 1e3 <= (t = (e = Et()) - s) && (i(r / t * 1e3), s = e, r = 0))
        }
    }

    try {
        if ("object" == typeof WebAssembly && "function" == typeof WebAssembly.instantiate) {
            var kt = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
            if (kt instanceof WebAssembly.Module) new WebAssembly.Instance(kt), WebAssembly.Instance
        }
    } catch (e) {
    }

    function y() {
        return /iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase())
    }

    function xt() {
        return !y() && !/ipad|android(?!.*mobile)|tablet|kindle|silk/i.test(window.navigator.userAgent.toLowerCase())
    }

    function Ct() {
        var e = window.navigator.userAgent.toLowerCase();
        return /android/i.test(e)
    }

    function Lt() {
        const t = window.navigator.userAgent.toLowerCase() || "", i = {type: "", version: ""}, e = {
            IE: window.ActiveXObject || "ActiveXObject" in window,
            Chrome: -1 < t.indexOf("chrome") && -1 < t.indexOf("safari"),
            Firefox: -1 < t.indexOf("firefox"),
            Opera: -1 < t.indexOf("opera"),
            Safari: -1 < t.indexOf("safari") && -1 == t.indexOf("chrome"),
            Edge: -1 < t.indexOf("edge"),
            QQBrowser: /qqbrowser/.test(t),
            WeixinBrowser: /MicroMessenger/i.test(t)
        };
        for (var r in e) if (e[r]) {
            let e = "";
            if ("IE" === r) {
                const i = t.match(/(msie\s|trident.*rv:)([\w.]+)/);
                i && 2 < i.length && (e = t.match(/(msie\s|trident.*rv:)([\w.]+)/)[2])
            } else if ("Chrome" === r) {
                for (var s in navigator.mimeTypes) "application/360softmgrplugin" === navigator.mimeTypes[s].type && (r = "360");
                const i = t.match(/chrome\/([\d.]+)/);
                i && 1 < i.length && (e = i[1])
            } else if ("Firefox" === r) {
                const i = t.match(/firefox\/([\d.]+)/);
                i && 1 < i.length && (e = i[1])
            } else if ("Opera" === r) {
                const i = t.match(/opera\/([\d.]+)/);
                i && 1 < i.length && (e = i[1])
            } else if ("Safari" === r) {
                const i = t.match(/version\/([\d.]+)/);
                i && 1 < i.length && (e = i[1])
            } else if ("Edge" === r) {
                const i = t.match(/edge\/([\d.]+)/);
                i && 1 < i.length && (e = i[1])
            } else if ("QQBrowser" === r) {
                const i = t.match(/qqbrowser\/([\d.]+)/);
                i && 1 < i.length && (e = i[1])
            }
            i.type = r, i.version = parseInt(e)
        }
        return i
    }

    function Dt() {
        var e = window.navigator.userAgent.toLowerCase();
        return e && /iphone|ipad|ipod|ios/.test(e)
    }

    function It() {
        const e = window.navigator.userAgent;
        return !e.match(/Chrome/gi) && e.match(/Safari/gi)
    }

    function Rt(e, t) {
        if (0 === arguments.length) return null;
        var t = t || "{y}-{m}-{d} {h}:{i}:{s}",
            e = "object" == typeof e ? e : (e = +(e = 10 === ("" + e).length ? 1e3 * parseInt(e) : e), new Date(e)),
            r = {
                y: e.getFullYear(),
                m: e.getMonth() + 1,
                d: e.getDate(),
                h: e.getHours(),
                i: e.getMinutes(),
                s: e.getSeconds(),
                a: e.getDay()
            };
        return t.replace(/{(y|m|d|h|i|s|a)+}/g, (e, t) => {
            var i = r[t];
            return "a" === t ? ["一", "二", "三", "四", "五", "六", "日"][i - 1] : (i = 0 < e.length && i < 10 ? "0" + i : i) || 0
        })
    }

    function Pt() {
        return "VideoFrame" in window
    }

    function Bt(e) {
        if ("string" != typeof e) return e;
        var t = Number(e);
        return isNaN(t) ? e : t
    }

    function Ut() {
        return "xxxxxxxxxxxx4xxx".replace(/[xy]/g, function (e) {
            var t = 16 * Math.random() | 0;
            return ("x" == e ? t : 3 & t | 8).toString(16)
        })
    }

    function Ft(s, a) {
        let n, o, l = !1;
        return function e() {
            for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
            if (l) return n = i, void (o = this);
            l = !0, s.apply(this, i), setTimeout(() => {
                l = !1, n && (e.apply(o, n), n = null, o = null)
            }, a)
        }
    }

    function Mt(e) {
        if (null == e || "" == e) return "0 Bytes";
        var t = new Array("Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"), e = parseFloat(e),
            i = Math.floor(Math.log(e) / Math.log(1024));
        return (e / Math.pow(1024, i)).toFixed(2) + t[i]
    }

    function h(e) {
        return "[object Number]" === Object.prototype.toString.call(e)
    }

    function Ot() {
        let e = !1;
        return e = "MediaSource" in window && window.MediaSource.isTypeSupported(Re) ? !0 : e
    }

    function Nt() {
        const e = Lt();
        return "chrome" === e.type.toLowerCase() && 107 <= e.version
    }

    function jt() {
        let e = !1;
        return e = "MediaStreamTrackGenerator" in window ? !0 : e
    }

    function zt() {
        let e = !1;
        return e = "MediaStream" in window ? !0 : e
    }

    function Gt(e, t) {
        let i = window.URL.createObjectURL(t), r = window.document.createElement("a"),
            s = (r.download = e, r.href = i, window.document.createEvent("MouseEvents"));
        s.initEvent("click", !0, !0), r.dispatchEvent(s), setTimeout(() => {
            window.URL.revokeObjectURL(i)
        }, Dt() ? 1e3 : 0)
    }

    function c(e) {
        return null == e
    }

    function Ht(e) {
        return !0 === e || !1 === e
    }

    function x(e) {
        return !c(e)
    }

    function Wt(e) {
        var t = {
            left: "",
            right: "",
            top: "",
            bottom: "",
            opacity: 1,
            backgroundColor: "",
            image: {src: "", width: "100", height: "60"},
            text: {content: "", fontSize: "14", color: "#000"},
            rect: {color: "", lineWidth: 2, width: "", height: ""},
            html: ""
        }, i = Object.assign(t.image, e.image || {}), r = Object.assign(t.text, e.text || {});
        return Object.assign(t, e, {image: i, text: r})
    }

    function Vt(e, t) {
        e = {container: e || "", text: "", opacity: "", angle: "", color: "", fontSize: "", fontFamily: ""};
        return {
            watermark_parent_node: (e = Object.assign(e, t)).container,
            watermark_alpha: e.opacity,
            watermark_angle: e.angle,
            watermark_fontsize: e.fontSize,
            watermark_color: e.color,
            watermark_font: e.fontFamily,
            watermark_txt: e.text
        }
    }

    function Kt(e, d) {
        return new Promise((t, i) => {
            let r = Wt(d);
            if (!r.image.src && !r.text.content) return t(e);
            let s = document.createElement("canvas"), a = (s.width = d.width, s.height = d.height, s.getContext("2d")),
                n = 0, o = 0;
            h(r.left) ? n = r.left : h(r.right) && (n = s.width - r.right), h(r.top) ? o = r.top : h(r.bottom) && (o = s.height - r.bottom);
            const l = new Image;
            l.src = e, l.onload = () => {
                if (a.drawImage(l, 0, 0), r.image && r.image.src) {
                    const e = new Image;
                    e.src = r.image.src, e.setAttribute("crossOrigin", "Anonymous"), e.onload = () => {
                        n -= r.image.width, a.drawImage(e, n, o, r.image.width, r.image.height), t(s.toDataURL(d.format, d.quality))
                    }, e.onerror = e => {
                        i()
                    }
                } else r.text && r.text.content && (a.font = r.text.fontSize + "px 宋体", a.fillStyle = r.text.color, a.textAlign = "right", a.fillText(r.text.content, n, o), t(s.toDataURL(d.format, d.quality)))
            }, l.onerror = e => {
                i(e)
            }
        })
    }

    function $t(e) {
        var t, i;
        return -1 < e && (t = e % 60, i = (i = Math.floor(e / 3600)) < 10 ? "0" + i + ":" : i + ":", (e = Math.floor(e / 60) % 60) < 10 && (i += "0"), i += e + ":", (t = Math.round(t)) < 10 && (i += "0"), i += t.toFixed(0)), i
    }

    function qt(e) {
        let t = "";
        var i, r;
        return -1 < e && (i = Math.floor(e / 60 / 60) % 60, r = Math.floor(e / 60) % 60, e = e % 60, r = Math.round(r), t = i < 10 ? "0" + i + ":" : i + ":", r < 10 && (t += "0"), t += r + ":", e < 10 && (t += "0"), t += e), t
    }

    function Yt(e, t) {
        var i = Math.floor(t / 60 / 60) % 60, r = Math.floor(t / 60) % 60, t = t % 60;
        return new Date(e).setHours(i, r, t, 0)
    }

    function Jt(e) {
        return ("" + e).length
    }

    function Qt(e) {
        return !e || 0 !== Object.keys(e).length
    }

    function Xt(e) {
        return "string" == typeof e
    }

    const Zt = () => {
        var e = window.navigator.userAgent;
        return /MicroMessenger/i.test(e)
    };

    function ei(e) {
        e = e || window.event;
        return e.target || e.srcElement
    }

    function b(e) {
        return "function" == typeof e
    }

    function ti(i) {
        if (y()) {
            let e = 0, t = 0;
            return 1 === i.touches.length && (r = i.touches[0], e = r.clientX, t = r.clientY), {posX: e, posY: t}
        }
        let e = 0, t = 0;
        var r = i || window.event;
        return r.pageX || r.pageY ? (e = r.pageX, t = r.pageY) : (r.clientX || r.clientY) && (e = i.clientX + document.documentElement.scrollLeft + document.body.scrollLeft, t = i.clientY + document.documentElement.scrollTop + document.body.scrollTop), {
            posX: e,
            posY: t
        }
    }

    function ii() {
        let e = document.createElement("video"), t = e.canPlayType("application/vnd.apple.mpegurl");
        return e = null, t
    }

    function ri(e) {
        return C(e.hasAudio) && (e.useMSE || e.useWCS && !e.useOffscreen) && C(e.demuxUseWorker)
    }

    function si(e) {
        e = e.toString().trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1], e = new Blob([e], {type: "application/javascript"});
        return URL.createObjectURL(e)
    }

    function ai(e) {
        e.close()
    }

    function ni() {
        return "https:" === window.location.protocol || "localhost" === window.location.hostname
    }

    function oi(i, r) {
        let s = (i = r ? i.filter(e => e.type === r) : i)[0], a = null, e = 1;
        var t;
        if (0 < i.length && ((t = i[1]) && 1e5 < t.ts - s.ts && (s = t, e = 2)), s) for (let t = e; t < i.length; t++) {
            let e = i[t];
            !(e = r && e.type !== r ? null : e) || 1e3 <= e.ts - s.ts && i[t - 1].ts - s.ts < 1e3 && (a = t + 1)
        }
        return a
    }

    function li(e) {
        for (var e = (e + "=".repeat((4 - e.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"), t = window.atob(e), i = new Uint8Array(t.length), r = 0; r < t.length; ++r) i[r] = t.charCodeAt(r);
        return i
    }

    function di(t) {
        let i = "";
        if ("object" == typeof t) try {
            i = JSON.stringify(t), i = JSON.parse(i)
        } catch (e) {
            i = t
        } else i = t;
        return i
    }

    function hi() {
        return di(se)
    }

    function ci() {
        return di(ae)
    }

    function ui(e) {
        return e[0] >> 4 == 1 && 0 === e[1]
    }

    function k(e) {
        return !0 === e || "true" === e
    }

    function C(e) {
        return !0 !== e && "true" !== e
    }

    function pi(e) {
        return e.replace(/-([a-z])/g, function (e, t) {
            return t.toUpperCase()
        })
    }

    function fi() {
        try {
            var e = document.createElement("canvas");
            return window.WebGL2RenderingContext && e.getContext("webgl2")
        } catch (e) {
            return
        }
    }

    function mi(e) {
        return e.trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1]
    }

    class gi {
        constructor(e) {
            this.destroys = [], this.proxy = this.proxy.bind(this), this.master = e
        }

        proxy(t, e, i) {
            let r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};
            if (t) {
                if (Array.isArray(e)) return e.map(e => this.proxy(t, e, i, r));
                t.addEventListener(e, i, r);
                var s = () => {
                    b(t.removeEventListener) && t.removeEventListener(e, i, r)
                };
                return this.destroys.push(s), s
            }
        }

        destroy() {
            this.master.debug && this.master.debug.log("Events", "destroy"), this.destroys.forEach(e => e()), this.destroys = []
        }
    }

    var yi = "undefined" != typeof Float32Array ? Float32Array : Array;

    function Ai() {
        var e = new yi(16);
        return yi != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
    }

    function bi(e) {
        e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1
    }

    Math.hypot || (Math.hypot = function () {
        for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];
        return Math.sqrt(e)
    });

    function vi(e, t, i) {
        var r = new yi(3);
        return r[0] = e, r[1] = t, r[2] = i, r
    }

    kt = new yi(3), yi != Float32Array && (kt[0] = 0, kt[1] = 0, kt[2] = 0), us = new yi(4), yi != Float32Array && (us[0] = 0, us[1] = 0, us[2] = 0, us[3] = 0);

    class _i {
        constructor(e, t) {
            this.gl = e, t && this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
            t = this._initShaderProgram();
            this._programInfo = {
                program: t,
                attribLocations: {
                    vertexPosition: e.getAttribLocation(t, "aVertexPosition"),
                    texturePosition: e.getAttribLocation(t, "aTexturePosition")
                },
                uniformLocations: {
                    projectionMatrix: e.getUniformLocation(t, "uProjectionMatrix"),
                    modelMatrix: e.getUniformLocation(t, "uModelMatrix"),
                    viewMatrix: e.getUniformLocation(t, "uViewMatrix"),
                    rgbatexture: e.getUniformLocation(t, "rgbaTexture"),
                    ytexture: e.getUniformLocation(t, "yTexture"),
                    utexture: e.getUniformLocation(t, "uTexture"),
                    vtexture: e.getUniformLocation(t, "vTexture"),
                    isyuv: e.getUniformLocation(t, "isyuv")
                }
            }, this._buffers = this._initBuffers(), this._rgbatexture = this._createTexture(), this._ytexture = this._createTexture(), this._utexture = this._createTexture(), this._vtexture = this._createTexture()
        }

        destroy() {
            this.gl.deleteProgram(this._programInfo.program), this.gl.deleteBuffer(this._buffers.position), this.gl.deleteBuffer(this._buffers.texPosition), this.gl.deleteBuffer(this._buffers.indices), this.gl.deleteTexture(this._rgbatexture), this.gl.deleteTexture(this._ytexture), this.gl.deleteTexture(this._utexture), this.gl.deleteTexture(this._vtexture), this._programInfo = null, this._buffers = null, this._rgbatexture = null, this._ytexture = null, this._utexture = null, this._vtexture = null
        }

        _initShaderProgram() {
            var e = this._loadShader(this.gl.VERTEX_SHADER, "\n            attribute vec4 aVertexPosition;\n            attribute vec2 aTexturePosition;\n            varying lowp vec2 vTexturePosition;\n            void main(void) {\n              gl_Position = aVertexPosition;\n              vTexturePosition = aTexturePosition;\n            }\n        "),
                t = this._loadShader(this.gl.FRAGMENT_SHADER, "\n            precision highp float;\n            varying highp vec2 vTexturePosition;\n            uniform int isyuv;\n            uniform sampler2D rgbaTexture;\n            uniform sampler2D yTexture;\n            uniform sampler2D uTexture;\n            uniform sampler2D vTexture;\n\n            const mat4 YUV2RGB = mat4( 1.1643828125, 0, 1.59602734375, -.87078515625,\n                                       1.1643828125, -.39176171875, -.81296875, .52959375,\n                                       1.1643828125, 2.017234375, 0, -1.081390625,\n                                       0, 0, 0, 1);\n\n\n            void main(void) {\n\n                if (isyuv>0) {\n\n                    highp float y = texture2D(yTexture,  vTexturePosition).r;\n                    highp float u = texture2D(uTexture,  vTexturePosition).r;\n                    highp float v = texture2D(vTexture,  vTexturePosition).r;\n                    gl_FragColor = vec4(y, u, v, 1) * YUV2RGB;\n\n                } else {\n                    gl_FragColor =  texture2D(rgbaTexture, vTexturePosition);\n                }\n            }\n        "),
                i = this.gl.createProgram();
            return this.gl.attachShader(i, e), this.gl.attachShader(i, t), this.gl.linkProgram(i), this.gl.getProgramParameter(i, this.gl.LINK_STATUS) ? i : (console.log("Unable to initialize the shader program: " + this.gl.getProgramInfoLog(i)), null)
        }

        _loadShader(e, t) {
            const i = this.gl, r = i.createShader(e);
            return i.shaderSource(r, t), i.compileShader(r), i.getShaderParameter(r, i.COMPILE_STATUS) ? r : (console.log("An error occurred compiling the shaders: " + i.getShaderInfoLog(r)), i.deleteShader(r), null)
        }

        _initBuffers() {
            const e = this.gl, t = e.createBuffer();
            e.bindBuffer(e.ARRAY_BUFFER, t);
            var i = [-1, -1, 1, -1, 1, 1, -1, 1];
            e.bufferData(e.ARRAY_BUFFER, new Float32Array(i), e.STATIC_DRAW);
            var r = (r = []).concat([0, 1], [1, 1], [1, 0], [0, 0]), s = e.createBuffer(),
                r = (e.bindBuffer(e.ARRAY_BUFFER, s), e.bufferData(e.ARRAY_BUFFER, new Float32Array(r), e.STATIC_DRAW), e.createBuffer());
            return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r), e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), e.STATIC_DRAW), {
                positions: i,
                position: t,
                texPosition: s,
                indices: r
            }
        }

        _createTexture() {
            var e = this.gl.createTexture();
            return this.gl.bindTexture(this.gl.TEXTURE_2D, e), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), e
        }

        _drawScene(e, t, i) {
            this.gl.viewport(0, 0, e, t), this.gl.enable(this.gl.BLEND), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._buffers.position), this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this._buffers.positions), this.gl.STATIC_DRAW), this.gl.vertexAttribPointer(this._programInfo.attribLocations.vertexPosition, 2, this.gl.FLOAT, !1, 0, 0), this.gl.enableVertexAttribArray(this._programInfo.attribLocations.vertexPosition), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._buffers.texPosition), this.gl.vertexAttribPointer(this._programInfo.attribLocations.texturePosition, 2, this.gl.FLOAT, !1, 0, 0), this.gl.enableVertexAttribArray(this._programInfo.attribLocations.texturePosition), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this._buffers.indices), i ? (this.gl.activeTexture(this.gl.TEXTURE0 + 3), this.gl.bindTexture(this.gl.TEXTURE_2D, this._ytexture), this.gl.activeTexture(this.gl.TEXTURE0 + 4), this.gl.bindTexture(this.gl.TEXTURE_2D, this._utexture), this.gl.activeTexture(this.gl.TEXTURE0 + 5), this.gl.bindTexture(this.gl.TEXTURE_2D, this._vtexture)) : (this.gl.activeTexture(this.gl.TEXTURE0 + 2), this.gl.bindTexture(this.gl.TEXTURE_2D, this._rgbatexture)), this.gl.useProgram(this._programInfo.program), this.gl.uniform1i(this._programInfo.uniformLocations.rgbatexture, 2), this.gl.uniform1i(this._programInfo.uniformLocations.ytexture, 3), this.gl.uniform1i(this._programInfo.uniformLocations.utexture, 4), this.gl.uniform1i(this._programInfo.uniformLocations.vtexture, 5), this.gl.uniform1i(this._programInfo.uniformLocations.isyuv, i ? 1 : 0), this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)
        }

        _calRect(e, t, i, r, s, a) {
            var n = 2 * e / s - 1, r = 2 * (a - t - r) / a - 1, e = 2 * (e + i) / s - 1, i = 2 * (a - t) / a - 1;
            return [n, r, e, r, e, i, n, i]
        }

        _clear() {
            this.gl.clearColor(0, 0, 0, 1), this.gl.clearDepth(1), this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)
        }

        render(e, t, i, r, s) {
            const a = this.gl;
            this._clear(), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this._ytexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, e, t, 0, a.LUMINANCE, a.UNSIGNED_BYTE, i), a.activeTexture(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._utexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, e / 2, t / 2, 0, a.LUMINANCE, a.UNSIGNED_BYTE, r), a.activeTexture(a.TEXTURE2), a.bindTexture(a.TEXTURE_2D, this._vtexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, e / 2, t / 2, 0, a.LUMINANCE, a.UNSIGNED_BYTE, s), this._buffers.positions = [-1, -1, 1, -1, 1, 1, -1, 1], this._drawScene(e, t, !0)
        }

        renderYUV(e, t, i) {
            var r = i.slice(0, e * t), s = i.slice(e * t, e * t * 5 / 4), i = i.slice(e * t * 5 / 4, e * t * 3 / 2);
            const a = this.gl;
            this._clear(), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this._ytexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, e, t, 0, a.LUMINANCE, a.UNSIGNED_BYTE, r), a.activeTexture(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._utexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, e / 2, t / 2, 0, a.LUMINANCE, a.UNSIGNED_BYTE, s), a.activeTexture(a.TEXTURE2), a.bindTexture(a.TEXTURE_2D, this._vtexture), a.texImage2D(a.TEXTURE_2D, 0, a.LUMINANCE, e / 2, t / 2, 0, a.LUMINANCE, a.UNSIGNED_BYTE, i), this._buffers.positions = [-1, -1, 1, -1, 1, 1, -1, 1], this._drawScene(e, t, !0)
        }

        drawDom(e, t, i, r, s) {
            const a = this.gl;
            a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this._rgbatexture), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, s), this._buffers.positions = this._calRect(i, r, s.width, s.height, e, t), this._drawScene(e, t, !1)
        }
    }

    class wi {
        constructor(e) {
            this.gpu = e, this.pipeline = null, this.matrixGroupInfo = null, this.depthTexture = null, this.textureGroupInfo = null, this.hasInited = !1, this.buffers = this._initBuffer(), this._initPipeline().then(e => {
                this.pipeline = e, this.matrixGroupInfo = this._initMatrixGroupInfo(), this.hasInited = !0
            })
        }

        destroy() {
            this.gpu && (this.gpu.device.destroy(), this.gpu = null), this.hasInited = !1, this.pipeline = null, this.matrixGroupInfo = null, this.depthTexture = null, this.textureGroupInfo = null
        }

        _initBuffer() {
            const e = this.gpu.device, t = new Float32Array([-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]),
                i = e.createBuffer({
                    size: t.byteLength,
                    usage: window.GPUBufferUsage.VERTEX | window.GPUBufferUsage.COPY_DST
                });
            e.queue.writeBuffer(i, 0, t);
            var r = new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]), s = e.createBuffer({
                size: r.byteLength,
                usage: window.GPUBufferUsage.VERTEX | window.GPUBufferUsage.COPY_DST
            }), r = (e.queue.writeBuffer(s, 0, r), new Uint16Array([0, 1, 2, 0, 2, 3])), a = e.createBuffer({
                size: r.byteLength,
                usage: window.GPUBufferUsage.INDEX | window.GPUBufferUsage.COPY_DST
            });
            return e.queue.writeBuffer(a, 0, r), {positionBuffer: i, texpositionBuffer: s, indexBuffer: a}
        }

        _initPipeline() {
            return new Promise((t, i) => {
                const e = this.gpu.device, r = this.gpu.format, s = {
                    layout: "auto", vertex: {
                        module: e.createShaderModule({code: "\n\n                  @binding(0) @group(0) var<uniform> uModelMatrix : mat4x4<f32>;\n                  @binding(1) @group(0) var<uniform> uViewMatrix : mat4x4<f32>;\n                  @binding(2) @group(0) var<uniform> uProjectionMatrix : mat4x4<f32>;\n\n                  struct VertexOutput {\n                    @builtin(position) Position : vec4<f32>,\n                    @location(0) vTexturePosition : vec2<f32>,\n                  }\n\n                  @vertex\n                  fn main(\n                    @location(0) aVertexPosition : vec4<f32>,\n                    @location(1) aTexturePosition : vec2<f32>\n                  ) -> VertexOutput {\n                    var output : VertexOutput;\n                    var tmppos : vec4<f32> = uProjectionMatrix * uViewMatrix * uModelMatrix * aVertexPosition;\n                    output.Position = vec4<f32>(tmppos.x, tmppos.y, (tmppos.z+1.)/2., tmppos.w);  // webgl z [-1, 1],  webgpu z [0, 1],  这里z做下调整 z-webgpu = (z-webgl+1)/2\n                    output.vTexturePosition = aTexturePosition;\n                    return output;\n                  }\n\n                "}),
                        entryPoint: "main",
                        buffers: [{
                            arrayStride: 12,
                            attributes: [{shaderLocation: 0, offset: 0, format: "float32x3"}]
                        }, {arrayStride: 8, attributes: [{shaderLocation: 1, offset: 0, format: "float32x2"}]}]
                    }, primitive: {topology: "triangle-list"}, fragment: {
                        module: e.createShaderModule({code: "\n                @group(1) @binding(0) var mySampler: sampler;\n                @group(1) @binding(1) var yTexture: texture_2d<f32>;\n                @group(1) @binding(2) var uTexture: texture_2d<f32>;\n                @group(1) @binding(3) var vTexture: texture_2d<f32>;\n\n                const YUV2RGB : mat4x4<f32> = mat4x4<f32>( 1.1643828125, 0, 1.59602734375, -.87078515625,\n                                                         1.1643828125, -.39176171875, -.81296875, .52959375,\n                                                         1.1643828125, 2.017234375, 0, -1.081390625,\n                                                         0, 0, 0, 1);\n\n                @fragment\n                fn main(\n                  @location(0) vTexturePosition: vec2<f32>\n                ) -> @location(0) vec4<f32> {\n\n                    var y : f32= textureSample(yTexture, mySampler, vTexturePosition).r;\n                    var u : f32 = textureSample(uTexture,  mySampler, vTexturePosition).r;\n                    var v : f32 = textureSample(vTexture, mySampler, vTexturePosition).r;\n\n                    return  vec4<f32>(y, u, v, 1.0)*YUV2RGB;\n                }\n\n                "}),
                        entryPoint: "main",
                        targets: [{format: r}]
                    }, depthStencil: {depthWriteEnabled: !0, depthCompare: "less", format: "depth24plus"}
                };
                e.createRenderPipelineAsync(s).then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                })
            })
        }

        _initMatrixGroupInfo() {
            const e = this.gpu.device, t = this.pipeline, i = Ai();
            r = (s = m = 1) / ((f = -1) - m), A = 1 / ((a = -1) - s), h = 1 / ((d = .1) - (l = 100)), (c = i)[0] = -2 * r, c[1] = 0, c[2] = 0, c[3] = 0, c[4] = 0, c[5] = -2 * A, c[6] = 0, c[7] = 0, c[8] = 0, c[9] = 0, c[10] = 2 * h, c[11] = 0, c[12] = (f + m) * r, c[13] = (s + a) * A, c[14] = (l + d) * h, c[15] = 1;
            var r, s, a, n, o, l, d, h, c, u, p, f = Ai(), m = (bi(f), Ai()),
                g = (r = m, s = vi(0, 0, 0), a = vi(0, 0, -1), A = vi(0, 1, 0), l = s[0], d = s[1], s = s[2], h = A[0], c = A[1], A = A[2], u = a[0], p = a[1], a = a[2], Math.abs(l - u) < 1e-6 && Math.abs(d - p) < 1e-6 && Math.abs(s - a) < 1e-6 ? bi(r) : (a = s - a, y = c * (a *= g = 1 / Math.hypot(u = l - u, p = d - p, a)) - A * (p *= g), A = A * (u *= g) - h * a, h = h * p - c * u, (g = Math.hypot(y, A, h)) ? (y *= g = 1 / g, A *= g, h *= g) : h = A = y = 0, c = p * h - a * A, n = a * y - u * h, o = u * A - p * y, (g = Math.hypot(c, n, o)) ? (c *= g = 1 / g, n *= g, o *= g) : o = n = c = 0, r[0] = y, r[1] = c, r[2] = u, r[3] = 0, r[4] = A, r[5] = n, r[6] = p, r[7] = 0, r[8] = h, r[9] = o, r[10] = a, r[11] = 0, r[12] = -(y * l + A * d + h * s), r[13] = -(c * l + n * d + o * s), r[14] = -(u * l + p * d + a * s), r[15] = 1), e.createBuffer({
                    size: 64,
                    usage: window.GPUBufferUsage.UNIFORM | window.GPUBufferUsage.COPY_DST
                })), y = (e.queue.writeBuffer(g, 0, f), e.createBuffer({
                    size: 64,
                    usage: window.GPUBufferUsage.UNIFORM | window.GPUBufferUsage.COPY_DST
                })), A = (e.queue.writeBuffer(y, 0, m), e.createBuffer({
                    size: 64,
                    usage: window.GPUBufferUsage.UNIFORM | window.GPUBufferUsage.COPY_DST
                }));
            return e.queue.writeBuffer(A, 0, i), {
                modelMatrixBuffer: g,
                viewMatrixBuffer: y,
                projectMatrixBuffer: A,
                group: e.createBindGroup({
                    label: "group0",
                    layout: t.getBindGroupLayout(0),
                    entries: [{binding: 0, resource: {buffer: g}}, {binding: 1, resource: {buffer: y}}, {
                        binding: 2,
                        resource: {buffer: A}
                    }]
                })
            }
        }

        _initTextureGroupInfo(e, t) {
            const i = this.gpu.device, r = this.pipeline, s = i.createTexture({
                size: [e, t],
                format: "r8unorm",
                usage: window.GPUTextureUsage.TEXTURE_BINDING | window.GPUTextureUsage.COPY_DST | window.GPUTextureUsage.RENDER_ATTACHMENT
            }), a = i.createTexture({
                size: [e / 2, t / 2],
                format: "r8unorm",
                usage: window.GPUTextureUsage.TEXTURE_BINDING | window.GPUTextureUsage.COPY_DST | window.GPUTextureUsage.RENDER_ATTACHMENT
            }), n = i.createTexture({
                size: [e / 2, t / 2],
                format: "r8unorm",
                usage: window.GPUTextureUsage.TEXTURE_BINDING | window.GPUTextureUsage.COPY_DST | window.GPUTextureUsage.RENDER_ATTACHMENT
            }), o = i.createSampler({magFilter: "linear", minFilter: "linear"}), l = i.createBindGroup({
                label: "group1",
                layout: r.getBindGroupLayout(1),
                entries: [{binding: 0, resource: o}, {binding: 1, resource: s.createView()}, {
                    binding: 2,
                    resource: a.createView()
                }, {binding: 3, resource: n.createView()}]
            });
            return {yTexture: s, uTexture: a, vTexture: n, group: l}
        }

        _drawScene() {
            const e = this.gpu.device, t = this.gpu.context, i = e.createCommandEncoder(), r = {
                colorAttachments: [{
                    view: t.getCurrentTexture().createView(),
                    clearValue: {r: 0, g: 0, b: 0, a: 0},
                    loadOp: "clear",
                    storeOp: "store"
                }],
                depthStencilAttachment: {
                    view: this.depthTexture.createView(),
                    depthClearValue: 1,
                    depthLoadOp: "clear",
                    depthStoreOp: "store"
                }
            }, s = i.beginRenderPass(r);
            s.setPipeline(this.pipeline), s.setBindGroup(0, this.matrixGroupInfo.group), s.setBindGroup(1, this.textureGroupInfo.group), s.setVertexBuffer(0, this.buffers.positionBuffer), s.setVertexBuffer(1, this.buffers.texpositionBuffer), s.setIndexBuffer(this.buffers.indexBuffer, "uint16"), s.drawIndexed(6), s.end(), e.queue.submit([i.finish()])
        }

        renderYUV(e, t, i) {
            if (this.hasInited) {
                var r = i.slice(0, e * t), s = i.slice(e * t, e * t * 5 / 4), i = i.slice(e * t * 5 / 4, e * t * 3 / 2);
                const a = this.gpu.device;
                this.depthTexture || (this.depthTexture = this.gpu.device.createTexture({
                    size: [e, t],
                    format: "depth24plus",
                    usage: window.GPUTextureUsage.RENDER_ATTACHMENT
                })), this.textureGroupInfo || (this.textureGroupInfo = this._initTextureGroupInfo(e, t)), a.queue.writeTexture({texture: this.textureGroupInfo.yTexture}, r, {
                    bytesPerRow: e,
                    rowsPerImage: t
                }, [e, t]), a.queue.writeTexture({texture: this.textureGroupInfo.uTexture}, s, {
                    bytesPerRow: e / 2,
                    rowsPerImage: t / 2
                }, [e / 2, t / 2]), a.queue.writeTexture({texture: this.textureGroupInfo.vTexture}, i, {
                    bytesPerRow: e / 2,
                    rowsPerImage: t / 2
                }, [e / 2, t / 2]), this._drawScene()
            }
        }

        clear() {
        }
    }

    class Si extends e {
        constructor() {
            super(), this.videoInfo = {width: null, height: null, encType: null}, this.init = !1
        }

        destroy() {
            this.resetInit(), this.off()
        }

        resetInit() {
            this.videoInfo = {width: null, height: null, encType: null}, this.init = !1
        }

        getHasInit() {
            return this.init
        }

        updateVideoInfo(e) {
            x(e.encTypeCode) && (this.videoInfo.encType = ve[e.encTypeCode]), x(e.encType) && (this.videoInfo.encType = e.encType), x(e.width) && (this.videoInfo.width = e.width), x(e.height) && (this.videoInfo.height = e.height), x(this.videoInfo.encType) && x(this.videoInfo.height) && x(this.videoInfo.width) && !this.init && (this.player.emit(w.videoInfo, this.videoInfo), this.init = !0)
        }

        getVideoInfo() {
            return this.videoInfo
        }

        clearView() {
        }

        resize() {
            "default" === this.player._opt.aspectRatio || y() ? this._resize() : this._resizeRatio(), this.getType() === J && this.contentWatermark && this.contentWatermark.resize(), this.player.singleWatermark && this.player.singleWatermark.resize()
        }

        _resizeRatio() {
            this.player.debug.log("Video", "_resizeRatio()");
            const e = this.player._opt.aspectRatio.split(":").map(Number);
            let t = this.player.width, i = this.player.height;
            var r = this.player._opt;
            let s = 0;
            r.hasControl && !r.controlAutoHide && (s = r.playType === A ? 48 : 38, i -= s);
            var r = this.videoInfo, a = r.width / r.height, n = e[0] / e[1];
            if (this.getType() === Y && (this.$videoElement.style.left = "0", this.$videoElement.style.top = "0", this.$videoElement.style.transform = "none"), this.getType() === J && this.player._opt.videoRenderSupportScale && (this.$videoElement.style.objectFit = "fill"), n < a) {
                const e = n * r.height / r.width;
                this.$videoElement.style.width = 100 * e + "%", this.$videoElement.style.height = `calc(100% - ${s}px)`, this.$videoElement.style.padding = `0 ${(t - t * e) / 2}px`
            } else {
                const e = r.width / n / r.height;
                this.$videoElement.style.width = "100%", this.$videoElement.style.height = `calc(${100 * e}% - ${s}px)`, this.$videoElement.style.padding = (i - i * e) / 2 + "px 0"
            }
        }

        play() {
        }

        pause() {
        }

        getType() {
            return ""
        }

        getCanvasType() {
            return ""
        }

        getCurrentTime() {
            return 0
        }

        getStreamFps() {
            return 25
        }

        isPlaying() {
            return !0
        }

        addContentToCanvas() {
        }

        getPlaybackQuality() {
            return null
        }
    }

    var Ei = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0;

    function Ti(e, t, i) {
        var r = new XMLHttpRequest;
        r.open("GET", e), r.responseType = "blob", r.onload = function () {
            Li(r.response, t, i)
        }, r.onerror = function () {
            console.error("could not download file")
        }, r.send()
    }

    function ki(e) {
        var t = new XMLHttpRequest;
        t.open("HEAD", e, !1);
        try {
            t.send()
        } catch (e) {
        }
        return 200 <= t.status && t.status <= 299
    }

    function xi(t) {
        try {
            t.dispatchEvent(new MouseEvent("click"))
        } catch (e) {
            var i = document.createEvent("MouseEvents");
            i.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(i)
        }
    }

    var Ci = Ei.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent),
        Li = "object" != typeof window || window !== Ei ? function () {
        } : "download" in HTMLAnchorElement.prototype && !Ci ? function (e, t, i) {
            var r = Ei.URL || Ei.webkitURL, s = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
            t = t || e.name || "download", s.download = t, s.rel = "noopener", "string" == typeof e ? (s.href = e, s.origin !== location.origin ? ki(s.href) ? Ti(e, t, i) : xi(s, s.target = "_blank") : xi(s)) : (s.href = r.createObjectURL(e), setTimeout(function () {
                r.revokeObjectURL(s.href)
            }, 4e4), setTimeout(function () {
                xi(s)
            }, 0))
        } : "msSaveOrOpenBlob" in navigator ? function (e, t, i) {
            var r;
            t = t || e.name || "download", "string" == typeof e ? ki(e) ? Ti(e, t, i) : ((r = document.createElement("a")).href = e, r.target = "_blank", setTimeout(function () {
                xi(r)
            })) : navigator.msSaveOrOpenBlob((e = e, void 0 === (i = i) ? i = {autoBom: !1} : "object" != typeof i && (console.warn("Deprecated: Expected third argument to be a object"), i = {autoBom: !i}), i.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob([String.fromCharCode(65279), e], {type: e.type}) : e), t)
        } : function (e, t, i, r) {
            if ((r = r || open("", "_blank")) && (r.document.title = r.document.body.innerText = "downloading..."), "string" == typeof e) return Ti(e, t, i);
            var s, a, n, t = "application/octet-stream" === e.type,
                i = /constructor/i.test(Ei.HTMLElement) || Ei.safari, o = /CriOS\/[\d]+/.test(navigator.userAgent);
            (o || t && i || Ci) && "undefined" != typeof FileReader ? ((s = new FileReader).onloadend = function () {
                var e = s.result, e = o ? e : e.replace(/^data:[^;]*;/, "data:attachment/file;");
                r ? r.location.href = e : location = e, r = null
            }, s.readAsDataURL(e)) : (a = Ei.URL || Ei.webkitURL, n = a.createObjectURL(e), r ? r.location = n : location.href = n, r = null, setTimeout(function () {
                a.revokeObjectURL(n)
            }, 4e4))
        };

    class Di {
        constructor(e, t) {
            this.gl = e, t && this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
            e = this._initShaderProgram();
            this.shaderProgram = e, this.programInfo = {
                program: e,
                attribLocations: {vertexPosition: this.gl.getAttribLocation(e, "aVertexPosition")},
                uniformLocations: {
                    linewidth: this.gl.getUniformLocation(e, "uLineWidth"),
                    rect: this.gl.getUniformLocation(e, "uRect"),
                    linecolor: this.gl.getUniformLocation(e, "uLineColor"),
                    resolution: this.gl.getUniformLocation(e, "uResolution")
                }
            }, this.buffers = this._initBuffers()
        }

        destroy() {
            this.gl.deleteProgram(this.shaderProgram), this.gl.deleteBuffer(this.buffers.position), this.gl.deleteBuffer(this.buffers.indices), this.shaderProgram = null, this.buffers = null
        }

        _initShaderProgram() {
            const e = this.gl,
                t = this._loadShader(e.VERTEX_SHADER, "\n          attribute vec4 aVertexPosition;\n            void main(void) {\n              gl_Position = aVertexPosition;\n            }\n            "),
                i = this._loadShader(e.FRAGMENT_SHADER, "\n            precision highp float;\n            uniform float uLineWidth;\n            uniform vec4 uRect;\n            uniform vec3 uLineColor;\n            uniform vec2 uResolution;\n\n\n            float inBox(vec2 st, vec4 rect){\n\n                vec2 bl = step(rect.xy,st);\n                float pct = bl.x * bl.y;\n\n                vec2 tr = step(st, rect.zw);\n                pct *= tr.x * tr.y;\n\n                return pct;\n            }\n\n            void main(void) {\n\n                vec2 cur = gl_FragCoord.xy/uResolution;\n\n                float xlinewidth  = uLineWidth/uResolution.x;\n                float ylinewidth  = uLineWidth/uResolution.y;\n\n                // vec4 outRect = uRect + vec4(-1.*xlinewidth/2., -1.*ylinewidth/2., xlinewidth/2., ylinewidth/2.);\n                // vec4 inRect  = uRect + vec4(xlinewidth/2., ylinewidth/2., -1.*xlinewidth/2., -1.*ylinewidth/2.);\n\n                vec4 outRect = uRect + vec4(-1.*xlinewidth/2., -1.*ylinewidth/2., xlinewidth/2., ylinewidth/2.);\n                vec4 inRect  = uRect;\n\n                float a = inBox(cur, outRect);\n                float b = inBox(cur, inRect);\n\n                gl_FragColor = mix(vec4(0., 0., 0., 0.), vec4(uLineColor.rgb, 1.0), a-b);\n\n            }\n            "),
                r = e.createProgram();
            return e.attachShader(r, t), e.attachShader(r, i), e.linkProgram(r), e.getProgramParameter(r, e.LINK_STATUS) ? r : (console.log("Unable to initialize the shader program: " + e.getProgramInfoLog(r)), null)
        }

        _loadShader(e, t) {
            const i = this.gl, r = i.createShader(e);
            return i.shaderSource(r, t), i.compileShader(r), i.getShaderParameter(r, i.COMPILE_STATUS) ? r : (console.log("An error occurred compiling the shaders: " + i.getShaderInfoLog(r)), i.deleteShader(r), null)
        }

        _createTexture() {
            const e = this.gl;
            var t = e.createTexture();
            return e.bindTexture(e.TEXTURE_2D, t), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), t
        }

        _initBuffers() {
            const e = this.gl, t = e.createBuffer();
            e.bindBuffer(e.ARRAY_BUFFER, t), e.bufferData(e.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.STATIC_DRAW);
            var i = e.createBuffer();
            return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, i), e.bufferData(e.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), e.STATIC_DRAW), {
                position: t,
                indices: i
            }
        }

        _drawScene(e) {
            var {canvasWidth: e, canvasHeight: t, rect: i, lineWidth: r, lineColor: s} = e;
            const a = this.gl, n = this.buffers, o = this.programInfo;
            a.viewport(0, 0, e, t), a.enable(a.BLEND), a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA), a.bindBuffer(a.ARRAY_BUFFER, n.position), a.vertexAttribPointer(o.attribLocations.vertexPosition, 2, a.FLOAT, !1, 0, 0), a.enableVertexAttribArray(o.attribLocations.vertexPosition), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, n.indices), a.useProgram(o.program), a.uniform2f(o.uniformLocations.resolution, e, t), a.uniform4f(o.uniformLocations.rect, i[0], i[1], i[2], i[3]), a.uniform1f(o.uniformLocations.linewidth, r), a.uniform3f(o.uniformLocations.linecolor, s[0], s[1], s[2]), a.drawElements(a.TRIANGLES, 6, a.UNSIGNED_SHORT, 0)
        }

        drawBox(e) {
            var {x: e, y: t, width: i, height: r, lineWidth: s, lineColor: a, canvasWidth: n, canvasHeight: o} = e,
                l = (l = e / n, r = (o - t - r) / o, e = (e + i) / n, i = (o - t) / o, (t = new yi(4))[0] = l, t[1] = r, t[2] = e, t[3] = i, t),
                a = vi(1, 0, 0);
            this._drawScene({canvasWidth: n, canvasHeight: o, rect: l, lineWidth: s, lineColor: a})
        }
    }

    class Ii {
        constructor(e, t) {
            this.canvas = e;
            e = (this.gl = t).createShader(t.VERTEX_SHADER);
            if (t.shaderSource(e, "\n            attribute vec2 xy;\n            varying highp vec2 uv;\n            void main(void) {\n                gl_Position = vec4(xy, 0.0, 1.0);\n                // Map vertex coordinates (-1 to +1) to UV coordinates (0 to 1).\n                // UV coordinates are Y-flipped relative to vertex coordinates.\n                uv = vec2((1.0 + xy.x) / 2.0, (1.0 - xy.y) / 2.0);\n            }\n        "), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS)) throw t.getShaderInfoLog(e);
            var i = t.createShader(t.FRAGMENT_SHADER);
            if (t.shaderSource(i, "\n             varying highp vec2 uv;\n             uniform sampler2D texture;\n             void main(void) {\n                gl_FragColor = texture2D(texture, uv);\n             }\n        "), t.compileShader(i), !t.getShaderParameter(i, t.COMPILE_STATUS)) throw t.getShaderInfoLog(i);
            var r = t.createProgram();
            if (t.attachShader(r, e), t.attachShader(r, i), t.linkProgram(r), !t.getProgramParameter(r, t.LINK_STATUS)) throw t.getProgramInfoLog(r);
            t.useProgram(r);
            var s = t.createBuffer(),
                a = (t.bindBuffer(t.ARRAY_BUFFER, s), t.bufferData(t.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), t.STATIC_DRAW), t.getAttribLocation(r, "xy")),
                a = (t.vertexAttribPointer(a, 2, t.FLOAT, !1, 0, 0), t.enableVertexAttribArray(a), t.createTexture());
            t.bindTexture(t.TEXTURE_2D, a), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), this.program = r, this.buffer = s, this.vertexShader = e, this.fragmentShader = i, this.texture = a
        }

        destroy() {
            this.gl.deleteProgram(this.program), this.gl.deleteBuffer(this.buffer), this.gl.deleteTexture(this.texture), this.gl.deleteShader(this.vertexShader), this.gl.deleteShader(this.fragmentShader), this.program = null, this.buffer = null, this.vertexShader = null, this.fragmentShader = null, this.texture = null
        }

        render(e) {
            this.canvas.width = e.displayWidth, this.canvas.height = e.displayHeight;
            const t = this.gl;
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), t.viewport(0, 0, t.drawingBufferWidth, t.drawingBufferHeight), t.clearColor(1, 0, 0, 1), t.clear(t.COLOR_BUFFER_BIT), t.drawArrays(t.TRIANGLE_FAN, 0, 4)
        }
    }

    class Ri extends Si {
        constructor(e) {
            super(), this.player = e;
            const t = document.createElement("canvas");
            t.style.position = "absolute", t.style.top = 0, t.style.left = 0, this.$videoElement = t, e.$container.appendChild(this.$videoElement), this.context2D = null, this.contextGl = null, this.webglRender = null, this.webglRectRender = null, this.webGPURender = null, this.isWebglContextLost = !1, this.isWcsWebgl2 = !1, this.bitmaprenderer = null, this.renderType = null, this.controlHeight = 0, this.proxyDestroyList = [], this.tempCanvasContentList = [], this._initCanvasRender()
        }

        destroy() {
            super.destroy(), 0 < this.proxyDestroyList.length && (this.proxyDestroyList.forEach(e => {
                e && e()
            }), this.proxyDestroyList = []), this.contextGl && (this.contextGl = null), this.context2D && (this.context2D = null), this.webglRender && (this.webglRender.destroy(), this.webglRender = null), this.webglRectRender && (this.webglRectRender.destroy(), this.webglRectRender = null), this.webGPURender && (this.webGPURender.destroy(), this.webGPURender = null), this.bitmaprenderer && (this.bitmaprenderer = null), this.renderType = null, this.isWebglContextLost = !1, this.videoInfo = {
                width: "",
                height: "",
                encType: ""
            }, this.tempCanvasContentList = [], this.player.$container.removeChild(this.$videoElement), this.init = !1, this.off()
        }

        _initContext2D() {
            this.context2D = this.$videoElement.getContext("2d", 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {})
        }

        _initContextGl() {
            this.player.events, this.contextGl = vt(this.$videoElement), this.contextGl ? (this._bindContextGlEvents(), this.webglRender = new _i(this.contextGl, this.player._opt.openWebglAlignment), this.webglRectRender = new Di(this.contextGl, this.player._opt.openWebglAlignment)) : this.player.debug.error("CommonCanvasLoader", "_initContextGl() createContextGL error")
        }

        _initContextGl2() {
            if (this.contextGl = _t(this.$videoElement), this.contextGl) {
                this._bindContextGlEvents(2);
                try {
                    this.webglRender = new Ii(this.$videoElement, this.contextGl)
                } catch (e) {
                    this.player.debug.error("CommonCanvasLoader", `create webgl2Render error is ${e} and next use context2d.draw render`), this.contextGl = null, this.webglRender = null, this._initContext2D()
                }
            } else this.player.debug.error("CommonCanvasLoader", "_initContextGl2() createContextGL2 error")
        }

        _bindContextGlEvents() {
            let t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
            const e = this.player.events["proxy"], i = e(this.$videoElement, "webglcontextlost", e => {
                e.preventDefault(), this.player.debug.error("canvasVideo", "webglcontextlost error", e), this.isWebglContextLost = !0, this.webglRender && (this.player.debug.log("CommonCanvasLoader", "webglcontextlost error and destroy webglRender"), this.webglRender.destroy(), this.webglRender = null), this.webglRectRender && (this.player.debug.log("CommonCanvasLoader", "webglcontextlost error and destroy webglRectRender"), this.webglRectRender.destroy(), this.webglRectRender = null), this.contextGl = null, setTimeout(() => {
                    this.player.debug.log("CommonCanvasLoader", "createContextGL() version " + t), 1 === t ? this.contextGl = vt(this.$videoElement) : 2 === t && (this.contextGl = _t(this.$videoElement)), this.player.debug.log("CommonCanvasLoader", "createContextGL success"), this.contextGl && this.contextGl.getContextAttributes && this.contextGl.getContextAttributes().stencil ? (1 === t ? (this.webglRender = new _i(this.contextGl, this.player._opt.openWebglAlignment), this.webglRectRender = new Di(this.contextGl, this.player._opt.openWebglAlignment)) : 2 === t && (this.webglRender = new Ii(this.$videoElement, this.contextGl)), this.isWebglContextLost = !1, this.player.debug.log("CommonCanvasLoader", "webglcontextlost error reset and getContextAttributes().stencil is true")) : (this.player.debug.error("CommonCanvasLoader", "webglcontextlost error, getContextAttributes().stencil is false"), this.player.emitError(S.webglContextLostError))
                }, 500)
            }), r = e(this.$videoElement, "webglcontextrestored", e => {
                e.preventDefault(), this.player.debug.log("CommonCanvasLoader", "webglcontextrestored ", e)
            });
            this.proxyDestroyList.push(i, r)
        }

        _initContextGPU() {
            var a = this.$videoElement;
            new Promise((r, s) => {
                navigator.gpu ? navigator.gpu.requestAdapter().then(i => {
                    i ? i.requestDevice().then(e => {
                        if (e) {
                            const t = a.getContext("webgpu");
                            if (t) {
                                const a = navigator.gpu.getPreferredCanvasFormat();
                                t.configure({device: e, format: a, alphaMode: "opaque"}), r({
                                    adapter: i,
                                    device: e,
                                    context: t,
                                    format: a
                                })
                            } else s('WebGPU "context" create fail')
                        } else s('WebGPU "device" request fail')
                    }).catch(e => {
                        s('WebGPU "adapter.requestDevice()" fail')
                    }) : s('WebGPU "adapter" request fail is empty')
                }).catch(e => {
                    s('WebGPU "navigator.gpu.requestAdapter()" fail')
                }) : s("WebGPU not support!!")
            }).then(e => {
                this.webGPURender = new wi(e), this.player.debug.log("CommonCanvasLoader", "webGPURender init success")
            }).catch(e => {
                this.player.debug.error("CommonCanvasLoader", `createWebGPUContext error is ${e} and next use webgl render`), this.renderType = xe, this._initContextGl()
            })
        }

        initCanvasViewSize() {
            this.$videoElement.width = this.videoInfo.width, this.$videoElement.height = this.videoInfo.height, this.resize()
        }

        screenshot(e, t, i, r) {
            e = e || p(), r = r || l.download;
            let s = .92;
            !d[t] && l[t] && (r = t, t = "png", i = void 0), "string" == typeof i && (r = i, i = void 0), void 0 !== i && (s = Number(i));
            const a = d[t] || d.png, n = this.$videoElement.toDataURL(a, s);
            if (r === l.base64) return n;
            {
                const t = wt(n);
                if (r === l.blob) return t;
                if (r === l.download) {
                    const i = a.split("/")[1];
                    Li(t, e + "." + i)
                }
            }
        }

        screenshotWatermark(s) {
            return new Promise((t, i) => {
                (s = (s = Xt(s) ? {filename: s} : s) || {}).width = this.videoInfo.width, s.height = this.videoInfo.height, s.filename = s.filename || p(), s.format = s.format ? d[s.format] : d.png, s.quality = Number(s.quality) || .92, s.type = s.type || l.download;
                const r = this.$videoElement.toDataURL(s.format, s.quality);
                Kt(r, s).then(e => {
                    if (s.type === l.base64) t(r); else {
                        const r = wt(e);
                        if (s.type === l.blob) t(r); else if (s.type === l.download) {
                            t();
                            const e = s.format.split("/")[1];
                            Li(r, s.filename + "." + e)
                        }
                    }
                }).catch(e => {
                    i(e)
                })
            })
        }

        render() {
        }

        clearView() {
        }

        play() {
        }

        pause() {
        }

        _resize() {
            this.player.debug.log("canvasVideo", "_resize()");
            var e = this.player._opt;
            let t = this.player.width, i = this.player.height;
            if (e.hasControl && !e.controlAutoHide) {
                const r = this.controlHeight;
                y() && this.player.fullscreen && e.useWebFullScreen ? t -= r : i -= r
            }
            let r = this.$videoElement.width, s = this.$videoElement.height;
            var a = e.rotate, n = (t - r) / 2, o = (i - s) / 2,
                l = (270 !== a && 90 !== a || (r = this.$videoElement.height, s = this.$videoElement.width), t / r),
                d = i / s;
            let h = d < l ? d : l,
                c = (e.isResize || l != d && (h = l + "," + d), "scale(" + (h = e.isFullResize ? d < l ? l : d : h) + ")");
            "none" === e.mirrorRotate && a && (c += " rotate(" + a + "deg)"), "level" === e.mirrorRotate ? c += " rotateY(180deg)" : "vertical" === e.mirrorRotate && (c += " rotateX(180deg)"), this.$videoElement.style.height = this.videoInfo.height + "px", this.$videoElement.style.width = this.videoInfo.width + "px", this.$videoElement.style.padding = "0", this.$videoElement.style.transform = c, this.$videoElement.style.left = n + "px", this.$videoElement.style.top = o + "px"
        }

        initFps() {
        }

        setStreamFps(e) {
        }

        getStreamFps() {
            return 25
        }

        getType() {
            return Y
        }

        getCanvasType() {
            let e = this.renderType === Ce ? Ce : xe;
            return e = this.isWcsWebgl2 ? "webgl2" : e
        }

        addContentToCanvas() {
            this.tempCanvasContentList = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : []
        }
    }

    class Pi extends Ri {
        constructor(e) {
            super(e), this.yuvList = [], this.controlHeight = 38, this.tempTextCanvas = null, this.tempTextCanvasCtx = null, this.player.debug.log("CanvasVideo", "init")
        }

        destroy() {
            super.destroy(), this.yuvList = [], this.tempTextCanvas && (this.tempTextCanvasCtx.clearRect(0, 0, this.tempTextCanvas.width, this.tempTextCanvas.height), this.tempTextCanvas.width = 0, this.tempTextCanvas.height = 0, this.tempTextCanvas = null), this.player.debug.log("CanvasVideoLoader", "destroy")
        }

        _initCanvasRender() {
            this.player._opt.useWCS && !this._supportOffscreen() ? (this.renderType = ke, fi() && this.player._opt.wcsUseWebgl2Render ? (this._initContextGl2(), this.webglRender && (this.isWcsWebgl2 = !0)) : this._initContext2D()) : this.player._opt.useMSE && this.player._opt.mseUseCanvasRender ? (this.renderType = De, this._initContext2D()) : this.player.isOldHls() && this.player._opt.useCanvasRender ? (this.renderType = "hls", this._initContext2D()) : this._supportOffscreen() ? (this.renderType = Le, this._bindOffscreen()) : this.player._opt.useWebGPU ? (this.renderType = Ce, this._initContextGPU()) : (this.renderType = xe, this._initContextGl())
        }

        _supportOffscreen() {
            return "function" == typeof this.$videoElement.transferControlToOffscreen && this.player._opt.useOffscreen
        }

        _bindOffscreen() {
            this.bitmaprenderer = this.$videoElement.getContext("bitmaprenderer")
        }

        render(e) {
            this.yuvList.push(e), this.startRender()
        }

        startRender() {
            for (; !(this.yuvList.length <= 0);) {
                var e = this.yuvList.shift();
                this.doRender(e)
            }
        }

        doRender(t) {
            var i;
            switch (this.player.videoTimestamp = t.ts || 0, this.renderType !== De && (i = {
                ts: t.ts || 0,
                fps: !0
            }, this.player.updateStats(i)), this.renderType) {
                case Le:
                    this.bitmaprenderer.transferFromImageBitmap(t.buffer);
                    break;
                case xe:
                case Ce:
                    if (this.isWebglContextLost) return void this.player.debug.warn("CanvasVideoLoader", "doRender() and webgl context is lost");
                    let e = t.output;
                    if (this.player.faceDetectActive && this.player.ai && this.player.ai.faceDetector && (e = this.player.ai.faceDetector.detect({
                        width: this.$videoElement.width,
                        height: this.$videoElement.height,
                        data: t.output
                    })), this.player.objectDetectActive && this.player.ai && this.player.ai.objectDetector && (e = this.player.ai.objectDetector.detect({
                        width: this.$videoElement.width,
                        height: this.$videoElement.height,
                        data: t.output
                    })), this.renderType === Ce) try {
                        if (!this.webGPURender) return void this.player.debug.warn("CanvasVideoLoader", "doRender webgpu render is not init");
                        this.webGPURender.renderYUV(this.$videoElement.width, this.$videoElement.height, e)
                    } catch (t) {
                        this.player.debug.error("CanvasVideoLoader", "doRender webgpu render and error: " + t.toString())
                    } else if (this.renderType === xe) try {
                        this.webglRender.renderYUV(this.$videoElement.width, this.$videoElement.height, e), this.doAddContentToWebGlCanvas()
                    } catch (t) {
                        this.player.debug.error("CanvasVideoLoader", `doRender webgl render context is lost ${this.contextGl && this.contextGl.isContextLost()}  and error: ` + t.toString())
                    }
                    break;
                case ke:
                    if (this.webglRender) this.webglRender.render(t.videoFrame), ai(t.videoFrame); else if (this.context2D) if (b(t.videoFrame.createImageBitmap)) try {
                        t.videoFrame.createImageBitmap().then(e => {
                            this.context2D.drawImage(e, 0, 0, this.$videoElement.width, this.$videoElement.height), ai(t.videoFrame), this.doAddContentToCanvas()
                        })
                    } catch (t) {
                    } else this.context2D.drawImage(t.videoFrame, 0, 0, this.$videoElement.width, this.$videoElement.height), ai(t.videoFrame), this.doAddContentToCanvas(); else this.player.debug.warn("CanvasVideoLoader", "doRender() and webcodecs context is lost");
                    break;
                case De:
                case"hls":
                    this.context2D.drawImage(t.$video, 0, 0, this.$videoElement.width, this.$videoElement.height), this.doAddContentToCanvas()
            }
        }

        clearView() {
            switch (this.renderType) {
                case Le:
                    !function (e, t) {
                        const i = document.createElement("canvas");
                        i.width = e, i.height = t;
                        e = window.createImageBitmap(i, 0, 0, e, t);
                        return i.width = 0, i.height = 0, e
                    }(this.$videoElement.width, this.$videoElement.height).then(e => {
                        this.bitmaprenderer.transferFromImageBitmap(e)
                    });
                    break;
                case xe:
                    this.contextGl.clear(this.contextGl.COLOR_BUFFER_BIT);
                    break;
                case Ce:
                    this.webGPURender.clear();
                    break;
                case ke:
                    this.contextGl ? this.contextGl.clear(this.contextGl.COLOR_BUFFER_BIT) : this.context2D && this.context2D.clearRect(0, 0, this.$videoElement.width, this.$videoElement.height);
                    break;
                case De:
                case"hls":
                    this.context2D.clearRect(0, 0, this.$videoElement.width, this.$videoElement.height)
            }
        }

        _initTempTextCanvas() {
            this.tempTextCanvas = document.createElement("canvas"), this.tempTextCanvasCtx = this.tempTextCanvas.getContext("2d"), this.tempTextCanvas.width = 600, this.tempTextCanvas.height = 20
        }

        doAddContentToCanvas() {
            if (0 < this.tempCanvasContentList.length && this.context2D) {
                let {ctx: t, list: e} = {ctx: this.context2D, list: this.tempCanvasContentList};
                t.save(), (e || []).forEach(e => {
                    "text" === e.type ? (t.font = `${e.fontSize || 12}px Arial`, t.fillStyle = e.color || "green", t.fillText(e.text, e.x, e.y)) : "rect" === e.type && (t.strokeStyle = e.color || "green", t.lineWidth = e.lineWidth || 2, t.strokeRect(e.x, e.y, e.width, e.height))
                }), t.restore()
            }
        }

        doAddContentToWebGlCanvas() {
            0 < this.tempCanvasContentList.length && this.contextGl && this.webglRectRender && this.tempCanvasContentList.forEach(e => {
                var t = e.x, i = e.y;
                if ("rect" === e.type) {
                    var r = e.width, s = e.height,
                        a = (a = e.color || "#008000", [parseInt(a.substring(1, 3), 16) / 255, parseInt(a.substring(3, 5), 16) / 255, parseInt(a.substring(5, 7), 16) / 255, 1]),
                        n = e.lineWidth || 4;
                    r && s && this.webglRectRender.drawBox({
                        x: t,
                        y: i,
                        width: r,
                        height: s,
                        lineColor: a,
                        lineWidth: n,
                        canvasWidth: this.$videoElement.width,
                        canvasHeight: this.$videoElement.height
                    })
                } else if ("text" === e.type) {
                    const a = e.text || "";
                    a && (r = e.fontSize || 20, s = e.color || "#008000", this.tempTextCanvas || this._initTempTextCanvas(), this.tempTextCanvasCtx.clearRect(0, 0, this.tempTextCanvas.width, this.tempTextCanvas.height), this.tempTextCanvasCtx.font = r + "px Arial", this.tempTextCanvasCtx.fillStyle = s, this.tempTextCanvasCtx.textBaseline = "top", this.tempTextCanvasCtx.fillText(a, 0, 0), this.webglRender.drawDom(this.$videoElement.width, this.$videoElement.height, t, i, this.tempTextCanvas))
                }
            })
        }
    }

    class Bi {
        constructor(e) {
            this.player = e, this.configList = [], this.shadowRoot = null, this.shadowRootRealDom = null, this.shadowRootInnerDom = null, this.scale = 1, this._initDom(), this.player.debug.log("SingleWatermark", "int")
        }

        destroy() {
            this.configList = [], this.shadowRootInnerDom = null, this.scale = 1, this.shadowRoot && (this.player.$container.removeChild(this.shadowRootRealDom), this.shadowRoot = null, this.shadowRootInnerDom = null), this.player.debug.log("SingleWatermark", "destroy")
        }

        resize() {
            "default" === this.player._opt.aspectRatio || y() ? this.player.getRenderType() === Y ? this._resizeDomForCanvas() : this.player.getRenderType() === J && this._resizeDomForVideo() : this._resizeDomRatio()
        }

        _initDom() {
            const e = this.player.$container;
            let t = null;
            const i = document.createElement("div"),
                r = (i.setAttribute("style", "pointer-events: none !important;display: block !important;"), t = "function" == typeof i.attachShadow ? i.attachShadow({mode: "open"}) : i.shadowRoot || i, document.createElement("div"));
            r.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0;display: none;"), t.appendChild(r);
            var s = e.children, a = Math.floor(Math.random() * (s.length - 1));
            s[a] ? e.insertBefore(i, s[a]) : e.appendChild(i), this.shadowRootInnerDom = r, this.shadowRootRealDom = i, this.shadowRoot = t
        }

        update(e) {
            this._removeDom();
            let t = [];
            Array.isArray(e) ? t = e : Qt(e) && t.push(e);
            e = t.map(e => Wt(e));
            this.configList = e, this._updateDom()
        }

        _resizeDomForVideo() {
            const n = this.player.width, o = this.player.height, l = this.player.getVideoInfo();
            if (l && 0 < l.height && 0 < l.width) {
                let e = l.width, t = l.height;
                var d = this.player._opt;
                let i = o, r = n;
                if (d.hasControl && !d.controlAutoHide) {
                    const n = d.playType === A ? 48 : 38;
                    y() && this.player.fullscreen && d.useWebFullScreen ? r -= n : i -= n
                }
                var h = d.rotate, c = (r - e) / 2, u = (i - t) / 2,
                    p = (270 !== h && 90 !== h || (e = l.height, t = l.width), r / e), f = i / t;
                let s = f < p ? f : p,
                    a = (d.isResize || p != f && (s = p + "," + f), "scale(" + (s = d.isFullResize ? f < p ? p : f : s) + ")");
                "none" === d.mirrorRotate && h && (a += " rotate(" + h + "deg)"), "level" === d.mirrorRotate ? a += " rotateY(180deg)" : "vertical" === d.mirrorRotate && (a += " rotateX(180deg)"), this.scale = -1 !== ("" + s).indexOf(",") ? p : s, this.shadowRootInnerDom.style.transform = a, this.shadowRootInnerDom.style.left = c + "px", this.shadowRootInnerDom.style.top = u + "px", this.shadowRootInnerDom.style.width = l.width + "px", this.shadowRootInnerDom.style.height = l.height + "px", this.shadowRootInnerDom.style.display = "block"
            }
        }

        _resizeDomForCanvas() {
            const n = this.player.getVideoInfo();
            if (n && 0 < n.height && 0 < n.width) {
                var o = this.player._opt;
                let e = this.player.width, t = this.player.height;
                if (o.hasControl && !o.controlAutoHide) {
                    const n = o.playType === A ? 48 : 38;
                    y() && this.player.fullscreen && o.useWebFullScreen ? e -= n : t -= n
                }
                let i = n.width, r = n.height;
                var l = o.rotate, d = (e - i) / 2, h = (t - r) / 2,
                    c = (270 !== l && 90 !== l || (i = n.height, r = n.width), e / i), u = t / r;
                let s = u < c ? u : c,
                    a = (o.isResize || c != u && (s = c + "," + u), "scale(" + (s = o.isFullResize ? u < c ? c : u : s) + ")");
                "none" === o.mirrorRotate && l && (a += " rotate(" + l + "deg)"), "level" === o.mirrorRotate ? a += " rotateY(180deg)" : "vertical" === o.mirrorRotate && (a += " rotateX(180deg)"), this.shadowRootInnerDom.style.height = n.height + "px", this.shadowRootInnerDom.style.width = n.width + "px", this.shadowRootInnerDom.style.padding = "0", this.shadowRootInnerDom.style.transform = a, this.shadowRootInnerDom.style.left = d + "px", this.shadowRootInnerDom.style.top = h + "px", this.shadowRootInnerDom.style.display = "block"
            }
        }

        _resizeDomRatio() {
            var r = this.player.getVideoInfo();
            if (r && 0 < r.height && 0 < r.width) {
                const n = this.player._opt.aspectRatio.split(":").map(Number);
                let e = this.player.width, t = this.player.height;
                var s = this.player._opt;
                let i = 0;
                s.hasControl && !s.controlAutoHide && (i = s.playType === A ? 48 : 38, t -= i);
                var s = r.width / r.height, a = n[0] / n[1];
                if (a < s) {
                    const n = a * r.height / r.width;
                    this.shadowRootInnerDom.style.width = 100 * n + "%", this.shadowRootInnerDom.style.height = `calc(100% - ${i}px)`, this.shadowRootInnerDom.style.padding = `0 ${(e - e * n) / 2}px`
                } else {
                    const n = r.width / a / r.height;
                    this.shadowRootInnerDom.style.width = "100%", this.shadowRootInnerDom.style.height = `calc(${100 * n}% - ${i}px)`, this.shadowRootInnerDom.style.padding = (t - t * n) / 2 + "px 0"
                }
                this.shadowRootInnerDom.style.display = "block"
            }
        }

        _updateDom() {
            this.shadowRoot && this.configList.forEach(e => {
                const t = document.createElement("div");
                let i = null;
                e.image && e.image.src ? ((i = document.createElement("img")).style.height = "100%", i.style.width = "100%", i.style.objectFit = "contain", i.src = e.image.src) : e.text && e.text.content ? i = document.createTextNode(e.text.content) : (e.rect && e.rect.color && e.rect.width || e.html) && (i = document.createElement("div")), i && (t.appendChild(i), t.style.visibility = "", t.style.position = "absolute", t.style.display = "block", t.style["-ms-user-select"] = "none", t.style["-moz-user-select"] = "none", t.style["-webkit-user-select"] = "none", t.style["-o-user-select"] = "none", t.style["user-select"] = "none", t.style["-webkit-touch-callout"] = "none", t.style["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", t.style["-webkit-text-size-adjust"] = "none", t.style["-webkit-touch-callout"] = "none", t.style.opacity = e.opacity, h(e.left) && (t.style.left = e.left + "px"), h(e.right) && (t.style.right = e.right + "px"), h(e.top) && (t.style.top = e.top + "px"), h(e.bottom) && (t.style.bottom = e.bottom + "px"), e.backgroundColor && (t.style.backgroundColor = e.backgroundColor), t.style.overflow = "hidden", t.style.zIndex = "9999999", e.image && e.image.src ? (t.style.width = e.image.width + "px", t.style.height = e.image.height + "px") : e.text && e.text.content ? (t.style.fontSize = e.text.fontSize + "px", t.style.color = e.text.color) : e.rect && e.rect.color && e.rect.width ? (t.style.width = e.rect.width + "px", t.style.height = e.rect.height + "px", t.style.borderWidth = e.rect.lineWidth + "px", t.style.borderStyle = "solid", t.style.borderColor = e.rect.color) : e.html && (t.innerHTML = e.html, t.style.width = e.width + "px", t.style.height = e.height + "px"), this.shadowRootInnerDom.appendChild(t))
            })
        }

        remove() {
            this._removeDom()
        }

        _removeDom() {
            this.shadowRootInnerDom && (this.shadowRootInnerDom.innerHTML = "")
        }
    }

    class Ui extends Si {
        constructor(t) {
            super(), this.player = t, this.TAG_NAME = "Video";
            const e = document.createElement("video"), i = document.createElement("canvas"),
                r = (e.muted = !0, e.style.position = "absolute", e.style.top = 0, e.style.left = 0, this._delayPlay = !1, t.$container.appendChild(e), this.$videoElement = e, this.$canvasElement = i, this.canvasContext = i.getContext("2d"), this.mediaStream = null, this.vwriter = null, t.canVideoTrackWritter() && jt() && zt() && (this.trackGenerator = new MediaStreamTrackGenerator({kind: "video"}), this.mediaStream = new MediaStream([this.trackGenerator]), e.srcObject = this.mediaStream, this.vwriter = this.trackGenerator.writable.getWriter()), this.fixChromeVideoFlashBug(), this.fixMobileAutoFullscreen(), this.resize(), this.eventListenList = [], this.tempContentList = [], this.contentWatermark = null, this.isRenderRetryPlaying = !1, this.isRenderRetryPlayingTimes = 0, this.isRetryPlaying = !1, this.isRetryPlayingTimes = 0, this.player.events)["proxy"],
                s = r(this.$videoElement, "canplay", () => {
                    this.player.debug.log("Video", "canplay"), this._delayPlay && this._play()
                }), a = r(this.$videoElement, "waiting", () => {
                    this.player.debug.log("Video", "waiting")
                }), n = r(this.$videoElement, "loadedmetadata", () => {
                    this.player.debug.log("Video", "loadedmetadata")
                }), o = r(this.$videoElement, "timeupdate", e => {
                    e = parseInt(e.timeStamp, 10);
                    (this.player.isWebrtcH264() || this.player.isOldHls()) && this.player.emit(w.timeUpdate, e), t.isWebrtcH264() && (t.handleRender(), t.updateStats({fps: !0}))
                }), l = r(this.$videoElement, "error", () => {
                    this.player.debug.error("Video", "Error Code" + this.$videoElement.error.code + "; Details: " + this.$videoElement.error.message)
                });
            this.eventListenList.push(s, a, o, l, n), this.player.debug.log("Video", "init")
        }

        destroy() {
            if (super.destroy(), this.eventListenList && (this.eventListenList.forEach(e => {
                e()
            }), this.eventListenList = []), this.contentWatermark && (this.contentWatermark.destroy(), this.contentWatermark = null), this.tempContentList = [], this.isRenderRetryPlaying = !1, this.isRenderRetryPlayingTimes = 0, this.isRetryPlaying = !1, this.isRetryPlayingTimes = 0, this.player._opt.videoRenderSupportScale && this._isNeedAddBackDropFilter()) {
                const e = this.player.$container;
                e.style.backdropFilter = "none", e.style.transform = "none"
            }
            if (this.$canvasElement.height = 0, this.$canvasElement.width = 0, this.$canvasElement = null, this.canvasContext = null, this.$videoElement) {
                this.$videoElement.pause(), this.$videoElement.currentTime = 0, this.$videoElement.srcObject && (this.$videoElement.srcObject = null, this.$videoElement.removeAttribute("srcObject")), this.$videoElement.src && (this.$videoElement.src = "", this.$videoElement.removeAttribute("src"));
                try {
                    this.$videoElement.load()
                } catch (e) {
                }
                this.player.$container.removeChild(this.$videoElement), this.$videoElement = null
            }
            this.trackGenerator && (this.trackGenerator.stop(), this.trackGenerator = null), this.vwriter && (this.vwriter.close(), this.vwriter = null), this._delayPlay = !1, this.mediaStream && (this.mediaStream.getTracks().forEach(e => e.stop()), this.mediaStream = null), this.off(), this.player.debug.log("Video", "destroy")
        }

        fixChromeVideoFlashBug() {
            if (this.player._opt.videoRenderSupportScale && this._isNeedAddBackDropFilter()) {
                const e = this.player.$container;
                e.style.backdropFilter = "blur(0px)", e.style.transform = "translateZ(0)"
            }
        }

        fixMobileAutoFullscreen() {
            var e = Dt(), t = Ct();
            (e || t) && (this.player.debug.log("Video", `fixMobileAutoFullscreen and isIOS ${e} and isAndroid ` + t), this.$videoElement.setAttribute("webkit-playsinline", "true"), this.$videoElement.setAttribute("playsinline", "true"), this.$videoElement.setAttribute("x5-video-player-type", "h5-page"))
        }

        _isNeedAddBackDropFilter() {
            var e = Lt().type.toLowerCase();
            return "chrome" === e || "edge" === e
        }

        isPaused() {
            let e = !0;
            return e = this.$videoElement ? this.$videoElement.paused : e
        }

        isPause() {
            return this.isPaused()
        }

        _getVideoReadyState() {
            let e = 0;
            return e = this.$videoElement ? this.$videoElement.readyState : e
        }

        _getVideoCurrentTime() {
            let e = 0;
            return e = this.$videoElement ? this.$videoElement.currentTime : e
        }

        play() {
            if (this.$videoElement) {
                var e = this._getVideoReadyState();
                if (this.player.debug.log("Video", "play and readyState: " + e), 0 === e) return this.player.debug.warn("Video", "readyState is 0 and set _delayPlay to true and listen canplay event to play"), void (this._delayPlay = !0);
                this._play()
            }
        }

        _play() {
            this.$videoElement && this.$videoElement.play().then(() => {
                this._delayPlay = !1, this.player.debug.log("Video", "_play success"), this.isPlaying() ? (this.player.emit(w.removeLoadingBgImage), this.isRetryPlayingTimes = 0, this.isRetryPlaying = !1) : setTimeout(() => {
                    this._replay()
                }, 100)
            }).catch(e => {
                this.player.debug.error("Video", "_play error", e), this.isRetryPlaying = !1, setTimeout(() => {
                    this._replay()
                }, 100)
            })
        }

        _replay() {
            !this.isPlaying() && C(this.isRetryPlaying) && (this.isRetryPlaying = !0, 3 <= this.isRetryPlayingTimes ? this.player.isWebrtcH264() ? (this.player.debug.error("Video", `_replay(webrtc H264) then but not playing and retry play times is ${this.isRetryPlayingTimes} and emit error`), this.player.emitError(S.videoElementPlayingFailedForWebrtc)) : (this.player.debug.error("Video", `_replay then but not playing and retry play times is ${this.isRetryPlayingTimes} and emit error to use canvas render`), this.player.emitError(S.videoElementPlayingFailed)) : (this.player.debug.warn("Video", "_play then but not playing and retry play"), this._play(), this.isRetryPlayingTimes++))
        }

        pause(e) {
            this.isPlaying() && (e ? this.$videoElement && this.$videoElement.pause() : setTimeout(() => {
                this.$videoElement && this.$videoElement.pause()
            }, 100))
        }

        clearView() {
            this.$videoElement && (this.$videoElement.pause(), this.$videoElement.currentTime = 0, this.$videoElement.src && (this.$videoElement.src = "", this.$videoElement.removeAttribute("src")), this.$videoElement.srcObject && (this.$videoElement.srcObject = null, this.$videoElement.removeAttribute("srcObject")))
        }

        screenshot(e, t, i, r) {
            if (!this._canScreenshot()) return this.player.debug.warn("Video", "screenshot failed, video is not ready"), null;
            e = e || p(), r = r || l.download;
            let s = .92;
            !d[t] && l[t] && (r = t, t = "png", i = void 0), "string" == typeof i && (r = i, i = void 0), void 0 !== i && (s = Number(i));
            i = this.$videoElement;
            let a = this.$canvasElement;
            a.width = i.videoWidth, a.height = i.videoHeight, this.canvasContext.drawImage(i, 0, 0, a.width, a.height);
            const n = d[t] || d.png, o = a.toDataURL(n, s);
            if (this.canvasContext.clearRect(0, 0, a.width, a.height), a.width = 0, a.height = 0, r === l.base64) return o;
            {
                const t = wt(o);
                if (r === l.blob) return t;
                if (r === l.download) {
                    const i = n.split("/")[1];
                    Li(t, e + "." + i)
                }
            }
        }

        screenshotWatermark(a) {
            return new Promise((i, t) => {
                if (Xt(a) && (a = {filename: a}), !this._canScreenshot()) return this.player.debug.warn("Video", "screenshot failed, video is not ready"), t("screenshot failed, video is not ready");
                var e = this.$videoElement;
                (a = a || {}).width = e.videoWidth, a.height = e.videoHeight, a.filename = a.filename || p(), a.format = a.format ? d[a.format] : d.png, a.quality = Number(a.quality) || .92, a.type = a.type || l.download;
                let r = this.$canvasElement;
                r.width = e.videoWidth, r.height = e.videoHeight, this.canvasContext.drawImage(e, 0, 0, r.width, r.height);
                const s = r.toDataURL(a.format, a.quality);
                this.canvasContext.clearRect(0, 0, r.width, r.height), r.width = 0, r.height = 0, Kt(s, a).then(e => {
                    if (a.type === l.base64) i(s); else {
                        var t = wt(e);
                        if (a.type === l.blob) i(t); else if (a.type === l.download) {
                            i();
                            const e = a.format.split("/")[1];
                            Li(t, a.filename + "." + e)
                        }
                    }
                }).catch(e => {
                    t(e)
                })
            })
        }

        initCanvasViewSize() {
            this.resize()
        }

        clear() {
            const e = this.$videoElement, t = e.buffered, i = t.length ? t.end(t.length - 1) : 0;
            e.currentTime = i
        }

        render(t) {
            if (this.vwriter) {
                if (this.$videoElement.srcObject || (this.$videoElement.srcObject = this.mediaStream), this.isPaused()) {
                    const t = this._getVideoReadyState();
                    if (this.player.debug.warn("Video", "render() error, video is paused and readyState is " + t), 4 === t && C(this.isRenderRetryPlaying)) {
                        if (this.isRenderRetryPlaying = !0, 3 < this.isRenderRetryPlayingTimes) return this.player.debug.error("Video", "render() error, video is paused and readyState is " + t + ", retry times is " + this.isRenderRetryPlayingTimes + ", emit error and use canvas render"), void this.player.emitError(S.videoElementPlayingFailed);
                        this.$videoElement.play().then(() => {
                            this.isRenderRetryPlayingTimes = 0, this.isRenderRetryPlaying = !1, this.player.debug.log("Video", "render() video is paused and replay success")
                        }).catch(e => {
                            this.isRenderRetryPlaying = !1, this.isRenderRetryPlayingTimes++, this.player.debug.warn("Video", "render() error, video is paused and replay error ", e)
                        })
                    }
                }
                if (this.player.videoTimestamp = t.ts || 0, this.player.updateStats({
                    fps: !0,
                    ts: t.ts || 0
                }), t.videoFrame) this.vwriter.write(t.videoFrame), ai(t.videoFrame); else if (t.output) {
                    let e = t.output;
                    this.player.faceDetectActive && this.player.ai && this.player.ai.faceDetector && (e = this.player.ai.faceDetector.detect({
                        width: this.videoInfo.width,
                        height: this.videoInfo.height,
                        data: t.output
                    })), this.player.objectDetectActive && this.player.ai && this.player.ai.objectDetector && (e = this.player.ai.objectDetector.detect({
                        width: this.videoInfo.width,
                        height: this.videoInfo.height,
                        data: t.output
                    }));
                    try {
                        r = e, s = {
                            format: "I420",
                            codedWidth: this.videoInfo.width,
                            codedHeight: this.videoInfo.height,
                            timestamp: t.ts
                        };
                        var i = new VideoFrame(r, s);
                        this.vwriter.write(i), ai(i)
                    } catch (t) {
                        this.player.debug.error("Video", "render error", t), this.player.emitError(S.wasmUseVideoRenderError, t)
                    }
                }
                this.doAddContentToWatermark()
            } else this.player.debug.warn("Video", "render and this.vwriter is null");
            var r, s
        }

        _resize() {
            this.player.debug.log("Video", "_resize()");
            let e = this.player.width, t = this.player.height;
            const i = this.player._opt, r = i.rotate;
            if (i.hasControl && !i.controlAutoHide) {
                const r = i.playType === A ? 48 : 38;
                y() && this.player.fullscreen && i.useWebFullScreen ? e -= r : t -= r
            }
            this.$videoElement.width = e, this.$videoElement.height = t, this.$videoElement.style.width = e + "px", this.$videoElement.style.height = t + "px", 270 !== r && 90 !== r || (this.$videoElement.width = t, this.$videoElement.height = e, this.$videoElement.style.width = t + "px", this.$videoElement.style.height = e + "px");
            let s = (e - this.$videoElement.width) / 2, a = (t - this.$videoElement.height) / 2, n = "contain",
                o = (i.isResize || (n = "fill"), i.isFullResize && (n = "none"), "");
            "none" === i.mirrorRotate && r && (o += " rotate(" + r + "deg)"), "level" === i.mirrorRotate ? o += " rotateY(180deg)" : "vertical" === i.mirrorRotate && (o += " rotateX(180deg)"), this.player._opt.videoRenderSupportScale && (this.$videoElement.style.objectFit = n), this.$videoElement.style.transform = o, this.$videoElement.style.padding = "0", this.$videoElement.style.left = s + "px", this.$videoElement.style.top = a + "px"
        }

        getType() {
            return J
        }

        getCurrentTime() {
            return this.$videoElement.currentTime
        }

        isPlaying() {
            return this.$videoElement && C(this.$videoElement.paused) && C(this.$videoElement.ended) && 0 !== this.$videoElement.playbackRate && 0 !== this.$videoElement.readyState
        }

        _canScreenshot() {
            return this.$videoElement && 2 <= this.$videoElement.readyState
        }

        addContentToCanvas() {
            this.tempContentList = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : []
        }

        doAddContentToWatermark() {
            var e;
            0 < this.tempContentList.length ? (this.contentWatermark || (this.contentWatermark = new Bi(this.player), this.contentWatermark.resize()), e = this.tempContentList.map(e => {
                let t = {left: e.x, top: e.y};
                return "text" === e.type ? t.text = {
                    content: e.text,
                    fontSize: e.fontSize,
                    color: e.color
                } : "rect" === e.type && (t.rect = {
                    width: e.width,
                    height: e.height,
                    color: e.color,
                    lineWidth: e.lineWidth
                }), t
            }), this.contentWatermark.update(e)) : this.contentWatermark && this.contentWatermark.remove()
        }

        getPlaybackQuality() {
            let e = null;
            var t;
            return this.$videoElement && (e = b(this.$videoElement.getVideoPlaybackQuality) ? {
                droppedVideoFrames: (t = this.$videoElement.getVideoPlaybackQuality()).droppedVideoFrames || t.corruptedVideoFrames,
                totalVideoFrames: t.totalVideoFrames,
                creationTime: t.creationTime
            } : {
                droppedVideoFrames: this.$videoElement.webkitDroppedFrameCount,
                totalVideoFrames: this.$videoElement.webkitDecodedFrameCount,
                creationTime: p()
            }) && (e.renderedVideoFrames = e.totalVideoFrames - e.droppedVideoFrames), e
        }
    }

    class Fi extends Ri {
        constructor(e) {
            super(e), this.controlHeight = 48, this.bufferList = [], this.playing = !1, this.playInterval = null, this.fps = 1, this.preFps = 1, this.streamFps = 0, this.playbackRate = 1, this._firstTimestamp = null, this._renderFps = 0, this._startfpsTime = null, this._startFpsTimestamp = null, this._hasCalcFps = !1, this.player.on(w.playbackPause, e => {
                e ? (this.pause(), this.player.playback.isPlaybackPauseClearCache && this.clear()) : this.resume()
            }), this.player.debug.log("CanvasPlaybackLoader", "init")
        }

        destroy() {
            this._stopSync(), this._firstTimestamp = null, this.playing = !1, this.playbackRate = 1, this.fps = 1, this.preFps = 1, this.bufferList = [], this._renderFps = 0, this._startfpsTime = null, this._startFpsTimestamp = null, this._hasCalcFps = !1, super.destroy(), this.player.debug.log("CanvasPlaybackLoader", "destroy")
        }

        _initCanvasRender() {
            this.player._opt.useWCS ? (this.renderType = ke, fi() && this.player._opt.wcsUseWebgl2Render ? (this._initContextGl2(), this.webglRender && (this.isWcsWebgl2 = !0)) : this._initContext2D()) : this.player._opt.useWebGPU ? (this.renderType = Ce, this._initContextGPU()) : (this.renderType = xe, this._initContextGl())
        }

        _sync() {
            this._stopSync(), this._doPlay(), this.playInterval = setInterval(() => {
                this._doPlay()
            }, this.fragDuration)
        }

        _doPlay() {
            var e;
            0 < this.bufferList.length && !this.player.seeking && ((e = this.bufferList.shift()) && e.buffer && (this._doRender(e.buffer), this.player.handleRender(), this.player.playback.updateStats({
                ts: e.ts,
                tfTs: e.tfTs
            })))
        }

        _stopSync() {
            this.playInterval && (clearInterval(this.playInterval), this.playInterval = null)
        }

        _doRender(t) {
            if (this.player._opt.useWCS) if (this.webglRender) this.webglRender.render(t), ai(t); else if (b(t.createImageBitmap)) try {
                t.createImageBitmap().then(e => {
                    this.context2D.drawImage(e, 0, 0, this.$videoElement.width, this.$videoElement.height), ai(t)
                })
            } catch (t) {
            } else this.context2D.drawImage(t, 0, 0, this.$videoElement.width, this.$videoElement.height), ai(t); else if (this.getCanvasType() === xe) try {
                this.webglRender.renderYUV(this.$videoElement.width, this.$videoElement.height, t)
            } catch (t) {
                this.player.debug.error("CanvasPlaybackLoader", `doRender webgl render context is lost ${this.contextGl && this.contextGl.isContextLost()}  and error: ` + t.toString())
            } else if (this.getCanvasType() === Ce) try {
                this.webGPURender ? this.webGPURender.renderYUV(this.$videoElement.width, this.$videoElement.height, t) : this.player.debug.warn("CanvasVideoLoader", "doRender webgpu render is not init")
            } catch (t) {
                this.player.debug.error("CanvasPlaybackLoader", "doRender webgpu render and error: " + t.toString())
            }
        }

        _updateStats(e) {
            this.player.updateStats({
                fps: !0,
                ts: e
            }), this._startfpsTime || (this._startfpsTime = e, this._startFpsTimestamp = p());
            var t = e, i = p(), r = i - this._startFpsTimestamp;
            r <= 1e3 ? this._renderFps += 1 : (this.player.emit(w.playbackStats, {
                fps: this._renderFps,
                start: this._startfpsTime,
                end: t,
                timestamp: r,
                dataTimestamp: t - this._startfpsTime,
                audioBufferSize: this.player.audio ? this.player.audio.bufferSize : 0,
                videoBufferSize: this.player.video ? this.player.video.bufferSize : 0,
                ts: e
            }), this._renderFps = 0, this._startfpsTime = t, this._startFpsTimestamp = i)
        }

        get rate() {
            return this.playbackRate
        }

        get fragDuration() {
            return Math.ceil(1e3 / (this.fps * this.playbackRate))
        }

        get bufferSize() {
            return this.bufferList.length
        }

        getStreamFps() {
            return this.streamFps
        }

        initFps() {
            this._hasCalcFps ? this.player.debug.log("CanvasPlaybackLoader", "initFps, has calc fps") : (this.preFps = E(this.player.playback.fps, 1, 100), this.fps = this.preFps)
        }

        setFps(e) {
            e !== this.fps ? (100 < e && this.player.debug.warn("CanvasPlaybackLoader", "setFps max", e), e < 0 && this.player.debug.warn("CanvasPlaybackLoader", "setFps min", e), this.fps = E(e, 1, 100), this.player.debug.log("CanvasPlaybackLoader", `setFps ${this.preFps} -> ` + this.fps), this.player.playback.isUseFpsRender && this._sync()) : this.player.debug.log("CanvasPlaybackLoader", "setFps, same fps " + e)
        }

        setStreamFps(e) {
            this.player.debug.log("CanvasPlaybackLoader", "setStreamFps", e), this._hasCalcFps = !0, this.streamFps = e, this.preFps = e, this.setFps(e)
        }

        setRate(e) {
            e !== this.playbackRate && (this.playbackRate = e, this.player.playback.isUseFpsRender && this._sync())
        }

        render$2(e) {
            null === this._firstTimestamp && (this._firstTimestamp = e.ts);
            const t = {tfTs: e.ts - this._firstTimestamp, ts: e.ts};
            e.videoFrame ? t.buffer = e.videoFrame : t.buffer = e.output, this.bufferList.push(t), this.startRender(), this.player.handleRender(), this.player.playback.updateStats({
                ts: e.ts,
                tfTs: t.tfTs
            })
        }

        startRender() {
            for (; !(this.bufferList.length <= 0);) {
                var e = this.bufferList.shift();
                this._doRender(e.buffer)
            }
        }

        pushData(e) {
            null === this._firstTimestamp && (this._firstTimestamp = e.ts);
            const t = {tfTs: e.ts - this._firstTimestamp, ts: e.ts};
            e.videoFrame ? t.buffer = e.videoFrame : t.buffer = e.output;
            e = this.player._opt.playbackConfig.isCacheBeforeDecodeForFpsRender;
            if (e || this.bufferSize > this.fps * this.playbackRate * 2 && (this.player.debug.warn("CanvasPlaybackLoader", "buffer size is " + this.bufferSize), this._doPlay()), this.bufferList.push(t), !this._hasCalcFps) {
                const e = oi(this.bufferList);
                null !== e && e !== this.preFps && (this.player.debug.log("CanvasPlaybackLoader", `calc fps is ${e} pre fps is ${this.preFps} and updatePreFps`), this.setStreamFps(e))
            }
            if (!e) {
                const e = this.bufferList.length, t = e / (this.fps * this.playbackRate);
                this.player.debug.log("CanvasPlaybackLoader", "rate is", t), t <= 1 ? this.setFps(this.preFps) : (this.setFps(this.fps + Math.floor(t * this.playbackRate)), this.player.debug.warn("CanvasPlaybackLoader", "rate is", t, "fps is", this.fps, "bufferListLength is", e))
            }
        }

        initVideo() {
            this.player.playback && this.player.playback.isUseFpsRender && this._sync(), this.playing = !0
        }

        initVideoDelay() {
            var e = this.player._opt.playbackDelayTime;
            0 < e ? this.delayTimeout = setTimeout(() => {
                this.initVideo()
            }, e) : this.initVideo()
        }

        clearView() {
            this.contextGl.clear(this.contextGl.COLOR_BUFFER_BIT)
        }

        clear() {
            this.player._opt.useWCS && this.bufferList.forEach(e => {
                e.buffer && ai(e.buffer)
            }), this.bufferList = []
        }

        resume() {
            this.player.playback.isUseFpsRender && this._sync(), this.playing = !0
        }

        pause() {
            this.player.playback.isUseFpsRender && this._stopSync(), this.playing = !1
        }
    }

    class Mi {
        constructor(e) {
            return new (Mi.getLoaderFactory(e._opt))(e)
        }

        static getLoaderFactory(e) {
            return e.useMSE ? e.mseUseCanvasRender ? Pi : Ui : e.isHls && C(e.supportHls265) ? e.useCanvasRender ? Pi : Ui : e.isWebrtc && C(e.isWebrtcH265) ? Ui : e.useWCS ? e.playType === A ? Fi : !e.useOffscreen && e.wcsUseVideoRender ? Ui : Pi : e.playType === A ? Fi : e.wasmUseVideoRender && !e.useOffscreen ? Ui : Pi
        }
    }

    class Oi extends e {
        constructor(e) {
            super(), this.bufferList = [], this.player = e, this.$audio = null, this.scriptNode = null, this.workletProcessorNode = null, this.hasInitScriptNode = !1, this.audioContext = new (window.AudioContext || window.webkitAudioContext)({sampleRate: 48e3}), this.gainNode = this.audioContext.createGain();
            const t = this.audioContext.createBufferSource();
            t.buffer = this.audioContext.createBuffer(1, 1, 22050), t.connect(this.audioContext.destination), t.noteOn ? t.noteOn(0) : t.start(0), this.audioBufferSourceNode = t, this.mediaStreamAudioDestinationNode = this.audioContext.createMediaStreamDestination(), this.gainNode.gain.value = 0, this.playing = !1, this.audioSyncVideoOption = {diff: null}, this.audioInfo = {
                encType: "",
                channels: "",
                sampleRate: ""
            }, this.init = !1, this.hasAudio = !1, this.audioResumeStateTimeout = null, this.on(w.videoSyncAudio, e => {
                this.audioSyncVideoOption = e
            })
        }

        destroy() {
            this.closeAudio(), this.resetInit(), this.audioContext.close(), this.audioContext = null, this.gainNode = null, this.hasAudio = !1, this.playing = !1, this.scriptNode && (this.scriptNode.onaudioprocess = o, this.scriptNode = null), this.workletProcessorNode && (this.workletProcessorNode.port.onmessage = o, this.workletProcessorNode = null), this.audioResumeStateTimeout && (clearTimeout(this.audioResumeStateTimeout), this.audioResumeStateTimeout = null), this.audioBufferSourceNode = null, this.mediaStreamAudioDestinationNode = null, this.hasInitScriptNode = !1, this.audioSyncVideoOption = {diff: null}, this.off()
        }

        resetInit() {
            this.audioInfo = {encType: "", channels: "", sampleRate: ""}, this.init = !1
        }

        getAudioInfo() {
            return this.audioInfo
        }

        updateAudioInfo(e) {
            e.encTypeCode && (this.audioInfo.encType = Ee[e.encTypeCode]), e.channels && (this.audioInfo.channels = e.channels), e.sampleRate && (this.audioInfo.sampleRate = e.sampleRate), this.audioInfo.sampleRate && this.audioInfo.channels && this.audioInfo.encType && !this.init && (this.player.emit(w.audioInfo, this.audioInfo), this.init = !0)
        }

        get isPlaying() {
            return this.playing
        }

        get isMute() {
            return 0 === this.gainNode.gain.value
        }

        get volume() {
            return this.gainNode.gain.value
        }

        get bufferSize() {
            return this.bufferList.length
        }

        initScriptNode() {
        }

        initMobileScriptNode() {
        }

        initWorkletScriptNode() {
        }

        getEngineType() {
            return ""
        }

        mute(e) {
            e ? (this.isMute || this.player.emit(w.mute, e), this.setVolume(0), this.clear()) : (this.isMute && this.player.emit(w.mute, e), this.setVolume(this.player.lastVolume || .5))
        }

        setVolume(e) {
            e = parseFloat(e).toFixed(2), isNaN(e) || (this.audioEnabled(!0), e = E(e, 0, 1), this.gainNode.gain.value = e, this.player.emit(w.volumechange, this.player.volume))
        }

        closeAudio() {
            this.hasInitScriptNode && (this.scriptNode && this.scriptNode.disconnect(this.gainNode), this.workletProcessorNode && this.workletProcessorNode.disconnect(this.gainNode), this.gainNode && (this.gainNode.disconnect(this.mediaStreamAudioDestinationNode), this.$audio || this.gainNode.disconnect(this.audioContext.destination))), this.clear()
        }

        audioEnabled(e) {
            e ? this.isStateSuspended() && (this.audioContext.resume().then(() => {
                this.player.emit(w.audioResumeState, {state: this.audioContext.state, isRunning: this.isStateRunning()})
            }), this.audioResumeStateTimeout = setTimeout(() => {
                clearTimeout(this.audioResumeStateTimeout), this.audioResumeStateTimeout = null, this.isStateSuspended() && this.player.emit(w.audioResumeState, {
                    state: this.audioContext.state,
                    isRunning: this.isStateRunning()
                })
            }, 1e3)) : this.isStateRunning() && this.audioContext.suspend()
        }

        isStateRunning() {
            return "running" === this.audioContext.state
        }

        isStateSuspended() {
            return "suspended" === this.audioContext.state
        }

        clear() {
            this.bufferList = []
        }

        play(e, t) {
        }

        pause() {
            this.audioSyncVideoOption = {diff: null}, this.playing = !1
        }

        resume() {
            this.playing = !0
        }

        setRate(e) {
        }

        getAudioBufferSize() {
            return 0
        }
    }

    class Ni {
        constructor(e, t, i, r) {
            this.player = e, this.audio = t, this.channel = i, this.bufferSize = r
        }

        extract(t, e) {
            var i = this.provide(e);
            for (let e = 0; e < i.size; e++) t[2 * e] = i.left[e], t[2 * e + 1] = i.right[e];
            return this.audio.tempAudioTimestamp = i.ts, i.size
        }

        provide(t) {
            let i = new Float32Array(t), r = new Float32Array(t), e = 0, s = 0, a = 0, n = t / this.bufferSize;
            const o = this.audio.bufferList;
            if (n && o.length >= n) {
                try {
                    for (let e = 0; e < n; e++) {
                        const t = o.shift();
                        2 === this.channel ? (i.set(t.buffer[0], a), r.set(t.buffer[1], a)) : (i.set(t.buffer[0], a), r.set(t.buffer[0], a)), a += this.bufferSize, s = t.ts
                    }
                } catch (t) {
                    this.player.debug.warn("Processor", "provide()", t), i = new Float32Array(0), r = new Float32Array(0)
                }
                e = i.length
            }
            return {size: e, ts: s, left: i, right: r}
        }

        destroy() {
            this.buffer = null, this.channel = null
        }
    }

    class ji {
        constructor() {
            this._vector = new Float32Array, this._position = 0, this._frameCount = 0
        }

        get vector() {
            return this._vector
        }

        get position() {
            return this._position
        }

        get startIndex() {
            return 2 * this._position
        }

        get frameCount() {
            return this._frameCount
        }

        get endIndex() {
            return 2 * (this._position + this._frameCount)
        }

        clear() {
            this.receive(this._frameCount), this.rewind()
        }

        put(e) {
            this._frameCount += e
        }

        putSamples(e, t) {
            let i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            var t = 2 * (t = t || 0), r = 2 * (i = 0 <= i ? i : (e.length - t) / 2),
                s = (this.ensureCapacity(i + this._frameCount), this.endIndex);
            this.vector.set(e.subarray(t, t + r), s), this._frameCount += i
        }

        putBuffer(e, t) {
            let i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            t = t || 0, 0 <= i || (i = e.frameCount - t), this.putSamples(e.vector, e.position + t, i)
        }

        receive(e) {
            0 <= e && !(e > this._frameCount) || (e = this.frameCount), this._frameCount -= e, this._position += e
        }

        receiveSamples(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i = this.startIndex;
            e.set(this._vector.subarray(i, i + 2 * t)), this.receive(t)
        }

        extract(e) {
            var t = this.startIndex + 2 * (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0);
            e.set(this._vector.subarray(t, t + 2 * (2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0)))
        }

        ensureCapacity() {
            var e = parseInt(2 * (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0));
            if (this._vector.length < e) {
                const t = new Float32Array(e);
                t.set(this._vector.subarray(this.startIndex, this.endIndex)), this._vector = t, this._position = 0
            } else this.rewind()
        }

        ensureAdditionalCapacity() {
            this.ensureCapacity(this._frameCount + (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0))
        }

        rewind() {
            0 < this._position && (this._vector.set(this._vector.subarray(this.startIndex, this.endIndex)), this._position = 0)
        }
    }

    class zi {
        constructor(e) {
            e ? (this._inputBuffer = new ji, this._outputBuffer = new ji) : this._inputBuffer = this._outputBuffer = null
        }

        get inputBuffer() {
            return this._inputBuffer
        }

        set inputBuffer(e) {
            this._inputBuffer = e
        }

        get outputBuffer() {
            return this._outputBuffer
        }

        set outputBuffer(e) {
            this._outputBuffer = e
        }

        clear() {
            this._inputBuffer.clear(), this._outputBuffer.clear()
        }
    }

    class Gi extends zi {
        constructor(e) {
            super(e), this.reset(), this._rate = 1
        }

        set rate(e) {
            this._rate = e
        }

        reset() {
            this.slopeCount = 0, this.prevSampleL = 0, this.prevSampleR = 0
        }

        clone() {
            const e = new Gi;
            return e.rate = this._rate, e
        }

        process() {
            var e = this._inputBuffer.frameCount,
                e = (this._outputBuffer.ensureAdditionalCapacity(e / this._rate + 1), this.transpose(e));
            this._inputBuffer.receive(), this._outputBuffer.put(e)
        }

        transpose() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
            if (0 === e) return 0;
            const t = this._inputBuffer.vector, i = this._inputBuffer.startIndex, r = this._outputBuffer.vector,
                s = this._outputBuffer.endIndex;
            let a = 0, n = 0;
            for (; this.slopeCount < 1;) r[s + 2 * n] = (1 - this.slopeCount) * this.prevSampleL + this.slopeCount * t[i], r[s + 2 * n + 1] = (1 - this.slopeCount) * this.prevSampleR + this.slopeCount * t[i + 1], n += 1, this.slopeCount += this._rate;
            if (--this.slopeCount, 1 !== e) e:for (; ;) {
                for (; 1 < this.slopeCount;) if (--this.slopeCount, (a += 1) >= e - 1) break e;
                var o = i + 2 * a;
                r[s + 2 * n] = (1 - this.slopeCount) * t[o] + this.slopeCount * t[o + 2], r[s + 2 * n + 1] = (1 - this.slopeCount) * t[o + 1] + this.slopeCount * t[o + 3], n += 1, this.slopeCount += this._rate
            }
            return this.prevSampleL = t[i + 2 * e - 2], this.prevSampleR = t[i + 2 * e - 1], n
        }
    }

    function Hi() {
    }

    class Wi extends class {
        constructor(e) {
            this._pipe = e
        }

        get pipe() {
            return this._pipe
        }

        get inputBuffer() {
            return this._pipe.inputBuffer
        }

        get outputBuffer() {
            return this._pipe.outputBuffer
        }

        fillInputBuffer() {
            throw new Error("fillInputBuffer() not overridden")
        }

        fillOutputBuffer() {
            let e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
            for (; this.outputBuffer.frameCount < e;) {
                const e = 16384 - this.inputBuffer.frameCount;
                if (this.fillInputBuffer(e), this.inputBuffer.frameCount < 16384) break;
                this._pipe.process()
            }
        }

        clear() {
            this._pipe.clear()
        }
    } {
        constructor(e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : Hi;
            super(t), this.callback = i, this.sourceSound = e, this.historyBufferSize = 22050, this._sourcePosition = 0, this.outputBufferPosition = 0, this._position = 0
        }

        get position() {
            return this._position
        }

        set position(e) {
            if (e > this._position) throw new RangeError("New position may not be greater than current position");
            var t = this.outputBufferPosition - (this._position - e);
            if (t < 0) throw new RangeError("New position falls outside of history buffer");
            this.outputBufferPosition = t, this._position = e
        }

        get sourcePosition() {
            return this._sourcePosition
        }

        set sourcePosition(e) {
            this.clear(), this._sourcePosition = e
        }

        onEnd() {
            this.callback()
        }

        fillInputBuffer() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, t = new Float32Array(2 * e),
                e = this.sourceSound.extract(t, e, this._sourcePosition);
            this._sourcePosition += e, this.inputBuffer.putSamples(t, 0, e)
        }

        extract(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                t = (this.fillOutputBuffer(this.outputBufferPosition + t), Math.min(t, this.outputBuffer.frameCount - this.outputBufferPosition)),
                e = (this.outputBuffer.extract(e, this.outputBufferPosition, t), this.outputBufferPosition + t);
            return this.outputBufferPosition = Math.min(this.historyBufferSize, e), this.outputBuffer.receive(Math.max(e - this.historyBufferSize, 0)), this._position += t, t
        }

        handleSampleData(e) {
            this.extract(e.data, 4096)
        }

        clear() {
            super.clear(), this.outputBufferPosition = 0
        }
    }

    const Vi = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];

    class Ki extends zi {
        constructor(e) {
            super(e), this._quickSeek = !0, this.midBufferDirty = !1, this.midBuffer = null, this.overlapLength = 0, this.autoSeqSetting = !0, this.autoSeekSetting = !0, this._tempo = 1, this.setParameters(44100, 0, 0, 8)
        }

        clear() {
            super.clear(), this.clearMidBuffer()
        }

        clearMidBuffer() {
            this.midBufferDirty && (this.midBufferDirty = !1, this.midBuffer = null)
        }

        setParameters(e, t, i, r) {
            0 < e && (this.sampleRate = e), 0 < r && (this.overlapMs = r), 0 < t ? (this.sequenceMs = t, this.autoSeqSetting = !1) : this.autoSeqSetting = !0, 0 < i ? (this.seekWindowMs = i, this.autoSeekSetting = !1) : this.autoSeekSetting = !0, this.calculateSequenceParameters(), this.calculateOverlapLength(this.overlapMs), this.tempo = this._tempo
        }

        set tempo(e) {
            this._tempo = e, this.calculateSequenceParameters(), this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength), this.skipFract = 0, e = Math.floor(this.nominalSkip + .5), this.sampleReq = Math.max(e + this.overlapLength, this.seekWindowLength) + this.seekLength
        }

        get tempo() {
            return this._tempo
        }

        get inputChunkSize() {
            return this.sampleReq
        }

        get outputChunkSize() {
            return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength)
        }

        calculateOverlapLength() {
            let e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
            e = (e = this.sampleRate * t / 1e3) < 16 ? 16 : e, e -= e % 8, this.overlapLength = e, this.refMidBuffer = new Float32Array(2 * this.overlapLength), this.midBuffer = new Float32Array(2 * this.overlapLength)
        }

        checkLimits(e, t, i) {
            return e < t ? t : i < e ? i : e
        }

        calculateSequenceParameters() {
            var e;
            this.autoSeqSetting && (e = 150 + -50 * this._tempo, e = this.checkLimits(e, 50, 125), this.sequenceMs = Math.floor(e + .5)), this.autoSeekSetting && (e = 28.333333333333332 + -10 / 1.5 * this._tempo, e = this.checkLimits(e, 15, 25), this.seekWindowMs = Math.floor(e + .5)), this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1e3), this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1e3)
        }

        set quickSeek(e) {
            this._quickSeek = e
        }

        clone() {
            const e = new Ki;
            return e.tempo = this._tempo, e.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs), e
        }

        seekBestOverlapPosition() {
            return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo()
        }

        seekBestOverlapPositionStereo() {
            let e, t, i, r = 0;
            for (this.preCalculateCorrelationReferenceStereo(), e = 0, t = Number.MIN_VALUE; r < this.seekLength; r += 1) (i = this.calculateCrossCorrelationStereo(2 * r, this.refMidBuffer)) > t && (t = i, e = r);
            return e
        }

        seekBestOverlapPositionStereoQuick() {
            let t, i, r, s, a, n = 0;
            for (this.preCalculateCorrelationReferenceStereo(), i = Number.MIN_VALUE, t = 0, s = 0, a = 0; n < 4; n += 1) {
                let e = 0;
                for (; Vi[n][e] && !((a = s + Vi[n][e]) >= this.seekLength);) (r = this.calculateCrossCorrelationStereo(2 * a, this.refMidBuffer)) > i && (i = r, t = a), e += 1;
                s = t
            }
            return t
        }

        preCalculateCorrelationReferenceStereo() {
            let e, t, i = 0;
            for (; i < this.overlapLength; i += 1) t = i * (this.overlapLength - i), e = 2 * i, this.refMidBuffer[e] = this.midBuffer[e] * t, this.refMidBuffer[1 + e] = this.midBuffer[1 + e] * t
        }

        calculateCrossCorrelationStereo(e, t) {
            var i = this._inputBuffer.vector;
            e += this._inputBuffer.startIndex;
            let r = 0, s = 2;
            for (var a, n = 2 * this.overlapLength; s < n; s += 2) a = s + e, r += i[a] * t[s] + i[a + 1] * t[s + 1];
            return r
        }

        overlap(e) {
            this.overlapStereo(2 * e)
        }

        overlapStereo(e) {
            var t = this._inputBuffer.vector;
            e += this._inputBuffer.startIndex;
            const i = this._outputBuffer.vector, r = this._outputBuffer.endIndex;
            let s, a, n = 0;
            for (var o, l, d, h = 1 / this.overlapLength; n < this.overlapLength; n += 1) a = (this.overlapLength - n) * h, o = n * h, l = (s = 2 * n) + e, d = s + r, i[d + 0] = t[l + 0] * o + this.midBuffer[0 + s] * a, i[d + 1] = t[l + 1] * o + this.midBuffer[1 + s] * a
        }

        process() {
            var e;
            if (null === this.midBuffer) {
                if (this._inputBuffer.frameCount < this.overlapLength) return;
                this.midBuffer = new Float32Array(2 * this.overlapLength), this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength)
            }
            for (; this._inputBuffer.frameCount >= this.sampleReq;) {
                e = this.seekBestOverlapPosition(), this._outputBuffer.ensureAdditionalCapacity(this.overlapLength), this.overlap(Math.floor(e)), this._outputBuffer.put(this.overlapLength), 0 < (t = this.seekWindowLength - 2 * this.overlapLength) && this._outputBuffer.putBuffer(this._inputBuffer, e + this.overlapLength, t);
                var t = this._inputBuffer.startIndex + 2 * (e + this.seekWindowLength - this.overlapLength);
                this.midBuffer.set(this._inputBuffer.vector.subarray(t, t + 2 * this.overlapLength)), this.skipFract += this.nominalSkip, e = Math.floor(this.skipFract), this.skipFract -= e, this._inputBuffer.receive(e)
            }
        }
    }

    function $i(e, t) {
        return 1e-10 < (t < e ? e - t : t - e)
    }

    class qi {
        constructor() {
            this.transposer = new Gi(!1), this.stretch = new Ki(!1), this._inputBuffer = new ji, this._intermediateBuffer = new ji, this._outputBuffer = new ji, this._rate = 0, this._tempo = 0, this.virtualPitch = 1, this.virtualRate = 1, this.virtualTempo = 1, this.calculateEffectiveRateAndTempo()
        }

        clear() {
            this.transposer.clear(), this.stretch.clear()
        }

        clone() {
            const e = new qi;
            return e.rate = this.rate, e.tempo = this.tempo, e
        }

        get rate() {
            return this._rate
        }

        set rate(e) {
            this.virtualRate = e, this.calculateEffectiveRateAndTempo()
        }

        set rateChange(e) {
            this._rate = 1 + .01 * e
        }

        get tempo() {
            return this._tempo
        }

        set tempo(e) {
            this.virtualTempo = e, this.calculateEffectiveRateAndTempo()
        }

        set tempoChange(e) {
            this.tempo = 1 + .01 * e
        }

        set pitch(e) {
            this.virtualPitch = e, this.calculateEffectiveRateAndTempo()
        }

        set pitchOctaves(e) {
            this.pitch = Math.exp(.69314718056 * e), this.calculateEffectiveRateAndTempo()
        }

        set pitchSemitones(e) {
            this.pitchOctaves = e / 12
        }

        get inputBuffer() {
            return this._inputBuffer
        }

        get outputBuffer() {
            return this._outputBuffer
        }

        calculateEffectiveRateAndTempo() {
            var e = this._tempo, t = this._rate;
            this._tempo = this.virtualTempo / this.virtualPitch, this._rate = this.virtualRate * this.virtualPitch, $i(this._tempo, e) && (this.stretch.tempo = this._tempo), $i(this._rate, t) && (this.transposer.rate = this._rate), 1 < this._rate ? this._outputBuffer != this.transposer.outputBuffer && (this.stretch.inputBuffer = this._inputBuffer, this.stretch.outputBuffer = this._intermediateBuffer, this.transposer.inputBuffer = this._intermediateBuffer, this.transposer.outputBuffer = this._outputBuffer) : this._outputBuffer != this.stretch.outputBuffer && (this.transposer.inputBuffer = this._inputBuffer, this.transposer.outputBuffer = this._intermediateBuffer, this.stretch.inputBuffer = this._intermediateBuffer, this.stretch.outputBuffer = this._outputBuffer)
        }

        process() {
            1 < this._rate ? (this.stretch.process(), this.transposer.process()) : (this.transposer.process(), this.stretch.process())
        }
    }

    class Yi {
        constructor(e, t, i) {
            this.player = e, this.audio = t, this.soundTouch = new qi, this.soundTouch.tempo = 1, this.soundTouch.rate = 1, this.filter = new Wi(i, this.soundTouch)
        }

        setRate(e) {
            e !== this.soundTouch.rate && (this.soundTouch.tempo = e)
        }

        provide(e) {
            let t = new Float32Array(2 * e), i = this.filter.extract(t, e), r = new Float32Array(i),
                s = new Float32Array(i);
            for (let e = 0; e < i; e++) r[e] = t[2 * e], s[e] = t[2 * e + 1];
            return {size: i, left: r, right: s, ts: this.audio.tempAudioTimestamp || 0}
        }

        destroy() {
            this.soundTouch && (this.soundTouch.clear(), this.soundTouch = null), this.filter && (this.filter = null)
        }
    }

    class Ji extends Oi {
        constructor(e) {
            super(e), this.defaultPlaybackRate = 1, this.playbackRate = 1, this.rateProcessor = null, this.processor = null, this.scriptNodeInterval = null, this.engineType = this.getAutoAudioEngineType(), this.audioBufferSize = this.getAudioBufferSizeByType(), this.$audio = null, this._delayPlay = !1, this.eventListenList = [], this.workletUrl = null, this.clearWorkletUrlTimeout = null, this.player._opt.supportLockScreenPlayAudio && Dt() && (this.$audio = document.createElement("audio"), Object.assign(this.$audio.style, {
                position: "absolute",
                left: "-100%",
                top: "-100%"
            }), (e.$container || document.body).appendChild(this.$audio), this._bindAudioProxy(), this.player.debug.log("AudioContext", "create audio element")), this.scriptStartTime = 0, this.player.debug.log("AudioContext", "init", `engineType: ${this.engineType}, audioBufferSize: ` + this.audioBufferSize)
        }

        destroy() {
            super.destroy(), this.workletUrl && (URL.revokeObjectURL(this.workletUrl), this.workletUrl = null), this.clearWorkletUrlTimeout && (clearTimeout(this.clearWorkletUrlTimeout), this.clearWorkletUrlTimeout = null), this.eventListenList && (this.eventListenList.forEach(e => {
                e()
            }), this.eventListenList = []), this.$audio && (this.$audio.pause(), this.$audio.srcObject = null, this.$audio.parentNode && this.$audio.parentNode.removeChild(this.$audio), this.$audio = null), this.processor && (this.processor.destroy(), this.processor = null), this.rateProcessor && (this.rateProcessor.destroy(), this.rateProcessor = null), this.scriptNodeInterval && (clearInterval(this.scriptNodeInterval), this.scriptNodeInterval = null), this.defaultPlaybackRate = 1, this.playbackRate = 1, this.scriptStartTime = 0, this.audioBufferSize = 0, this.engineType = it, this.player.debug.log("AudioContext", "destroy")
        }

        isAudioPlaying() {
            return this.$audio && C(this.$audio.paused) && C(this.$audio.ended) && 0 !== this.$audio.playbackRate && 0 !== this.$audio.readyState
        }

        _bindAudioProxy() {
            const e = this.player.events["proxy"], t = e(this.$audio, "canplay", () => {
                this.player.debug.log("AudioContext", "canplay"), this._delayPlay && this._audioElementPlay()
            });
            this.eventListenList.push(t)
        }

        _getAudioElementReadyState() {
            let e = 0;
            return e = this.$audio ? this.$audio.readyState : e
        }

        audioElementPlay() {
            if (this.$audio) {
                var e = this._getAudioElementReadyState();
                if (this.player.debug.log("AudioContext", "play and readyState: " + e), !(0 !== e || Zt() && Dt())) return this.player.debug.warn("AudioContext", "readyState is 0 and set _delayPlay to true"), void (this._delayPlay = !0);
                this._audioElementPlay()
            }
        }

        _audioElementPlay() {
            this.$audio && this.$audio.play().then(() => {
                this._delayPlay = !1, this.player.debug.log("AudioContext", "_audioElementPlay success"), setTimeout(() => {
                    this.isAudioPlaying() || (this.player.debug.warn("AudioContext", "play failed and retry play"), this._audioElementPlay())
                }, 100), this.isAudioPlaying() && (this.player.debug.log("AudioContext", "play success and remove document click event listener"), document.removeEventListener("click", this._audioElementPlay.bind(this)))
            }).catch(e => {
                this.player.debug.error("AudioContext", "_audioElementPlay error", e), this.player.addMemoryLog("AudioContext", "_audioElementPlay error", e), document.addEventListener("click", this._audioElementPlay.bind(this))
            })
        }

        getAudioBufferSize() {
            return this.audioBufferSize
        }

        get oneBufferDuration() {
            return this.audioBufferSize / this.audioContext.sampleRate * 1e3
        }

        get isActiveEngineType() {
            return this.engineType === rt
        }

        initProcessor() {
            this.processor = new Ni(this.player, this, this.audioInfo.channels, this.audioBufferSize), this.rateProcessor = new Yi(this.player, this, this.processor)
        }

        getAutoAudioEngineType() {
            let e = this.player._opt.audioEngine || it;
            var t = () => {
                e = Zt() && Ct() ? rt : (!Dt() || !this.player._opt.supportLockScreenPlayAudio) && ni() ? tt : it
            };
            return this.player._opt.audioEngine ? this.player._opt.audioEngine === tt && ni() ? e = tt : this.player._opt.audioEngine === rt ? e = rt : this.player._opt.audioEngine === it ? e = it : t() : t(), e
        }

        getAudioBufferSizeByType() {
            var e = this.engineType, t = (this.player._opt.hasVideo, this.player._opt.weiXinInAndroidAudioBufferSize);
            return e !== tt && e === rt ? t || 4800 : 1024
        }

        initScriptNode() {
            this.playing = !0, this.hasInitScriptNode || (this.initProcessor(), this.engineType === tt ? this.initWorkletScriptNode() : this.engineType === rt ? this.initIntervalScriptNode() : this.engineType === it && this.initProcessScriptNode(), this.audioElementPlay())
        }

        getEngineType() {
            return this.engineType
        }

        isPlaybackRateSpeed() {
            return this.playbackRate > this.defaultPlaybackRate
        }

        initProcessScriptNode() {
            const e = this.audioContext.createScriptProcessor(this.audioBufferSize, 0, this.audioInfo.channels);
            e.onaudioprocess = e => {
                e = e.outputBuffer;
                this.handleScriptNodeCallback(e)
            }, e.connect(this.gainNode), this.scriptNode = e, this.gainNode.connect(this.mediaStreamAudioDestinationNode), this.$audio ? this.$audio.srcObject = this.mediaStreamAudioDestinationNode.stream : this.gainNode.connect(this.audioContext.destination), this.hasInitScriptNode = !0
        }

        initIntervalScriptNode() {
            this.scriptStartTime = 0;
            var e = 1e3 * this.audioBufferSize / this.audioContext.sampleRate;
            this.scriptNodeInterval = setInterval(() => {
                if (0 === this.bufferList.length || C(this.playing) || this.isMute) this.playing && C(this.isMute) && this.player.debug.log("AudioContext", `interval script node and bufferList is ${this.bufferList.length} or playing is ` + this.playing); else {
                    const e = this.audioContext.createBufferSource(),
                        t = this.audioContext.createBuffer(this.audioInfo.channels, this.audioBufferSize, this.audioContext.sampleRate);
                    this.handleScriptNodeCallback(t, () => {
                        this.scriptStartTime < this.audioContext.currentTime && (this.player.debug.log("AudioContext", `script start time ${this.scriptStartTime} is less than current time ` + this.audioContext.currentTime), this.scriptStartTime = this.audioContext.currentTime), e.buffer = t, e.connect(this.gainNode), e.start(this.scriptStartTime), this.scriptStartTime += t.duration
                    })
                }
            }, e), this.gainNode.connect(this.mediaStreamAudioDestinationNode), this.$audio ? this.$audio.srcObject = this.mediaStreamAudioDestinationNode.stream : this.gainNode.connect(this.audioContext.destination), this.hasInitScriptNode = !0
        }

        initWorkletScriptNode() {
            var e = si(function () {
                class e extends AudioWorkletProcessor {
                    constructor() {
                        super(), this.audioBufferSize = 1024, this.start = !1, this.channels = 1, this.samplesArray = [], this.offset = 0, this.state = 0, this.port.onmessage = e => {
                            "init" === e.data.message ? (this.audioBufferSize = e.data.audioBufferSize, this.start = e.data.start, this.channels = e.data.channels, this.state = 0, this.offset = 0, this.samplesArray = []) : "stop" === e.data.message ? (this.state = 0, this.start = !1, this.offset = 0, this.samplesArray = []) : "data" === e.data.message ? this.samplesArray.push(e.data.buffer) : "zero" === e.data.message && this.samplesArray.push({
                                left: new Float32Array(this.audioBufferSize).fill(0),
                                right: new Float32Array(this.audioBufferSize).fill(0)
                            })
                        }
                    }

                    process(t, e, i) {
                        const r = e[0][0], s = e[0][1];
                        if (0 === this.offset && this.port.postMessage({message: "beep"}), 0 === this.state) this.state = 1; else if (1 === this.state && 4 <= this.samplesArray.length) this.state = 2; else if (2 === this.state) {
                            const t = this.samplesArray[0];
                            for (let e = 0; e < r.length; e++) 1 === this.channels ? r[e] = t.left[e + this.offset] : 2 === this.channels && (r[e] = t.left[e + this.offset], s && (s[e] = t.right[e + this.offset]))
                        } else 1 === this.channels ? r.fill(0) : 2 === this.channels && (r.fill(0), s && s.fill(0));
                        return this.offset += 128, this.offset === this.audioBufferSize && (this.offset = 0, 2 === this.state && this.samplesArray.shift(), 0 === this.samplesArray.length && (this.state = 0)), this.start
                    }
                }

                registerProcessor("worklet-processor", e)
            });
            this.workletUrl = e, this.audioContext && this.audioContext.audioWorklet.addModule(e).then(() => {
                if (this.audioContext) {
                    let e = [1];
                    2 === this.audioInfo.channels && (e = [1, 1]);
                    try {
                        this.workletProcessorNode = new AudioWorkletNode(this.audioContext, "worklet-processor", {
                            numberOfOutputs: this.audioInfo.channels,
                            outputChannelCount: e
                        })
                    } catch (e) {
                        this.player.debug.error("AudioContext", "initWorkletScriptNode error", e), this.workletProcessorNode = null, this.tierDownToProcessScript()
                    }
                    this.workletProcessorNode && (this.workletProcessorNode.connect(this.gainNode), this.gainNode.connect(this.mediaStreamAudioDestinationNode), this.$audio ? this.$audio.srcObject = this.mediaStreamAudioDestinationNode.stream : this.gainNode.connect(this.audioContext.destination), this.hasInitScriptNode = !0, this.workletProcessorNode.port.postMessage({
                        message: "init",
                        audioBufferSize: this.audioBufferSize,
                        start: !0,
                        channels: this.audioInfo.channels
                    }), this.workletProcessorNode.port.onmessage = e => {
                        this.workletProcessorNode ? this.audioContext ? this.handleScriptNodeCallback(this.workletProcessorNode, null, !0) : this.workletProcessorNode.port.postMessage({message: "zero"}) : this.player.debug.error("AudioContext", "workletProcessorNode is null")
                    })
                } else this.player.debug.error("AudioContext", "initWorkletScriptNode audioContext is null")
            }), this.clearWorkletUrlTimeout = setTimeout(() => {
                URL.revokeObjectURL(this.workletUrl), this.workletUrl = null, this.clearWorkletUrlTimeout = null
            }, re)
        }

        tierDownToProcessScript() {
            this.player.debug.log("AudioContext", "tierDownToProcessScript"), this.engineType = it, this.audioBufferSize = this.getAudioBufferSizeByType(), this.initProcessScriptNode(), this.audioElementPlay()
        }

        handleScriptNodeCallback(e, t) {
            let i, r = 2 < arguments.length && void 0 !== arguments[2] && arguments[2], s = (t = t || o, e.length);
            r && (i = e, s = this.audioBufferSize);
            var a, n = this.audioInfo.channels;
            if (this.bufferList.length && this.playing) return (a = this.player._opt).syncAudioAndVideo && a.hasVideo && (this.calcPlaybackRateBySync(), 1e3 < this.audioSyncVideoOption.diff) ? (this.player.debug.warn("AudioContext", `audioSyncVideoOption more than diff :${this.audioSyncVideoOption.diff}, waiting`), r ? i.port.postMessage({message: "zero"}) : this.fillScriptNodeOutputBuffer(e, n)) : 0 === (a = this._provide(s)).size ? (this.player.debug.warn("AudioContext", `bufferList size is ${this.bufferList.length} outputBufferLength is ${s},and bufferItem.size is 0`), r ? i.port.postMessage({message: "zero"}) : this.fillScriptNodeOutputBuffer(e, n)) : (a && a.ts && (this.player.audioTimestamp = a.ts), r ? i.port.postMessage({
                message: "data",
                buffer: a
            }) : this.fillScriptNodeOutputBuffer(e, n, a)), void t();
            r ? i.port.postMessage({message: "zero"}) : this.fillScriptNodeOutputBuffer(e, n), t()
        }

        fillScriptNodeOutputBuffer(e, t, i) {
            if (1 === t) {
                const t = e.getChannelData(0);
                !i || 0 === i.size ? t.fill(0) : t.set(i.left)
            } else if (2 === t) {
                const t = e.getChannelData(0), r = e.getChannelData(1);
                !i || 0 === i.size ? (t.fill(0), r.fill(0)) : (t.set(i.left), r.set(i.right))
            }
        }

        play(e, t) {
            this.isMute || (this.hasInitScriptNode ? (this.hasAudio = !0, this.bufferList.push({
                buffer: e,
                ts: t
            }), this.player._opt.syncAudioAndVideo || this.calcPlaybackRateByBuffer()) : this.player.debug.warn("AudioContext", "play has not init script node"))
        }

        calcPlaybackRateBySync() {
            if (!this.isMute && this.playing) {
                let e = this.playbackRate;
                this.audioSyncVideoOption.diff < -1e3 ? (e = this.defaultPlaybackRate + .1, this.player.debug.warn("AudioContext", `audioSyncVideoOption -1000 less than diff :${this.audioSyncVideoOption.diff}, speed up, playbackRate is ` + e)) : -500 < this.audioSyncVideoOption.diff && (e = this.defaultPlaybackRate), this.updatePlaybackRate(e)
            }
        }

        calcPlaybackRateByBuffer() {
            if (!this.isMute && this.playing && this.getEngineType() !== rt) {
                let e = this.playbackRate, t = 1e3, i = 5e3;
                this.isAudioPlayer && (t = this.player._opt.videoBufferDelay, i = this.player._opt.videoBufferMax);
                var r = Math.floor(t / this.oneBufferDuration), s = Math.floor(i / this.oneBufferDuration);
                if (this.bufferList.length > s) return this.player.debug.warn("AudioContext", `bufferList length ${this.bufferList.length} more than ${s}, and drop`), void this.clear();
                this.bufferList.length > r ? (e = this.defaultPlaybackRate + .1, this.player.debug.warn("AudioContext", `bufferList length ${this.bufferList.length} more than ${r}, speed up, playbackRate is ` + e)) : this.bufferList.length < r / 2 && (e = this.defaultPlaybackRate), this.updatePlaybackRate(e)
            }
        }

        updatePlaybackRate(e) {
            this.rateProcessor && (this.playbackRate = e, this.rateProcessor.setRate(this.playbackRate))
        }

        _provide(e) {
            return (1 === this.playbackRate ? this.processor : this.rateProcessor).provide(e)
        }
    }

    class Qi extends e {
        constructor(e) {
            super(), this.player = e, this.$video = e.video.$videoElement, this.init = !1, this.player._opt.hlsUseCanvasRender && (this.$video = this.player.hlsDecoder.$videoElement), this.audioInfo = {
                encType: "",
                channels: "",
                sampleRate: ""
            }, this.player.debug.log("Audio", "init")
        }

        destroy() {
            this.resetInit(), this.off(), this.player.debug.log("Audio", "destroy")
        }

        resetInit() {
            this.init = !1, this.audioInfo = {encType: "", channels: "", sampleRate: ""}
        }

        getAudioInfo() {
            return this.audioInfo
        }

        updateAudioInfo(e) {
            x(e.encTypeCode) && (this.audioInfo.encType = Ee[e.encTypeCode]), x(e.encType) && (this.audioInfo.encType = e.encType), x(e.channels) && (this.audioInfo.channels = e.channels), x(e.sampleRate) && (this.audioInfo.sampleRate = e.sampleRate), x(this.audioInfo.sampleRate) && x(this.audioInfo.channels) && x(this.audioInfo.encType) && !this.init && (this.player.debug.log("Audio", "audioInfo", JSON.stringify(this.audioInfo)), this.player.emit(w.audioInfo, this.audioInfo), this.init = !0)
        }

        get isPlaying() {
            return !0
        }

        get volume() {
            return k(this.$video.muted) ? 0 : this.$video.volume
        }

        get isMute() {
            return 0 === this.$video.volume || k(this.$video.muted)
        }

        mute(e) {
            this.setVolume(e ? 0 : this.player.lastVolume || .5)
        }

        setVolume(e) {
            e = parseFloat(e), isNaN(e) || (e = E(e, 0, 1), this.$video.muted && (this.$video.muted = !1), this.$video.volume = e, this.player.emit(w.volumechange, this.player.volume))
        }

        clear() {
        }

        play() {
        }

        pause() {
        }

        resume() {
        }

        getEngineType() {
            return "audio"
        }

        isPlaybackRateSpeed() {
            return !1
        }

        getAudioBufferSize() {
            return 0
        }
    }

    class Xi extends Ji {
        constructor(e) {
            super(e), this.delayTimeout = null, this.player.on(w.playbackPause, e => {
                this.listenPlaybackPause(e)
            }), this.player.debug.log("AudioPlaybackContext", "init")
        }

        destroy() {
            this.delayTimeout && (clearTimeout(this.delayTimeout), this.delayTimeout = null), super.destroy(), this.player.debug.log("AudioPlaybackLoader", "destroy")
        }

        listenPlaybackPause(e) {
            e ? (this.pause(), this.player.playback.isPlaybackPauseClearCache && this.clear()) : this.resume()
        }

        initScriptNodeDelay() {
            var e = this.player._opt.playbackDelayTime;
            0 < e ? this.delayTimeout = setTimeout(() => {
                this.initScriptNode()
            }, e) : this.initScriptNode()
        }

        setRate(e) {
            e !== this.defaultPlaybackRate && this.rateProcessor && (this.player.debug.log("AudioPlaybackContext", "setRate", e), this.defaultPlaybackRate = e, this.updatePlaybackRate(e))
        }
    }

    class Zi extends Ji {
        constructor(e) {
            super(e), this.TAG_NAME = "AudioPlayerLoader", this.isAudioPlayer = !0, this.player.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.player.debug.log(this.TAG_NAME, "destroy")
        }

        play(e, t) {
            C(this.playing) || super.play(e, t)
        }

        pause() {
            this.player.debug.log(this.TAG_NAME, "pause"), this.playing = !1, this.clear()
        }

        resume() {
            this.player.debug.log(this.TAG_NAME, "resume"), this.playing = !0
        }
    }

    class er {
        constructor(e) {
            return new (er.getLoaderFactory(e._opt))(e)
        }

        static getLoaderFactory(e) {
            return e.playType === A ? Xi : e.playType === j ? Zi : e.isHls && C(e.supportHls265) || e.isWebrtc && C(e.isWebrtcH265) ? Qi : Ji
        }
    }

    class tr extends e {
        constructor(t) {
            super(), this.TAG_NAME = "FetchWorkerLoader", this.player = t, this.playing = !1, this.fetchWorker = null, this.workerClearTimeout = null, this.workerUrl = null, this.abortController = new AbortController, this.streamRate = Tt(e => {
                t.emit(w.kBps, (e / 1024).toFixed(2))
            }), this.streamRateInterval = null, this._initFetchWorker(), t.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            this.off(), this.workerUrl && (window.URL.revokeObjectURL(this.workerUrl), this.workerUrl = null), this.workerClearTimeout && (clearTimeout(this.workerClearTimeout), this.workerClearTimeout = null), this.fetchWorker && (this.fetchWorker.postMessage({cmd: "destroy"}), this.fetchWorker.terminate(), this.fetchWorker = null), this._stopStreamRateInterval(), this.streamRate = null, this.player.debug.log(this.TAG_NAME, "destroy")
        }

        _initFetchWorker() {
            var e = mi(function () {
                const i = "The user aborted a request", r = "AbortError", s = "AbortError", a = "fetchError",
                    n = "fetchClose", o = "fetchSuccess";
                let l = new class {
                    constructor() {
                        this.abortController = new AbortController
                    }

                    destroy() {
                        this.abort()
                    }

                    fetchStream(e) {
                        var t = Object.assign({signal: this.abortController.signal}, {headers: (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}).headers || {}});
                        fetch(e, t).then(e => {
                            if (!(e.ok && 200 <= e.status && e.status <= 299)) return this.abort(), void postMessage({
                                cmd: a,
                                message: `fetch response status is ${e.status} and ok is ` + e.ok
                            });
                            if (postMessage({cmd: o}), "undefined" != typeof WritableStream) e.body.pipeTo(new WritableStream({
                                write: e => {
                                    this.streamRate && this.streamRate(e.byteLength), postMessage({
                                        cmd: "buffer",
                                        buffer: e
                                    }, [e.buffer])
                                }, close: () => {
                                    postMessage({cmd: n})
                                }, abort: e => {
                                    const t = e.toString();
                                    -1 === t.indexOf(i) && -1 === t.indexOf(r) && e.name !== s && (this.abort(), postMessage({
                                        cmd: a,
                                        message: e.toString()
                                    }))
                                }
                            })); else {
                                const t = e.body.getReader(), o = () => {
                                    t.read().then(e => {
                                        var {done: e, value: t} = e;
                                        e ? postMessage({cmd: n}) : (postMessage({
                                            cmd: "buffer",
                                            buffer: t
                                        }, [t.buffer]), o())
                                    }).catch(e => {
                                        const t = e.toString();
                                        -1 === t.indexOf(i) && -1 === t.indexOf(r) && e.name !== s && (this.abort(), postMessage({
                                            cmd: a,
                                            message: e.toString()
                                        }))
                                    })
                                };
                                o()
                            }
                        }).catch(e => {
                            "AbortError" !== e.name && (this.abort(), postMessage({cmd: a, message: e.toString()}))
                        })
                    }

                    abort() {
                        this.abortController && (this.abortController.abort(), this.abortController = null)
                    }
                };
                self.onmessage = e => {
                    var t = e.data;
                    switch (t.cmd) {
                        case"fetch":
                            l.fetchStream(t.url, JSON.parse(t.options));
                            break;
                        case"destroy":
                            l.destroy(), l = null
                    }
                }
            }.toString()), e = new Blob([e], {type: "text/javascript"}), e = URL.createObjectURL(e);
            const t = new Worker(e);
            this.workerUrl = e, this.workerClearTimeout = setTimeout(() => {
                window.URL.revokeObjectURL(this.workerUrl), this.workerUrl = null, this.workerClearTimeout = null
            }, re), t.onmessage = e => {
                const t = this.player["demux"], i = e.data;
                switch (i.cmd) {
                    case"buffer":
                        this.streamRate && this.streamRate(i.buffer.byteLength), t.dispatch(i.buffer);
                        break;
                    case"fetchSuccess":
                        this.emit(w.streamSuccess), this._startStreamRateInterval();
                        break;
                    case"fetchClose":
                        t.close(), this.emit(w.streamEnd);
                        break;
                    case"fetchError":
                        t.close(), this.emit(S.fetchError, i.message)
                }
            }, this.fetchWorker = t
        }

        _startStreamRateInterval() {
            this._stopStreamRateInterval(), this.streamRateInterval = setInterval(() => {
                this.streamRate && this.streamRate(0)
            }, 1e3)
        }

        _stopStreamRateInterval() {
            this.streamRateInterval && (clearInterval(this.streamRateInterval), this.streamRateInterval = null)
        }

        fetchStream(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            this.player._times.streamStart = p(), this.fetchWorker.postMessage({
                cmd: "fetch",
                url: e,
                options: JSON.stringify(t)
            })
        }

        getStreamType() {
            return t
        }
    }

    class ir extends e {
        constructor(t) {
            super(), this.player = t, this.socket = null, this.socketStatus = ge, this.wsUrl = null, this.socketDestroyFnList = [], this.streamRate = Tt(e => {
                t.emit(w.kBps, (e / 1024).toFixed(2))
            }), this.streamRateInterval = null, t.debug.log("WebsocketStream", "init")
        }

        destroy() {
            this._closeWebSocket(), this.stopStreamRateInterval(), this.wsUrl = null, this.off(), this.player.debug.log("WebsocketStream", "destroy")
        }

        startStreamRateInterval() {
            this.stopStreamRateInterval(), this.streamRateInterval = setInterval(() => {
                this.streamRate && this.streamRate(0)
            }, 1e3)
        }

        stopStreamRateInterval() {
            this.streamRateInterval && (clearInterval(this.streamRateInterval), this.streamRateInterval = null)
        }

        _createWebSocket() {
            const e = this.player, {debug: t, events: {proxy: i}, demux: r} = e;
            this.socket = new WebSocket(this.wsUrl), this.socket.binaryType = "arraybuffer";
            var s = i(this.socket, "open", () => {
                t.log("WebsocketStream", "socket open"), this.socketStatus = ye, this.emit(w.streamSuccess), this.player.emit(w.websocketOpen), this.startStreamRateInterval()
            }), a = i(this.socket, "message", e => {
                this.streamRate && this.streamRate(e.data.byteLength), this._handleMessage(e.data)
            }), n = i(this.socket, "close", e => {
                t.log("WebsocketStream", "socket close and code is " + e.code), 1006 === e.code && t.error("WebsocketStream", "socket close abnormally and code is " + e.code), r.close(), this.socketStatus = "close", this.player.emit(w.websocketClose), this.emit(w.streamEnd)
            }), o = i(this.socket, "error", e => {
                t.error("WebsocketStream", "socket error", e), this.socketStatus = "error", this.emit(S.websocketError, e), r.close(), t.log("WebsocketStream", "socket error:", e.isTrusted ? "websocket user aborted" : "websocket error")
            });
            this.socketDestroyFnList.push(s, a, n, o)
        }

        _closeWebSocket() {
            this.socketDestroyFnList.forEach(e => e()), this.socket && (this.socket.close(1e3, "Client disconnecting"), this.socket = null), this.socketStatus = ge, this.streamRate = null
        }

        _handleMessage(e) {
            const t = this.player["demux"];
            t ? t.dispatch(e) : this.player.debug.warn("WebsocketStream", "websocket handle message demux is null")
        }

        fetchStream(e, t) {
            this.player._times.streamStart = p(), this.wsUrl = e, this._createWebSocket()
        }

        sendMessage(e) {
            this.socket ? this.socketStatus === ye ? this.socket.send(e) : this.player.debug.error("WebsocketStream", "websocket send message error and  socket status is " + this.socketStatus) : this.player.debug.error("WebsocketStream", "websocket send message socket is null")
        }

        resetFetchStream() {
            this._closeWebSocket(), this._createWebSocket()
        }

        getStreamType() {
            return O
        }
    }

    class rr extends e {
        constructor(e) {
            super(), (this.player = e).debug.log("HlsStream", "init")
        }

        destroy() {
            this.off(), this.player.debug.log("HlsStream", "destroy")
        }

        fetchStream(e) {
            const t = this.player["hlsDecoder"];
            this.player._times.streamStart = p(), t.loadSource(e).then(() => {
                this.player.debug.log("HlsStream", "loadSource success"), this.emit(w.streamSuccess)
            }).catch(e => {
                this.emit(S.hlsError, e)
            })
        }

        getStreamType() {
            return "hls"
        }
    }

    class sr extends e {
        constructor(e) {
            super(), this.player = e, this.webrctUrl = null, e.debug.log("WebrtcStream", "init")
        }

        destroy() {
            this.webrctUrl = null, this.off(), this.player.debug.log("WebrtcStream", "destroy")
        }

        fetchStream(e) {
            const t = this.player["webrtc"];
            if (this.player._times.streamStart = p(), this.webrctUrl = e.replace("webrtc:", window.location.protocol), -1 === this.webrctUrl.indexOf("/webrtc/play") && this.player.isWebrtcForM7S()) {
                const t = new URL(this.webrctUrl), i = "/webrtc/play" + t.pathname;
                this.webrctUrl = t.origin + i + t.search, this.player.debug.log("WebrtcStream", `original url is ${e}, and new url is: ` + this.webrctUrl)
            }
            t.loadSource(this.webrctUrl).then(() => {
                this.player.debug.log("WebrtcStream", "loadSource success"), this.emit(w.streamSuccess)
            }).catch(e => {
                this.emit(S.webrtcError, e)
            })
        }

        getStreamType() {
            return "webrtc"
        }
    }

    class ar extends e {
        constructor(t) {
            super(), this.player = t, this.transport = null, this.wtUrl = null, this.streamRate = Tt(e => {
                t.emit(w.kBps, (e / 1024).toFixed(2))
            }), this.streamRateInterval = null, t.debug.log("WebTransportLoader", "init")
        }

        destroy() {
            this.abort(), this.off(), this.player.debug.log("WebTransportLoader", "destroy")
        }

        startStreamRateInterval() {
            this.stopStreamRateInterval(), this.streamRateInterval = setInterval(() => {
                this.streamRate && this.streamRate(0)
            }, 1e3)
        }

        stopStreamRateInterval() {
            this.streamRateInterval && (clearInterval(this.streamRateInterval), this.streamRateInterval = null)
        }

        _createWebTransport() {
            const e = this.player, {events: {}, demux: t} = e;
            try {
                this.transport = new WebTransport(this.wtUrl), this.transport.ready.then(() => {
                    this.emit(w.streamSuccess), this.startStreamRateInterval(), this.transport.createBidirectionalStream().then(e => {
                        e.readable.pipeTo(new WritableStream(t.input))
                    })
                }).catch(e => {
                    this.player.debug.warn("WebTransportLoader", "_createWebTransport-ready", e)
                })
            } catch (e) {
                this.player.debug.warn("WebTransportLoader", "_createWebTransport", e)
            }
        }

        fetchStream(e) {
            this.player._times.streamStart = p(), this.wtUrl = e.replace(/^wt:/, "https:"), this._createWebTransport()
        }

        abort() {
            if (this.transport) try {
                this.transport.close(), this.transport = null
            } catch (e) {
                this.transport = null
            }
        }

        getStreamType() {
            return i
        }
    }

    class nr extends e {
        constructor(e) {
            super(), this.player = e, this.workUrl = null, e.debug.log("WorkerStream", "init")
        }

        destroy() {
            this.workUrl = null, this.off(), this.player.debug.log("WorkerStream", "destroy")
        }

        sendMessage(e) {
            this.player.decoderWorker.workerSendMessage(e)
        }

        fetchStream(e) {
            this.workUrl = e, this.player._times.streamStart = p(), this.player.decoderWorker.workerFetchStream(e)
        }

        getStreamType() {
            var e = this.player._opt.protocol;
            return N + " " + (2 === e ? t : O)
        }
    }

    class or {
        constructor(e) {
            return new (or.getLoaderFactory(e._opt))(e)
        }

        static getLoaderFactory(e) {
            var {protocol: t, useWasm: i, playType: r, playbackConfig: s, demuxUseWorker: a} = e;
            return 2 === t ? r === j ? nr : r === n ? i && !ri(e) || a ? nr : tr : !s.useWCS || a ? nr : tr : 1 === t ? r === j ? nr : r === n ? i && !ri(e) || a ? nr : ir : !s.useWCS || a ? nr : ir : 3 === t ? rr : 4 === t ? sr : 5 === t ? ar : void 0
        }
    }

    var lr = ft(function (e) {
        function S(i, s) {
            if (!i) throw"First parameter is required.";
            s = new f(i, s = s || {type: "video"});
            var a = this;

            function t(e) {
                e && (s.initCallback = function () {
                    e(), e = s.initCallback = null
                });
                var t = new m(i, s);
                (h = new t(i, s)).record(), d("recording"), s.disableLogs || console.log("Initialized recorderType:", h.constructor.name, "for output-type:", s.type)
            }

            function n(r) {
                if (r = r || function () {
                }, h) {
                    if ("paused" === a.state) return a.resumeRecording(), void setTimeout(function () {
                        n(r)
                    }, 1);
                    "recording" === a.state || s.disableLogs || console.warn('Recording state should be: "recording", however current state is: ', a.state), s.disableLogs || console.log("Stopped recording " + s.type + " stream."), "gif" !== s.type ? h.stop(e) : (h.stop(), e()), d("stopped")
                } else c();

                function e(e) {
                    if (h) {
                        Object.keys(h).forEach(function (e) {
                            "function" != typeof h[e] && (a[e] = h[e])
                        });
                        var t, i = h.blob;
                        if (!i) {
                            if (!e) throw"Recording failed.";
                            h.blob = i = e
                        }
                        if (i && !s.disableLogs && console.log(i.type, "->", A(i.size)), r) {
                            try {
                                t = E.createObjectURL(i)
                            } catch (e) {
                            }
                            "function" == typeof r.call ? r.call(a, t) : r(t)
                        }
                        s.autoWriteToDisk && l(function (e) {
                            var t = {};
                            t[s.type + "Blob"] = e, L.Store(t)
                        })
                    } else "function" == typeof r.call ? r.call(a, "") : r("")
                }
            }

            function o(e) {
                postMessage((new FileReaderSync).readAsDataURL(e))
            }

            function l(t, e) {
                if (!t) throw"Pass a callback function over getDataURL.";
                var i, r = (e || h || {}).blob;
                if (!r) return s.disableLogs || console.warn("Blob encoder did not finish its job yet."), void setTimeout(function () {
                    l(t, e)
                }, 1e3);
                "undefined" == typeof Worker || navigator.mozGetUserMedia ? ((i = new FileReader).readAsDataURL(r), i.onload = function (e) {
                    t(e.target.result)
                }) : ((i = function (e) {
                    try {
                        var t = E.createObjectURL(new Blob([e.toString(), "this.onmessage =  function (eee) {" + e.name + "(eee.data);}"], {type: "application/javascript"})),
                            i = new Worker(t);
                        return E.revokeObjectURL(t), i
                    } catch (e) {
                    }
                }(o)).onmessage = function (e) {
                    t(e.data)
                }, i.postMessage(r))
            }

            function r(e) {
                e = e || 0, "paused" !== a.state ? "stopped" !== a.state && (e >= a.recordingDuration ? n(a.onRecordingStopped) : (e += 1e3, setTimeout(function () {
                    r(e)
                }, 1e3))) : setTimeout(function () {
                    r(e)
                }, 1e3)
            }

            function d(e) {
                a && (a.state = e, "function" == typeof a.onStateChanged.call ? a.onStateChanged.call(a, e) : a.onStateChanged(e))
            }

            var h,
                e = 'It seems that recorder is destroyed or "startRecording" is not invoked for ' + s.type + " recorder.";

            function c() {
                !0 !== s.disableLogs && console.warn(e)
            }

            var u, p = {
                startRecording: function (e) {
                    return s.disableLogs || console.log("RecordRTC version: ", a.version), (s = e ? new f(i, e) : s).disableLogs || console.log("started recording " + s.type + " stream."), h ? (h.clearRecordedData(), h.record(), d("recording"), a.recordingDuration && r()) : t(function () {
                        a.recordingDuration && r()
                    }), a
                }, stopRecording: n, pauseRecording: function () {
                    h ? "recording" === a.state ? (d("paused"), h.pause(), s.disableLogs || console.log("Paused recording.")) : s.disableLogs || console.warn("Unable to pause the recording. Recording state: ", a.state) : c()
                }, resumeRecording: function () {
                    h ? "paused" === a.state ? (d("recording"), h.resume(), s.disableLogs || console.log("Resumed recording.")) : s.disableLogs || console.warn("Unable to resume the recording. Recording state: ", a.state) : c()
                }, initRecorder: t, setRecordingDuration: function (e, t) {
                    if (void 0 === e) throw"recordingDuration is required.";
                    if ("number" != typeof e) throw"recordingDuration must be a number.";
                    return a.recordingDuration = e, a.onRecordingStopped = t || function () {
                    }, {
                        onRecordingStopped: function (e) {
                            a.onRecordingStopped = e
                        }
                    }
                }, clearRecordedData: function () {
                    h ? (h.clearRecordedData(), s.disableLogs || console.log("Cleared old recorded data.")) : c()
                }, getBlob: function () {
                    if (h) return h.blob;
                    c()
                }, getDataURL: l, toURL: function () {
                    if (h) return E.createObjectURL(h.blob);
                    c()
                }, getInternalRecorder: function () {
                    return h
                }, save: function (e) {
                    h ? b(h.blob, e) : c()
                }, getFromDisk: function (e) {
                    h ? S.getFromDisk(s.type, e) : c()
                }, setAdvertisementArray: function (e) {
                    s.advertisement = [];
                    for (var t = e.length, i = 0; i < t; i++) s.advertisement.push({duration: i, image: e[i]})
                }, blob: null, bufferSize: 0, sampleRate: 0, buffer: null, reset: function () {
                    "recording" !== a.state || s.disableLogs || console.warn("Stop an active recorder."), h && "function" == typeof h.clearRecordedData && h.clearRecordedData(), h = null, d("inactive"), a.blob = null
                }, onStateChanged: function (e) {
                    s.disableLogs || console.log("Recorder state changed:", e)
                }, state: "inactive", getState: function () {
                    return a.state
                }, destroy: function () {
                    var e = s.disableLogs;
                    s = {disableLogs: !0}, a.reset(), d("destroyed"), p = a = null, v.AudioContextConstructor && (v.AudioContextConstructor.close(), v.AudioContextConstructor = null), s.disableLogs = e, s.disableLogs || console.log("RecordRTC is destroyed.")
                }, version: "5.6.2"
            };
            if (!this) return a = p;
            for (u in p) this[u] = p[u];
            return a = this, p
        }

        function f(e, t) {
            return t.recorderType || t.type || (t.audio && t.video ? t.type = "video" : t.audio && !t.video && (t.type = "audio")), t.recorderType && !t.type && (t.recorderType === u || t.recorderType === r || t.recorderType === P ? t.type = "video" : t.recorderType === D ? t.type = "gif" : t.recorderType === d ? t.type = "audio" : t.recorderType === _ && (T(e, "audio").length && T(e, "video").length || !T(e, "audio").length && T(e, "video").length ? t.type = "video" : T(e, "audio").length && !T(e, "video").length && (t.type = "audio"))), "undefined" != typeof MediaRecorder && "requestData" in MediaRecorder.prototype && (t.mimeType || (t.mimeType = "video/webm"), t.type || (t.type = t.mimeType.split("/")[0]), t.bitsPerSecond), t.type || (t.mimeType && (t.type = t.mimeType.split("/")[0]), t.type || (t.type = "audio")), t
        }

        function m(e, t) {
            var i;
            return (h || s || n) && (i = d), "undefined" != typeof MediaRecorder && "requestData" in MediaRecorder.prototype && !h && (i = _), "video" === t.type && (h || n) && (i = u, "undefined" != typeof ReadableStream && (i = P)), "gif" === t.type && (i = D), "canvas" === t.type && (i = r), c() && i !== r && i !== D && "undefined" != typeof MediaRecorder && "requestData" in MediaRecorder.prototype && (T(e, "video").length || T(e, "audio").length) && ("audio" === t.type ? "function" == typeof MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported("audio/webm") && (i = _) : "function" == typeof MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported("video/webm") && (i = _)), e instanceof Array && e.length && (i = R), t.recorderType && (i = t.recorderType), !t.disableLogs && i && i.name && console.log("Using recorderType:", i.name || i.constructor.name), i = !i && l ? _ : i
        }

        function t(n) {
            this.addStream = function (e) {
                e && (n = e)
            }, this.mediaType = {audio: !0, video: !0}, this.startRecording = function () {
                var e, t, i, r, s = this.mediaType, a = this.mimeType || {audio: null, video: null, gif: null};
                if ("function" != typeof s.audio && c() && !T(n, "audio").length && (s.audio = !1), "function" != typeof s.video && c() && !T(n, "video").length && (s.video = !1), "function" != typeof s.gif && c() && !T(n, "video").length && (s.gif = !1), !s.audio && !s.video && !s.gif) throw"MediaStream must have either audio or video tracks.";
                s.audio && (e = null, "function" == typeof s.audio && (e = s.audio), this.audioRecorder = new S(n, {
                    type: "audio",
                    bufferSize: this.bufferSize,
                    sampleRate: this.sampleRate,
                    numberOfAudioChannels: this.numberOfAudioChannels || 2,
                    disableLogs: this.disableLogs,
                    recorderType: e,
                    mimeType: a.audio,
                    timeSlice: this.timeSlice,
                    onTimeStamp: this.onTimeStamp
                }), s.video || this.audioRecorder.startRecording()), s.video && (e = null, "function" == typeof s.video && (e = s.video), t = n, c() && s.audio && "function" == typeof s.audio && (r = T(n, "video")[0], o ? ((t = new y).addTrack(r), e && e === u && (e = _)) : (t = new y).addTrack(r)), this.videoRecorder = new S(t, {
                    type: "video",
                    video: this.video,
                    canvas: this.canvas,
                    frameInterval: this.frameInterval || 10,
                    disableLogs: this.disableLogs,
                    recorderType: e,
                    mimeType: a.video,
                    timeSlice: this.timeSlice,
                    onTimeStamp: this.onTimeStamp,
                    workerPath: this.workerPath,
                    webAssemblyPath: this.webAssemblyPath,
                    frameRate: this.frameRate,
                    bitrate: this.bitrate
                }), s.audio || this.videoRecorder.startRecording()), s.audio && s.video && (i = this, r = !0 === c(), !0 === (r = s.audio instanceof d && s.video || !0 !== s.audio && !0 !== s.video && s.audio !== s.video ? !1 : r) ? (i.audioRecorder = null, i.videoRecorder.startRecording()) : i.videoRecorder.initRecorder(function () {
                    i.audioRecorder.initRecorder(function () {
                        i.videoRecorder.startRecording(), i.audioRecorder.startRecording()
                    })
                })), s.gif && (e = null, "function" == typeof s.gif && (e = s.gif), this.gifRecorder = new S(n, {
                    type: "gif",
                    frameRate: this.frameRate || 200,
                    quality: this.quality || 10,
                    disableLogs: this.disableLogs,
                    recorderType: e,
                    mimeType: a.gif
                }), this.gifRecorder.startRecording())
            }, this.stopRecording = function (t) {
                t = t || function () {
                }, this.audioRecorder && this.audioRecorder.stopRecording(function (e) {
                    t(e, "audio")
                }), this.videoRecorder && this.videoRecorder.stopRecording(function (e) {
                    t(e, "video")
                }), this.gifRecorder && this.gifRecorder.stopRecording(function (e) {
                    t(e, "gif")
                })
            }, this.pauseRecording = function () {
                this.audioRecorder && this.audioRecorder.pauseRecording(), this.videoRecorder && this.videoRecorder.pauseRecording(), this.gifRecorder && this.gifRecorder.pauseRecording()
            }, this.resumeRecording = function () {
                this.audioRecorder && this.audioRecorder.resumeRecording(), this.videoRecorder && this.videoRecorder.resumeRecording(), this.gifRecorder && this.gifRecorder.resumeRecording()
            }, this.getBlob = function (e) {
                var t = {};
                return this.audioRecorder && (t.audio = this.audioRecorder.getBlob()), this.videoRecorder && (t.video = this.videoRecorder.getBlob()), this.gifRecorder && (t.gif = this.gifRecorder.getBlob()), e && e(t), t
            }, this.destroy = function () {
                this.audioRecorder && (this.audioRecorder.destroy(), this.audioRecorder = null), this.videoRecorder && (this.videoRecorder.destroy(), this.videoRecorder = null), this.gifRecorder && (this.gifRecorder.destroy(), this.gifRecorder = null)
            }, this.getDataURL = function (i) {
                function r(e, t) {
                    var i;
                    "undefined" != typeof Worker ? ((i = function (e) {
                        var t,
                            e = E.createObjectURL(new Blob([e.toString(), "this.onmessage =  function (eee) {" + e.name + "(eee.data);}"], {type: "application/javascript"})),
                            i = new Worker(e);
                        if (void 0 !== E) t = E; else {
                            if ("undefined" == typeof webkitURL) throw"Neither URL nor webkitURL detected.";
                            t = webkitURL
                        }
                        return t.revokeObjectURL(e), i
                    }(function (e) {
                        postMessage((new FileReaderSync).readAsDataURL(e))
                    })).onmessage = function (e) {
                        t(e.data)
                    }, i.postMessage(e)) : ((i = new FileReader).readAsDataURL(e), i.onload = function (e) {
                        t(e.target.result)
                    })
                }

                this.getBlob(function (e) {
                    e.audio && e.video ? r(e.audio, function (t) {
                        r(e.video, function (e) {
                            i({audio: t, video: e})
                        })
                    }) : e.audio ? r(e.audio, function (e) {
                        i({audio: e})
                    }) : e.video && r(e.video, function (e) {
                        i({video: e})
                    })
                })
            }, this.writeToDisk = function () {
                S.writeToDisk({audio: this.audioRecorder, video: this.videoRecorder, gif: this.gifRecorder})
            }, this.save = function (e) {
                (e = e || {
                    audio: !0,
                    video: !0,
                    gif: !0
                }).audio && this.audioRecorder && this.audioRecorder.save("string" == typeof e.audio ? e.audio : ""), e.video && this.videoRecorder && this.videoRecorder.save("string" == typeof e.video ? e.video : ""), e.gif && this.gifRecorder && this.gifRecorder.save("string" == typeof e.gif ? e.gif : "")
            }
        }

        S.version = "5.6.2", (e.exports = S).getFromDisk = function (i, r) {
            if (!r) throw"callback is mandatory.";
            console.log("Getting recorded " + ("all" === i ? "blobs" : i + " blob ") + " from disk!"), L.Fetch(function (e, t) {
                "all" !== i && t === i + "Blob" && r && r(e), "all" === i && r && r(e, t.replace("Blob", ""))
            })
        }, S.writeToDisk = function (e) {
            console.log("Writing recorded blob(s) to disk!"), (e = e || {}).audio && e.video && e.gif ? e.audio.getDataURL(function (i) {
                e.video.getDataURL(function (t) {
                    e.gif.getDataURL(function (e) {
                        L.Store({audioBlob: i, videoBlob: t, gifBlob: e})
                    })
                })
            }) : e.audio && e.video ? e.audio.getDataURL(function (t) {
                e.video.getDataURL(function (e) {
                    L.Store({audioBlob: t, videoBlob: e})
                })
            }) : e.audio && e.gif ? e.audio.getDataURL(function (t) {
                e.gif.getDataURL(function (e) {
                    L.Store({audioBlob: t, gifBlob: e})
                })
            }) : e.video && e.gif ? e.video.getDataURL(function (t) {
                e.gif.getDataURL(function (e) {
                    L.Store({videoBlob: t, gifBlob: e})
                })
            }) : e.audio ? e.audio.getDataURL(function (e) {
                L.Store({audioBlob: e})
            }) : e.video ? e.video.getDataURL(function (e) {
                L.Store({videoBlob: e})
            }) : e.gif && e.gif.getDataURL(function (e) {
                L.Store({gifBlob: e})
            })
        }, t.getFromDisk = S.getFromDisk, t.writeToDisk = S.writeToDisk, S.MRecordRTC = t, (e = void 0 !== B ? B : null) && "undefined" == typeof window && void 0 !== B && (B.navigator = {
            userAgent: "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45",
            getUserMedia: function () {
            }
        }, B.console || (B.console = {}), void 0 !== B.console.log && void 0 !== B.console.error || (B.console.error = B.console.log = B.console.log || function () {
            console.log(arguments)
        }), "undefined" == typeof document && (e.document = {
            documentElement: {
                appendChild: function () {
                    return ""
                }
            }
        }, document.createElement = document.captureStream = document.mozCaptureStream = function () {
            var e = {
                getContext: function () {
                    return e
                }, play: function () {
                }, pause: function () {
                }, drawImage: function () {
                }, toDataURL: function () {
                    return ""
                }, style: {}
            };
            return e
        }, e.HTMLVideoElement = function () {
        }), "undefined" == typeof location && (e.location = {
            protocol: "file:",
            href: "",
            hash: ""
        }), "undefined" == typeof screen && (e.screen = {
            width: 0,
            height: 0
        }), void 0 === E && (e.URL = {
            createObjectURL: function () {
                return ""
            }, revokeObjectURL: function () {
                return ""
            }
        }), e.window = B);
        var a, p = window.requestAnimationFrame,
            g = (void 0 === p && ("undefined" != typeof webkitRequestAnimationFrame ? p = webkitRequestAnimationFrame : "undefined" != typeof mozRequestAnimationFrame ? p = mozRequestAnimationFrame : "undefined" != typeof msRequestAnimationFrame ? p = msRequestAnimationFrame : void 0 === p && (a = 0, p = function (e, t) {
                var i = (new Date).getTime(), r = Math.max(0, 16 - (i - a)), s = setTimeout(function () {
                    e(i + r)
                }, r);
                return a = i + r, s
            })), window.cancelAnimationFrame),
            e = (void 0 === g && ("undefined" != typeof webkitCancelAnimationFrame ? g = webkitCancelAnimationFrame : "undefined" != typeof mozCancelAnimationFrame ? g = mozCancelAnimationFrame : "undefined" != typeof msCancelAnimationFrame ? g = msCancelAnimationFrame : void 0 === g && (g = function (e) {
                clearTimeout(e)
            })), window.AudioContext),
            E = (void 0 === e && ("undefined" != typeof webkitAudioContext && (e = webkitAudioContext), "undefined" != typeof mozAudioContext && (e = mozAudioContext)), window.URL),
            s = (void 0 === E && "undefined" != typeof webkitURL && (E = webkitURL), "undefined" != typeof navigator && void 0 === navigator.getUserMedia && (void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia), void 0 !== navigator.mozGetUserMedia && (navigator.getUserMedia = navigator.mozGetUserMedia)), !(-1 === navigator.userAgent.indexOf("Edge") || !navigator.msSaveBlob && !navigator.msSaveOrOpenBlob)),
            n = !!window.opera || -1 !== navigator.userAgent.indexOf("OPR/"),
            o = -1 < navigator.userAgent.toLowerCase().indexOf("firefox") && "netscape" in window && / rv:/.test(navigator.userAgent),
            h = !n && !s && !!navigator.webkitGetUserMedia || i() || -1 !== navigator.userAgent.toLowerCase().indexOf("chrome/"),
            l = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
            y = (l && !h && -1 !== navigator.userAgent.indexOf("CriOS") && (h = !(l = !1)), window.MediaStream);

        function A(e) {
            if (0 === e) return "0 Bytes";
            var t = parseInt(Math.floor(Math.log(e) / Math.log(1e3)), 10);
            return (e / Math.pow(1e3, t)).toPrecision(3) + " " + ["Bytes", "KB", "MB", "GB", "TB"][t]
        }

        function b(e, t) {
            if (!e) throw"Blob object is required.";
            if (!e.type) try {
                e.type = "video/webm"
            } catch (e) {
            }
            var i = (e.type || "video/webm").split("/")[1],
                r = (-1 !== i.indexOf(";") && (i = i.split(";")[0]), t && -1 !== t.indexOf(".") && (t = (r = t.split("."))[0], i = r[1]), (t || Math.round(9999999999 * Math.random()) + 888888888) + "." + i);
            if (void 0 !== navigator.msSaveOrOpenBlob) return navigator.msSaveOrOpenBlob(e, r);
            if (void 0 !== navigator.msSaveBlob) return navigator.msSaveBlob(e, r);
            t = document.createElement("a");
            t.href = E.createObjectURL(e), t.download = r, t.style = "display:none;opacity:0;color:transparent;", (document.body || document.documentElement).appendChild(t), "function" == typeof t.click ? t.click() : (t.target = "_blank", t.dispatchEvent(new MouseEvent("click", {
                view: window,
                bubbles: !0,
                cancelable: !0
            }))), E.revokeObjectURL(t.href)
        }

        function i() {
            return "undefined" != typeof window && "object" == typeof window.process && "renderer" === window.process.type || !("undefined" == typeof process || "object" != typeof process.versions || !process.versions.electron) || "object" == typeof navigator && "string" == typeof navigator.userAgent && 0 <= navigator.userAgent.indexOf("Electron")
        }

        function T(e, t) {
            return e && e.getTracks ? e.getTracks().filter(function (e) {
                return e.kind === (t || "audio")
            }) : []
        }

        function w(e, t) {
            !("srcObject" in t) && "mozSrcObject" in t ? t.mozSrcObject = e : t.srcObject = e
        }

        void 0 !== (y = void 0 === y && "undefined" != typeof webkitMediaStream ? webkitMediaStream : y) && void 0 === y.prototype.stop && (y.prototype.stop = function () {
            this.getTracks().forEach(function (e) {
                e.stop()
            })
        }), S.invokeSaveAsDialog = b, S.getTracks = T, S.getSeekableBlob = function (e, r) {
            if ("undefined" == typeof EBML) throw new Error("Please link: https://www.webrtc-experiment.com/EBML.js");
            var s = new EBML.Reader, a = new EBML.Decoder, n = EBML.tools, t = new FileReader;
            t.onload = function (e) {
                a.decode(this.result).forEach(function (e) {
                    s.read(e)
                }), s.stop();
                var t = n.makeMetadataSeekable(s.metadatas, s.duration, s.cues), i = this.result.slice(s.metadataSize),
                    t = new Blob([t, i], {type: "video/webm"});
                r(t)
            }, t.readAsArrayBuffer(e)
        }, S.bytesToSize = A, S.isElectron = i;
        var v = {};

        function c() {
            if (o || l || s) return !0;
            var e, t = navigator.userAgent, i = "" + parseFloat(navigator.appVersion),
                r = parseInt(navigator.appVersion, 10);
            return (h || n) && (e = t.indexOf("Chrome"), i = t.substring(e + 7)), -1 !== (t = (i = -1 !== (t = i.indexOf(";")) ? i.substring(0, t) : i).indexOf(" ")) && (i = i.substring(0, t)), r = parseInt("" + i, 10), isNaN(r) && (i = "" + parseFloat(navigator.appVersion), r = parseInt(navigator.appVersion, 10)), 49 <= r
        }

        function _(i, r) {
            var e, s = this;
            if (void 0 === i) throw'First argument "MediaStream" is required.';
            if ("undefined" == typeof MediaRecorder) throw"Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.";
            "audio" === (r = r || {mimeType: "video/webm"}).type && (T(i, "video").length && T(i, "audio").length && (navigator.mozGetUserMedia ? (e = new y).addTrack(T(i, "audio")[0]) : e = new y(T(i, "audio")), i = e), r.mimeType && -1 !== r.mimeType.toString().toLowerCase().indexOf("audio") || (r.mimeType = h ? "audio/webm" : "audio/ogg"), r.mimeType && "audio/ogg" !== r.mimeType.toString().toLowerCase() && navigator.mozGetUserMedia && (r.mimeType = "audio/ogg"));
            var a, n = [];

            function o() {
                s.timestamps.push((new Date).getTime()), "function" == typeof r.onTimeStamp && r.onTimeStamp(s.timestamps[s.timestamps.length - 1], s.timestamps)
            }

            function l(e) {
                return a && a.mimeType ? a.mimeType : e.mimeType || "video/webm"
            }

            function t() {
                n = [], a = null, s.timestamps = []
            }

            this.getArrayOfBlobs = function () {
                return n
            }, this.record = function () {
                s.blob = null, s.clearRecordedData(), s.timestamps = [], d = [], n = [];
                var t = r;
                r.disableLogs || console.log("Passing following config over MediaRecorder API.", t), a = a && null, h && !c() && (t = "video/vp8"), "function" == typeof MediaRecorder.isTypeSupported && t.mimeType && !MediaRecorder.isTypeSupported(t.mimeType) && (r.disableLogs || console.warn("MediaRecorder API seems unable to record mimeType:", t.mimeType), t.mimeType = "audio" === r.type ? "audio/webm" : "video/webm");
                try {
                    a = new MediaRecorder(i, t), r.mimeType = t.mimeType
                } catch (e) {
                    a = new MediaRecorder(i)
                }
                t.mimeType && !MediaRecorder.isTypeSupported && "canRecordMimeType" in a && !1 === a.canRecordMimeType(t.mimeType) && (r.disableLogs || console.warn("MediaRecorder API seems unable to record mimeType:", t.mimeType)), a.ondataavailable = function (e) {
                    e.data && d.push("ondataavailable: " + A(e.data.size)), "number" != typeof r.timeSlice ? !e.data || !e.data.size || e.data.size < 100 || s.blob ? s.recordingCallback && (s.recordingCallback(new Blob([], {type: l(t)})), s.recordingCallback = null) : (s.blob = r.getNativeBlob ? e.data : new Blob([e.data], {type: l(t)}), s.recordingCallback && (s.recordingCallback(s.blob), s.recordingCallback = null)) : e.data && e.data.size && (n.push(e.data), o(), "function" == typeof r.ondataavailable) && (e = r.getNativeBlob ? e.data : new Blob([e.data], {type: l(t)}), r.ondataavailable(e))
                }, a.onstart = function () {
                    d.push("started")
                }, a.onpause = function () {
                    d.push("paused")
                }, a.onresume = function () {
                    d.push("resumed")
                }, a.onstop = function () {
                    d.push("stopped")
                }, a.onerror = function (e) {
                    e && (e.name || (e.name = "UnknownError"), d.push("error: " + e), r.disableLogs || (-1 !== e.name.toString().toLowerCase().indexOf("invalidstate") ? console.error("The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.", e) : -1 !== e.name.toString().toLowerCase().indexOf("notsupported") ? console.error("MIME type (", t.mimeType, ") is not supported.", e) : -1 !== e.name.toString().toLowerCase().indexOf("security") ? console.error("MediaRecorder security error", e) : "OutOfMemory" === e.name ? console.error("The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.", e) : "IllegalStreamModification" === e.name ? console.error("A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.", e) : "OtherRecordingError" === e.name ? console.error("Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.", e) : "GenericError" === e.name ? console.error("The UA cannot provide the codec or recording option that has been requested.", e) : console.error("MediaRecorder Error", e)), !s.manuallyStopped && a && "inactive" === a.state ? (delete r.timeslice, a.start(6e5)) : setTimeout(void 0, 1e3), "inactive" !== a.state && "stopped" !== a.state && a.stop())
                }, "number" == typeof r.timeSlice ? (o(), a.start(r.timeSlice)) : a.start(36e5), r.initCallback && r.initCallback()
            }, this.timestamps = [], this.stop = function (e) {
                e = e || function () {
                }, s.manuallyStopped = !0, a && (this.recordingCallback = e, "recording" === a.state && a.stop(), "number" == typeof r.timeSlice && setTimeout(function () {
                    s.blob = new Blob(n, {type: l(r)}), s.recordingCallback(s.blob)
                }, 100))
            }, this.pause = function () {
                a && "recording" === a.state && a.pause()
            }, this.resume = function () {
                a && "paused" === a.state && a.resume()
            }, this.clearRecordedData = function () {
                a && "recording" === a.state && s.stop(t), t()
            }, this.getInternalRecorder = function () {
                return a
            }, this.blob = null, this.getState = function () {
                return a && a.state || "inactive"
            };
            var d = [];
            this.getAllStates = function () {
                return d
            }, void 0 === r.checkForInactiveTracks && (r.checkForInactiveTracks = !1), s = this, function e() {
                if (a && !1 !== r.checkForInactiveTracks) return !1 === function () {
                    if ("active" in i) {
                        if (!i.active) return !1
                    } else if ("ended" in i && i.ended) return !1;
                    return !0
                }() ? (r.disableLogs || console.log("MediaStream seems stopped."), void s.stop()) : void setTimeout(e, 1e3)
            }(), this.name = "MediaStreamRecorder", this.toString = function () {
                return this.name
            }
        }

        function d(e, r) {
            if (!T(e, "audio").length) throw"Your stream has no audio tracks.";
            var s, a = this, n = [], o = [], l = !1, d = 0, h = 2, c = (r = r || {}).desiredSampRate;

            function u() {
                if (!1 === r.checkForInactiveTracks) return !0;
                if ("active" in e) {
                    if (!e.active) return !1
                } else if ("ended" in e && e.ended) return !1;
                return !0
            }

            function t(e, t) {
                function i(e, t) {
                    var i, r = e.numberOfAudioChannels, s = e.leftBuffers.slice(0), a = e.rightBuffers.slice(0),
                        n = e.sampleRate, o = e.internalInterleavedLength, e = e.desiredSampRate;

                    function l(e, t, i) {
                        var r = Math.round(e.length * (t / i)), s = [], a = Number((e.length - 1) / (r - 1));
                        s[0] = e[0];
                        for (var n, o = 1; o < r - 1; o++) {
                            var l = o * a, d = Number(Math.floor(l)).toFixed(), h = Number(Math.ceil(l)).toFixed();
                            s[o] = (n = e[d], h = e[h], n + (h - n) * (l - d))
                        }
                        return s[r - 1] = e[e.length - 1], s
                    }

                    function d(e, t) {
                        for (var i = new Float64Array(t), r = 0, s = e.length, a = 0; a < s; a++) {
                            var n = e[a];
                            i.set(n, r), r += n.length
                        }
                        return i
                    }

                    function h(e, t, i) {
                        for (var r = i.length, s = 0; s < r; s++) e.setUint8(t + s, i.charCodeAt(s))
                    }

                    2 === r && (s = d(s, o), a = d(a, o), e && (s = l(s, e, n), a = l(a, e, n))), 1 === r && (s = d(s, o), e && (s = l(s, e, n))), e && (n = e), 2 === r && (i = function (e, t) {
                        for (var i = e.length + t.length, r = new Float64Array(i), s = 0, a = 0; a < i;) r[a++] = e[s], r[a++] = t[s], s++;
                        return r
                    }(s, a));
                    var o = (i = 1 === r ? s : i).length, e = new ArrayBuffer(44 + 2 * o), c = new DataView(e);
                    h(c, 0, "RIFF"), c.setUint32(4, 36 + 2 * o, !0), h(c, 8, "WAVE"), h(c, 12, "fmt "), c.setUint32(16, 16, !0), c.setUint16(20, 1, !0), c.setUint16(22, r, !0), c.setUint32(24, n, !0), c.setUint32(28, n * r * 2, !0), c.setUint16(32, 2 * r, !0), c.setUint16(34, 16, !0), h(c, 36, "data"), c.setUint32(40, 2 * o, !0);
                    for (var u = o, p = 44, f = 0; f < u; f++) c.setInt16(p, 32767 * i[f], !0), p += 2;
                    if (t) return t({buffer: e, view: c});
                    postMessage({buffer: e, view: c})
                }

                var r, s, a;
                e.noWorker ? i(e, function (e) {
                    t(e.buffer, e.view)
                }) : (r = i, r = E.createObjectURL(new Blob([r.toString(), ";this.onmessage =  function (eee) {" + r.name + "(eee.data);}"], {type: "application/javascript"})), (s = new Worker(r)).workerURL = r, (a = s).onmessage = function (e) {
                    t(e.data.buffer, e.data.view), E.revokeObjectURL(a.workerURL), a.terminate()
                }, a.postMessage(e))
            }

            !0 === r.leftChannel && (h = 1), (!(h = 1 === r.numberOfAudioChannels ? 1 : h) || h < 1) && (h = 2), r.disableLogs || console.log("StereoAudioRecorder is set to record number of channels: " + h), void 0 === r.checkForInactiveTracks && (r.checkForInactiveTracks = !0), this.record = function () {
                if (!1 === u()) throw"Please make sure MediaStream is active.";
                A(), v = y = !1, l = !0, void 0 !== r.timeSlice && w()
            }, this.stop = function (i) {
                i = i || function () {
                }, l = !1, t({
                    desiredSampRate: c,
                    sampleRate: g,
                    numberOfAudioChannels: h,
                    internalInterleavedLength: d,
                    leftBuffers: n,
                    rightBuffers: 1 === h ? [] : o,
                    noWorker: r.noWorker
                }, function (e, t) {
                    a.blob = new Blob([t], {type: "audio/wav"}), a.buffer = new ArrayBuffer(t.buffer.byteLength), a.view = t, a.sampleRate = c || g, a.bufferSize = m, a.length = d, v = !1, i && i(a.blob)
                })
            }, (S.Storage = void 0 === S.Storage ? {
                AudioContextConstructor: null,
                AudioContext: window.AudioContext || window.webkitAudioContext
            } : S.Storage).AudioContextConstructor && "closed" !== S.Storage.AudioContextConstructor.state || (S.Storage.AudioContextConstructor = new S.Storage.AudioContext);
            var i = S.Storage.AudioContextConstructor, p = i.createMediaStreamSource(e),
                f = [0, 256, 512, 1024, 2048, 4096, 8192, 16384], m = void 0 === r.bufferSize ? 4096 : r.bufferSize;
            if (-1 !== f.indexOf(m) || r.disableLogs || console.log("Legal values for buffer-size are " + JSON.stringify(f, null, "\t")), i.createJavaScriptNode) s = i.createJavaScriptNode(m, h, h); else {
                if (!i.createScriptProcessor) throw"WebAudio API has no support on this browser.";
                s = i.createScriptProcessor(m, h, h)
            }
            p.connect(s), r.bufferSize || (m = s.bufferSize);
            var g = void 0 !== r.sampleRate ? r.sampleRate : i.sampleRate || 44100,
                y = ((g < 22050 || 96e3 < g) && !r.disableLogs && console.log("sample-rate must be under range 22050 and 96000."), r.disableLogs || r.desiredSampRate && console.log("Desired sample-rate: " + r.desiredSampRate), !1);

            function A() {
                n = [], d = 0, y = l = v = !(o = []), i = null, a.leftchannel = n, a.rightchannel = o, a.numberOfAudioChannels = h, a.desiredSampRate = c, a.sampleRate = g, a.recordingLength = d, _ = {
                    left: [],
                    right: [],
                    recordingLength: 0
                }
            }

            function b() {
                s && (s.onaudioprocess = null, s.disconnect(), s = null), p && (p.disconnect(), p = null), A()
            }

            this.pause = function () {
                y = !0
            }, this.resume = function () {
                if (!1 === u()) throw"Please make sure MediaStream is active.";
                if (!l) return r.disableLogs || console.log("Seems recording has been restarted."), void this.record();
                y = !1
            }, this.clearRecordedData = function () {
                r.checkForInactiveTracks = !1, l && this.stop(b), b()
            }, this.name = "StereoAudioRecorder";
            var v = !(this.toString = function () {
                return this.name
            }), _ = (s.onaudioprocess = function (e) {
                var t, i;
                y || (!1 === u() && (r.disableLogs || console.log("MediaStream seems stopped."), s.disconnect(), l = !1), l ? (v || (v = !0, r.onAudioProcessStarted && r.onAudioProcessStarted(), r.initCallback && r.initCallback()), t = e.inputBuffer.getChannelData(0), t = new Float32Array(t), n.push(t), 2 === h && (e = e.inputBuffer.getChannelData(1), i = new Float32Array(e), o.push(i)), d += m, a.recordingLength = d, void 0 !== r.timeSlice && (_.recordingLength += m, _.left.push(t), 2 === h && _.right.push(i))) : p && (p.disconnect(), p = null))
            }, i.createMediaStreamDestination ? s.connect(i.createMediaStreamDestination()) : s.connect(i.destination), this.leftchannel = n, this.rightchannel = o, this.numberOfAudioChannels = h, this.desiredSampRate = c, this.sampleRate = g, a.recordingLength = d, {
                left: [],
                right: [],
                recordingLength: 0
            });

            function w() {
                l && "function" == typeof r.ondataavailable && void 0 !== r.timeSlice && (_.left.length ? (t({
                    desiredSampRate: c,
                    sampleRate: g,
                    numberOfAudioChannels: h,
                    internalInterleavedLength: _.recordingLength,
                    leftBuffers: _.left,
                    rightBuffers: 1 === h ? [] : _.right
                }, function (e, t) {
                    t = new Blob([t], {type: "audio/wav"});
                    r.ondataavailable(t), setTimeout(w, r.timeSlice)
                }), _ = {left: [], right: [], recordingLength: 0}) : setTimeout(w, r.timeSlice))
            }
        }

        function r(s, a) {
            if ("undefined" == typeof html2canvas) throw"Please link: https://www.webrtc-experiment.com/screenshot.js";
            (a = a || {}).frameInterval || (a.frameInterval = 10);
            var r = !1;
            ["captureStream", "mozCaptureStream", "webkitCaptureStream"].forEach(function (e) {
                e in document.createElement("canvas") && (r = !0)
            });
            var i, n, o, e = !(!window.webkitRTCPeerConnection && !window.webkitGetUserMedia || !window.chrome), t = 50,
                l = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
            if (e && l && l[2] && (t = parseInt(l[2], 10)), e && t < 52 && (r = !1), r = a.useWhammyRecorder ? !1 : r) if (a.disableLogs || console.log("Your browser supports both MediRecorder API and canvas.captureStream!"), s instanceof HTMLCanvasElement) i = s; else {
                if (!(s instanceof CanvasRenderingContext2D)) throw"Please pass either HTMLCanvasElement or CanvasRenderingContext2D.";
                i = s.canvas
            } else !navigator.mozGetUserMedia || a.disableLogs || console.error("Canvas recording is NOT supported in Firefox.");
            this.record = function () {
                if (o = !0, r && !a.useWhammyRecorder) {
                    var e;
                    "captureStream" in i ? e = i.captureStream(25) : "mozCaptureStream" in i ? e = i.mozCaptureStream(25) : "webkitCaptureStream" in i && (e = i.webkitCaptureStream(25));
                    try {
                        var t = new y;
                        t.addTrack(T(e, "video")[0]), e = t
                    } catch (e) {
                    }
                    if (!e) throw"captureStream API are NOT available.";
                    (n = new _(e, {mimeType: a.mimeType || "video/webm"})).record()
                } else p.frames = [], u = (new Date).getTime(), c();
                a.initCallback && a.initCallback()
            }, this.getWebPImages = function (e) {
                var r;
                "canvas" === s.nodeName.toLowerCase() && (r = p.frames.length, p.frames.forEach(function (e, t) {
                    var i = r - t,
                        i = (a.disableLogs || console.log(i + "/" + r + " frames remaining"), a.onEncodingCallback && a.onEncodingCallback(i, r), e.image.toDataURL("image/webp", 1));
                    p.frames[t].image = i
                }), a.disableLogs || console.log("Generating WebM")), e()
            };
            var d = !(this.stop = function (t) {
                o = !1;
                var i = this;
                r && n ? n.stop(t) : this.getWebPImages(function () {
                    p.compile(function (e) {
                        a.disableLogs || console.log("Recording finished!"), i.blob = e, i.blob.forEach && (i.blob = new Blob([], {type: "video/webm"})), t && t(i.blob), p.frames = []
                    })
                })
            });

            function h() {
                p.frames = [], d = o = !1
            }

            function c() {
                return d ? (u = (new Date).getTime(), setTimeout(c, 500)) : "canvas" === s.nodeName.toLowerCase() ? (e = (new Date).getTime() - u, u = (new Date).getTime(), p.frames.push({
                    image: (i = (t = document.createElement("canvas")).getContext("2d"), t.width = s.width, t.height = s.height, i.drawImage(s, 0, 0), t),
                    duration: e
                }), void (o && setTimeout(c, a.frameInterval))) : void html2canvas(s, {
                    grabMouse: void 0 === a.showMousePointer || a.showMousePointer,
                    onrendered: function (e) {
                        var t = (new Date).getTime() - u;
                        if (!t) return setTimeout(c, a.frameInterval);
                        u = (new Date).getTime(), p.frames.push({
                            image: e.toDataURL("image/webp", 1),
                            duration: t
                        }), o && setTimeout(c, a.frameInterval)
                    }
                });
                var e, t, i
            }

            this.pause = function () {
                d = !0, n instanceof _ && n.pause()
            }, this.resume = function () {
                d = !1, n instanceof _ ? n.resume() : o || this.record()
            }, this.clearRecordedData = function () {
                o && this.stop(h), h()
            }, this.name = "CanvasRecorder", this.toString = function () {
                return this.name
            };
            var u = (new Date).getTime(), p = new k.Video(100)
        }

        function u(e, b) {
            function i(e) {
                e = void 0 !== e ? e : 10;
                var t = (new Date).getTime() - n;
                return t ? s ? (n = (new Date).getTime(), setTimeout(i, 100)) : (n = (new Date).getTime(), a.paused && a.play(), o.drawImage(a, 0, 0, _.width, _.height), v.frames.push({
                    duration: t,
                    image: _.toDataURL("image/webp")
                }), void (r || setTimeout(i, e, e))) : setTimeout(i, e, e)
            }

            (b = b || {}).frameInterval || (b.frameInterval = 10), b.disableLogs || console.log("Using frames-interval:", b.frameInterval);
            var r = !(this.record = function () {
                b.width || (b.width = 320), b.height || (b.height = 240), b.video || (b.video = {
                    width: b.width,
                    height: b.height
                }), b.canvas || (b.canvas = {
                    width: b.width,
                    height: b.height
                }), _.width = b.canvas.width || 320, _.height = b.canvas.height || 240, o = _.getContext("2d"), b.video && b.video instanceof HTMLVideoElement ? (a = b.video.cloneNode(), b.initCallback && b.initCallback()) : (a = document.createElement("video"), w(e, a), a.onloadedmetadata = function () {
                    b.initCallback && b.initCallback()
                }, a.width = b.video.width, a.height = b.video.height), a.muted = !0, a.play(), n = (new Date).getTime(), v = new k.Video, b.disableLogs || (console.log("canvas resolutions", _.width, "*", _.height), console.log("video width/height", a.width || _.width, "*", a.height || _.height)), i(b.frameInterval)
            }), s = !(this.stop = function (y) {
                y = y || function () {
                }, r = !0;
                var A = this;
                setTimeout(function () {
                    var i, e, t, r, s, a, n, h, c, u, o, p, f, m, g, l, d;
                    i = v.frames, e = -1, r = t = null, s = function (e) {
                        v.frames = e, b.advertisement && b.advertisement.length && (v.frames = b.advertisement.concat(v.frames)), v.compile(function (e) {
                            A.blob = e, A.blob.forEach && (A.blob = new Blob([], {type: "video/webm"})), y && y(A.blob)
                        })
                    }, (a = document.createElement("canvas")).width = _.width, a.height = _.height, h = a.getContext("2d"), c = [], u = -1 === e, o = e && 0 < e && e <= i.length ? e : i.length, p = Math.sqrt(Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2)), f = t && 0 <= t && t <= 1 ? t : 0, m = r && 0 <= r && r <= 1 ? r : 0, g = !1, l = -1, d = (n = {
                        length: o,
                        functionToLoop: function (e, t) {
                            function a() {
                                !g && l - n <= l * m || (u && (g = !0), c.push(i[t])), e()
                            }

                            var n, o, l, d;
                            g ? a() : ((d = new Image).onload = function () {
                                h.drawImage(d, 0, 0, _.width, _.height);
                                var e = h.getImageData(0, 0, _.width, _.height);
                                n = 0, o = e.data.length, l = e.data.length / 4;
                                for (var t = 0; t < o; t += 4) {
                                    var i = e.data[t], r = e.data[t + 1], s = e.data[t + 2];
                                    Math.sqrt(Math.pow(+i, 2) + Math.pow(+r, 2) + Math.pow(+s, 2)) <= p * f && n++
                                }
                                a()
                            }, d.src = i[t].image)
                        },
                        callback: function () {
                            (c = c.concat(i.slice(o))).length <= 0 && c.push(i[i.length - 1]), s(c)
                        }
                    }).length, function e() {
                        ++l !== d ? setTimeout(function () {
                            n.functionToLoop(e, l)
                        }, 1) : n.callback()
                    }()
                }, 10)
            });

            function t() {
                v.frames = [], s = !(r = !0)
            }

            this.pause = function () {
                s = !0
            }, this.resume = function () {
                s = !1, r && this.record()
            }, this.clearRecordedData = function () {
                r || this.stop(t), t()
            }, this.name = "WhammyRecorder", this.toString = function () {
                return this.name
            };
            var a, n, v, _ = document.createElement("canvas"), o = _.getContext("2d")
        }

        void 0 !== e ? v.AudioContext = e : "undefined" != typeof webkitAudioContext && (v.AudioContext = webkitAudioContext), S.Storage = v, S.MediaStreamRecorder = _, S.StereoAudioRecorder = d, S.CanvasRecorder = r, S.WhammyRecorder = u;
        x.prototype.add = function (e, t) {
            if ("toDataURL" in (e = "canvas" in e ? e.canvas : e) && (e = e.toDataURL("image/webp", this.quality)), !/^data:image\/webp;base64,/gi.test(e)) throw"Input must be formatted properly as a base64 encoded DataURI of type image/webp";
            this.frames.push({image: e, duration: t || this.duration})
        }, x.prototype.compile = function (t) {
            i = C, i = E.createObjectURL(new Blob([i.toString(), "this.onmessage =  function (eee) {" + i.name + "(eee.data);}"], {type: "application/javascript"})), e = new Worker(i), E.revokeObjectURL(i);
            var e, i = e;
            i.onmessage = function (e) {
                e.data.error ? console.error(e.data.error) : t(e.data)
            }, i.postMessage(this.frames)
        };
        var k = {Video: x};

        function x(e) {
            this.frames = [], this.duration = e || 1, this.quality = .8
        }

        function C(e) {
            function n(e) {
                var t = [];
                e = (e.length % 8 ? new Array(9 - e.length % 8).join("0") : "") + e;
                for (var i = 0; i < e.length; i += 8) t.push(parseInt(e.substr(i, 8), 2));
                return new Uint8Array(t)
            }

            function d(e) {
                for (var t = [], i = 0; i < e.length; i++) {
                    var r = e[i].data,
                        s = (r = "string" == typeof (r = "number" == typeof (r = "object" == typeof r ? d(r) : r) ? n(r.toString(2)) : r) ? new Uint8Array(r.split("").map(function (e) {
                            return e.charCodeAt(0)
                        })) : r).size || r.byteLength || r.length,
                        a = Math.ceil(Math.ceil(Math.log(s) / Math.log(2)) / 8), s = s.toString(2),
                        s = new Array(7 * a + 7 + 1 - s.length).join("0") + s, a = new Array(a).join("0") + "1" + s;
                    t.push(function (e) {
                        for (var t = []; 0 < e;) t.push(255 & e), e >>= 8;
                        return new Uint8Array(t.reverse())
                    }(e[i].id)), t.push(n(a)), t.push(r)
                }
                return new Blob(t, {type: "video/webm"})
            }

            function o(e) {
                for (var t = 0, i = {}; t < e.length;) {
                    var r = e.substr(t, 4), s = (s = t, parseInt(e.substr(s + 4, 4).split("").map(function (e) {
                        e = e.charCodeAt(0).toString(2);
                        return new Array(8 - e.length + 1).join("0") + e
                    }).join(""), 2)), a = e.substr(t + 4 + 4, s);
                    t += 8 + s, i[r] = i[r] || [], "RIFF" === r || "LIST" === r ? i[r].push(o(a)) : i[r].push(a)
                }
                return i
            }

            e = new function (e) {
                var t = function (e) {
                    if (e[0]) {
                        for (var t = e[0].width, i = e[0].height, r = e[0].duration, s = 1; s < e.length; s++) r += e[s].duration;
                        return {duration: r, width: t, height: i}
                    }
                    postMessage({error: "Something went wrong. Maybe WebP format is not supported in the current browser."})
                }(e);
                if (!t) return [];
                for (var i, r = [{
                    id: 440786851,
                    data: [{data: 1, id: 17030}, {data: 1, id: 17143}, {data: 4, id: 17138}, {
                        data: 8,
                        id: 17139
                    }, {data: "webm", id: 17026}, {data: 2, id: 17031}, {data: 2, id: 17029}]
                }, {
                    id: 408125543,
                    data: [{
                        id: 357149030,
                        data: [{data: 1e6, id: 2807729}, {data: "whammy", id: 19840}, {
                            data: "whammy",
                            id: 22337
                        }, {
                            data: (i = t.duration, [].slice.call(new Uint8Array(new Float64Array([i]).buffer), 0).map(function (e) {
                                return String.fromCharCode(e)
                            }).reverse().join("")), id: 17545
                        }]
                    }, {
                        id: 374648427,
                        data: [{
                            id: 174,
                            data: [{data: 1, id: 215}, {data: 1, id: 29637}, {data: 0, id: 156}, {
                                data: "und",
                                id: 2274716
                            }, {data: "V_VP8", id: 134}, {data: "VP8", id: 2459272}, {data: 1, id: 131}, {
                                id: 224,
                                data: [{data: t.width, id: 176}, {data: t.height, id: 186}]
                            }]
                        }]
                    }]
                }], s = 0, a = 0; s < e.length;) {
                    for (var n = [], o = 0; n.push(e[s]), o += e[s].duration, ++s < e.length && o < 3e4;) ;
                    var l = {
                        id: 524531317, data: function (e, i, t) {
                            return [{data: e, id: 231}].concat(t.map(function (e) {
                                var t = function (e) {
                                    var t = 0;
                                    if (e.keyframe && (t |= 128), e.invisible && (t |= 8), e.lacing && (t |= e.lacing << 1), e.discardable && (t |= 1), 127 < e.trackNum) throw"TrackNumber > 127 not supported";
                                    return [128 | e.trackNum, e.timecode >> 8, 255 & e.timecode, t].map(function (e) {
                                        return String.fromCharCode(e)
                                    }).join("") + e.frame
                                }({
                                    discardable: 0,
                                    frame: e.data.slice(4),
                                    invisible: 0,
                                    keyframe: 1,
                                    lacing: 0,
                                    trackNum: 1,
                                    timecode: Math.round(i)
                                });
                                return i += e.duration, {data: t, id: 163}
                            }))
                        }(a, 0, n)
                    };
                    r[1].data.push(l), a += o
                }
                return d(r)
            }(e.map(function (e) {
                var t = function (e) {
                    for (var t = e.RIFF[0].WEBP[0], i = t.indexOf("*"), r = 0, s = []; r < 4; r++) s[r] = t.charCodeAt(i + 3 + r);
                    return {width: 16383 & (s[1] << 8 | s[0]), height: 16383 & (s[3] << 8 | s[2]), data: t, riff: e}
                }(o(atob(e.image.slice(23))));
                return t.duration = e.duration, t
            }));
            postMessage(e)
        }

        S.Whammy = k;
        var L = {
            init: function () {
                var i, e, t, r = this;

                function s(e) {
                    e.createObjectStore(r.dataStoreName)
                }

                function a() {
                    var e = i.transaction([r.dataStoreName], "readwrite");

                    function t(t) {
                        e.objectStore(r.dataStoreName).get(t).onsuccess = function (e) {
                            r.callback && r.callback(e.target.result, t)
                        }
                    }

                    r.videoBlob && e.objectStore(r.dataStoreName).put(r.videoBlob, "videoBlob"), r.gifBlob && e.objectStore(r.dataStoreName).put(r.gifBlob, "gifBlob"), r.audioBlob && e.objectStore(r.dataStoreName).put(r.audioBlob, "audioBlob"), t("audioBlob"), t("videoBlob"), t("gifBlob")
                }

                "undefined" != typeof indexedDB && void 0 !== indexedDB.open ? (e = this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, ""), (t = indexedDB.open(e, 1)).onerror = r.onError, t.onsuccess = function () {
                    (i = t.result).onerror = r.onError, i.setVersion && 1 !== i.version ? i.setVersion(1).onsuccess = function () {
                        s(i), a()
                    } : a()
                }, t.onupgradeneeded = function (e) {
                    s(e.target.result)
                }) : console.error("IndexedDB API are not available in this browser.")
            }, Fetch: function (e) {
                return this.callback = e, this.init(), this
            }, Store: function (e) {
                return this.audioBlob = e.audioBlob, this.videoBlob = e.videoBlob, this.gifBlob = e.gifBlob, this.init(), this
            }, onError: function (e) {
                console.error(JSON.stringify(e, null, "\t"))
            }, dataStoreName: "recordRTC", dbName: null
        };

        function D(e, i) {
            "undefined" == typeof GIFEncoder && ((t = document.createElement("script")).src = "https://www.webrtc-experiment.com/gif-recorder.js", (document.body || document.documentElement).appendChild(t)), i = i || {};
            var t, r, s = e instanceof CanvasRenderingContext2D || e instanceof HTMLCanvasElement,
                a = (this.record = function () {
                    "undefined" != typeof GIFEncoder && l ? (s || (i.width || (i.width = r.offsetWidth || 320), i.height || (i.height = r.offsetHeight || 240), i.video || (i.video = {
                        width: i.width,
                        height: i.height
                    }), i.canvas || (i.canvas = {
                        width: i.width,
                        height: i.height
                    }), n.width = i.canvas.width || 320, n.height = i.canvas.height || 240, r.width = i.video.width || 320, r.height = i.video.height || 240), (h = new GIFEncoder).setRepeat(0), h.setDelay(i.frameRate || 200), h.setQuality(i.quality || 10), h.start(), "function" == typeof i.onGifRecordingStarted && i.onGifRecordingStarted(), c = p(function e(t) {
                        if (!0 !== u.clearedRecordedData) {
                            if (a) return setTimeout(function () {
                                e(t)
                            }, 100);
                            c = p(e), t - d < 90 || (!s && r.paused && r.play(), s || o.drawImage(r, 0, 0, n.width, n.height), i.onGifPreview && i.onGifPreview(n.toDataURL("image/png")), h.addFrame(o), d = t)
                        }
                    }), i.initCallback && i.initCallback()) : setTimeout(u.record, 1e3)
                }, !(this.stop = function (e) {
                    e = e || function () {
                    }, c && g(c), this.blob = new Blob([new Uint8Array(h.stream().bin)], {type: "image/gif"}), e(this.blob), h.stream().bin = []
                })), n = (this.pause = function () {
                    a = !0
                }, this.resume = function () {
                    a = !1
                }, this.clearRecordedData = function () {
                    u.clearedRecordedData = !0, h && (h.stream().bin = [])
                }, this.name = "GifRecorder", this.toString = function () {
                    return this.name
                }, document.createElement("canvas")), o = n.getContext("2d"),
                l = (s && (e instanceof CanvasRenderingContext2D ? n = (o = e).canvas : e instanceof HTMLCanvasElement && (o = e.getContext("2d"), n = e)), !0);
            s || ((r = document.createElement("video")).muted = !0, r.autoplay = !0, r.playsInline = !0, l = !1, r.onloadedmetadata = function () {
                l = !0
            }, w(e, r), r.play());
            var d, h, c = null, u = this
        }

        function I(r, s) {
            s = s || "multi-streams-mixer";
            var a = [], n = !1, o = document.createElement("canvas"), l = o.getContext("2d"),
                d = (o.style.opacity = 0, o.style.position = "absolute", o.style.zIndex = -1, o.style.top = "-1000em", o.style.left = "-1000em", o.className = s, (document.body || document.documentElement).appendChild(o), this.disableLogs = !1, this.frameInterval = 10, this.width = 360, this.height = 240, this.useGainNode = !0, this),
                e = window.AudioContext;
            void 0 === e && ("undefined" != typeof webkitAudioContext && (e = webkitAudioContext), "undefined" != typeof mozAudioContext && (e = mozAudioContext));
            window.URL, "undefined" != typeof navigator && void 0 === navigator.getUserMedia && (void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia), void 0 !== navigator.mozGetUserMedia && (navigator.getUserMedia = navigator.mozGetUserMedia));
            var h = window.MediaStream,
                c = (void 0 !== (h = void 0 === h && "undefined" != typeof webkitMediaStream ? webkitMediaStream : h) && void 0 === h.prototype.stop && (h.prototype.stop = function () {
                    this.getTracks().forEach(function (e) {
                        e.stop()
                    })
                }), {});

            function u() {
                var e, t, i;
                n || (e = a.length, t = !1, i = [], a.forEach(function (e) {
                    e.stream || (e.stream = {}), e.stream.fullcanvas ? t = e : i.push(e)
                }), t ? (o.width = t.stream.width, o.height = t.stream.height) : i.length ? (o.width = 1 < e ? 2 * i[0].width : i[0].width, o.height = i[0].height * (9 !== e && 10 !== e ? 7 !== e && 8 !== e ? 5 !== e && 6 !== e ? 3 !== e && 4 !== e ? 1 : 2 : 3 : 4 : 5)) : (o.width = d.width || 360, o.height = d.height || 240), t && t instanceof HTMLVideoElement && p(t), i.forEach(function (e, t) {
                    p(e, t)
                }), setTimeout(u, d.frameInterval))
            }

            function p(e, t) {
                var i, r, s, a;
                n || (r = i = 0, s = e.width, a = e.height, 1 === t && (i = e.width), 2 === t && (r = e.height), 3 === t && (i = e.width, r = e.height), 4 === t && (r = 2 * e.height), 5 === t && (i = e.width, r = 2 * e.height), 6 === t && (r = 3 * e.height), 7 === t && (i = e.width, r = 3 * e.height), void 0 !== e.stream.left && (i = e.stream.left), void 0 !== e.stream.top && (r = e.stream.top), void 0 !== e.stream.width && (s = e.stream.width), void 0 !== e.stream.height && (a = e.stream.height), l.drawImage(e, i, r, s, a), "function" == typeof e.stream.onRender && e.stream.onRender(l, i, r, s, a, t))
            }

            function f(e) {
                var t, i, r = document.createElement("video");
                return t = e, !("srcObject" in (i = r)) && "mozSrcObject" in i ? i.mozSrcObject = t : i.srcObject = t, r.className = s, r.muted = !0, r.volume = 0, r.width = e.width || d.width || 360, r.height = e.height || d.height || 240, r.play(), r
            }

            function m(e) {
                a = [], (e = e || r).forEach(function (e) {
                    var t;
                    e.getTracks().filter(function (e) {
                        return "video" === e.kind
                    }).length && ((t = f(e)).stream = e, a.push(t))
                })
            }

            void 0 !== e ? c.AudioContext = e : "undefined" != typeof webkitAudioContext && (c.AudioContext = webkitAudioContext), this.startDrawingFrames = function () {
                u()
            }, this.appendStreams = function (e) {
                if (!e) throw"First parameter is required.";
                (e = e instanceof Array ? e : [e]).forEach(function (e) {
                    var t, i = new h;
                    e.getTracks().filter(function (e) {
                        return "video" === e.kind
                    }).length && ((t = f(e)).stream = e, a.push(t), i.addTrack(e.getTracks().filter(function (e) {
                        return "video" === e.kind
                    })[0])), e.getTracks().filter(function (e) {
                        return "audio" === e.kind
                    }).length && (t = d.audioContext.createMediaStreamSource(e), d.audioDestination = d.audioContext.createMediaStreamDestination(), t.connect(d.audioDestination), i.addTrack(d.audioDestination.stream.getTracks().filter(function (e) {
                        return "audio" === e.kind
                    })[0])), r.push(i)
                })
            }, this.releaseStreams = function () {
                a = [], n = !0, d.gainNode && (d.gainNode.disconnect(), d.gainNode = null), d.audioSources.length && (d.audioSources.forEach(function (e) {
                    e.disconnect()
                }), d.audioSources = []), d.audioDestination && (d.audioDestination.disconnect(), d.audioDestination = null), d.audioContext && d.audioContext.close(), d.audioContext = null, l.clearRect(0, 0, o.width, o.height), o.stream && (o.stream.stop(), o.stream = null)
            }, this.resetVideoStreams = function (e) {
                m(e = !e || e instanceof Array ? e : [e])
            }, this.name = "MultiStreamsMixer", this.toString = function () {
                return this.name
            }, this.getMixedStream = function () {
                n = !1;
                m(), "captureStream" in o ? e = o.captureStream() : "mozCaptureStream" in o ? e = o.mozCaptureStream() : d.disableLogs || console.error("Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features"), t = new h, e.getTracks().filter(function (e) {
                    return "video" === e.kind
                }).forEach(function (e) {
                    t.addTrack(e)
                });
                var t, i = o.stream = t, e = function () {
                    c.AudioContextConstructor || (c.AudioContextConstructor = new c.AudioContext), d.audioContext = c.AudioContextConstructor, d.audioSources = [], !0 === d.useGainNode && (d.gainNode = d.audioContext.createGain(), d.gainNode.connect(d.audioContext.destination), d.gainNode.gain.value = 0);
                    var t = 0;
                    if (r.forEach(function (e) {
                        e.getTracks().filter(function (e) {
                            return "audio" === e.kind
                        }).length && (t++, e = d.audioContext.createMediaStreamSource(e), !0 === d.useGainNode && e.connect(d.gainNode), d.audioSources.push(e))
                    }), t) return d.audioDestination = d.audioContext.createMediaStreamDestination(), d.audioSources.forEach(function (e) {
                        e.connect(d.audioDestination)
                    }), d.audioDestination.stream
                }();
                return e && e.getTracks().filter(function (e) {
                    return "audio" === e.kind
                }).forEach(function (e) {
                    i.addTrack(e)
                }), r.forEach(function (e) {
                    e.fullcanvas
                }), i
            }
        }

        function R(i, r) {
            i = i || [];
            var s, a, n = this;
            (r = r || {
                elementClass: "multi-streams-mixer",
                mimeType: "video/webm",
                video: {width: 360, height: 240}
            }).frameInterval || (r.frameInterval = 10), r.video || (r.video = {}), r.video.width || (r.video.width = 360), r.video.height || (r.video.height = 240), this.record = function () {
                var t;
                s = new I(i, r.elementClass || "multi-streams-mixer"), t = [], i.forEach(function (e) {
                    T(e, "video").forEach(function (e) {
                        t.push(e)
                    })
                }), t.length && (s.frameInterval = r.frameInterval || 10, s.width = r.video.width || 360, s.height = r.video.height || 240, s.startDrawingFrames()), r.previewStream && "function" == typeof r.previewStream && r.previewStream(s.getMixedStream()), (a = new _(s.getMixedStream(), r)).record()
            }, this.stop = function (t) {
                a && a.stop(function (e) {
                    n.blob = e, t(e), n.clearRecordedData()
                })
            }, this.pause = function () {
                a && a.pause()
            }, this.resume = function () {
                a && a.resume()
            }, this.clearRecordedData = function () {
                a && (a.clearRecordedData(), a = null), s && (s.releaseStreams(), s = null)
            }, this.addStreams = function (e) {
                if (!e) throw"First parameter is required.";
                e instanceof Array || (e = [e]), i.concat(e), a && s && (s.appendStreams(e), r.previewStream && "function" == typeof r.previewStream && r.previewStream(s.getMixedStream()))
            }, this.resetVideoStreams = function (e) {
                s && (!e || e instanceof Array || (e = [e]), s.resetVideoStreams(e))
            }, this.getMixer = function () {
                return s
            }, this.name = "MultiStreamRecorder", this.toString = function () {
                return this.name
            }
        }

        function P(i, o) {
            var l, r, s;

            function a(t, e) {
                if (!o.workerPath && !e) return l = !1, fetch("https://unpkg.com/webm-wasm@latest/dist/webm-worker.js").then(function (e) {
                    e.arrayBuffer().then(function (e) {
                        a(t, e)
                    })
                });
                !o.workerPath && e instanceof ArrayBuffer && (e = new Blob([e], {type: "text/javascript"}), o.workerPath = E.createObjectURL(e)), o.workerPath || console.error("workerPath parameter is missing."), (r = new Worker(o.workerPath)).postMessage(o.webAssemblyPath || "https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm"), r.addEventListener("message", function (e) {
                    "READY" === e.data ? (r.postMessage({
                        width: o.width,
                        height: o.height,
                        bitrate: o.bitrate || 1200,
                        timebaseDen: o.frameRate || 30,
                        realtime: o.realtime
                    }), new ReadableStream({
                        start: function (r) {
                            var s = document.createElement("canvas"), a = document.createElement("video"), n = !0;
                            a.srcObject = i, a.muted = !0, a.height = o.height, a.width = o.width, a.volume = 0, a.onplaying = function () {
                                s.width = o.width, s.height = o.height;
                                var e = s.getContext("2d"), t = 1e3 / o.frameRate, i = setInterval(function () {
                                    if (l && (clearInterval(i), r.close()), n && (n = !1, o.onVideoProcessStarted && o.onVideoProcessStarted()), e.drawImage(a, 0, 0), "closed" !== r._controlledReadableStream.state) try {
                                        r.enqueue(e.getImageData(0, 0, o.width, o.height))
                                    } catch (e) {
                                    }
                                }, t)
                            }, a.play()
                        }
                    }).pipeTo(new WritableStream({
                        write: function (e) {
                            l ? console.error("Got image, but recorder is finished!") : r.postMessage(e.data.buffer, [e.data.buffer])
                        }
                    }))) : !e.data || s || n.push(e.data)
                })
            }

            "undefined" != typeof ReadableStream && "undefined" != typeof WritableStream || console.error("Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js"), (o = o || {}).width = o.width || 640, o.height = o.height || 480, o.frameRate = o.frameRate || 30, o.bitrate = o.bitrate || 1200, o.realtime = o.realtime || !0, this.record = function () {
                s = !(n = []), this.blob = null, a(i), "function" == typeof o.initCallback && o.initCallback()
            }, this.pause = function () {
                s = !0
            }, this.resume = function () {
                s = !1
            };
            var n = [];
            this.stop = function (e) {
                l = !0;
                var t, i = this;
                t = function () {
                    i.blob = new Blob(n, {type: "video/webm"}), e(i.blob)
                }, r ? (r.addEventListener("message", function (e) {
                    null === e.data && (r.terminate(), r = null, t())
                }), r.postMessage(null)) : t()
            }, this.name = "WebAssemblyRecorder", this.toString = function () {
                return this.name
            }, this.clearRecordedData = function () {
                s = !(n = []), this.blob = null
            }, this.blob = null
        }

        S.DiskStorage = L, S.GifRecorder = D, S.MultiStreamRecorder = R, S.RecordRTCPromisesHandler = function (e, t) {
            if (!this) throw'Use "new RecordRTCPromisesHandler()"';
            if (void 0 === e) throw'First argument "MediaStream" is required.';
            var r = this;
            r.recordRTC = new S(e, t), this.startRecording = function () {
                return new Promise(function (e, t) {
                    try {
                        r.recordRTC.startRecording(), e()
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.stopRecording = function () {
                return new Promise(function (t, i) {
                    try {
                        r.recordRTC.stopRecording(function (e) {
                            r.blob = r.recordRTC.getBlob(), r.blob && r.blob.size ? t(e) : i("Empty blob.", r.blob)
                        })
                    } catch (t) {
                        i(t)
                    }
                })
            }, this.pauseRecording = function () {
                return new Promise(function (e, t) {
                    try {
                        r.recordRTC.pauseRecording(), e()
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.resumeRecording = function () {
                return new Promise(function (e, t) {
                    try {
                        r.recordRTC.resumeRecording(), e()
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.getDataURL = function (e) {
                return new Promise(function (t, e) {
                    try {
                        r.recordRTC.getDataURL(function (e) {
                            t(e)
                        })
                    } catch (t) {
                        e(t)
                    }
                })
            }, this.getBlob = function () {
                return new Promise(function (e, t) {
                    try {
                        e(r.recordRTC.getBlob())
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.getInternalRecorder = function () {
                return new Promise(function (e, t) {
                    try {
                        e(r.recordRTC.getInternalRecorder())
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.reset = function () {
                return new Promise(function (e, t) {
                    try {
                        e(r.recordRTC.reset())
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.destroy = function () {
                return new Promise(function (e, t) {
                    try {
                        e(r.recordRTC.destroy())
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.getState = function () {
                return new Promise(function (e, t) {
                    try {
                        e(r.recordRTC.getState())
                    } catch (e) {
                        t(e)
                    }
                })
            }, this.blob = null, this.version = "5.6.2"
        }, S.WebAssemblyRecorder = P
    });

    class dr {
        constructor(e) {
            this._buffer = e, this._buffer_index = 0, this._total_bytes = e.byteLength, this._total_bits = 8 * e.byteLength, this._current_word = 0, this._current_word_bits_left = 0
        }

        destroy() {
            this._buffer = null
        }

        _fillCurrentWord() {
            var i = this._total_bytes - this._buffer_index;
            if (i <= 0) console.error("ExpGolomb: _fillCurrentWord() but no bytes available", this._total_bytes, this._buffer_index); else {
                let e = Math.min(4, i), t = new Uint8Array(4);
                t.set(this._buffer.subarray(this._buffer_index, this._buffer_index + e)), this._current_word = new DataView(t.buffer).getUint32(0, !1), this._buffer_index += e, this._current_word_bits_left = 8 * e
            }
        }

        readBits(e) {
            if (32 < e && console.error("ExpGolomb: readBits() bits exceeded max 32bits!"), e <= this._current_word_bits_left) return t = this._current_word >>> 32 - e, this._current_word <<= e, this._current_word_bits_left -= e, t;
            var t = this._current_word_bits_left ? this._current_word : 0,
                e = (t >>>= 32 - this._current_word_bits_left, e - this._current_word_bits_left),
                e = (this._fillCurrentWord(), Math.min(e, this._current_word_bits_left)),
                i = this._current_word >>> 32 - e;
            return this._current_word <<= e, this._current_word_bits_left -= e, t << e | i
        }

        readBool() {
            return 1 === this.readBits(1)
        }

        readByte() {
            return this.readBits(8)
        }

        _skipLeadingZero() {
            let e;
            for (e = 0; e < this._current_word_bits_left; e++) if (0 != (this._current_word & 2147483648 >>> e)) return this._current_word <<= e, this._current_word_bits_left -= e, e;
            return this._fillCurrentWord(), e + this._skipLeadingZero()
        }

        readUEG() {
            var e = this._skipLeadingZero();
            return this.readBits(e + 1) - 1
        }

        readSEG() {
            var e = this.readUEG();
            return 1 & e ? e + 1 >>> 1 : -1 * (e >>> 1)
        }
    }

    class P {
        static _ebsp2rbsp(e) {
            let t = e, i = t.byteLength, r = new Uint8Array(i), s = 0;
            for (let e = 0; e < i; e++) 2 <= e && 3 === t[e] && 0 === t[e - 1] && 0 === t[e - 2] || (r[s] = t[e], s++);
            return new Uint8Array(r.buffer, 0, s)
        }

        static parseSPS(e) {
            let t = P._ebsp2rbsp(e), i = new dr(t);
            i.readByte();
            var e = i.readByte(), r = (i.readByte(), i.readByte());
            i.readUEG();
            let s = P.getProfileString(e), a = P.getLevelString(r), n = 1, o = 420, l = 8;
            if ((100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e || 138 === e || 144 === e) && (3 === (n = i.readUEG()) && i.readBits(1), n <= 3 && (o = [0, 420, 422, 444][n]), l = i.readUEG() + 8, i.readUEG(), i.readBits(1), i.readBool())) {
                var d = 3 !== n ? 8 : 12;
                for (let e = 0; e < d; e++) i.readBool() && (e < 6 ? P._skipScalingList(i, 16) : P._skipScalingList(i, 64))
            }
            i.readUEG();
            r = i.readUEG();
            if (0 === r) i.readUEG(); else if (1 === r) {
                i.readBits(1), i.readSEG(), i.readSEG();
                var h = i.readUEG();
                for (let e = 0; e < h; e++) i.readSEG()
            }
            var e = i.readUEG(), r = (i.readBits(1), i.readUEG()), c = i.readUEG(), u = i.readBits(1);
            0 === u && i.readBits(1), i.readBits(1);
            let p = 0, f = 0, m = 0, g = 0,
                y = (i.readBool() && (p = i.readUEG(), f = i.readUEG(), m = i.readUEG(), g = i.readUEG()), 1), A = 1,
                b = 0, v = !0, _ = 0, w = 0,
                S = (i.readBool() && (i.readBool() && (0 < (x = i.readByte()) && x < 16 ? (y = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2][x - 1], A = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1][x - 1]) : 255 === x && (y = i.readByte() << 8 | i.readByte(), A = i.readByte() << 8 | i.readByte())), i.readBool() && i.readBool(), i.readBool() && (i.readBits(4), i.readBool() && i.readBits(24)), i.readBool() && (i.readUEG(), i.readUEG()), i.readBool() && (x = i.readBits(32), k = i.readBits(32), v = i.readBool(), _ = k, w = 2 * x, b = _ / w)), 1),
                E = (1 === y && 1 === A || (S = y / A), 0), T = 0;
            T = 0 === n ? (E = 1, 2 - u) : (E = 3 === n ? 1 : 2, (1 === n ? 2 : 1) * (2 - u));
            var k = 16 * (r + 1), x = 16 * (c + 1) * (2 - u),
                r = (k -= (p + f) * E, x -= (m + g) * T, Math.ceil(k * S));
            return i.destroy(), i = null, {
                profile_string: s,
                level_string: a,
                bit_depth: l,
                ref_frames: e,
                chroma_format: o,
                chroma_format_string: P.getChromaFormatString(o),
                frame_rate: {fixed: v, fps: b, fps_den: w, fps_num: _},
                sar_ratio: {width: y, height: A},
                codec_size: {width: k, height: x},
                present_size: {width: r, height: x}
            }
        }

        static parseSPS$2(e) {
            let i = e.subarray(1, 4), r = "avc1.";
            for (let t = 0; t < 3; t++) {
                let e = i[t].toString(16);
                e.length < 2 && (e = "0" + e), r += e
            }
            let t = P._ebsp2rbsp(e), s = new dr(t);
            s.readByte();
            var e = s.readByte(), a = (s.readByte(), s.readByte());
            s.readUEG();
            let n = P.getProfileString(e), o = P.getLevelString(a), l = 1, d = 420, h = 8, c = 8;
            if ((100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e || 138 === e || 144 === e) && (3 === (l = s.readUEG()) && s.readBits(1), l <= 3 && (d = [0, 420, 422, 444][l]), h = s.readUEG() + 8, c = s.readUEG() + 8, s.readBits(1), s.readBool())) {
                var u = 3 !== l ? 8 : 12;
                for (let e = 0; e < u; e++) s.readBool() && (e < 6 ? P._skipScalingList(s, 16) : P._skipScalingList(s, 64))
            }
            s.readUEG();
            var p = s.readUEG();
            if (0 === p) s.readUEG(); else if (1 === p) {
                s.readBits(1), s.readSEG(), s.readSEG();
                var f = s.readUEG();
                for (let e = 0; e < f; e++) s.readSEG()
            }
            var p = s.readUEG(), m = (s.readBits(1), s.readUEG()), g = s.readUEG(), y = s.readBits(1);
            0 === y && s.readBits(1), s.readBits(1);
            let A = 0, b = 0, v = 0, _ = 0,
                w = (s.readBool() && (A = s.readUEG(), b = s.readUEG(), v = s.readUEG(), _ = s.readUEG()), 1), S = 1,
                E = 0, T = !0, k = 0, x = 0,
                C = (s.readBool() && (s.readBool() && (0 < (R = s.readByte()) && R < 16 ? (w = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2][R - 1], S = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1][R - 1]) : 255 === R && (w = s.readByte() << 8 | s.readByte(), S = s.readByte() << 8 | s.readByte())), s.readBool() && s.readBool(), s.readBool() && (s.readBits(4), s.readBool() && s.readBits(24)), s.readBool() && (s.readUEG(), s.readUEG()), s.readBool() && (R = s.readBits(32), I = s.readBits(32), T = s.readBool(), k = I, x = 2 * R, E = k / x)), 1),
                L = (1 === w && 1 === S || (C = w / S), 0), D = 0;
            D = 0 === l ? (L = 1, 2 - y) : (L = 3 === l ? 1 : 2, (1 === l ? 2 : 1) * (2 - y));
            var I = 16 * (m + 1), R = 16 * (g + 1) * (2 - y),
                m = (I -= (A + b) * L, R -= (v + _) * D, Math.ceil(I * C));
            return s.destroy(), s = null, {
                codec_mimetype: r,
                profile_idc: e,
                level_idc: a,
                profile_string: n,
                level_string: o,
                chroma_format_idc: l,
                bit_depth: h,
                bit_depth_luma: h,
                bit_depth_chroma: c,
                ref_frames: p,
                chroma_format: d,
                chroma_format_string: P.getChromaFormatString(d),
                frame_rate: {fixed: T, fps: E, fps_den: x, fps_num: k},
                sar_ratio: {width: w, height: S},
                codec_size: {width: I, height: R},
                present_size: {width: m, height: R}
            }
        }

        static _skipScalingList(t, i) {
            let r = 8, s = 8, a;
            for (let e = 0; e < i; e++) 0 !== s && (a = t.readSEG(), s = (r + a + 256) % 256), r = 0 === s ? r : s
        }

        static getProfileString(e) {
            switch (e) {
                case 66:
                    return "Baseline";
                case 77:
                    return "Main";
                case 88:
                    return "Extended";
                case 100:
                    return "High";
                case 110:
                    return "High10";
                case 122:
                    return "High422";
                case 244:
                    return "High444";
                default:
                    return "Unknown"
            }
        }

        static getLevelString(e) {
            return (e / 10).toFixed(1)
        }

        static getChromaFormatString(e) {
            switch (e) {
                case 420:
                    return "4:2:0";
                case 422:
                    return "4:2:2";
                case 444:
                    return "4:4:4";
                default:
                    return "Unknown"
            }
        }
    }

    class hr {
        constructor(e) {
            this.buffer = e, this.buflen = e.length, this.bufpos = 0, this.bufoff = 0, this.iserro = !1
        }

        read(e) {
            let t = 0, i;
            for (; e;) {
                if (e < 0 || this.bufpos >= this.buflen) return this.iserro = !0, 0;
                this.iserro = !1, i = 8 < this.bufoff + e ? 8 - this.bufoff : e, t = (t <<= i) + (this.buffer[this.bufpos] >> 8 - this.bufoff - i & 255 >> 8 - i), this.bufoff += i, e -= i, 8 == this.bufoff && (this.bufpos++, this.bufoff = 0)
            }
            return t
        }

        look(e) {
            var t = this.bufpos, i = this.bufoff, e = this.read(e);
            return this.bufpos = t, this.bufoff = i, e
        }

        read_golomb() {
            let e;
            for (e = 0; 0 === this.read(1) && !this.iserro; e++) ;
            return (1 << e) + this.read(e) - 1
        }
    }

    function cr(i) {
        const s = {}, r = new DataView(i.buffer);
        let e = r.getUint8(0), t = r.getUint8(1);
        if (r.getUint8(2), r.getUint8(3), 1 !== e || 0 === t) return {};
        var a = 1 + (3 & r.getUint8(4));
        if (3 != a && 4 != a) return {};
        var n = 31 & r.getUint8(5);
        if (0 == n) return {};
        let o = 6;
        for (let t = 0; t < n; t++) {
            var l = r.getUint16(o, !1);
            if (o += 2, 0 !== l) {
                let e = new Uint8Array(i.buffer, o, l);
                o += l;
                l = P.parseSPS(e);
                if (0 === t) {
                    s.sps = e, s.timescale = 1e3, s.codecWidth = l.codec_size.width, s.codecHeight = l.codec_size.height, s.presentWidth = l.present_size.width, s.presentHeight = l.present_size.height, s.profile = l.profile_string, s.level = l.level_string, s.bitDepth = l.bit_depth, s.chromaFormat = l.chroma_format, s.sarRatio = l.sar_ratio, s.frameRate = l.frame_rate, !1 !== l.frame_rate.fixed && 0 !== l.frame_rate.fps_num && 0 !== l.frame_rate.fps_den || (s.frameRate = {
                        fixed: !0,
                        fps: 23.976,
                        fps_num: 23976,
                        fps_den: 1e3
                    });
                    var l = s.frameRate.fps_den, d = s.frameRate.fps_num;
                    s.refSampleDuration = s.timescale * (l / d);
                    let i = e.subarray(1, 4), r = "avc1.";
                    for (let t = 0; t < 3; t++) {
                        let e = i[t].toString(16);
                        e.length < 2 && (e = "0" + e), r += e
                    }
                    s.codec = r
                }
            }
        }
        var h = r.getUint8(o);
        if (0 === h) return {};
        o++;
        for (let e = 0; e < h; e++) {
            var c, u = r.getUint16(o, !1);
            o += 2, 0 !== u && (c = new Uint8Array(i.buffer, o, u), o += u, s.pps = c)
        }
        if (s.videoType = "avc", s.sps) {
            const i = s.sps.byteLength, r = new Uint8Array([i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i]),
                e = new Uint8Array(i + 4);
            e.set(r, 0), e.set(s.sps, 4), s.sps = e
        }
        if (s.pps) {
            const i = s.pps.byteLength, r = new Uint8Array([i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i]),
                e = new Uint8Array(i + 4);
            e.set(r, 0), e.set(s.pps, 4), s.pps = e
        }
        return s
    }

    function ur(e) {
        let {sps: t, pps: i} = e, r = 8 + t.byteLength + 1 + 2 + i.byteLength, s = !1;
        e = P.parseSPS$2(t);
        66 !== t[3] && 77 !== t[3] && 88 !== t[3] && (s = !0, r += 4);
        let a = new Uint8Array(r);
        a[0] = 1, a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = 255, a[5] = 225;
        var n = t.byteLength, o = (a[6] = n >>> 8, a[7] = 255 & n, 8),
            n = (a.set(t, 8), o += n, a[o] = 1, i.byteLength);
        a[o + 1] = n >>> 8, a[o + 2] = 255 & n, a.set(i, o + 3), o += 3 + n, s && (a[o] = 252 | e.chroma_format_idc, a[o + 1] = 248 | e.bit_depth_luma - 8, a[o + 2] = 248 | e.bit_depth_chroma - 8, a[o + 3] = 0, o += 4);
        const l = [23, 0, 0, 0, 0], d = new Uint8Array(l.length + a.byteLength);
        return d.set(l, 0), d.set(a, l.length), d
    }

    function pr(e, t) {
        let i = [];
        i[0] = t ? 23 : 39, i[1] = 1, i[2] = 0, i[3] = 0, i[4] = 0;
        const r = new Uint8Array(i.length + e.byteLength);
        return r.set(i, 0), r.set(e, i.length), r
    }

    function fr(e) {
        return 31 & e[0]
    }

    function mr(e) {
        return e === Te
    }

    function gr(e) {
        return 7 !== e && 8 !== e && !mr(e)
    }

    const yr = e => {
        let t = e, i = t.byteLength, r = new Uint8Array(i), s = 0;
        for (let e = 0; e < i; e++) 2 <= e && 3 === t[e] && 0 === t[e - 1] && 0 === t[e - 2] || (r[s] = t[e], s++);
        return new Uint8Array(r.buffer, 0, s)
    };

    function Ar(e) {
        const t = e.byteLength, i = new Uint8Array(4),
            r = (i[0] = t >>> 24 & 255, i[1] = t >>> 16 & 255, i[2] = t >>> 8 & 255, i[3] = 255 & t, new Uint8Array(t + 4));
        return r.set(i, 0), r.set(e, 4), r
    }

    function br(e) {
        let s = {width: 0, height: 0, profile: 0, level: 0};
        e = e.slice(5);
        do {
            let t = {};
            if (e.length < 23) {
                console.warn("parseHEVCDecoderConfigurationRecord$2", `arrayBuffer.length ${e.length} < 23`);
                break
            }
            if (t.configurationVersion = e[0], 1 != t.configurationVersion) break;
            t.general_profile_space = e[1] >> 6 & 3, t.general_tier_flag = e[1] >> 5 & 1, t.general_profile_idc = 31 & e[1], t.general_profile_compatibility_flags = e[2] << 24 | e[3] << 16 | e[4] << 8 | e[5], t.general_constraint_indicator_flags = e[6] << 24 | e[7] << 16 | e[8] << 8 | e[9], t.general_constraint_indicator_flags = t.general_constraint_indicator_flags << 16 | e[10] << 8 | e[11], t.general_level_idc = e[12], t.min_spatial_segmentation_idc = (15 & e[13]) << 8 | e[14], t.parallelismType = 3 & e[15], t.chromaFormat = 3 & e[16], t.bitDepthLumaMinus8 = 7 & e[17], t.bitDepthChromaMinus8 = 7 & e[18], t.avgFrameRate = e[19] << 8 | e[20], t.constantFrameRate = e[21] >> 6 & 3, t.numTemporalLayers = e[21] >> 3 & 7, t.temporalIdNested = e[21] >> 2 & 1, t.lengthSizeMinusOne = 3 & e[21];
            let i = e[22], r = e.slice(23);
            for (let e = 0; e < i && !(r.length < 3); e++) {
                var a = 63 & r[0], n = r[1] << 8 | r[2];
                r = r.slice(3);
                for (let e = 0; e < n && !(r.length < 2); e++) {
                    var o = r[0] << 8 | r[1];
                    if (r.length < 2 + o) break;
                    if (r = r.slice(2), 33 == a) {
                        let e = new Uint8Array(o);
                        e.set(r.slice(0, o), 0), t.psps = function (e) {
                            let t = {}, i = e.length, r = [], s = new hr(e);
                            s.read(1), s.read(6), s.read(6), s.read(3);
                            for (let e = 2; e < i; e++) e + 2 < i && 3 == s.look(24) ? (r.push(s.read(8)), r.push(s.read(8)), e += 2, s.read(8)) : r.push(s.read(8));
                            let a = new Uint8Array(r), n = new hr(a);
                            {
                                var o;
                                t.sps_video_parameter_set_id = n.read(4), t.sps_max_sub_layers_minus1 = n.read(3), t.sps_temporal_id_nesting_flag = n.read(1), t.profile_tier_level = function (t, i) {
                                    let r = {};
                                    r.profile_space = t.read(2), r.tier_flag = t.read(1), r.profile_idc = t.read(5), r.profile_compatibility_flags = t.read(32), r.general_progressive_source_flag = t.read(1), r.general_interlaced_source_flag = t.read(1), r.general_non_packed_constraint_flag = t.read(1), r.general_frame_only_constraint_flag = t.read(1), t.read(32), t.read(12), r.level_idc = t.read(8), r.sub_layer_profile_present_flag = [], r.sub_layer_level_present_flag = [];
                                    for (let e = 0; e < i; e++) r.sub_layer_profile_present_flag[e] = t.read(1), r.sub_layer_level_present_flag[e] = t.read(1);
                                    if (0 < i) for (let e = i; e < 8; e++) t.read(2);
                                    r.sub_layer_profile_space = [], r.sub_layer_tier_flag = [], r.sub_layer_profile_idc = [], r.sub_layer_profile_compatibility_flag = [], r.sub_layer_progressive_source_flag = [], r.sub_layer_interlaced_source_flag = [], r.sub_layer_non_packed_constraint_flag = [], r.sub_layer_frame_only_constraint_flag = [], r.sub_layer_level_idc = [];
                                    for (let e = 0; e < i; e++) r.sub_layer_profile_present_flag[e] && (r.sub_layer_profile_space[e] = t.read(2), r.sub_layer_tier_flag[e] = t.read(1), r.sub_layer_profile_idc[e] = t.read(5), r.sub_layer_profile_compatibility_flag[e] = t.read(32), r.sub_layer_progressive_source_flag[e] = t.read(1), r.sub_layer_interlaced_source_flag[e] = t.read(1), r.sub_layer_non_packed_constraint_flag[e] = t.read(1), r.sub_layer_frame_only_constraint_flag[e] = t.read(1), t.read(32), t.read(12)), r.sub_layer_level_present_flag[e] ? r.sub_layer_level_idc[e] = t.read(8) : r.sub_layer_level_idc[e] = 1;
                                    return r
                                }(n, t.sps_max_sub_layers_minus1), t.sps_seq_parameter_set_id = n.read_golomb(), t.chroma_format_idc = n.read_golomb(), 3 == t.chroma_format_idc ? t.separate_colour_plane_flag = n.read(1) : t.separate_colour_plane_flag = 0, t.pic_width_in_luma_samples = n.read_golomb(), t.pic_height_in_luma_samples = n.read_golomb(), t.conformance_window_flag = n.read(1), t.conformance_window_flag ? (e = 1 + (t.chroma_format_idc < 2), o = 1 + (t.chroma_format_idc < 3), t.conf_win_left_offset = n.read_golomb() * o, t.conf_win_right_offset = n.read_golomb() * o, t.conf_win_top_offset = n.read_golomb() * e, t.conf_win_bottom_offset = n.read_golomb() * e) : (t.conf_win_left_offset = 0, t.conf_win_right_offset = 0, t.conf_win_top_offset = 0, t.conf_win_bottom_offset = 0)
                            }
                            return t
                        }(e, t), s.profile = t.general_profile_idc, s.level = t.general_level_idc / 30, s.width = t.psps.pic_width_in_luma_samples - (t.psps.conf_win_left_offset + t.psps.conf_win_right_offset), s.height = t.psps.pic_height_in_luma_samples - (t.psps.conf_win_top_offset + t.psps.conf_win_bottom_offset)
                    }
                    r = r.slice(o)
                }
            }
        } while (0);
        return s.codecWidth = s.width || 1920, s.codecHeight = s.height || 1080, s.presentHeight = s.codecHeight, s.presentWidth = s.codecWidth, s.timescale = 1e3, s.refSampleDuration = 1e3 / 23976 * 1e3, s.videoType = "hevc", s
    }

    function vr(e) {
        var {vps: e, pps: t, sps: i} = e, r = {configurationVersion: 1}, s = (e => {
            let t = yr(e), i = new dr(t);
            return i.readByte(), i.readByte(), i.readBits(4), i.readBits(2), i.readBits(6), {
                num_temporal_layers: i.readBits(3) + 1,
                temporal_id_nested: i.readBool()
            }
        })(e), a = (e => {
            let t = yr(e), a = new dr(t), i = (a.readByte(), a.readByte(), 0), r = 0, s = 0, n = 0;
            a.readBits(4);
            var o = a.readBits(3);
            a.readBool();
            let l = a.readBits(2), d = a.readBool(), h = a.readBits(5), c = a.readByte(), u = a.readByte(),
                p = a.readByte(), f = a.readByte(), m = a.readByte(), g = a.readByte(), y = a.readByte(),
                F = a.readByte(), M = a.readByte(), O = a.readByte(), A = a.readByte(), b = [], N = [];
            for (let e = 0; e < o; e++) b.push(a.readBool()), N.push(a.readBool());
            if (0 < o) for (let e = o; e < 8; e++) a.readBits(2);
            for (let e = 0; e < o; e++) b[e] && (a.readByte(), a.readByte(), a.readByte(), a.readByte(), a.readByte(), a.readByte(), a.readByte(), a.readByte(), a.readByte(), a.readByte(), a.readByte()), b[e] && a.readByte();
            a.readUEG();
            var v, e = a.readUEG(), j = (3 == e && a.readBits(1), a.readUEG()), z = a.readUEG(),
                _ = (a.readBool() && (i += a.readUEG(), r += a.readUEG(), s += a.readUEG(), n += a.readUEG()), a.readUEG()),
                G = a.readUEG(), H = a.readUEG();
            for (let e = a.readBool() ? 0 : o; e <= o; e++) a.readUEG(), a.readUEG(), a.readUEG();
            if (a.readUEG(), a.readUEG(), a.readUEG(), a.readUEG(), a.readUEG(), a.readUEG(), a.readBool() && a.readBool()) for (let t = 0; t < 4; t++) for (let e = 0; e < (3 === t ? 2 : 6); e++) if (a.readBool()) {
                var W = Math.min(64, 1 << 4 + (t << 1));
                1 < t && a.readSEG();
                for (let e = 0; e < W; e++) a.readSEG()
            } else a.readUEG();
            a.readBool(), a.readBool(), a.readBool() && (a.readByte(), a.readUEG(), a.readUEG(), a.readBool());
            let w = a.readUEG(), S = 0;
            for (let t = 0; t < w; t++) {
                let e = !1;
                if (e = 0 !== t ? a.readBool() : e) {
                    t === w && a.readUEG(), a.readBool(), a.readUEG();
                    let i = 0;
                    for (let e = 0; e <= S; e++) {
                        let e = a.readBool(), t = !1;
                        e || (t = a.readBool()), (e || t) && i++
                    }
                    S = i
                } else {
                    var E = a.readUEG(), T = a.readUEG();
                    S = E + T;
                    for (let e = 0; e < E; e++) a.readUEG(), a.readBool();
                    for (let e = 0; e < T; e++) a.readUEG(), a.readBool()
                }
            }
            if (a.readBool()) {
                var V = a.readUEG();
                for (let e = 0; e < V; e++) {
                    for (let e = 0; e < H + 4; e++) a.readBits(1);
                    a.readBits(1)
                }
            }
            let k = 0, x = 1, C = 1, L = !1, D = 1, I = 1;
            if (a.readBool(), a.readBool(), a.readBool()) {
                if (a.readBool() && (0 < (v = a.readByte()) && v < 16 ? (x = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2][v - 1], C = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1][v - 1]) : 255 === v && (x = a.readBits(16), C = a.readBits(16))), a.readBool() && a.readBool(), a.readBool() && (a.readBits(3), a.readBool(), a.readBool() && (a.readByte(), a.readByte(), a.readByte())), a.readBool() && (a.readUEG(), a.readUEG()), a.readBool(), a.readBool(), a.readBool(), a.readBool() && (i += a.readUEG(), r += a.readUEG(), s += a.readUEG(), n += a.readUEG()), a.readBool() && (D = a.readBits(32), I = a.readBits(32), a.readBool() && (a.readUEG(), a.readBool()))) {
                    let i, r, s = !1;
                    i = a.readBool(), r = a.readBool(), (i || r) && ((s = a.readBool()) && (a.readByte(), a.readBits(5), a.readBool(), a.readBits(5)), a.readBits(4), a.readBits(4), s && a.readBits(4), a.readBits(5), a.readBits(5), a.readBits(5));
                    for (let e = 0; e <= o; e++) {
                        var R = a.readBool();
                        L = R;
                        let e = !1, t = !1;
                        if ((e = R ? e : a.readBool()) ? a.readSEG() : t = a.readBool(), t || (cpbcnt = a.readUEG() + 1), i) for (let e = 0; e < 1; e++) a.readUEG(), a.readUEG(), s && (a.readUEG(), a.readUEG());
                        if (r) for (let e = 0; e < 1; e++) a.readUEG(), a.readUEG(), s && (a.readUEG(), a.readUEG())
                    }
                }
                a.readBool() && (a.readBool(), a.readBool(), a.readBool(), k = a.readUEG(), a.readUEG(), a.readUEG(), a.readUEG(), a.readUEG())
            }
            a.readBool();
            let K = `hvc1.${h}.1.L${A}.B0`, P = j, B = z, U = 1;
            return 1 !== x && 1 !== C && (U = x / C), a.destroy(), a = null, {
                codec_mimetype: K,
                level_string: (A / 30).toFixed(1),
                profile_idc: h,
                bit_depth: _ + 8,
                ref_frames: 1,
                chroma_format: e,
                chroma_format_string: (e => {
                    switch (e) {
                        case 0:
                            return "4:0:0";
                        case 1:
                            return "4:2:0";
                        case 2:
                            return "4:2:2";
                        case 3:
                            return "4:4:4";
                        default:
                            return "Unknown"
                    }
                })(e),
                general_level_idc: A,
                general_profile_space: l,
                general_tier_flag: d,
                general_profile_idc: h,
                general_profile_compatibility_flags_1: c,
                general_profile_compatibility_flags_2: u,
                general_profile_compatibility_flags_3: p,
                general_profile_compatibility_flags_4: f,
                general_constraint_indicator_flags_1: m,
                general_constraint_indicator_flags_2: g,
                general_constraint_indicator_flags_3: y,
                general_constraint_indicator_flags_4: F,
                general_constraint_indicator_flags_5: M,
                general_constraint_indicator_flags_6: O,
                min_spatial_segmentation_idc: k,
                constant_frame_rate: 0,
                chroma_format_idc: e,
                bit_depth_luma_minus8: _,
                bit_depth_chroma_minus8: G,
                frame_rate: {fixed: L, fps: I / D, fps_den: D, fps_num: I},
                sar_ratio: {width: x, height: C},
                codec_size: {width: P, height: B},
                present_size: {width: P * U, height: B}
            }
        })(i), n = (e => {
            let t = yr(e), i = new dr(t),
                r = (i.readByte(), i.readByte(), i.readUEG(), i.readUEG(), i.readBool(), i.readBool(), i.readBits(3), i.readBool(), i.readBool(), i.readUEG(), i.readUEG(), i.readSEG(), i.readBool(), i.readBool(), i.readBool() && i.readUEG(), i.readSEG(), i.readSEG(), i.readBool(), i.readBool(), i.readBool(), i.readBool(), i.readBool()),
                s = i.readBool(), a = 1;
            return s && r ? a = 0 : s ? a = 3 : r && (a = 2), {parallelismType: a}
        })(t), r = Object.assign(r, s, a, n);
        let o = 23 + (5 + e.byteLength) + (5 + i.byteLength) + (5 + t.byteLength), l = new Uint8Array(o);
        l[0] = 1, l[1] = (3 & r.general_profile_space) << 6 | (r.general_tier_flag ? 1 : 0) << 5 | 31 & r.general_profile_idc, l[2] = r.general_profile_compatibility_flags_1 || 0, l[3] = r.general_profile_compatibility_flags_2 || 0, l[4] = r.general_profile_compatibility_flags_3 || 0, l[5] = r.general_profile_compatibility_flags_4 || 0, l[6] = r.general_constraint_indicator_flags_1 || 0, l[7] = r.general_constraint_indicator_flags_2 || 0, l[8] = r.general_constraint_indicator_flags_3 || 0, l[9] = r.general_constraint_indicator_flags_4 || 0, l[10] = r.general_constraint_indicator_flags_5 || 0, l[11] = r.general_constraint_indicator_flags_6 || 0, l[12] = 60, l[13] = 240 | (3840 & r.min_spatial_segmentation_idc) >> 8, l[14] = 255 & r.min_spatial_segmentation_idc, l[15] = 252 | 3 & r.parallelismType, l[16] = 252 | 3 & r.chroma_format_idc, l[17] = 248 | 7 & r.bit_depth_luma_minus8, l[18] = 248 | 7 & r.bit_depth_chroma_minus8, l[19] = 0, l[20] = 0, l[21] = (3 & r.constant_frame_rate) << 6 | (7 & r.num_temporal_layers) << 3 | (r.temporal_id_nested ? 1 : 0) << 2 | 3, l[22] = 3, l[23] = 160, l[24] = 0, l[25] = 1, l[26] = (65280 & e.byteLength) >> 8, l[27] = (255 & e.byteLength) >> 0, l.set(e, 28), l[23 + (5 + e.byteLength) + 0] = 161, l[23 + (5 + e.byteLength) + 1] = 0, l[23 + (5 + e.byteLength) + 2] = 1, l[23 + (5 + e.byteLength) + 3] = (65280 & i.byteLength) >> 8, l[23 + (5 + e.byteLength) + 4] = (255 & i.byteLength) >> 0, l.set(i, 23 + (5 + e.byteLength) + 5), l[23 + (5 + e.byteLength + 5 + i.byteLength) + 0] = 162, l[23 + (5 + e.byteLength + 5 + i.byteLength) + 1] = 0, l[23 + (5 + e.byteLength + 5 + i.byteLength) + 2] = 1, l[23 + (5 + e.byteLength + 5 + i.byteLength) + 3] = (65280 & t.byteLength) >> 8, l[23 + (5 + e.byteLength + 5 + i.byteLength) + 4] = (255 & t.byteLength) >> 0, l.set(t, 23 + (5 + e.byteLength + 5 + i.byteLength) + 5);
        const d = [28, 0, 0, 0, 0], h = new Uint8Array(d.length + l.byteLength);
        return h.set(d, 0), h.set(l, d.length), h
    }

    function _r(e, t) {
        let i = [];
        i[0] = t ? 28 : 44, i[1] = 1, i[2] = 0, i[3] = 0, i[4] = 0;
        const r = new Uint8Array(i.length + e.byteLength);
        return r.set(i, 0), r.set(e, i.length), r
    }

    function wr(e) {
        return (126 & e[0]) >> 1
    }

    function Sr(e) {
        return !(32 <= e && e <= 40)
    }

    function Er(e) {
        return 16 <= e && e <= 21
    }

    class Tr extends e {
        constructor(e) {
            super(), this.TAG_NAME = "recorderCommon", this.player = e, this.fileName = "", this._isRecording = !1, this._recordingTimestamp = 0, this.recordingInterval = null, this.sps = null, this.pps = null, this.vps = null, this.codecId = null, this.mdatBytesLength = 0, this.metaInfo = {
                codecWidth: 0,
                codecHeight: 0,
                presentWidth: 0,
                presentHeight: 0,
                refSampleDuration: 0,
                timescale: 1e3,
                avcc: null,
                videoType: ""
            }, this.audioMetaInfo = {
                timescale: 1e3,
                sampleRate: 0,
                refSampleDuration: 0,
                channelCount: 0,
                codec: "",
                originalCodec: ""
            }
        }

        destroy() {
            this._reset()
        }

        get isH264() {
            return 7 === this.codecId
        }

        get isH265() {
            return 12 === this.codecId
        }

        setFileName(e) {
            this.fileName = e
        }

        get isRecording() {
            return this._isRecording
        }

        get recording() {
            return this._isRecording
        }

        get recordTime() {
            return this._recordingTimestamp
        }

        startRecord() {
        }

        handleAddNaluTrack(e, t, i, r) {
        }

        handleAddAudioTrack(e, t) {
        }

        handleAddTrack(e) {
        }

        stopRecordAndSave() {
        }

        startRecordingInterval() {
        }

        stopRecordingInterval() {
            this.recordingInterval && clearInterval(this.recordingInterval), this.recordingInterval = null
        }

        getToTalByteLength() {
            return 0
        }

        _reset() {
            this.fileName = "", this._isRecording = !1, this._recordingTimestamp = 0, this.stopRecordingInterval(), this.sps = null, this.pps = null, this.vps = null, this.codecId = null, this.mdatBytesLength = 0
        }

        initMetaData(e, t) {
            let i;
            var r = e.slice(5);
            if (this.codecId = t, this.metaInfo.avcc = r, 7 === t) i = cr(r); else if (12 === t) {
                i = function (e) {
                    var t = 23, i = e[23];
                    if (32 != (63 & i)) return console.warn("parseHEVCDecoderVPSAndSPSAndPPS and vpsTag is " + i), {};
                    t += 2, ++t;
                    var i = e[27] | e[26] << 8, r = (t += 2, e.slice(28, 28 + i)), s = e[t += i];
                    if (33 != (63 & s)) return console.warn("parseHEVCDecoderVPSAndSPSAndPPS and sps tag is " + s), {};
                    t += 2;
                    var s = e[1 + ++t] | e[t] << 8, a = e.slice(t += 2, t + s), n = e[t += s];
                    if (34 != (63 & n)) return console.warn("parseHEVCDecoderVPSAndSPSAndPPS and pps tag is " + n), {};
                    t += 2;
                    n = e[1 + ++t] | e[t] << 8;
                    const o = e.slice(t += 2, t + n),
                        l = new Uint8Array([s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s]),
                        d = new Uint8Array([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n]),
                        h = new Uint8Array([i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i]),
                        c = new Uint8Array(4 + s), u = (c.set(l, 0), c.set(a, 4), new Uint8Array(4 + n)),
                        p = (u.set(d, 0), u.set(o, 4), new Uint8Array(4 + i));
                    return p.set(h, 0), p.set(r, 4), {sps: c, pps: u, vps: p}
                }(r);
                const t = br(e);
                i = Object.assign(i, t)
            }
            i && (i.vps && (this.vps = i.vps), i.pps && (this.pps = i.pps), i.sps && (this.sps = i.sps), i.presentWidth && (this.metaInfo.presentWidth = i.presentWidth), i.presentHeight && (this.metaInfo.presentHeight = i.presentHeight), i.codecWidth && (this.metaInfo.codecWidth = i.codecWidth), i.codecHeight && (this.metaInfo.codecHeight = i.codecHeight), i.timescale && (this.metaInfo.timescale = i.timescale), i.refSampleDuration && (this.metaInfo.refSampleDuration = i.refSampleDuration), i.videoType && (this.metaInfo.videoType = i.videoType))
        }

        initAudioMetaData(e) {
            e = function (t) {
                let i = new Uint8Array(t), r = null, s = 0, a, n, o = null;
                if (s = a = i[0] >>> 3, (n = (7 & i[0]) << 1 | i[1] >>> 7) < 0 || n >= bt.length) console.error("Flv: AAC invalid sampling frequency index!"); else {
                    var t = bt[n], l = (120 & i[1]) >>> 3;
                    if (!(l < 0 || 8 <= l)) {
                        5 === s && (o = (7 & i[1]) << 1 | i[2] >>> 7, i[2]);
                        let e = self.navigator.userAgent.toLowerCase();
                        return -1 !== e.indexOf("firefox") ? o = 6 <= n ? (s = 5, r = new Array(4), n - 3) : (s = 2, r = new Array(2), n) : -1 !== e.indexOf("android") ? (s = 2, r = new Array(2), o = n) : (s = 5, o = n, r = new Array(4), 6 <= n ? o = n - 3 : 1 == l && (s = 2, r = new Array(2), o = n)), r[0] = s << 3, r[0] |= (15 & n) >>> 1, r[1] = (15 & n) << 7, r[1] |= (15 & l) << 3, 5 === s && (r[1] |= (15 & o) >>> 1, r[2] = (1 & o) << 7, r[2] |= 8, r[3] = 0), {
                            config: r,
                            sampleRate: t,
                            channelCount: l,
                            codec: "mp4a.40." + s,
                            originalCodec: "mp4a.40." + a
                        }
                    }
                    console.log("Flv: AAC invalid channel configuration")
                }
            }(e.slice(2));
            e && (e.channelCount && (this.audioMetaInfo.channelCount = e.channelCount), e.codec && (this.audioMetaInfo.codec = e.codec), e.originalCodec && (this.audioMetaInfo.originalCodec = e.originalCodec), e.config && (this.audioMetaInfo.config = e.config), e.sampleRate && (this.audioMetaInfo.sampleRate = e.sampleRate), this.audioMetaInfo.sampleRate && this.audioMetaInfo.timescale && (this.audioMetaInfo.refSampleDuration = 1024 / this.audioMetaInfo.sampleRate * this.audioMetaInfo.timescale))
        }
    }

    class kr extends Tr {
        constructor(e) {
            super(e), this.totalByteLength = 0, this._startRecordingTimestamp = null, e.debug.log("RecorderRTC", "init")
        }

        _reset() {
            super._reset(), this.totalByteLength = 0, this._startRecordingTimestamp = null, this.recorder && (this.recorder.destroy(), this.recorder = null)
        }

        destroy() {
            super.destroy(), this._reset(), this.player.debug.log("RecorderRTC", "destroy")
        }

        getSeekableBlob(t) {
            const s = new EBML.Reader, a = new EBML.Decoder, n = EBML.tools, i = new FileReader;
            return new Promise((r, e) => {
                i.onload = function (e) {
                    a.decode(this.result).forEach(function (e) {
                        s.read(e)
                    }), s.stop();
                    var t = n.makeMetadataSeekable(s.metadatas, s.duration, s.cues),
                        i = this.result.slice(s.metadataSize), t = new Blob([t, i], {type: "video/webm"});
                    r(t)
                }, i.readAsArrayBuffer(t)
            })
        }

        startRecord() {
            const t = this.player.debug, i = {
                type: "video", mimeType: "video/webm;codecs=h264", timeSlice: 1e3, onTimeStamp: e => {
                    t.log("RecorderRTC", "record timestamp :" + e), null === this._startRecordingTimestamp && (this._startRecordingTimestamp = e), this._recordingTimestamp = (e - this._startRecordingTimestamp) / 1e3
                }, ondataavailable: e => {
                    this.totalByteLength += e.size, t.log("RecorderRTC", "ondataavailable", e.size)
                }, disableLogs: !this.player._opt.debug
            };
            try {
                let e = null;
                if (this.player.getRenderType() === Y ? e = this.player.video.$videoElement.captureStream(25) : this.player.video.mediaStream ? e = this.player.video.mediaStream : this.player.isOldHls() || this.player._opt.useMSE || this.player._opt.useWCS ? e = this.player.video.$videoElement.captureStream(25) : this.player.isWebrtcH264() && (e = this.player.webrtc.videoStream), e) {
                    if (this.player.audio && this.player.audio.mediaStreamAudioDestinationNode && this.player.audio.mediaStreamAudioDestinationNode.stream && !this.player.audio.isStateSuspended() && this.player.audio.hasAudio && this.player._opt.hasAudio) {
                        const t = this.player.audio.mediaStreamAudioDestinationNode.stream;
                        if (0 < t.getAudioTracks().length) {
                            const i = t.getAudioTracks()[0];
                            i && i.enabled && e.addTrack(i)
                        }
                    }
                    this.recorder = lr(e, i)
                } else t.error("RecorderRTC", "startRecord error and can not create stream"), this.emit(w.recordCreateError)
            } catch (i) {
                t.error("RecorderRTC", "startRecord error", i), this.emit(w.recordCreateError)
            }
            this.recorder && (this._isRecording = !0, this.player.emit(w.recording, !0), this.recorder.startRecording(), t.log("RecorderRTC", "start recording"), this.player.emit(w.recordStart), this.startRecordingInterval())
        }

        startRecordingInterval() {
            this.stopRecordingInterval(), this.recordingInterval = window.setInterval(() => {
                this.player.emit(w.recordingTimestamp, this._recordingTimestamp)
            }, 1e3)
        }

        stopRecordAndSave() {
            let i = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : Ae,
                r = 1 < arguments.length ? arguments[1] : void 0;
            return new Promise((t, e) => {
                this.recorder && this._isRecording || e("recorder is not ready"), r && this.setFileName(r), this.recorder.stopRecording(() => {
                    this.player.debug.log("RecorderRTC", "stop recording");
                    var e = (this.fileName || p()) + "." + z;
                    if (this.recorder.getBlob(), i === be) {
                        const i = this.recorder.getBlob();
                        t(i), this.player.emit(w.recordBlob, i)
                    } else t(), this.recorder.save(e);
                    this.player.emit(w.recordEnd), this._reset(), this.player.emit(w.recording, !1)
                })
            })
        }

        getToTalByteLength() {
            return this.totalByteLength
        }

        getTotalDuration() {
            return this.recordTime
        }

        getType() {
            return z
        }

        initMetaData() {
        }
    }

    class f {
        static init() {
            for (var e in f.types = {
                avc1: [],
                avcC: [],
                hvc1: [],
                hvcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                mvex: [],
                mvhd: [],
                sdtp: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
                smhd: [],
                ".mp3": [],
                free: [],
                edts: [],
                elst: [],
                stss: []
            }, f.types) f.types.hasOwnProperty(e) && (f.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
            let t = f.constants = {};
            t.FTYP = new Uint8Array([105, 115, 111, 109, 0, 0, 2, 0, 105, 115, 111, 109, 105, 115, 111, 50, 97, 118, 99, 49, 109, 112, 52, 49, 0, 0, 0, 0]), t.STSD_PREFIX = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), t.STTS = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t.STSC = t.STCO = t.STTS, t.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), t.HDLR_VIDEO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), t.HDLR_AUDIO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), t.DREF = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), t.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
        }

        static box(e) {
            let t = 8, i = null, r = Array.prototype.slice.call(arguments, 1), s = r.length;
            for (let e = 0; e < s; e++) t += r[e].byteLength;
            (i = new Uint8Array(t))[0] = t >>> 24 & 255, i[1] = t >>> 16 & 255, i[2] = t >>> 8 & 255, i[3] = 255 & t, i.set(e, 4);
            let a = 8;
            for (let e = 0; e < s; e++) i.set(r[e], a), a += r[e].byteLength;
            return i
        }

        static generateInitSegment(e, t, i) {
            let r = f.box(f.types.ftyp, f.constants.FTYP), s = f.box(f.types.free), a = 8, n = new Uint8Array;
            i + a >= Math.pow(2, 32) - 1 ? (a = 16, (n = new Uint8Array(i + a)).set(new Uint8Array([0, 0, 0, 1]), 0), n.set(f.types.mdat, 4), n.set(new Uint8Array([i + 8 >>> 56 & 255, i + 8 >>> 48 & 255, i + 8 >>> 40 & 255, i + 8 >>> 32 & 255, i + 8 >>> 24 & 255, i + 8 >>> 16 & 255, i + 8 >>> 8 & 255, i + 8 & 255]), 8)) : ((n = new Uint8Array(i + a))[0] = i + 8 >>> 24 & 255, n[1] = i + 8 >>> 16 & 255, n[2] = i + 8 >>> 8 & 255, n[3] = i + 8 & 255, n.set(f.types.mdat, 4));
            for (let e = 0; e < t.length; e++) {
                let i = t[e];
                i.duration = i.refSampleDuration * i.sequenceNumber;
                for (let t = 0; t < i.sequenceNumber; t++) {
                    let e = i.samples[t];
                    e.chunkOffset = r.byteLength + s.byteLength + a;
                    var o = e.data;
                    n.set(o, a), a += o.byteLength
                }
            }
            let l = f.moov(e, t), d = new Uint8Array(r.byteLength + l.byteLength + n.byteLength + s.byteLength);
            return d.set(r, 0), d.set(s, r.byteLength), d.set(n, r.byteLength + s.byteLength), d.set(l, r.byteLength + n.byteLength + s.byteLength), d
        }

        static moov(e, r) {
            let t = e.timescale, i = e.duration, s = r.length, a = f.mvhd(t, i), n = new Uint8Array;
            for (let i = 0; i < s; i++) {
                let e = f.trak(r[i]), t = new Uint8Array(e.byteLength + n.byteLength);
                t.set(n, 0), t.set(e, n.byteLength), (n = new Uint8Array(t.byteLength)).set(t, 0)
            }
            return f.box(f.types.moov, a, n)
        }

        static mvhd(e, t) {
            return f.box(f.types.mvhd, new Uint8Array([0, 0, 0, 0, 206, 186, 253, 168, 206, 186, 253, 168, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3]))
        }

        static trak(e) {
            return f.box(f.types.trak, f.tkhd(e), f.mdia(e))
        }

        static tkhd(e) {
            var t = e.id, i = e.duration, r = e.presentWidth, s = e.presentHeight;
            return "video" === e.type ? f.box(f.types.tkhd, new Uint8Array([0, 0, 0, 15, 206, 186, 253, 168, 206, 186, 253, 168, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, 0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >>> 8 & 255, 255 & r, 0, 0, s >>> 8 & 255, 255 & s, 0, 0])) : "audio" === e.type ? f.box(f.types.tkhd, new Uint8Array([0, 0, 0, 15, 206, 186, 253, 168, 206, 186, 253, 168, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, 0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) : void 0
        }

        static edts(e, t) {
            return f.box(f.types.edts, f.elst(e, t))
        }

        static elst(t, i) {
            let r = 0;
            for (let e = 0; e < i; e++) "video" === t[e].type && (r += t[e].duration);
            var e = t[i].duration;
            return 0 === r && (r = t[i].refSampleDuration), f.box(f.types.elst, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, 255, 255, 255, 255, 0, 1, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, 0, 0, 0, 0, 0, 1, 0, 0]))
        }

        static mdia(e) {
            return f.box(f.types.mdia, f.mdhd(e), f.hdlr(e), f.minf(e))
        }

        static mdhd(e) {
            var t = e.timescale / e.refSampleDuration, e = t * e.duration / e.timescale;
            return f.box(f.types.mdhd, new Uint8Array([0, 0, 0, 0, 206, 186, 253, 168, 206, 186, 253, 168, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, 85, 196, 0, 0]))
        }

        static hdlr(e) {
            e = "audio" === e.type ? f.constants.HDLR_AUDIO : f.constants.HDLR_VIDEO;
            return f.box(f.types.hdlr, e)
        }

        static minf(e) {
            var t = "audio" === e.type ? f.box(f.types.smhd, f.constants.SMHD) : f.box(f.types.vmhd, f.constants.VMHD);
            return f.box(f.types.minf, t, f.dinf(), f.stbl(e))
        }

        static dinf() {
            return f.box(f.types.dinf, f.box(f.types.dref, f.constants.DREF))
        }

        static stbl(e) {
            let i = e.samples, r = [{No: 1, num: 0, sampleDelte: 1, chunkNo: 1, duration: i[0].duration}],
                s = [i[0].duration], a = i.length;
            for (let t = 0; t < a; t++) for (let e = 0; e < r.length; e++) i[t].duration === r[e].duration ? r[e].num++ : s.indexOf(i[t].duration) < 0 && (s.push(i[t].duration), r.push({
                No: 2,
                num: 0,
                sampleDelte: 1,
                chunkNo: t + 1,
                duration: i[t].duration
            }));
            return f.box(f.types.stbl, f.stsd(e), f.stts(r), f.stss(i), f.stsc(r), f.stsz(i), f.stco(r, i))
        }

        static stts(t) {
            let i = t.length, e = new Uint8Array([0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i]),
                r = e.byteLength, s = new Uint8Array(r + 8 * i);
            s.set(e, 0);
            for (let e = 0; e < i; e++) s.set(new Uint8Array([t[e].num >>> 24 & 255, t[e].num >>> 16 & 255, t[e].num >>> 8 & 255, 255 & t[e].num, t[e].sampleDelte >>> 24 & 255, t[e].sampleDelte >>> 16 & 255, t[e].sampleDelte >>> 8 & 255, 255 & t[e].sampleDelte]), r), r += 8;
            return f.box(f.types.stts, s)
        }

        static stss(t) {
            let i = [], r = t.length;
            for (let e = 0; e < r; e++) !0 === t[e].isKeyframe && i.push(e + 1);
            let s = i.length, e = new Uint8Array([0, 0, 0, 0, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s]),
                a = e.byteLength, n = new Uint8Array(a + 4 * s);
            n.set(e, 0);
            for (let e = 0; e < s; e++) n.set(new Uint8Array([i[e] >>> 24 & 255, i[e] >>> 16 & 255, i[e] >>> 8 & 255, 255 & i[e]]), a), a += 4;
            return f.box(f.types.stss, n)
        }

        static stsc(t) {
            let i = t.length, e = new Uint8Array([0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i]),
                r = e.byteLength, s = new Uint8Array(r + 12 * i);
            s.set(e, 0);
            for (let e = 0; e < i; e++) {
                var a = t[e].chunkNo, n = t[e].num, o = t[e].sampleDelte;
                s.set(new Uint8Array([a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o]), r), r += 12
            }
            return f.box(f.types.stsc, s)
        }

        static stsz(t) {
            let i = t.length,
                e = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i]),
                r = e.byteLength, s = new Uint8Array(r + 4 * i);
            s.set(e, 0);
            for (let e = 0; e < i; e++) {
                var a = t[e].data.byteLength;
                s.set(new Uint8Array([a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a]), r), r += 4
            }
            return f.box(f.types.stsz, s)
        }

        static stco(e, t) {
            t = t[0].chunkOffset;
            return f.box(f.types.stco, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t]))
        }

        static stsd(e) {
            return "audio" === e.type ? "mp3" === e.codec ? f.box(f.types.stsd, f.constants.STSD_PREFIX, f.mp3(e)) : f.box(f.types.stsd, f.constants.STSD_PREFIX, f.mp4a(e)) : "avc" === e.videoType ? f.box(f.types.stsd, f.constants.STSD_PREFIX, f.avc1(e)) : f.box(f.types.stsd, f.constants.STSD_PREFIX, f.hvc1(e))
        }

        static mp3(e) {
            var t = e.channelCount, e = e.sampleRate,
                t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t, 0, 16, 0, 0, 0, 0, e >>> 8 & 255, 255 & e, 0, 0]);
            return f.box(f.types[".mp3"], t)
        }

        static mp4a(e) {
            var t = e.channelCount, i = e.sampleRate,
                t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t, 0, 16, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, 0, 0]);
            return f.box(f.types.mp4a, t, f.esds(e))
        }

        static esds(e) {
            var e = e.config || [], t = e.length,
                t = new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e).concat([6, 1, 2]));
            return f.box(f.types.esds, t)
        }

        static avc1(e) {
            var t = e.avcc, i = e.codecWidth, e = e.codecHeight,
                i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, e >>> 8 & 255, 255 & e, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 13, 106, 101, 115, 115, 105, 98, 117, 99, 97, 45, 112, 114, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 255, 255]);
            return f.box(f.types.avc1, i, f.box(f.types.avcC, t))
        }

        static hvc1(e) {
            var t = e.avcc, i = e.codecWidth, e = e.codecHeight,
                i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, e >>> 8 & 255, 255 & e, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 13, 106, 101, 115, 115, 105, 98, 117, 99, 97, 45, 112, 114, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 255, 255]);
            return f.box(f.types.hvc1, i, f.box(f.types.hvcC, t))
        }

        static mvex(e) {
            return f.box(f.types.mvex, f.trex(e))
        }

        static trex(e) {
            e = e.id, e = new Uint8Array([0, 0, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]);
            return f.box(f.types.trex, e)
        }

        static moof(e, t) {
            return f.box(f.types.moof, f.mfhd(e.sequenceNumber), f.traf(e, t))
        }

        static mfhd(e) {
            e = new Uint8Array([0, 0, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e]);
            return f.box(f.types.mfhd, e)
        }

        static traf(e, t) {
            var i = e.id,
                i = f.box(f.types.tfhd, new Uint8Array([0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i])),
                t = f.box(f.types.tfdt, new Uint8Array([0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t])),
                r = f.sdtp(e), e = f.trun(e, r.byteLength + 16 + 16 + 8 + 16 + 8 + 8);
            return f.box(f.types.traf, i, t, e, r)
        }

        static sdtp(e) {
            let t = e.samples || [], i = t.length, r = new Uint8Array(4 + i);
            for (let e = 0; e < i; e++) {
                var s = t[e].flags;
                r[e + 4] = s.isLeading << 6 | s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy
            }
            return f.box(f.types.sdtp, r)
        }

        static trun(e, t) {
            let i = e.samples || [], r = i.length, s = 12 + 16 * r, a = new Uint8Array(s);
            t += 8 + s, a.set([0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0);
            for (let e = 0; e < r; e++) {
                var n = i[e].duration, o = i[e].size, l = i[e].flags, d = i[e].cts;
                a.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o, l.isLeading << 2 | l.dependsOn, l.isDependedOn << 6 | l.hasRedundancy << 4 | l.isNonSync, 0, 0, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d], 12 + 16 * e)
            }
            return f.box(f.types.trun, a)
        }

        static mdat(e) {
            return f.box(f.types.mdat, e)
        }
    }

    f.init();

    class xr extends Tr {
        constructor(e) {
            super(e), this.TAG_NAME = "recorderMP4", this._reset(), e.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this._reset(), this.player.debug.log(this.TAG_NAME, "destroy")
        }

        _reset() {
            super._reset(), this.totalDuration = 0, this.totalAudioDuration = 0, this.totalByteLength = 0, this.totalAudioByteLength = 0, this.bufferList = [], this.audioBufferList = [], this.cacheTrack = {}, this.audioCacheTrack = {}, this.sequenceNumber = 0, this.audioSequenceNumber = 0
        }

        startRecord() {
            const e = this.player.debug;
            this._isRecording = !0, this.player.emit(w.recording, !0), e.log(this.TAG_NAME, "start recording"), this.player.emit(w.recordStart), this.startRecordingInterval()
        }

        startRecordingInterval() {
            this.stopRecordingInterval(), this.recordingInterval = window.setInterval(() => {
                this.player.emit(w.recordingTimestamp, this.getTotalDuration())
            }, 1e3)
        }

        formatFmp4Track(e, t, i, r) {
            return {
                id: 1,
                sequenceNumber: ++this.sequenceNumber,
                size: e.byteLength,
                dts: i,
                cts: r,
                isKeyframe: t,
                data: e,
                duration: 0,
                flags: {
                    isLeading: 0,
                    dependsOn: t ? 2 : 1,
                    isDependedOn: t ? 1 : 0,
                    hasRedundancy: 0,
                    isNonSync: t ? 0 : 1
                }
            }
        }

        formatAudioFmp4Track(e, t) {
            return {
                id: 2,
                sequenceNumber: ++this.audioSequenceNumber,
                size: e.byteLength,
                dts: t,
                pts: t,
                cts: 0,
                data: new Uint8Array(e),
                duration: 0,
                originalDts: t,
                flags: {isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0}
            }
        }

        handleAddNaluTrack(e, t, i, r) {
            this.cacheTrack.id && i >= this.cacheTrack.dts ? (this.cacheTrack.duration = i - this.cacheTrack.dts, this.handleAddFmp4Track(this.cacheTrack)) : this.cacheTrack = {}, this.cacheTrack = this.formatFmp4Track(e, t, i, r)
        }

        handleAddAudioTrack(e, t) {
            this.audioCacheTrack.id && t >= this.audioCacheTrack.dts ? (this.audioCacheTrack.duration = t - this.audioCacheTrack.dts, this.handleAddFmp4AudioTrack(this.audioCacheTrack)) : this.audioCacheTrack = {}, this.audioCacheTrack = this.formatAudioFmp4Track(e, t)
        }

        handleAddFmp4Track(e) {
            if (this.isRecording) if (null !== this.sps && null !== this.pps || !this.isH264) if (null !== this.sps && null !== this.pps && null !== this.vps || !this.isH265) {
                const i = Object.assign({}, e);
                i.pts = i.dts + i.cts;
                var t = i.data;
                if (i.isKeyframe) if (this.isH264) {
                    const e = new Uint8Array(this.sps.byteLength + this.pps.byteLength),
                        r = (e.set(this.sps, 0), e.set(this.pps, this.sps.byteLength), new Uint8Array(e.byteLength + t.byteLength));
                    r.set(e, 0), r.set(t, e.byteLength), i.data = r
                } else if (this.isH265) {
                    const e = new Uint8Array(this.sps.byteLength + this.pps.byteLength + this.vps.byteLength),
                        s = (e.set(this.vps, 0), e.set(this.sps, this.vps.byteLength), e.set(this.pps, this.vps.byteLength + this.sps.byteLength), new Uint8Array(e.byteLength + t.byteLength));
                    s.set(e, 0), s.set(t, e.byteLength), i.data = s
                }
                i.size = i.data.byteLength, this.totalDuration += i.duration, this.totalByteLength += i.data.byteLength, i.duration = 0, i.originalDts = i.dts, delete i.id, delete i.sequenceNumber, this.bufferList.push(i)
            } else this.player.debug.error(this.TAG_NAME, "handleAddFmp4Track, is h265 and this.sps or this.pps or this.vps is null "); else this.player.debug.error(this.TAG_NAME, "handleAddFmp4Track, is h264 and this.sps or this.pps is null "); else this.player.debug.error(this.TAG_NAME, "handleAddFmp4Track, isRecording is false ")
        }

        handleAddFmp4AudioTrack(e) {
            const t = Object.assign({}, e);
            t.pts = t.dts + t.cts, t.size = t.data.byteLength, this.totalAudioDuration += t.duration, this.totalAudioByteLength += t.data.byteLength, t.duration = 0, t.originalDts = t.dts, delete t.id, delete t.sequenceNumber, this.audioBufferList.push(t)
        }

        getTotalDuration() {
            return this.totalDuration / 1e3
        }

        getType() {
            return u
        }

        getToTalByteLength() {
            return this.totalByteLength + this.totalAudioByteLength
        }

        stopRecordAndSave() {
            let a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : Ae,
                n = 1 < arguments.length ? arguments[1] : void 0;
            return new Promise((e, t) => {
                if (!this.isRecording) return this.player.debug.error(this.TAG_NAME, "stop recording fail, isRecording is false "), t("stop recording fail, isRecording is false ");
                if (0 === this.bufferList.length) return this.player.debug.error(this.TAG_NAME, "stop recording fail, this.bufferList.length is 0 "), t("stop recording fail, this.bufferList.length is 0 ");
                n && this.setFileName(n);
                const i = {
                    id: 1,
                    type: "video",
                    sps: this.sps,
                    pps: this.pps,
                    samples: this.bufferList,
                    sequenceNumber: this.bufferList.length,
                    length: 0,
                    addSampleNum: 1,
                    duration: 0, ...this.metaInfo
                }, r = {
                    id: 2,
                    type: "audio",
                    sequenceNumber: this.audioBufferList.length,
                    samples: this.audioBufferList, ...this.audioMetaInfo
                }, s = [i];
                0 < r.samples.length && s.push(r), this.player.debug.log(this.TAG_NAME, "trackList length is " + s.length);
                t = f.generateInitSegment({
                    timescale: 1e3,
                    duration: this.totalDuration
                }, s, this.totalByteLength + this.totalAudioByteLength), this.player.debug.log(this.TAG_NAME, "stop recording"), t = new Blob([t], {type: "application/octet-stream"});
                a === be ? (e(t), this.player.emit(w.recordBlob, t)) : (e(), Gt((this.fileName || p()) + "." + u, t)), this._reset(), this.player.emit(w.recording, !1)
            })
        }
    }

    class Cr extends Tr {
        constructor(e) {
            super(e), this.TAG_NAME = "FlvRecorderLoader", this.player = e, this._init(), this.player.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this._init(), this.player.debug.log(this.TAG_NAME, "destroy")
        }

        _init() {
            this.hasAudio = !1, this.hasVideo = !1, this.startTime = null, this.currentTime = 0, this.prevTimestamp = 0, this.totalByteLength = 0, this.totalDuration = 0, this.flvMetaData = null, this.aacSequenceHeader = null, this.videoSequenceHeader = null, this.bufferList = []
        }

        _reset() {
            super._reset(), this._init()
        }

        startRecord() {
            const e = this.player.debug;
            this._isRecording = !0, this.player.emit(w.recording, !0), e.log(this.TAG_NAME, "start recording"), this.player.emit(w.recordStart), this.startRecordingInterval()
        }

        startRecordingInterval() {
            this.stopRecordingInterval(), this.recordingInterval = window.setInterval(() => {
                this.player.emit(w.recordingTimestamp, this.getTotalDuration())
            }, 1e3)
        }

        addMetaData(e) {
            this.flvMetaData = e
        }

        addAACSequenceHeader(e) {
            this.aacSequenceHeader = e
        }

        addVideoSequenceHeader(e) {
            this.videoSequenceHeader = e
        }

        addVideo(e, t) {
            this._setStartTime(t);
            t = this._getBufferTs(t);
            this.hasVideo = !0, this._createBufferItem(e, 9, t)
        }

        addAudio(e, t) {
            this._setStartTime(t);
            t = this._getBufferTs(t);
            this.hasAudio = !0, this._createBufferItem(e, 8, t)
        }

        _setStartTime(e) {
            null === this.startTime && this._isRecording && (this.startTime = e, this.player.debug.log(this.TAG_NAME, "_setStartTime is " + e))
        }

        _getBufferTs(e) {
            e > this.currentTime && (this.currentTime = e);
            let t = 0;
            return (t = this.startTime && e >= this.startTime ? e - this.startTime : t) > this.prevTimestamp ? this.prevTimestamp = t : t = this.prevTimestamp, t
        }

        _createBufferItem(e, t, i) {
            e = this._createFlvPacket(e, t, i), t = this._createFlvTag(e);
            this.totalByteLength += t.byteLength, this.bufferList.push(t)
        }

        _createFlvTag(e) {
            let t = 11 + e.header.length, i = new Uint8Array(t + 4), r = (i[0] = e.header.type, new DataView(i.buffer));
            return i[1] = e.header.length >> 16 & 255, i[2] = e.header.length >> 8 & 255, i[3] = 255 & e.header.length, i[4] = e.header.timestamp >> 16 & 255, i[5] = e.header.timestamp >> 8 & 255, i[6] = 255 & e.header.timestamp, i[7] = e.header.timestamp >> 24 & 255, i[8] = 0, i[9] = 0, i[10] = 0, r.setUint32(t, t), i.set(e.payload.subarray(0, e.header.length), 11), i
        }

        _createFlvPacket() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null,
                t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
            return {
                header: {
                    length: e ? e.length : 0,
                    timestamp: 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                    type: t
                }, payload: e
            }
        }

        stopRecordAndSave() {
            let s = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : Ae,
                a = 1 < arguments.length ? arguments[1] : void 0;
            return new Promise((e, t) => {
                if (!this.isRecording) return this.player.debug.error(this.TAG_NAME, "stop recording fail, isRecording is false "), t("stop recording fail, isRecording is false ");
                if (0 === this.bufferList.length) return this.player.debug.error(this.TAG_NAME, "stop recording fail, this.bufferList.length is 0 "), t("stop recording fail, this.bufferList.length is 0 ");
                a && this.setFileName(a);
                const i = new Uint8Array([70, 76, 86, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0]);
                this.hasVideo && (i[4] |= 1), this.hasAudio && (i[4] |= 4);
                let r = [i];
                if (this.flvMetaData) {
                    const s = this._createFlvPacket(this.flvMetaData, 18), a = this._createFlvTag(s);
                    r.push(a)
                }
                if (this.videoSequenceHeader) {
                    const s = this._createFlvPacket(this.videoSequenceHeader, 9), a = this._createFlvTag(s);
                    r.push(a)
                }
                if (this.aacSequenceHeader) {
                    const s = this._createFlvPacket(this.aacSequenceHeader, 8), a = this._createFlvTag(s);
                    r.push(a)
                }
                t = function (e) {
                    const r = e[0].constructor;
                    return e.reduce((e, t) => {
                        const i = new r((0 | e.byteLength) + (0 | t.byteLength));
                        return i.set(e, 0), i.set(t, 0 | e.byteLength), i
                    }, new r)
                }(r.concat(this.bufferList)), this.player.debug.log(this.TAG_NAME, "stop recording"), t = new Blob([t], {type: "application/octet-stream"});
                s === be ? (e(t), this.player.emit(w.recordBlob, t)) : (e(), Gt((this.fileName || p()) + "." + G, t)), this._reset(), this.player.emit(w.recording, !1)
            })
        }

        getTotalDuration() {
            let e = 0;
            return null !== this.startTime && null !== this.currentTime && (e = this.currentTime - this.startTime), Math.round(e / 1e3)
        }

        getType() {
            return G
        }

        getToTalByteLength() {
            return this.totalByteLength
        }
    }

    class Lr {
        constructor(e) {
            return new (Lr.getLoaderFactory(e._opt))(e)
        }

        static getLoaderFactory(e) {
            if (e.recordType === u) {
                if (e.useWasm || e.useMSE || e.useWCS) return xr
            } else if (e.recordType === G) return Cr;
            return kr
        }
    }

    function Dr(e, t, i) {
        var r = e;
        if (t + i < r.length) {
            for (; i--;) if (128 != (192 & r[++t])) return;
            return 1
        }
    }

    function Ir(e) {
        let t = [], i = e, r = 0, s = e.length;
        for (; r < s;) if (i[r] < 128) t.push(String.fromCharCode(i[r])), ++r; else {
            if (!(i[r] < 192)) if (i[r] < 224) {
                if (Dr(i, r, 1)) {
                    var a = (31 & i[r]) << 6 | 63 & i[r + 1];
                    if (128 <= a) {
                        t.push(String.fromCharCode(65535 & a)), r += 2;
                        continue
                    }
                }
            } else if (i[r] < 240) {
                if (Dr(i, r, 2)) {
                    a = (15 & i[r]) << 12 | (63 & i[r + 1]) << 6 | 63 & i[r + 2];
                    if (2048 <= a && 55296 != (63488 & a)) {
                        t.push(String.fromCharCode(65535 & a)), r += 3;
                        continue
                    }
                }
            } else if (i[r] < 248 && Dr(i, r, 3)) {
                let e = (7 & i[r]) << 18 | (63 & i[r + 1]) << 12 | (63 & i[r + 2]) << 6 | 63 & i[r + 3];
                if (65536 < e && e < 1114112) {
                    e -= 65536, t.push(String.fromCharCode(e >>> 10 | 55296)), t.push(String.fromCharCode(1023 & e | 56320)), r += 4;
                    continue
                }
            }
            t.push(String.fromCharCode(65533)), ++r
        }
        return t.join("")
    }

    us = new ArrayBuffer(2), new DataView(us).setInt16(0, 256, !0);
    let Rr = 256 === new Int16Array(us)[0];

    class m {
        static parseScriptData(e, t, i) {
            let r = {};
            try {
                var s = m.parseValue(e, t, i), a = m.parseValue(e, t + s.size, i - s.size);
                r[s.data] = a.data
            } catch (e) {
                console.error("AMF", e.toString())
            }
            return r
        }

        static parseObject(e, t, i) {
            var r = m.parseString(e, t, i), e = m.parseValue(e, t + r.size, i - r.size), t = e.objectEnd;
            return {data: {name: r.data, value: e.data}, size: r.size + e.size, objectEnd: t}
        }

        static parseVariable(e, t, i) {
            return m.parseObject(e, t, i)
        }

        static parseString(e, t, i) {
            i = new DataView(e, t, i).getUint16(0, !Rr);
            return {data: 0 < i ? Ir(new Uint8Array(e, t + 2, i)) : "", size: 2 + i}
        }

        static parseLongString(e, t, i) {
            i = new DataView(e, t, i).getUint32(0, !Rr);
            return {data: 0 < i ? Ir(new Uint8Array(e, t + 4, i)) : "", size: 4 + i}
        }

        static parseDate(e, t, i) {
            let r = new DataView(e, t, i), s = r.getFloat64(0, !Rr);
            return s += 60 * r.getInt16(8, !Rr) * 1e3, {data: new Date(s), size: 10}
        }

        static parseValue(t, i, r) {
            let s, a = new DataView(t, i, r), n = 1, e = a.getUint8(0), o = !1;
            try {
                switch (e) {
                    case 0:
                        s = a.getFloat64(1, !Rr), n += 8;
                        break;
                    case 1:
                        s = !!a.getUint8(1), n += 1;
                        break;
                    case 2:
                        var l = m.parseString(t, i + 1, r - 1);
                        s = l.data, n += l.size;
                        break;
                    case 3: {
                        s = {};
                        let e = 0;
                        for (9 == (16777215 & a.getUint32(r - 4, !Rr)) && (e = 3); n < r - 4;) {
                            var d = m.parseObject(t, i + n, r - n - e);
                            if (d.objectEnd) break;
                            s[d.data.name] = d.data.value, n += d.size
                        }
                        n <= r - 3 && 9 == (16777215 & a.getUint32(n - 1, !Rr)) && (n += 3);
                        break
                    }
                    case 8: {
                        s = {}, n += 4;
                        let e = 0;
                        for (9 == (16777215 & a.getUint32(r - 4, !Rr)) && (e = 3); n < r - 8;) {
                            var h = m.parseVariable(t, i + n, r - n - e);
                            if (h.objectEnd) break;
                            s[h.data.name] = h.data.value, n += h.size
                        }
                        n <= r - 3 && 9 == (16777215 & a.getUint32(n - 1, !Rr)) && (n += 3);
                        break
                    }
                    case 9:
                        s = void 0, n = 1, o = !0;
                        break;
                    case 10:
                        s = [];
                        var c = a.getUint32(1, !Rr);
                        n += 4;
                        for (let e = 0; e < c; e++) {
                            var u = m.parseValue(t, i + n, r - n);
                            s.push(u.data), n += u.size
                        }
                        break;
                    case 11:
                        var p = m.parseDate(t, i + 1, r - 1);
                        s = p.data, n += p.size;
                        break;
                    case 12:
                        var f = m.parseString(t, i + 1, r - 1);
                        s = f.data, n += f.size;
                        break;
                    default:
                        n = r, console.warn("AMF", "Unsupported AMF value type " + e)
                }
            } catch (t) {
                console.error("AMF", t.toString())
            }
            return {data: s, size: n, objectEnd: o}
        }
    }

    function Pr(e) {
        return m.parseScriptData(e.buffer, e.byteOffset, e.byteLength)
    }

    class Br {
        constructor(e) {
            this.player = e, this.destroyResolve = null, this.workerClearTimeout = null, this.workerUrl = null;
            let t = e._opt.decoder, i = !1;
            if (0 === (t = C(this.player._opt.useWasm) ? this.player._opt.demuxUseWorker ? e._opt.decoderHard : e._opt.decoderAudio : t).indexOf("http") && this.player._opt.isDecoderUseCDN) {
                const e = new Blob([`importScripts("${t}")`], {type: "application/javascript"});
                t = window.URL.createObjectURL(e), i = !0, this.workerUrl = t, this.workerClearTimeout = setTimeout(() => {
                    window.URL.revokeObjectURL(this.workerUrl), this.workerUrl = null, this.workerClearTimeout = null
                }, re)
            }
            this.decoderWorker = new Worker(t), this._initDecoderWorker(), e.debug.log("decoderWorker", "init and decoder url is " + (i ? "" : t)), e.on(w.visibilityChange, () => {
                this.updateWorkConfig({key: "visibility", value: e.visibility})
            })
        }

        destroy() {
            return new Promise((e, t) => {
                this.player.loaded ? (this.player.debug.log("decoderWorker", "has loaded and post message to destroy"), this.decoderWorker ? (this.decoderWorker.postMessage({cmd: "close"}), this.destroyResolve = e) : (this.player.debug.warn("decoderWorker", "has loaded but decoderWorker is null and destroy directly"), this._destroy(), setTimeout(() => {
                    e()
                }, 0))) : (this.player.debug.log("decoderWorker", "has not loaded and destroy directly"), this._destroy(), setTimeout(() => {
                    e()
                }, 0))
            })
        }

        _destroy() {
            this.workerUrl && (window.URL.revokeObjectURL(this.workerUrl), this.workerUrl = null), this.workerClearTimeout && (clearTimeout(this.workerClearTimeout), this.workerClearTimeout = null), this.decoderWorker && (this.decoderWorker.terminate(), this.decoderWorker = null), this.player.debug.log("decoderWorker", "destroy"), this.destroyResolve && (this.destroyResolve(), this.destroyResolve = null)
        }

        _initDecoderWorker() {
            const {debug: s, events: {}} = this.player;
            this.decoderWorker.onerror = e => {
                this.player.debug.error("decoderWorker", "onerror", e), this.player.emitError(S.decoderWorkerInitError, e)
            }, this.decoderWorker.onmessageerror = e => {
                this.player.debug.error("decoderWorker", "onmessageerror", e)
            }, this.decoderWorker.onmessage = e => {
                const t = e.data;
                switch (t.cmd) {
                    case ne:
                        s.log("decoderWorker", "onmessage:", ne), this.decoderWorker && this._initWork(), this.player.loaded || this.player.emit(w.load), this.player.emit(w.decoderWorkerInit);
                        break;
                    case he:
                        s.log("decoderWorker", "onmessage:", he, t.code), this.player._times.decodeStart || (this.player._times.decodeStart = p()), this.player.video.updateVideoInfo({encTypeCode: t.code});
                        break;
                    case ce:
                        s.log("decoderWorker", "onmessage:", ce, t.codecId), this.player.recorder && this.player.recorder.initMetaData(t.buffer, t.codecId);
                        break;
                    case de:
                        s.log("decoderWorker", "onmessage:", de, t.code), this.player.audio && this.player.audio.updateAudioInfo({encTypeCode: t.code});
                        break;
                    case oe:
                        if (s.log("decoderWorker", "onmessage:", oe, `width:${t.w},height:` + t.h), this.player.video.updateVideoInfo({
                            width: t.w,
                            height: t.h
                        }), !this.player._opt.openWebglAlignment && t.w / 2 % 4 != 0 && this.player.getRenderType() === Y) return void this.player.emitError(S.webglAlignmentError);
                        this.player.video.initCanvasViewSize(), this.player._opt.playType === A && (this.player.video.initFps(), this.player.video.initVideoDelay());
                        break;
                    case le:
                        if (s.log("decoderWorker", "onmessage:", le, `channels:${t.channels},sampleRate:` + t.sampleRate), 2 < t.channels) return void this.player.emitError(S.audioChannelError, `audio channel is ${t.channels}, max is 2`);
                        this.player.audio && (this.player.audio.updateAudioInfo(t), this.player._opt.playType === n ? this.player.audio.initScriptNode() : this.player._opt.playType === A && this.player.audio.initScriptNodeDelay());
                        break;
                    case"render":
                        if (!this.player.video) return void s.warn("decoderWorker", "onmessage render but video is null");
                        if (this.player.isPlayer()) {
                            if (C(this.player.video.getHasInit())) return void s.warn("decoderWorker", "onmessage render but video has not init");
                            this.player.video.render(t), this.player.handleRender(), this.player.emit(w.timeUpdate, t.ts), this.player.updateStats({
                                dfps: !0,
                                buf: t.delay
                            }), this.player._times.videoStart || (this.player._times.videoStart = p(), this.player.handlePlayToRenderTimes())
                        } else this.player.isPlayback() && (this.player.updateStats({dfps: !0}), C(this.player.playbackPause) ? (this.player.playback.isUseLocalCalculateTime && this.player.playback.increaseLocalTimestamp(), this.player.playback.isUseFpsRender ? this.player.video.pushData(t) : this.player.video.render$2(t)) : !this.player.playback.isPlaybackPauseClearCache && this.player.playback.isCacheBeforeDecodeForFpsRender && this.player.playback.isUseFpsRender && this.player.video.pushData(t));
                        break;
                    case"videoNalu":
                        this.player.recorder && this.player.recorder.isRecording && this.player._opt.recordType === u && this.player.recorder.handleAddNaluTrack(t.buffer, t.isIFrame, t.ts, t.cts);
                        break;
                    case"videoPayload":
                        const {webcodecsDecoder: e, mseDecoder: r} = this.player;
                        this.player.updateStats({buf: t.delay});
                        var i = new Uint8Array(t.payload);
                        this.player._opt.useWCS && !this.player._opt.useOffscreen ? e.decodeVideo(i, t.ts, t.isIFrame, t.cts) : this.player._opt.useMSE && r.decodeVideo(i, t.ts, t.isIFrame, t.cts);
                        break;
                    case"playAudio":
                        if (!this.player.audio) return void s.warn("decoderWorker", "onmessage playAudio but audio is null");
                        (this.player.playing && this.player.audio || !this.player.video) && (this.player._opt.hasVideo || this.player.handleRender(), (this.player._opt.playType === n || this.player._opt.playType === A && (C(this.player.playbackPause) || !this.player.playback.isPlaybackPauseClearCache && this.player.playback.isCacheBeforeDecodeForFpsRender && this.player.playback.isUseFpsRender)) && this.player.audio.play(t.buffer, t.ts));
                        break;
                    case"workerFetch":
                        if (t.type === w.streamSuccess) this.player.stream ? this.player.stream.emit(w.streamSuccess) : s.warn("decoderWorker", "onmessage and workerFetch response stream success but stream is null"); else if (t.type === w.streamRate) this.player.emit(w.kBps, (t.value / 1024).toFixed(2)); else if (t.type === w.streamEnd) this.player ? (t.value === O && this.player.emit(w.websocketClose), this.player.stream ? this.player.stream.emit(w.streamEnd) : s && s.warn("decoderWorker", "onmessage and workerFetch response stream end but player.stream is null")) : s && s.warn("decoderWorker", "onmessage and workerFetch response stream end but player is null"); else if (t.type === S.websocketError) this.player && this.player.stream ? this.player.stream.emit(S.websocketError, t.value) : s && s.warn("decoderWorker", "onmessage and workerFetch response websocket error but stream is null"); else if (t.type === S.fetchError) this.player && this.player.stream ? this.player.stream.emit(S.fetchError, t.value) : s && s.warn("decoderWorker", "onmessage and workerFetch response fetch error but stream is null"); else if (t.type === w.streamAbps) this.player.updateStats({abps: t.value}); else if (t.type === w.streamVbps) this.player._times.demuxStart || (this.player._times.demuxStart = p()), this.player.updateStats({vbps: t.value}); else if (t.type === w.streamDts) this.player.updateStats({dts: t.value}); else if (t.type === w.netBuf) this.player.updateStats({netBuf: t.value}); else if (t.type === w.networkDelayTimeout) this.player.emit(w.networkDelayTimeout, t.value); else if (t.type === w.streamStats) {
                            const s = JSON.parse(t.value);
                            this.player.updateStats({workerStats: s})
                        } else t.type === w.websocketOpen && this.player.emit(w.websocketOpen);
                        break;
                    case"iframeIntervalTs":
                        this.player && (this.player.videoIframeIntervalTs = t.value);
                        break;
                    case"playbackStreamVideoFps":
                        this.player && this.player.video && this.player.video.setStreamFps(t.value);
                        break;
                    case"wasmError":
                        t.message && -1 !== t.message.indexOf("Invalid NAL unit size") && this.player.emitError(S.wasmDecodeError, "");
                        break;
                    case"wasmDecodeVideoNoResponseError":
                        this.player.emitError(S.wasmDecodeVideoNoResponseError);
                        break;
                    case"simdH264DecodeVideoWidthIsTooLarge":
                        this.player.emitError(S.simdH264DecodeVideoWidthIsTooLarge);
                        break;
                    case"wasmWidthOrHeightChange":
                        this.player.emitError(S.wasmWidthOrHeightChange);
                        break;
                    case"simdDecodeError":
                        this.player.emitError(S.simdDecodeError);
                        break;
                    case ue:
                        s.log("decoderWorker", "onmessage:", ue), this.player.destroy(), console.error("jessibuca pro 体验结束,请刷新页面再次体验，如需要购买商业授权，可以联系微信：bosswancheng"), alert("jessibuca pro 体验结束,请刷新页面再次体验，如需要购买商业授权，可以联系微信：bosswancheng"), window.location.reload();
                        break;
                    case pe:
                        s.log("decoderWorker", "onmessage:", pe), this._destroy();
                        break;
                    case"tempStream":
                        this.player && this.player.pushTempStream(t.buffer);
                        break;
                    case"videoSEI":
                        this.player && this.player.emit(w.videoSEI, {ts: t.ts, data: new Uint8Array(t.buffer)});
                        break;
                    case"flvScriptData":
                        if (this.player) {
                            if (this.player.isRecordTypeFlv()) {
                                const s = new Uint8Array(t.buffer);
                                this.player.recorder.addMetaData(s)
                            }
                            const s = Pr(new Uint8Array(t.buffer));
                            s && s.onMetaData && this.player.updateMetaData(s.onMetaData)
                        }
                        break;
                    case"aacSequenceHeader":
                        if (this.player && this.player.isRecordTypeFlv()) {
                            const s = new Uint8Array(t.buffer);
                            this.player.recorder.addAACSequenceHeader(s, t.ts)
                        }
                        break;
                    case"videoSequenceHeader":
                        if (this.player && this.player.isRecordTypeFlv()) {
                            const s = new Uint8Array(t.buffer);
                            this.player.recorder.addVideoSequenceHeader(s, t.ts)
                        }
                        break;
                    case"flvBufferData":
                        if (this.player && this.player.isRecordTypeFlv() && this.player.recording) {
                            const s = new Uint8Array(t.buffer);
                            2 === t.type ? this.player.recorder.addVideo(s, t.ts) : 1 === t.type && this.player.recorder.addAudio(s, t.ts)
                        }
                        break;
                    default:
                        this.player[t.cmd] && this.player[t.cmd](t)
                }
            }
        }

        _initWork() {
            var e = {
                debug: this.player._opt.debug,
                debugLevel: this.player._opt.debugLevel,
                debugUuid: this.player._opt.debugUuid,
                useOffscreen: this.player._opt.useOffscreen,
                useWCS: this.player._opt.useWCS,
                videoBuffer: this.player._opt.videoBuffer,
                videoBufferDelay: this.player._opt.videoBufferDelay,
                openWebglAlignment: this.player._opt.openWebglAlignment,
                playType: this.player._opt.playType,
                hasAudio: this.player._opt.hasAudio,
                hasVideo: this.player._opt.hasVideo,
                playbackRate: 1,
                playbackForwardMaxRateDecodeIFrame: this.player._opt.playbackForwardMaxRateDecodeIFrame,
                playbackIsCacheBeforeDecodeForFpsRender: this.player._opt.playbackConfig.isCacheBeforeDecodeForFpsRender,
                sampleRate: this.player.audio && this.player.audio.audioContext && this.player.audio.audioContext.sampleRate || 0,
                audioBufferSize: this.player.audio && this.player.audio.getAudioBufferSize() || 1024,
                networkDelay: this.player._opt.networkDelay,
                visibility: this.player.visibility,
                useSIMD: this.player._opt.useSIMD,
                recordType: this.player._opt.recordType,
                checkFirstIFrame: this.player._opt.checkFirstIFrame,
                isCrypto: this.player._opt.isCrypto,
                isFlv: this.player._opt.isFlv,
                isFmp4: this.player._opt.isFmp4,
                isMpeg4: this.player._opt.isMpeg4,
                isNakedFlow: this.player._opt.isNakedFlow,
                isHls265: this.player.isUseHls265(),
                isFmp4Private: this.player._opt.isFmp4Private,
                isSm4Crypto: this.player._opt.isSm4Crypto,
                sm4CryptoKey: this.player._opt.sm4CryptoKey,
                isEmitSEI: this.player._opt.isEmitSEI,
                isRecordTypeFlv: this.player.isRecordTypeFlv()
            };
            this.decoderWorker.postMessage({
                cmd: "init",
                opt: JSON.stringify(e)
            }), this.player._opt.isCrypto && (this.updateWorkConfig({
                key: "cryptoKey",
                value: this.player._opt.cryptoKey
            }), this.updateWorkConfig({key: "cryptoIV", value: this.player._opt.cryptoIV}))
        }

        decodeVideo(e, t, i) {
            this.player._opt.playType === n ? this.player.isUseHls265() ? this._decodeVideoNoDelay(e, t, i) : this._decodeVideo(e, t, i) : this.player._opt.playType === A && (this.player.video.rate >= this.player._opt.playbackForwardMaxRateDecodeIFrame ? i && (this.player.debug.log("decoderWorker", `current rate is ${this.player.video.rate},only decode i frame`), this._decodeVideoNoDelay(e, t, i)) : 1 === this.player.video.rate ? this._decodeVideo(e, t, i) : this._decodeVideoNoDelay(e, t, i))
        }

        _decodeVideo(e, t, i) {
            t = {type: 2, ts: Math.max(t, 0), isIFrame: i};
            this.decoderWorker.postMessage({cmd: "decode", buffer: e, options: t}, [e.buffer])
        }

        _decodeVideoNoDelay(e, t, i) {
            this.decoderWorker.postMessage({cmd: "videoDecode", buffer: e, ts: Math.max(t, 0), isIFrame: i}, [e.buffer])
        }

        decodeAudio(e, t) {
            this.player._opt.playType === n ? this.player._opt.useWCS || this.player._opt.useMSE || this.player.isUseHls265() ? this._decodeAudioNoDelay(e, t) : this._decodeAudio(e, t) : this.player._opt.playType === A && (1 === this.player.video.rate ? this._decodeAudio(e, t) : this._decodeAudioNoDelay(e, t))
        }

        _decodeAudio(e, t) {
            t = {type: 1, ts: Math.max(t, 0)};
            this.decoderWorker.postMessage({cmd: "decode", buffer: e, options: t}, [e.buffer])
        }

        _decodeAudioNoDelay(e, t) {
            this.decoderWorker.postMessage({cmd: "audioDecode", buffer: e, ts: Math.max(t, 0)}, [e.buffer])
        }

        updateWorkConfig(e) {
            this.decoderWorker && this.decoderWorker.postMessage({cmd: "updateConfig", key: e.key, value: e.value})
        }

        workerFetchStream(e) {
            var t = this.player["_opt"], t = {
                protocol: t.protocol,
                isFlv: t.isFlv,
                isFmp4: t.isFmp4,
                isMpeg4: t.isMpeg4,
                isNakedFlow: t.isNakedFlow
            };
            this.decoderWorker.postMessage({cmd: "fetchStream", url: e, opt: JSON.stringify(t)})
        }

        clearWorkBuffer() {
            this.decoderWorker.postMessage({
                cmd: "clearBuffer",
                needClear: 0 < arguments.length && void 0 !== arguments[0] && arguments[0]
            })
        }

        workerSendMessage(e) {
            this.decoderWorker.postMessage({cmd: "sendWsMessage", message: e})
        }
    }

    class Ur extends e {
        constructor(e) {
            super(), this.player = e, this.stopId = null, this.firstTimestamp = null, this.startTimestamp = null, this.preDelayTimestamp = null, this.preLoopTimestamp = null, this.bufferStartDts = null, this.bufferStartLocalTs = null, this.preIframeTs = null, this.preFrameTs = null, this.preTimestamp = null, this.preTimestampDuration = 0, this.prevPayloadBufferSize = 0, this.isStreamTsMoreThanLocal = !1, this.delay = -1, this.pushLatestDelay = -1, this.bufferList = [], this.historyIntervalDiffTimeList = [], this.playbackStreamFps = null, this.playbackStreamAudioFps = null, this.playbackStreamVideoFps = null, this.dropping = !1, this.isPushDropping = !1, this.initInterval(), this.player.debug.log("CommonDemux", "init")
        }

        destroy() {
            this.bufferList = [], this.historyIntervalDiffTimeList = [], this.playbackStreamFps = null, this.playbackStreamAudioFps = null, this.playbackStreamVideoFps = null, this.clearStopInterval(), this.firstTimestamp = null, this.startTimestamp = null, this.bufferStartDts = null, this.bufferStartLocalTs = null, this.preDelayTimestamp = null, this.preLoopTimestamp = null, this.preIframeTs = null, this.preTimestamp = null, this.preTimestampDuration = 0, this.prevPayloadBufferSize = 0, this.isStreamTsMoreThanLocal = !1, this.delay = -1, this.pushLatestDelay = -1, this.dropping = !1, this.isPushDropping = !1, this.off(), this.player.debug.log("CommonDemux", "destroy")
        }

        isDropping() {
            return this.dropping || this.isPushDropping
        }

        getDelay(e) {
            return e && this.player.isDemuxDecodeFirstIIframeInit() ? (this.preDelayTimestamp && this.preDelayTimestamp > e ? 1e3 < this.preDelayTimestamp - e && this.player.debug.warn("CommonDemux", `getDelay and preDelayTimestamp is ${this.preDelayTimestamp} > timestamp is ${e} more than ${this.preDelayTimestamp - e}ms`) : this.firstTimestamp ? e && (t = Date.now() - this.startTimestamp, (i = e - this.firstTimestamp) <= t ? (this.isStreamTsMoreThanLocal = !1, this.delay = t - i) : (this.isStreamTsMoreThanLocal = !0, this.delay = i - t)) : (this.firstTimestamp = e, this.startTimestamp = Date.now(), this.delay = -1), this.preDelayTimestamp = e, this.delay) : -1;
            var t, i
        }

        getDelayNotUpdateDelay(t) {
            if (!t || !this.player.isDemuxDecodeFirstIIframeInit()) return -1;
            if (this.preDelayTimestamp && 1e3 < this.preDelayTimestamp - t) return this.player.debug.warn("CommonDemux", `getDelayNotUpdateDelay and preDelayTimestamp is ${this.preDelayTimestamp} > timestamp is ${t} more than ${this.preDelayTimestamp - t}ms`), -1;
            if (this.firstTimestamp) {
                let e = -1;
                var i;
                return t && (i = Date.now() - this.startTimestamp, t = t - this.firstTimestamp, e = t <= i ? i - t : t - i), e
            }
            return -1
        }

        resetDelay() {
            this.firstTimestamp = null, this.startTimestamp = null, this.delay = -1, this.dropping = !1
        }

        resetAllDelay() {
            this.resetDelay(), this.preDelayTimestamp = null
        }

        initInterval() {
            this.player.isUseHls265() ? this.player.debug.log("CommonDemux", "initInterval() and is hls and support hls265 so return") : -1 === this.player.getStreamType().indexOf(N) ? this.player.isPlaybackCacheBeforeDecodeForFpsRender() ? this.player.debug.log("CommonDemux", "initInterval() and playback and playbackIsCacheBeforeDecodeForFpsRender is true so return") : (this.player.debug.log("CommonDemux", "initInterval()"), this._loop(), this.stopId = setInterval(() => {
                var e = (new Date).getTime(),
                    e = (this.preLoopTimestamp || (this.preLoopTimestamp = e), e - this.preLoopTimestamp);
                this.updateHistoryIntervalDiffTimeList(e), 100 < e && this.player.debug.warn("CommonDemux", "loop demux diff time is " + e), this._loop(), this.preLoopTimestamp = (new Date).getTime()
            }, 20)) : this.player.debug.log("CommonDemux", "initInterval() and is worker stream so return")
        }

        clearStopInterval() {
            this.stopId && (clearInterval(this.stopId), this.stopId = null)
        }

        updateHistoryIntervalDiffTimeList(e) {
            5 < this.historyIntervalDiffTimeList.length && this.historyIntervalDiffTimeList.shift(), this.historyIntervalDiffTimeList.push(e)
        }

        isHistoryIntervalDiffTimeAllLarge() {
            if (this.historyIntervalDiffTimeList.length < 5) return !1;
            for (let e = 0; e < this.historyIntervalDiffTimeList.length; e++) if (this.historyIntervalDiffTimeList[e] < 900) return !1;
            return !0
        }

        initPlaybackCacheLoop() {
            this.clearStopInterval();
            var e = () => {
                var e;
                this.bufferList.length && (e = this.bufferList.shift(), this._doDecoderDecode(e))
            }, t = (e(), Math.ceil(1e3 / (this.playbackStreamFps * this.player.getPlaybackRate())));
            this.player.debug.log("CommonDemux", `initPlaybackCacheLoop() and fragDuration is ${t}, playbackStreamFps is ${this.playbackStreamFps}, playbackRate is ` + this.player.getPlaybackRate()), this.stopId = setInterval(e, t)
        }

        _loop() {
            let e;
            const t = this.player._opt.videoBuffer, i = this.player._opt.videoBufferDelay,
                r = this.player._opt.playType === n;
            if (this.bufferList.length) if (this.isPushDropping) this.player.debug.warn("CommonDemux", "_loop isPushDropping is true and bufferList length is " + this.bufferList.length); else if (this.dropping) {
                for (e = this.bufferList.shift(), this.player.debug.warn("CommonDemux", `_loop is dropping and data.ts is ${e.ts}, data.isIFrame is ${e.isIFrame}, delay is ${this.delay} ,buffer list is ` + this.bufferList.length); !e.isIFrame && this.bufferList.length;) e = this.bufferList.shift();
                const t = this.getDelayNotUpdateDelay(e.ts);
                e.isIFrame && t <= this.getNotDroppingDelayTs() && (this.player.debug.log("CommonDemux", "_loop data isIFrame is true and delay is " + this.delay), this.dropping = !1, this._doDecoderDecode(e), this._decodeNext(e))
            } else if (e = this.bufferList[0], -1 === this.getDelay(e.ts) || this.player.isPlayback()) this.player.isPlayer() && this.player.debug.log("CommonDemux", `delay is -1 and data.ts is ${e.ts} data.type is ` + e.type), this.bufferList.shift(), this._doDecoderDecode(e), this._decodeNext(e); else if (this.delay > i + t && r) this.hasIframeInBufferList() ? (this.player.debug.warn("CommonDemux", `_loop delay is ${this.delay}, set dropping is true`), this.resetAllDelay(), this.dropping = !0) : (this.bufferList.shift(), this._doDecoderDecode(e), this._decodeNext(e)); else for (; this.bufferList.length;) {
                if (e = this.bufferList[0], !(this.getDelay(e.ts) > t)) {
                    this.delay < 0 && this.player.debug.warn("CommonDemux", `_loop delay is ${this.delay} bufferList is ` + this.bufferList);
                    break
                }
                this.bufferList.shift(), this._doDecoderDecode(e)
            } else -1 !== this.delay && this.player.debug.log("CommonDemux", "loop() bufferList is empty and reset delay"), this.resetAllDelay()
        }

        _doDecode(e, t, i, r) {
            const s = this.player;
            let a = {
                ts: i,
                cts: 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
                type: t,
                isIFrame: !1
            };
            this.player.isPlayer() ? (2 === t && s._opt.playType === n && this.calcNetworkDelay(i), s._opt.useWCS && !s._opt.useOffscreen || s._opt.useMSE ? (2 === t && (a.isIFrame = r), this.pushBuffer(e, a)) : 2 === t ? s.decoderWorker && s.decoderWorker.decodeVideo(e, i, r) : 1 === t && s._opt.hasAudio && s.decoderWorker && s.decoderWorker.decodeAudio(e, i)) : this.player.isPlayback() && (2 === t && (a.isIFrame = r), this.player.isPlaybackOnlyDecodeIFrame() ? 2 === t && r && this.pushBuffer(e, a) : this.player.isPlaybackCacheBeforeDecodeForFpsRender() || 1 === this.player.getPlaybackRate() ? this.pushBuffer(e, a) : 2 === t ? this._doDecoderDecode({
                ts: a.ts,
                cts: a.cts,
                payload: e,
                type: 2,
                isIFrame: a.isIFrame
            }) : 1 === t && s.decoderWorker && s.decoderWorker.decodeAudio(e, i))
        }

        _doDecodeByHls(e, t, i, r) {
            var s = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0;
            const a = this.player, {webcodecsDecoder: n, mseDecoder: o} = a;
            2 === t ? a._opt.useWCS && !a._opt.useOffscreen ? n.decodeVideo(e, i, r, s) : a._opt.useMSE ? o.decodeVideo(e, i, r, s) : a.decoderWorker && a.decoderWorker.decodeVideo(e, i, r) : 1 === t && a._opt.hasAudio && a.decoderWorker && a.decoderWorker.decodeAudio(e, i)
        }

        _doDecodeByFmp4(e, t, i, r) {
            this._doDecode(e, t, i, r, 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0)
        }

        _decodeNext(e) {
            var t, i, r, s, a = e.ts;
            this.player.isPlayback() || 0 !== this.bufferList.length && (i = (t = this.bufferList[0]).ts - a, r = 2 === e.type && 1 === t.type, s = 2 === e.type && ui(e.payload), (i <= 20 || r || s) && (this.player.debug.log("CommonDemux", `decode data type is ${e.type} and
            ts is ${a} next data type is ${t.type} ts is ${t.ts}
            diff is ${i} and isVideoAndNextAudio is ${r} and isVideoSqeHeader is ` + s), this.bufferList.shift(), this._doDecoderDecode(t)))
        }

        _doDecoderDecode(e) {
            const t = this.player, {webcodecsDecoder: i, mseDecoder: r} = t;
            this.player.isPlayer() && this.player.updateStats({buf: this.delay}), 1 === e.type ? t._opt.hasAudio && t.decoderWorker && t.decoderWorker.decodeAudio(e.payload, e.ts) : 2 === e.type && (t._opt.useWCS && !t._opt.useOffscreen ? i.decodeVideo(e.payload, e.ts, e.isIFrame, e.cts) : t._opt.useMSE && r.decodeVideo(e.payload, e.ts, e.isIFrame, e.cts))
        }

        pushBuffer(e, t) {
            const i = this.player._opt.videoBuffer, r = this.player._opt.videoBufferDelay, s = this.player.isPlayer();
            if (1 === t.type && ((a = e)[0] >> 4 == 10 && 0 === a[1])) {
                if (this.player.debug.log("CommonDemux", `pushBuffer audio ts is ${t.ts}, isAacCodecPacket is true`), this.player.isRecordTypeFlv()) {
                    const i = new Uint8Array(e);
                    this.player.recorder.addAACSequenceHeader(i, t.ts)
                }
                this._doDecoderDecode({ts: t.ts, payload: e, type: 1})
            } else if (2 === t.type && t.isIFrame && ui(e)) {
                if (this.player.debug.log("CommonDemux", `pushBuffer video ts is ${t.ts}, isVideoSequenceHeader is true`), this.player.isRecordTypeFlv()) {
                    const i = new Uint8Array(e);
                    this.player.recorder.addVideoSequenceHeader(i, t.ts)
                }
                this._doDecoderDecode({ts: t.ts, payload: e, type: 2, isIFrame: t.isIFrame, cts: t.cts})
            } else {
                if (this.player.isRecordTypeFlv() && this.player.recording) {
                    const i = new Uint8Array(e);
                    2 === t.type ? this.player.recorder.addVideo(i, t.ts) : 1 === t.type && this.player.recorder.addAudio(i, t.ts)
                }
                if (s) {
                    if (0 < this.preTimestampDuration && 0 < this.preTimestamp && 2 === t.type) {
                        const e = t.ts - this.preTimestamp;
                        e >= 2 * this.preTimestampDuration - 5 && this.player.debug.warn("CommonDemux", `pushBuffer video
                ts is ${t.ts}, preTimestamp is ${this.preTimestamp},
                diff is ${e} and preTimestampDuration is ${this.preTimestampDuration}
                maybe trigger black screen or flower screen`)
                    }
                    if (0 < this.preTimestamp && t.ts < this.preTimestamp && 2 === t.type && 36e5 < this.preTimestamp - t.ts && (this.player.debug.warn("CommonDemux", `pushBuffer video
            ts is ${t.ts}, preTimestamp is ${this.preTimestamp},
            diff is ${this.preTimestamp - t.ts} more than 3600000
            and resetAllDelay()`), this.resetAllDelay()), t.ts <= this.preTimestamp && 0 < this.preTimestamp && 2 === t.type && this.player.debug.warn("CommonDemux", `pushBuffer video
            ts is ${t.ts} less than (or equal) preTimestamp is ${this.preTimestamp} and
            payloadBufferSize is ${e.byteLength} and prevPayloadBufferSize is ` + this.prevPayloadBufferSize), this.player.isDemuxDecodeFirstIIframeInit()) {
                        a = this.getDelayNotUpdateDelay(t.ts);
                        this.pushLatestDelay = a;
                        const s = r + i;
                        this.player._opt.useMSE ? a > s && this.delay < s && 0 < this.delay && this.hasIframeInBufferList() && !1 === this.isPushDropping && (this.player.debug.warn("CommonDemux", `useMSE, pushLatestDelay is ${a} > ${r + i}, bufferList is ${this.bufferList.length}, delay is ${this.delay} and dropBuffer$2()`), this.dropBuffer$2()) : a > s && this.delay < s && 0 < this.delay && this.hasIframeInBufferList() && !1 === this.isPushDropping && (this.player.debug.warn("CommonDemux", `useWCS, pushLatestDelay is ${a} > ${r + i},bufferList is ${this.bufferList.length}, delay is ${this.delay} and dropBuffer$2()`), this.dropBuffer$2()), this.isHistoryIntervalDiffTimeAllLarge() && C(this.player.visibility) && (this.player._opt.useMSE ? this.hasIframeInBufferList() && !1 === this.isPushDropping && (this.player.debug.warn("CommonDemux", `useMSE, page visibility is false and
                                history interval diff is ${this.historyIntervalDiffTimeList.join(",")}  and
                                bufferList is ${this.bufferList.length},
                                delay is ${this.delay} and dropBuffer$2()`), this.dropBuffer$2()) : this.hasIframeInBufferList() && !1 === this.isPushDropping && (this.player.debug.warn("CommonDemux", `useWCS, page visibility is false and
                                history interval diff is ${this.historyIntervalDiffTimeList.join(",")}  and
                                bufferList is ${this.bufferList.length},
                                delay is ${this.delay} and dropBuffer$2()`), this.dropBuffer$2()))
                    }
                }
                if (2 === t.type && (0 < this.preTimestamp && (this.preTimestampDuration = t.ts - this.preTimestamp), this.prevPayloadBufferSize = e.byteLength, this.preTimestamp = t.ts), 1 === t.type ? this.bufferList.push({
                    ts: t.ts,
                    payload: e,
                    type: 1
                }) : 2 === t.type && this.bufferList.push({
                    ts: t.ts,
                    cts: t.cts,
                    payload: e,
                    type: 2,
                    isIFrame: t.isIFrame
                }), this.player.isPlaybackCacheBeforeDecodeForFpsRender() && (c(this.playbackStreamVideoFps) || c(this.playbackStreamAudioFps))) {
                    let e = this.playbackStreamVideoFps, t = this.playbackStreamAudioFps;
                    c(this.playbackStreamVideoFps) && (0 < (e = oi(this.bufferList, 2)) && (this.playbackStreamVideoFps = e, this.player.video && this.player.video.setStreamFps(this.playbackStreamVideoFps), this.playbackStreamFps = t ? e + t : e, this.initPlaybackCacheLoop())), c(this.playbackStreamAudioFps) && (0 < (t = oi(this.bufferList, 1)) && (this.playbackStreamAudioFps = t, this.playbackStreamFps = e ? e + t : t, this.initPlaybackCacheLoop())), c(this.playbackStreamVideoFps) && c(this.playbackStreamAudioFps) && this.player.debug.log("CommonDemux", `playbackCacheBeforeDecodeForFpsRender, calc streamAudioFps is ${t}, streamVideoFps is ${e}, bufferListLength  is ` + this.bufferList.length)
                }
            }
            var a
        }

        dropBuffer$2() {
            if (0 < this.bufferList.length) {
                this.isPushDropping = !0;
                let t = this.bufferList.findIndex(e => k(e.isIFrame) && 2 === e.type);
                if (this.isAllIframeInBufferList()) for (let e = 0; e < this.bufferList.length; e++) {
                    var i = this.bufferList[e], i = this.getDelayNotUpdateDelay(i.ts);
                    if (i >= this.getNotDroppingDelayTs()) {
                        this.player.debug.log("CommonDemux", `dropBuffer$2() isAllIframeInBufferList() is true, and index is ${e} and tempDelay is ${i} and notDroppingDelayTs is ` + this.getNotDroppingDelayTs()), t = e;
                        break
                    }
                }
                var e, r;
                0 <= t ? (this.bufferList = this.bufferList.slice(t), e = this.bufferList.shift(), r = this.getDelayNotUpdateDelay(e.ts), this._doDecoderDecode(e), this.isPushDropping = !1, this.player.debug.log("CommonDemux", `dropBuffer$2() iFrameIndex is ${t},and bufferList length is ${this.bufferList.length} and tempDelay is ${r} ,delay is ${this.delay} `)) : this.isPushDropping = !1
            }
            0 === this.bufferList.length && (this.isPushDropping = !1)
        }

        clearBuffer() {
            var e = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            this.player.debug.log("CommonDemux", `clearBuffer,buffer length is ${this.bufferList.length}, need clear is ` + e), e && (this.bufferList = []), this.resetAllDelay(), this.dropping = !0
        }

        calcNetworkDelay(e) {
            var t, i, r;
            this.player.isDemuxDecodeFirstIIframeInit() && 0 < e && (null === this.bufferStartDts ? (this.bufferStartDts = e, this.bufferStartLocalTs = p()) : e < this.bufferStartDts && (this.player.debug.warn("CommonDemux", `calcNetworkDelay dts is ${e} and bufferStartDts is ` + this.bufferStartDts), this.bufferStartDts = e, this.bufferStartLocalTs = p()), (r = (t = e - this.bufferStartDts) < (i = p() - this.bufferStartLocalTs) ? i - t : 0) > this.player._opt.networkDelay && this.player._opt.playType === n && (this.player.debug.warn("CommonDemux", `delay is more than networkDelay and now dts:${e},start dts is ${this.bufferStartDts}, vs start is ${t},local diff is ${i} ,delay is ${r}, _opt.networkDelay is ` + this.player._opt.networkDelay), this.player.emit(w.networkDelayTimeout, r)), this.player.updateStats({netBuf: r}))
        }

        calcIframeIntervalTimestamp(e) {
            var t;
            null === this.preIframeTs ? this.preIframeTs = e : this.preIframeTs < e && (t = e - this.preIframeTs, this.player && (this.player.videoIframeIntervalTs = t), this.preIframeTs = e)
        }

        calcBufferFps(e) {
        }

        getNotDroppingDelayTs() {
            return this.player._opt.videoBuffer + this.player._opt.videoBufferDelay / 2
        }

        getMaxDelayTs() {
            return this.player._opt.videoBuffer + this.player._opt.videoBufferDelay
        }

        getPushLatestDelay() {
            return this.pushLatestDelay
        }

        getVideoBufferLength() {
            let t = 0;
            return this.bufferList.forEach(e => {
                2 === e.type && (t += 1)
            }), t
        }

        hasIframeInBufferList() {
            return this.bufferList.some(e => 2 === e.type && e.isIFrame)
        }

        isAllIframeInBufferList() {
            var e = this.getVideoBufferLength();
            let t = 0;
            return this.bufferList.forEach(e => {
                2 === e.type && e.isIFrame && (t += 1)
            }), e === t
        }

        getInputByteLength() {
            return 0
        }

        getIsStreamTsMoreThanLocal() {
            return this.isStreamTsMoreThanLocal
        }

        close() {
        }

        reset() {
        }

        findSei(e, i) {
            const t = function (i, e) {
                var r = 1 < arguments.length && void 0 !== e ? e : 4;
                if (!(i.length < 4)) {
                    const s = i.length, a = [];
                    let e, t = 0;
                    for (; t + r < s;) if (e = function (e, t) {
                        return (e[t = 1 < arguments.length && void 0 !== t ? t : 0] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + (e[t + 3] || 0)
                    }(i, t), 3 === r && (e >>>= 8), t += r, e) {
                        if (t + e > s) break;
                        a.push(i.subarray(t, t + e)), t += e
                    }
                    return a
                }
            }(e.slice(5)), r = this.player.video.encType === we;
            t.forEach(e => {
                var t = r ? e[0] >>> 1 & 63 : 31 & e[0];
                (r && (40 == t || 39 == t) || C(r) && t === Te) && this.player.emit(w.videoSEI, {ts: i, data: e})
            })
        }
    }

    const Fr = Symbol(32), Mr = Symbol(16), Or = Symbol(8);

    class Nr {
        constructor(e) {
            this.g = e, this.consumed = 0, e && (this.need = e.next().value)
        }

        setG(e) {
            this.g = e, this.demand(e.next().value, !0)
        }

        consume() {
            this.buffer && this.consumed && (this.buffer.copyWithin(0, this.consumed), this.buffer = this.buffer.subarray(0, this.buffer.length - this.consumed), this.consumed = 0)
        }

        demand(e, t) {
            return t && this.consume(), this.need = e, this.flush()
        }

        read(i) {
            return e = this, l = function* () {
                return this.lastReadPromise && (yield this.lastReadPromise), this.lastReadPromise = new Promise((t, e) => {
                    this.reject = e, this.resolve = e => {
                        delete this.lastReadPromise, delete this.resolve, delete this.need, t(e)
                    }, this.demand(i, !0) || null == (e = this.pull) || e.call(this, i)
                })
            }, new (o = (o = n = void 0) || Promise)(function (i, t) {
                function r(e) {
                    try {
                        a(l.next(e))
                    } catch (e) {
                        t(e)
                    }
                }

                function s(e) {
                    try {
                        a(l.throw(e))
                    } catch (e) {
                        t(e)
                    }
                }

                function a(e) {
                    var t;
                    e.done ? i(e.value) : ((t = e.value) instanceof o ? t : new o(function (e) {
                        e(t)
                    })).then(r, s)
                }

                a((l = l.apply(e, n || [])).next())
            });
            var e, n, o, l
        }

        readU32() {
            return this.read(Fr)
        }

        readU16() {
            return this.read(Mr)
        }

        readU8() {
            return this.read(Or)
        }

        close() {
            var e;
            this.g && this.g.return(), this.buffer && this.buffer.subarray(0, 0), null != (e = this.reject) && e.call(this, new Error("EOF")), delete this.lastReadPromise
        }

        flush() {
            if (this.buffer && this.need) {
                let e = null;
                const r = this.buffer.subarray(this.consumed);
                let t = 0;
                var i = e => r.length < (t = e);
                if ("number" == typeof this.need) {
                    if (i(this.need)) return;
                    e = r.subarray(0, t)
                } else if (this.need === Fr) {
                    if (i(4)) return;
                    e = r[0] << 24 | r[1] << 16 | r[2] << 8 | r[3]
                } else if (this.need === Mr) {
                    if (i(2)) return;
                    e = r[0] << 8 | r[1]
                } else if (this.need === Or) {
                    if (i(1)) return;
                    e = r[0]
                } else if ("buffer" in this.need) {
                    if ("byteOffset" in this.need) {
                        if (i(this.need.byteLength - this.need.byteOffset)) return;
                        new Uint8Array(this.need.buffer, this.need.byteOffset).set(r.subarray(0, t)), e = this.need
                    } else if (this.g) return void this.g.throw(new Error("Unsupported type"))
                } else {
                    if (i(this.need.byteLength)) return;
                    new Uint8Array(this.need).set(r.subarray(0, t)), e = this.need
                }
                return this.consumed += t, this.g ? this.demand(this.g.next(e).value, !0) : this.resolve && this.resolve(e), e
            }
        }

        write(e) {
            if (e instanceof Uint8Array ? this.malloc(e.length).set(e) : "buffer" in e ? this.malloc(e.byteLength).set(new Uint8Array(e.buffer, e.byteOffset, e.byteLength)) : this.malloc(e.byteLength).set(new Uint8Array(e)), !this.g && !this.resolve) return new Promise(e => this.pull = e);
            this.flush()
        }

        writeU32(e) {
            this.malloc(4).set([e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e]), this.flush()
        }

        writeU16(e) {
            this.malloc(2).set([e >> 8 & 255, 255 & e]), this.flush()
        }

        writeU8(e) {
            this.malloc(1)[0] = e, this.flush()
        }

        malloc(e) {
            if (this.buffer) {
                var t = this.buffer.length, i = t + e;
                if (i <= this.buffer.buffer.byteLength - this.buffer.byteOffset) this.buffer = new Uint8Array(this.buffer.buffer, this.buffer.byteOffset, i); else {
                    const e = new Uint8Array(i);
                    e.set(this.buffer), this.buffer = e
                }
                return this.buffer.subarray(t, i)
            }
            return this.buffer = new Uint8Array(e), this.buffer
        }
    }

    Nr.U32 = Fr, Nr.U16 = Mr, Nr.U8 = Or;
    var jr, zr = "application/json, text/javascript", Gr = "text/html", Hr = /^(?:text|application)\/xml/i,
        Wr = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Vr = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
        Kr = /^\s*$/, $r = {}, qr = {}, Yr = "", Jr = {
            type: "GET",
            beforeSend: Qr,
            success: Qr,
            error: Qr,
            complete: Qr,
            context: null,
            xhr: function () {
                return new window.XMLHttpRequest
            },
            accepts: {json: zr, xml: "application/xml, text/xml", html: Gr, text: "text/plain", "*": "*/".concat("*")},
            crossDomain: !1,
            timeout: 0,
            username: null,
            password: null,
            processData: !0,
            promise: Qr,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8"
        };

    function Qr() {
    }

    function Xr(e, t) {
        "object" == typeof e && (t = e, e = void 0);
        var i, r = as({}, t = t || {});
        for (i in Jr) void 0 === r[i] && (r[i] = Jr[i]);
        try {
            var s = {}, a = new Promise(function (e, t) {
                s.resolve = e, s.reject = t
            });
            a.resolve = s.resolve, a.reject = s.reject, r.promise = a
        } catch (e) {
            r.promise = {resolve: Qr, reject: Qr}
        }
        var n, o, l, d, h, a = Vr.exec(window.location.href.toLowerCase()) || [],
            c = (r.url = ((e || r.url || window.location.href) + "").replace(/#.*$/, "").replace(/^\/\//, a[1] + "//"), r.url),
            u = (r.crossDomain || (r.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(r.url) && RegExp.$2 !== window.location.href), r.dataType);
        if ("jsonp" === u) return /=\?/.test(r.url) || (a = (r.jsonp || "callback") + "=?", r.url = rs(r.url, a)), l = (n = r).jsonpCallback || "jsonp" + ls(), d = window.document.createElement("script"), h = {
            abort: function () {
                l in window && (window[l] = Qr)
            }
        }, a = window.document.getElementsByTagName("head")[0] || window.document.documentElement, d.onerror = function (e) {
            e = e, window.clearTimeout(o), h.abort(), ts(e.type, h, e.type, n), p()
        }, window[l] = function (e) {
            window.clearTimeout(o), Zr(e, h, n), p()
        }, ss(n), d.src = n.url.replace(/=\?/, "=" + l), d.src = rs(d.src, "_=" + (new Date).getTime()), d.async = !0, n.scriptCharset && (d.charset = n.scriptCharset), a.insertBefore(d, a.firstChild), 0 < n.timeout && (o = window.setTimeout(function () {
            h.abort(), ts("timeout", h, "timeout", n), p()
        }, n.timeout)), n.promise.abort = function () {
            h.abort()
        }, n.promise.xhr = h, n.promise;

        function p() {
            d.clearAttributes ? d.clearAttributes() : d.onload = d.onreadystatechange = d.onerror = null, d.parentNode && d.parentNode.removeChild(d), d = null, delete window[l]
        }

        ss(r);
        var f = r.accepts[u] || r.accepts["*"], m = {};
        /^([\w-]+:)\/\//.test(r.url) ? RegExp.$1 : window.location.protocol;
        var g, y = Jr.xhr(),
            f = (r.crossDomain || m["X-Requested-With"] || (m["X-Requested-With"] = "XMLHttpRequest"), r.ifModified && ($r[c] && (m["If-Modified-Since"] = $r[c]), qr[c] && (m["If-None-Match"] = qr[c])), f && (-1 < (m.Accept = f).indexOf(",") && (f = f.split(",", 2)[0]), y.overrideMimeType && y.overrideMimeType(f)), !/^(?:GET|HEAD)$/.test(r.type.toUpperCase())),
            f = ((r.data && f && !1 !== r.contentType || t.contentType) && (m["Content-Type"] = r.contentType), !1 !== r.cache || f || (r.url = (t = /([?&])_=[^&]*/).test(c) ? c.replace(t, "$1_=" + ls()) : c + (/\?/.test(c) ? "&" : "?") + "_=" + ls()), r.headers = as(m, r.headers || {}), y.onreadystatechange = function () {
                if (4 === y.readyState) {
                    clearTimeout(g);
                    var e, t = !1;
                    if (200 <= y.status && y.status < 300 || 304 === y.status) {
                        Yr = y.getAllResponseHeaders(), r.ifModified && ((i = is("Last-Modified")) && ($r[c] = i), (i = is("etag")) && (qr[c] = i)), u = u || ((i = y.getResponseHeader("content-type")) && (i === Gr ? "html" : i === zr ? "json" : Hr.test(i) && "xml") || "text"), e = y.responseText;
                        try {
                            "xml" === u ? e = y.responseXML : "json" === u && (e = Kr.test(e) ? null : JSON.parse(e))
                        } catch (e) {
                            t = e
                        }
                        t ? ts(t, "parseerror", y, r) : Zr(e, y, r)
                    } else ts(null, "error", y, r)
                }
                var i
            }, !("async" in r) || r.async);
        if (y.open(r.type, r.url, f, r.username, r.password), r.xhrFields) for (var A in r.xhrFields) y[A] = r.xhrFields[A];
        for (A in r.mimeType && y.overrideMimeType && y.overrideMimeType(r.mimeType), r.headers) void 0 !== r.headers[A] && y.setRequestHeader(A, r.headers[A] + "");
        return !1 === function (e) {
            var t = e.context;
            if (!1 === e.beforeSend.call(t, y, e)) return !1
        }(r) ? (y.abort(), !1) : (0 < r.timeout && (g = window.setTimeout(function () {
            y.onreadystatechange = Qr, y.abort(), ts(null, "timeout", y, r)
        }, r.timeout)), y.send(r.data || null), r.promise.abort = function () {
            y.abort()
        }, r.promise)
    }

    function Zr(e, t, i) {
        var r = i.context, s = "success";
        i.success.call(r, e, s, t), i.promise.resolve(e, s, t), es(s, t, i)
    }

    function es(e, t, i) {
        var r = i.context;
        i.complete.call(r, t, e)
    }

    function ts(e, t, i, r) {
        var s = r.context;
        r.error.call(s, i, t, e), r.promise.reject(i, t, e), es(t, i, r)
    }

    function is(e) {
        var t;
        if (!jr) {
            for (jr = {}; t = Wr.exec(Yr);) jr[t[1].toLowerCase()] = t[2];
            t = jr[e.toLowerCase()]
        }
        return null === t ? null : t
    }

    function rs(e, t) {
        return (e + "&" + t).replace(/[&?]{1,2}/, "?")
    }

    function ss(e) {
        var t, i;
        !ns(e) || e.data instanceof FormData || !e.processData || (e.data = (t = e.data, (i = []).add = function (e, t) {
            this.push(encodeURIComponent(e) + "=" + encodeURIComponent(t))
        }, function e(t, i, r, s) {
            var a = function (e) {
                return "[object Array]" === Object.prototype.toString.call(e)
            }(i);
            for (var n in i) {
                var o = i[n];
                s && (n = r ? s : s + "[" + (a ? "" : n) + "]"), !s && a ? t.add(o.name, o.value) : (r ? a : ns)(o) ? e(t, o, r, n) : t.add(n, o)
            }
        }(i, t, void 0), i.join("&").replace("%20", "+"))), !e.data || e.type && "GET" !== e.type.toUpperCase() || (e.url = rs(e.url, e.data))
    }

    function as(e) {
        for (var t = Array.prototype.slice.call(arguments, 1), i = 0, r = t.length; i < r; i++) {
            var s, a = t[i] || {};
            for (s in a) a.hasOwnProperty(s) && void 0 !== a[s] && (e[s] = a[s])
        }
        return e
    }

    function ns(e) {
        var t = typeof e;
        return "function" == t || "object" == t && !!e
    }

    function os(e) {
        return "function" == typeof e
    }

    function ls() {
        return (new Date).getTime()
    }

    function ds(e) {
        return parseInt(e) === e
    }

    function hs(e) {
        if (ds(e.length)) {
            for (var t = 0; t < e.length; t++) if (!ds(e[t]) || e[t] < 0 || 255 < e[t]) return;
            return 1
        }
    }

    function a(e, t) {
        if (e.buffer && "Uint8Array" === e.name) return e = t ? e.slice ? e.slice() : Array.prototype.slice.call(e) : e;
        if (Array.isArray(e)) {
            if (hs(e)) return new Uint8Array(e);
            throw new Error("Array contains invalid value: " + e)
        }
        if (ds(e.length) && hs(e)) return new Uint8Array(e);
        throw new Error("unsupported array-like object")
    }

    function v(e) {
        return new Uint8Array(e)
    }

    function L(e, t, i, r, s) {
        null == r && null == s || (e = e.slice ? e.slice(r, s) : Array.prototype.slice.call(e, r, s)), t.set(e, i)
    }

    Xr.get = function (e, t, i, r) {
        return os(t) && (r = r || i, i = t, t = void 0), Xr({url: e, data: t, success: i, dataType: r})
    }, Xr.post = function (e, t, i, r) {
        return os(t) && (r = r || i, i = t, t = void 0), Xr({type: "POST", url: e, data: t, success: i, dataType: r})
    }, Xr.getJSON = function (e, t, i) {
        return os(t) && (i = t, t = void 0), Xr({url: e, data: t, success: i, dataType: "json"})
    }, Xr.ajaxSetup = function (e, t) {
        return t ? as(as(e, Jr), t) : as(Jr, e)
    };
    var cs, us = {
            toBytes: function (e) {
                var t = [], i = 0;
                for (e = encodeURI(e); i < e.length;) {
                    var r = e.charCodeAt(i++);
                    37 === r ? (t.push(parseInt(e.substr(i, 2), 16)), i += 2) : t.push(r)
                }
                return a(t)
            }, fromBytes: function (e) {
                for (var t = [], i = 0; i < e.length;) {
                    var r = e[i];
                    r < 128 ? (t.push(String.fromCharCode(r)), i++) : 191 < r && r < 224 ? (t.push(String.fromCharCode((31 & r) << 6 | 63 & e[i + 1])), i += 2) : (t.push(String.fromCharCode((15 & r) << 12 | (63 & e[i + 1]) << 6 | 63 & e[i + 2])), i += 3)
                }
                return t.join("")
            }
        }, ps = (cs = "0123456789abcdef", {
            toBytes: function (e) {
                for (var t = [], i = 0; i < e.length; i += 2) t.push(parseInt(e.substr(i, 2), 16));
                return t
            }, fromBytes: function (e) {
                for (var t = [], i = 0; i < e.length; i++) {
                    var r = e[i];
                    t.push(cs[(240 & r) >> 4] + cs[15 & r])
                }
                return t.join("")
            }
        }), fs = {16: 10, 24: 12, 32: 14},
        ms = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
        D = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22],
        gs = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125],
        ys = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986],
        As = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766],
        bs = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126],
        vs = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436],
        _s = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890],
        ws = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935],
        Ss = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600],
        Es = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480],
        Ts = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795],
        ks = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855],
        xs = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150],
        Cs = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

    function Ls(e) {
        for (var t = [], i = 0; i < e.length; i += 4) t.push(e[i] << 24 | e[i + 1] << 16 | e[i + 2] << 8 | e[i + 3]);
        return t
    }

    function Ds(e) {
        if (!(this instanceof Ds)) throw Error("AES must be instanitated with `new`");
        Object.defineProperty(this, "key", {value: a(e, !0)}), this._prepare()
    }

    function Is(e) {
        if (!(this instanceof Is)) throw Error("AES must be instanitated with `new`");
        this.description = "Electronic Code Block", this.name = "ecb", this._aes = new Ds(e)
    }

    function Rs(e, t) {
        if (!(this instanceof Rs)) throw Error("AES must be instanitated with `new`");
        if (this.description = "Cipher Block Chaining", this.name = "cbc", t) {
            if (16 != t.length) throw new Error("invalid initialation vector size (must be 16 bytes)")
        } else t = v(16);
        this._lastCipherblock = a(t, !0), this._aes = new Ds(e)
    }

    function Ps(e, t, i) {
        if (!(this instanceof Ps)) throw Error("AES must be instanitated with `new`");
        if (this.description = "Cipher Feedback", this.name = "cfb", t) {
            if (16 != t.length) throw new Error("invalid initialation vector size (must be 16 size)")
        } else t = v(16);
        this.segmentSize = i = i || 1, this._shiftRegister = a(t, !0), this._aes = new Ds(e)
    }

    function Bs(e, t) {
        if (!(this instanceof Bs)) throw Error("AES must be instanitated with `new`");
        if (this.description = "Output Feedback", this.name = "ofb", t) {
            if (16 != t.length) throw new Error("invalid initialation vector size (must be 16 bytes)")
        } else t = v(16);
        this._lastPrecipher = a(t, !0), this._lastPrecipherIndex = 16, this._aes = new Ds(e)
    }

    function Us(e) {
        if (!(this instanceof Us)) throw Error("Counter must be instanitated with `new`");
        "number" == typeof (e = 0 === e || e ? e : 1) ? (this._counter = v(16), this.setValue(e)) : this.setBytes(e)
    }

    function Fs(e, t) {
        if (!(this instanceof Fs)) throw Error("AES must be instanitated with `new`");
        this.description = "Counter", this.name = "ctr", t instanceof Us || (t = new Us(t)), this._counter = t, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new Ds(e)
    }

    Ds.prototype._prepare = function () {
        var e = fs[this.key.length];
        if (null == e) throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        this._Ke = [], this._Kd = [];
        for (var t = 0; t <= e; t++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
        for (var i, r = 4 * (e + 1), s = this.key.length / 4, a = Ls(this.key), t = 0; t < s; t++) this._Ke[i = t >> 2][t % 4] = a[t], this._Kd[e - i][t % 4] = a[t];
        for (var n, o = 0, l = s; l < r;) {
            if (n = a[s - 1], a[0] ^= D[n >> 16 & 255] << 24 ^ D[n >> 8 & 255] << 16 ^ D[255 & n] << 8 ^ D[n >> 24 & 255] ^ ms[o] << 24, o += 1, 8 != s) for (t = 1; t < s; t++) a[t] ^= a[t - 1]; else {
                for (t = 1; t < s / 2; t++) a[t] ^= a[t - 1];
                for (n = a[s / 2 - 1], a[s / 2] ^= D[255 & n] ^ D[n >> 8 & 255] << 8 ^ D[n >> 16 & 255] << 16 ^ D[n >> 24 & 255] << 24, t = s / 2 + 1; t < s; t++) a[t] ^= a[t - 1]
            }
            for (t = 0; t < s && l < r;) this._Ke[d = l >> 2][h = l % 4] = a[t], this._Kd[e - d][h] = a[t++], l++
        }
        for (var d = 1; d < e; d++) for (var h = 0; h < 4; h++) n = this._Kd[d][h], this._Kd[d][h] = Ts[n >> 24 & 255] ^ ks[n >> 16 & 255] ^ xs[n >> 8 & 255] ^ Cs[255 & n]
    }, Ds.prototype.encrypt = function (e) {
        if (16 != e.length) throw new Error("invalid plaintext size (must be 16 bytes)");
        for (var t = this._Ke.length - 1, i = [0, 0, 0, 0], r = Ls(e), s = 0; s < 4; s++) r[s] ^= this._Ke[0][s];
        for (var a = 1; a < t; a++) {
            for (s = 0; s < 4; s++) i[s] = ys[r[s] >> 24 & 255] ^ As[r[(s + 1) % 4] >> 16 & 255] ^ bs[r[(s + 2) % 4] >> 8 & 255] ^ vs[255 & r[(s + 3) % 4]] ^ this._Ke[a][s];
            r = i.slice()
        }
        for (var n, o = v(16), s = 0; s < 4; s++) n = this._Ke[t][s], o[4 * s] = 255 & (D[r[s] >> 24 & 255] ^ n >> 24), o[4 * s + 1] = 255 & (D[r[(s + 1) % 4] >> 16 & 255] ^ n >> 16), o[4 * s + 2] = 255 & (D[r[(s + 2) % 4] >> 8 & 255] ^ n >> 8), o[4 * s + 3] = 255 & (D[255 & r[(s + 3) % 4]] ^ n);
        return o
    }, Ds.prototype.decrypt = function (e) {
        if (16 != e.length) throw new Error("invalid ciphertext size (must be 16 bytes)");
        for (var t = this._Kd.length - 1, i = [0, 0, 0, 0], r = Ls(e), s = 0; s < 4; s++) r[s] ^= this._Kd[0][s];
        for (var a = 1; a < t; a++) {
            for (s = 0; s < 4; s++) i[s] = _s[r[s] >> 24 & 255] ^ ws[r[(s + 3) % 4] >> 16 & 255] ^ Ss[r[(s + 2) % 4] >> 8 & 255] ^ Es[255 & r[(s + 1) % 4]] ^ this._Kd[a][s];
            r = i.slice()
        }
        for (var n, o = v(16), s = 0; s < 4; s++) n = this._Kd[t][s], o[4 * s] = 255 & (gs[r[s] >> 24 & 255] ^ n >> 24), o[4 * s + 1] = 255 & (gs[r[(s + 3) % 4] >> 16 & 255] ^ n >> 16), o[4 * s + 2] = 255 & (gs[r[(s + 2) % 4] >> 8 & 255] ^ n >> 8), o[4 * s + 3] = 255 & (gs[255 & r[(s + 1) % 4]] ^ n);
        return o
    }, Is.prototype.encrypt = function (e) {
        if ((e = a(e)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        for (var t = v(e.length), i = v(16), r = 0; r < e.length; r += 16) L(e, i, 0, r, r + 16), L(i = this._aes.encrypt(i), t, r);
        return t
    }, Is.prototype.decrypt = function (e) {
        if ((e = a(e)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        for (var t = v(e.length), i = v(16), r = 0; r < e.length; r += 16) L(e, i, 0, r, r + 16), L(i = this._aes.decrypt(i), t, r);
        return t
    }, Rs.prototype.encrypt = function (e) {
        if ((e = a(e)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        for (var t = v(e.length), i = v(16), r = 0; r < e.length; r += 16) {
            L(e, i, 0, r, r + 16);
            for (var s = 0; s < 16; s++) i[s] ^= this._lastCipherblock[s];
            this._lastCipherblock = this._aes.encrypt(i), L(this._lastCipherblock, t, r)
        }
        return t
    }, Rs.prototype.decrypt = function (e) {
        if ((e = a(e)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        for (var t = v(e.length), i = v(16), r = 0; r < e.length; r += 16) {
            L(e, i, 0, r, r + 16);
            for (var i = this._aes.decrypt(i), s = 0; s < 16; s++) t[r + s] = i[s] ^ this._lastCipherblock[s];
            L(e, this._lastCipherblock, 0, r, r + 16)
        }
        return t
    }, Ps.prototype.encrypt = function (e) {
        if (e.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)");
        for (var t = a(e, !0), i = 0; i < t.length; i += this.segmentSize) {
            for (var r = this._aes.encrypt(this._shiftRegister), s = 0; s < this.segmentSize; s++) t[i + s] ^= r[s];
            L(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), L(t, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize)
        }
        return t
    }, Ps.prototype.decrypt = function (e) {
        if (e.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        for (var t = a(e, !0), i = 0; i < t.length; i += this.segmentSize) {
            for (var r = this._aes.encrypt(this._shiftRegister), s = 0; s < this.segmentSize; s++) t[i + s] ^= r[s];
            L(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), L(e, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize)
        }
        return t
    }, Bs.prototype.decrypt = Bs.prototype.encrypt = function (e) {
        for (var t = a(e, !0), i = 0; i < t.length; i++) 16 === this._lastPrecipherIndex && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), t[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        return t
    }, Us.prototype.setValue = function (e) {
        if ("number" != typeof e || parseInt(e) != e) throw new Error("invalid counter value (must be an integer)");
        if (e > Number.MAX_SAFE_INTEGER) throw new Error("integer value out of safe range");
        for (var t = 15; 0 <= t; --t) this._counter[t] = e % 256, e = parseInt(e / 256)
    }, Us.prototype.setBytes = function (e) {
        if (16 != (e = a(e, !0)).length) throw new Error("invalid counter bytes size (must be 16 bytes)");
        this._counter = e
    }, Us.prototype.increment = function () {
        for (var e = 15; 0 <= e; e--) {
            if (255 !== this._counter[e]) {
                this._counter[e]++;
                break
            }
            this._counter[e] = 0
        }
    };
    Fs.prototype.decrypt = Fs.prototype.encrypt = function (e) {
        for (var t = a(e, !0), i = 0; i < t.length; i++) 16 === this._remainingCounterIndex && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), t[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        return t
    };
    const Ms = {
        AES: Ds,
        Counter: Us,
        ModeOfOperation: {ecb: Is, cbc: Rs, cfb: Ps, ofb: Bs, ctr: Fs},
        utils: {hex: ps, utf8: us},
        padding: {
            pkcs7: {
                pad: function (e) {
                    var t = 16 - (e = a(e, !0)).length % 16, i = v(e.length + t);
                    L(e, i);
                    for (var r = e.length; r < i.length; r++) i[r] = t;
                    return i
                }, strip: function (e) {
                    if ((e = a(e, !0)).length < 16) throw new Error("PKCS#7 invalid length");
                    var t = e[e.length - 1];
                    if (16 < t) throw new Error("PKCS#7 padding byte out of range");
                    for (var i = e.length - t, r = 0; r < t; r++) if (e[i + r] !== t) throw new Error("PKCS#7 invalid padding byte");
                    var s = v(i);
                    return L(e, s, 0, 0, i), s
                }
            }
        },
        _arrayTest: {coerceArray: a, createArray: v, copyArray: L}
    };
    const Os = 16,
        Ns = [214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5, 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153, 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98, 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166, 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168, 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53, 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135, 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158, 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161, 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227, 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111, 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81, 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216, 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176, 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132, 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72],
        js = [462357, 472066609, 943670861, 1415275113, 1886879365, 2358483617, 2830087869, 3301692121, 3773296373, 4228057617, 404694573, 876298825, 1347903077, 1819507329, 2291111581, 2762715833, 3234320085, 3705924337, 4177462797, 337322537, 808926789, 1280531041, 1752135293, 2223739545, 2695343797, 3166948049, 3638552301, 4110090761, 269950501, 741554753, 1213159005, 1684763257];

    function zs(i) {
        const r = [];
        for (let e = 0, t = i.length; e < t; e += 2) r.push(parseInt(i.substr(e, 2), 16));
        return r
    }

    function Gs(e, t) {
        t &= 31;
        return e << t | e >>> 32 - t
    }

    function Hs(e) {
        return (255 & Ns[e >>> 24 & 255]) << 24 | (255 & Ns[e >>> 16 & 255]) << 16 | (255 & Ns[e >>> 8 & 255]) << 8 | 255 & Ns[255 & e]
    }

    function Ws(e) {
        return e ^ Gs(e, 2) ^ Gs(e, 10) ^ Gs(e, 18) ^ Gs(e, 24)
    }

    function Vs(e) {
        return e ^ Gs(e, 13) ^ Gs(e, 23)
    }

    function Ks(t, i, r, e) {
        let {
            padding: s = "pkcs#7",
            mode: a,
            iv: n = [],
            output: o = "string"
        } = 3 < arguments.length && void 0 !== e ? e : {};
        if ("cbc" === a && 16 !== (n = "string" == typeof n ? zs(n) : n).length) throw new Error("iv is invalid");
        if (16 !== (i = "string" == typeof i ? zs(i) : i).length) throw new Error("key is invalid");
        if (t = "string" == typeof t ? (0 !== r ? function (i) {
            const r = [];
            for (let e = 0, t = i.length; e < t; e++) {
                var s = i.codePointAt(e);
                if (s <= 127) r.push(s); else if (s <= 2047) r.push(192 | s >>> 6), r.push(128 | 63 & s); else if (s <= 55295 || 57344 <= s && s <= 65535) r.push(224 | s >>> 12), r.push(128 | s >>> 6 & 63), r.push(128 | 63 & s); else {
                    if (!(65536 <= s && s <= 1114111)) throw r.push(s), new Error("input is not supported");
                    e++, r.push(240 | s >>> 18 & 28), r.push(128 | s >>> 12 & 63), r.push(128 | s >>> 6 & 63), r.push(128 | 63 & s)
                }
            }
            return r
        } : zs)(t) : [...t], ("pkcs#5" === s || "pkcs#7" === s) && 0 !== r) {
            const i = Os - t.length % Os;
            for (let e = 0; e < i; e++) t.push(i)
        }
        var l = new Array(32);
        {
            var d = i, h = l;
            e = r;
            const b = new Array(4), v = new Array(4);
            for (let e = 0; e < 4; e++) v[0] = 255 & d[0 + 4 * e], v[1] = 255 & d[1 + 4 * e], v[2] = 255 & d[2 + 4 * e], v[3] = 255 & d[3 + 4 * e], b[e] = v[0] << 24 | v[1] << 16 | v[2] << 8 | v[3];
            b[0] ^= 2746333894, b[1] ^= 1453994832, b[2] ^= 1736282519, b[3] ^= 2993693404;
            for (let e, t = 0; t < 32; t += 4) e = b[1] ^ b[2] ^ b[3] ^ js[t + 0], h[t + 0] = b[0] ^= Vs(Hs(e)), e = b[2] ^ b[3] ^ b[0] ^ js[t + 1], h[t + 1] = b[1] ^= Vs(Hs(e)), e = b[3] ^ b[0] ^ b[1] ^ js[t + 2], h[t + 2] = b[2] ^= Vs(Hs(e)), e = b[0] ^ b[1] ^ b[2] ^ js[t + 3], h[t + 3] = b[3] ^= Vs(Hs(e));
            if (0 === e) for (let e, t = 0; t < 16; t++) e = h[t], h[t] = h[31 - t], h[31 - t] = e
        }
        const c = [];
        let u = n, p = t.length, f = 0;
        for (; p >= Os;) {
            const i = t.slice(f, f + 16), s = new Array(16);
            if ("cbc" === a) for (let e = 0; e < Os; e++) 0 !== r && (i[e] ^= u[e]);
            {
                m = void 0;
                g = void 0;
                y = void 0;
                var m = i;
                var g = s;
                var y = l;
                const _ = new Array(4), w = new Array(4);
                for (let e = 0; e < 4; e++) w[0] = 255 & m[4 * e], w[1] = 255 & m[4 * e + 1], w[2] = 255 & m[4 * e + 2], w[3] = 255 & m[4 * e + 3], _[e] = w[0] << 24 | w[1] << 16 | w[2] << 8 | w[3];
                for (let e, t = 0; t < 32; t += 4) e = _[1] ^ _[2] ^ _[3] ^ y[t + 0], _[0] ^= Ws(Hs(e)), e = _[2] ^ _[3] ^ _[0] ^ y[t + 1], _[1] ^= Ws(Hs(e)), e = _[3] ^ _[0] ^ _[1] ^ y[t + 2], _[2] ^= Ws(Hs(e)), e = _[0] ^ _[1] ^ _[2] ^ y[t + 3], _[3] ^= Ws(Hs(e));
                for (let e = 0; e < 16; e += 4) g[e] = _[3 - e / 4] >>> 24 & 255, g[e + 1] = _[3 - e / 4] >>> 16 & 255, g[e + 2] = _[3 - e / 4] >>> 8 & 255, g[e + 3] = 255 & _[3 - e / 4]
            }
            for (let e = 0; e < Os; e++) "cbc" === a && 0 === r && (s[e] ^= u[e]), c[f + e] = s[e];
            "cbc" === a && (u = 0 !== r ? s : i), p -= Os, f += Os
        }
        if (("pkcs#5" === s || "pkcs#7" === s) && 0 === r) {
            const t = c.length, i = c[t - 1];
            for (let e = 1; e <= i; e++) if (c[t - e] !== i) throw new Error("padding is invalid");
            c.splice(t - i, i)
        }
        {
            if ("array" === o) return c;
            if (0 !== r) return c.map(e => 1 === (e = e.toString(16)).length ? "0" + e : e).join("");
            {
                var A = c;
                const S = [];
                for (let e = 0, t = A.length; e < t; e++) 240 <= A[e] && A[e] <= 247 ? (S.push(String.fromCodePoint(((7 & A[e]) << 18) + ((63 & A[e + 1]) << 12) + ((63 & A[e + 2]) << 6) + (63 & A[e + 3]))), e += 3) : 224 <= A[e] && A[e] <= 239 ? (S.push(String.fromCodePoint(((15 & A[e]) << 12) + ((63 & A[e + 1]) << 6) + (63 & A[e + 2]))), e += 2) : 192 <= A[e] && A[e] <= 223 ? (S.push(String.fromCodePoint(((31 & A[e]) << 6) + (63 & A[e + 1]))), e++) : S.push(String.fromCodePoint(A[e]));
                return S.join("")
            }
        }
    }

    class $s extends Ur {
        constructor(e) {
            super(e), this.input = new Nr(this.demux()), e.debug.log("FlvDemux", "init")
        }

        destroy() {
            super.destroy(), this.input = null, this.player.debug.log("FlvDemux", "destroy")
        }

        dispatch(e) {
            this.input ? this.input.write(e) : this.player && this.player.debug.warn("FlvDemux", "dispatch() this.input is null")
        }

        * demux() {
            yield 9;
            const e = new ArrayBuffer(4), t = new Uint8Array(e), i = new Uint32Array(e), r = this.player;
            for (; ;) {
                if (!this.input) return;
                t[3] = 0;
                const e = yield 15, l = e[4];
                t[0] = e[7], t[1] = e[6], t[2] = e[5];
                var s = i[0], a = (t[0] = e[10], t[1] = e[9], t[2] = e[8], t[3] = e[11], i[0]), n = (yield s).slice();
                if (!r) return;
                switch (l) {
                    case 8:
                        r._opt.hasAudio && (r.updateStats({abps: n.byteLength}), 0 < n.byteLength && this._doDecode(n, 1, a));
                        break;
                    case 9:
                        if (r._opt.hasVideo) {
                            r.updateStats({vbps: n.byteLength, dts: a});
                            const t = n[0] >> 4 & 15, d = 1 == t;
                            if (1 != t && 2 != t && r.debug.warn("FlvDemux", `frameType is ${t} is not keyFrame or interFrame`), d && this.calcIframeIntervalTimestamp(a), 0 < n.byteLength) {
                                i[0] = n[4], i[1] = n[3], i[2] = n[2], i[3] = 0;
                                var o = i[0];
                                r._times.demuxStart || (r._times.demuxStart = p());
                                let e = n;
                                r._opt.isCrypto ? r._opt.cryptoKey && 0 < r._opt.cryptoKey.byteLength && r._opt.cryptoIV && 0 < r._opt.cryptoIV.byteLength ? e = function (t, i, r) {
                                    i = new Uint8Array(i), r = new Uint8Array(r);
                                    const s = t.byteLength;
                                    let a = 5;
                                    for (; a < s;) {
                                        o = (o = t.slice(a, a + 4))[3] | o[2] << 8 | o[1] << 16 | o[0] << 24;
                                        if (o > s) break;
                                        var n = t[a + 4];
                                        if (1 == (n &= 31) || 5 == n) {
                                            const s = t.slice(a + 4 + 2, a + 4 + o);
                                            let e = new Ms.ModeOfOperation.ctr(i, new Ms.Counter(r));
                                            n = e.decrypt(s);
                                            e = null, t.set(n, a + 4 + 2)
                                        }
                                        a = a + 4 + o
                                    }
                                    var o;
                                    return t
                                }(n, r._opt.cryptoKey, r._opt.cryptoIV) : r.debug.error("FlvDemux", `cryptoKey.length is ${r._opt.cryptoKey && r._opt.cryptoKey.byteLength} or cryptoIV.length is ${r._opt.cryptoIV && r._opt.cryptoIV.byteLength} null`) : r._opt.isSm4Crypto && r._opt.sm4CryptoKey && d && (e = function (e, t) {
                                    const i = e.byteLength;
                                    let r = 5;
                                    for (; r < i;) {
                                        a = (a = e.slice(r, r + 4))[3] | a[2] << 8 | a[1] << 16 | a[0] << 24;
                                        if (a > i) break;
                                        var s = e[r + 4];
                                        if (1 == (s &= 31) || 5 == s) {
                                            const i = Ks(e.slice(r + 4 + 2, r + 4 + a), t, 0, {
                                                padding: "none",
                                                output: "array"
                                            });
                                            e.set(i, r + 4 + 2)
                                        }
                                        r = r + 4 + a
                                    }
                                    var a;
                                    return e
                                }(n, r._opt.sm4CryptoKey)), r._opt.isEmitSEI && this.findSei(e, a), this._doDecode(e, 2, a, d, o)
                            }
                        }
                        break;
                    case 18:
                        if (this.player.isRecordTypeFlv()) {
                            const e = new Uint8Array(n);
                            this.player.recorder.addMetaData(e)
                        }
                        const e = Pr(n);
                        e && e.onMetaData && r.updateMetaData(e.onMetaData);
                        break;
                    default:
                        r.debug.warn("FlvDemux", "demux() type is " + l)
                }
            }
        }

        close() {
            this.input = null
        }

        getInputByteLength() {
            let e = 0;
            return e = this.input && this.input.buffer ? this.input.buffer.byteLength : e
        }
    }

    class qs extends Ur {
        constructor(e) {
            super(e), e.debug.log("M7sDemux", "init")
        }

        destroy() {
            super.destroy(), this.player.debug.log("M7sDemux", "destroy")
        }

        dispatch(e) {
            const t = this.player, i = new DataView(e), r = i.getUint8(0), s = i.getUint32(1, !1);
            switch (r) {
                case 1:
                    if (t._opt.hasAudio) {
                        const i = new Uint8Array(e, 5);
                        t.updateStats({abps: i.byteLength}), 0 < i.byteLength && this._doDecode(i, r, s)
                    }
                    break;
                case 2:
                    var a, n;
                    t._opt.hasVideo && (t._times.demuxStart || (t._times.demuxStart = p()), 5 < i.byteLength ? (a = new Uint8Array(e, 5), n = i.getUint8(5) >> 4 == 1, t.updateStats({
                        vbps: a.byteLength,
                        dts: s
                    }), 0 < a.byteLength && (n && this.calcIframeIntervalTimestamp(s), t._opt.isEmitSEI && this.findSei(a, s), this._doDecode(a, r, s, n))) : this.player.debug.warn("M7sDemux", "dispatch", "dv byteLength is", i.byteLength))
            }
        }
    }

    class Ys extends $s {
        constructor(e) {
            super(e), e.debug.log("WebTransportDemux", "init")
        }

        destroy() {
            this.player.debug.log("WebTransportDemux", "destroy"), super.destroy()
        }
    }

    var s = pt(ft(function (e) {
        e.exports = function (e, t, i) {
            return t in e ? Object.defineProperty(e, t, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = i, e
        }, e.exports.__esModule = !0, e.exports.default = e.exports
    }));

    class Js extends Ur {
        constructor(e) {
            super(e), s(this, "TAG_NAME", "NakedFlowDemux"), this.lastBuf = null, this.vps = null, this.sps = null, this.pps = null, this.streamVideoType = null, this.streamAudioType = null, this.tempNaluBufferList = new Uint8Array(0), this.localDts = 0, this.isSendSeqHeader = !1, this.isSendAACSeqHeader = !1, e.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.lastBuf = null, this.vps = null, this.sps = null, this.pps = null, this.streamVideoType = null, this.streamAudioType = null, this.tempNaluBufferList = new Uint8Array(0), this.localDts = 0, this.localAudioDts = 0, this.isSendSeqHeader = !1, this.isSendAACSeqHeader = !1, this.player.debug.log(this.TAG_NAME, "destroy")
        }

        dispatch(e) {
            this.player;
            e = new Uint8Array(e);
            this.extractNALu$2(e)
        }

        addNaluToBuffer(e) {
            const t = e.byteLength + this.tempNaluBufferList.byteLength, i = new Uint8Array(t);
            i.set(this.tempNaluBufferList, 0), i.set(e, this.tempNaluBufferList.byteLength), this.tempNaluBufferList = i
        }

        downloadNakedFlowFile() {
            var e = new Blob([this.tempNaluBufferList]);
            try {
                const t = document.createElement("a");
                t.href = window.URL.createObjectURL(e), t.download = Date.now() + ".h264", t.click(), window.URL.revokeObjectURL(t.href)
            } catch (e) {
                console.error("downloadTempNalu", e)
            }
        }

        getNaluDts() {
            var e = this.player._opt.nakedFlowFps;
            return this.localDts = this.localDts + parseInt(1e3 / e), this.localDts
        }

        getNaluAudioDts() {
            var e = this.player.audio.audioContext.sampleRate, t = this.player.audio.audioBufferSize;
            return this.localDts + parseInt(t / e * 1e3)
        }

        extractNALu(e) {
            let t, i, r = 0, s = e.byteLength, a = 0, n = [];
            for (; r < s;) switch (t = e[r++], a) {
                case 0:
                    0 === t && (a = 1);
                    break;
                case 1:
                    a = 0 === t ? 2 : 0;
                    break;
                case 2:
                case 3:
                    a = 0 === t ? 3 : (1 === t && r < s && (e[r], i && n.push(e.subarray(i, r - a - 1)), i = r), 0)
            }
            return i && n.push(e.subarray(i, s)), n
        }

        extractNALu$2(t) {
            let a = null;
            if (t && !(t.byteLength < 1)) {
                this.lastBuf ? ((a = new Uint8Array(t.byteLength + this.lastBuf.length)).set(this.lastBuf), a.set(new Uint8Array(t), this.lastBuf.length)) : a = new Uint8Array(t);
                let i = 0, r = -1, s = -2;
                const n = new Array;
                for (let t = 0; t < a.length; t += 2) {
                    const e = a[t], o = a[t + 1];
                    0 == r && 0 == e && 0 == o ? n.push(t - 1) : 1 == o && 0 == e && 0 == r && 0 == s && n.push(t - 2), s = e, r = o
                }
                if (1 < n.length) for (let t = 0; t < n.length - 1; ++t) {
                    const e = a.subarray(n[t], n[t + 1] + 1);
                    this.handleNALu(e), i = n[t + 1]
                } else i = n[0];
                if (0 != i && i < a.length) this.lastBuf = a.subarray(i); else {
                    this.lastBuf || (this.lastBuf = a);
                    const e = new Uint8Array(this.lastBuf.length + t.byteLength);
                    e.set(this.lastBuf), e.set(new Uint8Array(t), this.lastBuf.length), this.lastBuf = e
                }
            }
        }

        handleNALu(e) {
            e.byteLength < 4 ? this.player.debug.warn(this.TAG_NAME, `handleNALu nalu byteLength is ${e.byteLength} <= 4`) : (e = e.slice(4), this.handleVideoNalu(e))
        }

        handleVideoNalu(e) {
            const t = new Uint8Array(e);
            if (this.streamVideoType || (this.streamVideoType = function (e) {
                let t = null, i = 31 & e[0];
                return (t = 7 !== i && 8 !== i ? t : _e) || (32 !== (i = (126 & e[0]) >> 1) && 33 !== i && 34 !== i || (t = we)), t
            }(t)), this.streamVideoType === _e) {
                const e = this.handleAddNaluStartCode(t), i = this.extractNALu(e);
                if (0 === i.length) this.player.debug.warn(this.TAG_NAME, "handleVideoNalu", "naluList.length === 0"); else {
                    const r = [];
                    if (i.forEach(e => {
                        var t = fr(e);
                        8 === t || 7 === t ? this.handleVideoH264Nalu(e) : gr(t) && r.push(e)
                    }), 1 === r.length) this.handleVideoH264Nalu(r[0]); else {
                        const e = function (t) {
                            if (0 === t.length) return !1;
                            var i = fr(t[0]);
                            for (let e = 1; e < t.length; e++) if (i !== fr(t[e])) return !1;
                            return !0
                        }(r);
                        if (e) {
                            const e = fr(r[0]), t = 5 === e;
                            this.handleVideoH264NaluList(r, t, e)
                        } else r.forEach(e => {
                            this.handleVideoH264Nalu(e)
                        })
                    }
                }
            } else if (this.streamVideoType === we) {
                const e = this.handleAddNaluStartCode(t), s = this.extractNALu(e);
                if (0 === s.length) this.player.debug.warn(this.TAG_NAME, "handleVideoNalu", "h265 naluList.length === 0"); else {
                    const a = [];
                    if (s.forEach(e => {
                        var t = wr(e);
                        34 === t || 33 === t || 32 === t ? this.handleVideoH265Nalu(e) : Sr(t) && a.push(e)
                    }), 1 === a.length) this.handleVideoH265Nalu(a[0]); else {
                        const e = function (t) {
                            if (0 === t.length) return !1;
                            var i = wr(t[0]);
                            for (let e = 1; e < t.length; e++) if (i !== wr(t[e])) return !1;
                            return !0
                        }(a);
                        if (e) {
                            const e = wr(a[0]), t = Er(e);
                            this.handleVideoH265NaluList(a, t, e)
                        } else a.forEach(e => {
                            this.handleVideoH265Nalu(e)
                        })
                    }
                }
            } else this.player.debug.error(this.TAG_NAME, " this.streamVideoType is null")
        }

        extractH264PPS(e) {
            e = this.handleAddNaluStartCode(e);
            this.extractNALu(e).forEach(e => {
                mr(fr(e)) ? this.extractH264SEI(e) : this.handleVideoH264Nalu(e)
            })
        }

        extractH265PPS(e) {
            e = this.handleAddNaluStartCode(e);
            this.extractNALu(e).forEach(e => {
                39 === wr(e) ? this.extractH265SEI(e) : this.handleVideoH265Nalu(e)
            })
        }

        extractH264SEI(e) {
            e = this.handleAddNaluStartCode(e);
            this.extractNALu(e).forEach(e => {
                this.handleVideoH264Nalu(e)
            })
        }

        extractH265SEI(e) {
            e = this.handleAddNaluStartCode(e);
            this.extractNALu(e).forEach(e => {
                this.handleVideoH265Nalu(e)
            })
        }

        handleAddNaluStartCode(e) {
            const t = [0, 0, 0, 1], i = new Uint8Array(e.length + t.length);
            return i.set(t), i.set(e, t.length), i
        }

        handleAudioAACNalu(t) {
            if (t && !(t.byteLength < 1)) {
                this.streamAudioType || (this.streamAudioType = Se.AAC);
                let e = new Uint8Array(t);
                var i = e.slice(0, 7);
                if (e = e.slice(7), !this.isSendAACSeqHeader) {
                    const t = (192 & i[2]) >> 6, e = (60 & i[2]) >> 2, r = (1 & i[2]) << 2 | (192 & i[3]) >> 6,
                        s = new Uint8Array([175, 0, t << 3 | (14 & e) >> 1, (1 & e) << 7 | r << 3]);
                    this.isSendAACSeqHeader = !0, this._doDecode(s, 1, 0, !1, 0)
                }
                const r = this.getNaluAudioDts(), s = new Uint8Array(e.length + 2);
                s.set([175, 1], 0), s.set(e, 2), this._doDecode(s, 1, r, !1, 0)
            }
        }

        handleAudioG711ANalu(e) {
            if (e && !(e.byteLength < 1)) {
                this.streamAudioType || (this.streamAudioType = Se.ALAW);
                e = new Uint8Array(e);
                const t = this.getNaluAudioDts(), i = new Uint8Array(e.length + 1);
                i.set([114], 0), i.set(e, 1), this._doDecode(i, 1, t, !1, 0)
            }
        }

        handleAudioG711UNalu(e) {
            if (e && !(e.byteLength < 1)) {
                this.streamAudioType || (this.streamAudioType = Se.MULAW);
                e = new Uint8Array(e);
                const t = this.getNaluAudioDts(), i = new Uint8Array(e.length + 1);
                i.set([130], 0), i.set(e, 1), this._doDecode(i, 1, t, !1, 0)
            }
        }

        handleVideoH264Nalu(e) {
            const t = fr(e);
            switch (t) {
                case 7:
                    this.sps = e;
                    break;
                case 8:
                    this.pps = e
            }
            if (this.isSendSeqHeader) {
                if (this.sps && this.pps) {
                    const e = ur({sps: this.sps, pps: this.pps}), t = this.getNaluDts();
                    this._doDecode(e, 2, t, !0, 0), this.sps = null, this.pps = null
                }
                if (gr(t)) {
                    this.player._times.demuxStart || (this.player._times.demuxStart = p());
                    const r = 5 === t, i = this.getNaluDts(), s = function (e) {
                        let t = [];
                        t[0] = r ? 23 : 39, t[1] = 1, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e.byteLength >> 24 & 255, t[6] = e.byteLength >> 16 & 255, t[7] = e.byteLength >> 8 & 255, t[8] = 255 & e.byteLength;
                        const i = new Uint8Array(t.length + e.byteLength);
                        return i.set(t, 0), i.set(e, t.length), i
                    }(e);
                    this._preDoDecode(s, 2, i, r, 0)
                } else this.player.debug.warn(this.TAG_NAME, "handleVideoH264Nalu is avc seq head nalType is " + t)
            } else if (this.sps && this.pps) {
                this.isSendSeqHeader = !0;
                const e = ur({sps: this.sps, pps: this.pps});
                this._doDecode(e, 2, 0, !0, 0), this.sps = null, this.pps = null
            }
        }

        handleVideoH264NaluList(e, t, i) {
            if (this.isSendSeqHeader) {
                this.player._times.demuxStart || (this.player._times.demuxStart = p());
                const i = this.getNaluDts(), r = pr(e.reduce((e, t) => {
                    const i = Ar(e), r = Ar(t), s = new Uint8Array(i.byteLength + r.byteLength);
                    return s.set(i, 0), s.set(r, i.byteLength), s
                }), t);
                this._preDoDecode(r, 2, i, t, 0)
            } else this.player.debug.warn(this.TAG_NAME, "handleVideoH264NaluList isSendSeqHeader is false")
        }

        handleVideoH265Nalu(e) {
            const t = wr(e);
            switch (t) {
                case 32:
                    this.vps = e;
                    break;
                case 33:
                    this.sps = e;
                    break;
                case 34:
                    this.pps = e
            }
            if (this.isSendSeqHeader) {
                if (this.vps && this.sps && this.pps) {
                    const e = vr({vps: this.vps, sps: this.sps, pps: this.pps}), t = this.getNaluDts();
                    this._doDecode(e, 2, t, !0, 0), this.vps = null, this.sps = null, this.pps = null
                }
                if (Sr(t)) {
                    this.player._times.demuxStart || (this.player._times.demuxStart = p());
                    const r = Er(t), i = this.getNaluDts(), s = function (e) {
                        let t = [];
                        t[0] = r ? 28 : 44, t[1] = 1, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e.byteLength >> 24 & 255, t[6] = e.byteLength >> 16 & 255, t[7] = e.byteLength >> 8 & 255, t[8] = 255 & e.byteLength;
                        const i = new Uint8Array(t.length + e.byteLength);
                        return i.set(t, 0), i.set(e, t.length), i
                    }(e);
                    this._preDoDecode(s, 2, i, r, 0)
                }
            } else if (this.vps && this.sps && this.pps) {
                this.isSendSeqHeader = !0;
                const e = vr({vps: this.vps, sps: this.sps, pps: this.pps});
                this._doDecode(e, 2, 0, !0, 0), this.vps = null, this.sps = null, this.pps = null
            }
        }

        handleVideoH265NaluList(e, t, i) {
            if (this.isSendSeqHeader) {
                this.player._times.demuxStart || (this.player._times.demuxStart = p());
                const i = this.getNaluDts(), r = _r(e.reduce((e, t) => {
                    const i = Ar(e), r = Ar(t), s = new Uint8Array(i.byteLength + r.byteLength);
                    return s.set(i, 0), s.set(r, i.byteLength), s
                }), t);
                this._preDoDecode(r, 2, i, t, 0)
            } else this.player.debug.warn(this.TAG_NAME, "handleVideoH265NaluList isSendSeqHeader is false")
        }

        _preDoDecode(e, t, i, r, s) {
            this.player.updateStats({
                vbps: e.byteLength,
                dts: i
            }), r && this.calcIframeIntervalTimestamp(i), this.player._opt.isEmitSEI && this.findSei(e, i), this._doDecode(e, 2, i, r, s)
        }

        getInputByteLength() {
            let e = 0;
            return e = this.lastBuf ? this.lastBuf.byteLength : e
        }
    }

    class Qs extends Ur {
        constructor(e) {
            super(e), (this.player = e).debug.log("EmptyDemux", "init")
        }

        destroy() {
            super.destroy(), this.player.debug.log("EmptyDemux", "destroy")
        }
    }

    var I = ft(function (e, t) {
        function c(e) {
            if (!(e instanceof ArrayBuffer)) throw"Needs an array buffer";
            this.buffer = e, this.dataview = new DataView(e), this.position = 0
        }

        function l(e, t, i) {
            this._byteOffset = t || 0, e instanceof ArrayBuffer ? this.buffer = e : "object" == typeof e ? (this.dataView = e, t && (this._byteOffset += t)) : this.buffer = new ArrayBuffer(e || 0), this.position = 0, this.endianness = null == i ? l.LITTLE_ENDIAN : i
        }

        function i(e) {
            this.buffers = [], this.bufferIndex = -1, e && (this.insertBuffer(e), this.bufferIndex = 0)
        }

        function r() {
            var s = [],
                r = (s[3] = "ES_Descriptor", s[4] = "DecoderConfigDescriptor", s[5] = "DecoderSpecificInfo", s[6] = "SLConfigDescriptor", this.getDescriptorName = function (e) {
                    return s[e]
                }, this), a = {};
            return this.parseOneDescriptor = function (e) {
                for (var t = 0, i = e.readUint8(), r = e.readUint8(); 128 & r;) t = (127 & r) << 7, r = e.readUint8();
                return u.debug("MPEG4DescriptorParser", "Found " + (s[i] || "Descriptor " + i) + ", size " + (t += 127 & r) + " at position " + e.getPosition()), (i = new (s[i] ? a[s[i]] : a.Descriptor)(t)).parse(e), i
            }, a.Descriptor = function (e, t) {
                this.tag = e, this.size = t, this.descs = []
            }, a.Descriptor.prototype.parse = function (e) {
                this.data = e.readUint8Array(this.size)
            }, a.Descriptor.prototype.findDescriptor = function (e) {
                for (var t = 0; t < this.descs.length; t++) if (this.descs[t].tag == e) return this.descs[t];
                return null
            }, a.Descriptor.prototype.parseRemainingDescriptors = function (e) {
                for (var t = e.position; e.position < t + this.size;) {
                    var i = r.parseOneDescriptor(e);
                    this.descs.push(i)
                }
            }, a.ES_Descriptor = function (e) {
                a.Descriptor.call(this, 3, e)
            }, a.ES_Descriptor.prototype = new a.Descriptor, a.ES_Descriptor.prototype.parse = function (e) {
                var t;
                this.ES_ID = e.readUint16(), this.flags = e.readUint8(), this.size -= 3, 128 & this.flags ? (this.dependsOn_ES_ID = e.readUint16(), this.size -= 2) : this.dependsOn_ES_ID = 0, 64 & this.flags ? (t = e.readUint8(), this.URL = e.readString(t), this.size -= t + 1) : this.URL = "", 32 & this.flags ? (this.OCR_ES_ID = e.readUint16(), this.size -= 2) : this.OCR_ES_ID = 0, this.parseRemainingDescriptors(e)
            }, a.ES_Descriptor.prototype.getOTI = function (e) {
                var t = this.findDescriptor(4);
                return t ? t.oti : 0
            }, a.ES_Descriptor.prototype.getAudioConfig = function (e) {
                var t = this.findDescriptor(4);
                if (!t) return null;
                var i, t = t.findDescriptor(5);
                return t && t.data ? 31 === (i = (248 & t.data[0]) >> 3) && 2 <= t.data.length ? 32 + ((7 & t.data[0]) << 3) + ((224 & t.data[1]) >> 5) : i : null
            }, a.DecoderConfigDescriptor = function (e) {
                a.Descriptor.call(this, 4, e)
            }, a.DecoderConfigDescriptor.prototype = new a.Descriptor, a.DecoderConfigDescriptor.prototype.parse = function (e) {
                this.oti = e.readUint8(), this.streamType = e.readUint8(), this.bufferSize = e.readUint24(), this.maxBitrate = e.readUint32(), this.avgBitrate = e.readUint32(), this.size -= 13, this.parseRemainingDescriptors(e)
            }, a.DecoderSpecificInfo = function (e) {
                a.Descriptor.call(this, 5, e)
            }, a.DecoderSpecificInfo.prototype = new a.Descriptor, a.SLConfigDescriptor = function (e) {
                a.Descriptor.call(this, 6, e)
            }, a.SLConfigDescriptor.prototype = new a.Descriptor, this
        }

        function s() {
        }

        function a() {
        }

        function k(e) {
            this.stream = e || new i, this.boxes = [], this.mdats = [], this.moofs = [], this.isProgressive = !1, this.moovStartFound = !1, this.onMoovStart = null, this.moovStartSent = !1, this.onReady = null, this.readySent = !1, this.onSegment = null, this.onSamples = null, this.onError = null, this.sampleListBuilt = !1, this.fragmentedTracks = [], this.extractedTracks = [], this.isFragmentationInitialized = !1, this.sampleProcessingStarted = !1, this.nextMoofNumber = 0, this.itemListBuilt = !1, this.onSidx = null, this.sidxSent = !1
        }

        n = new Date, o = 4;
        var n, o, u = {
            setLogLevel: function (e) {
                o = e == this.debug ? 1 : e == this.info ? 2 : e == this.warn ? 3 : (this.error, 4)
            }, debug: function (e, t) {
                void 0 === console.debug && (console.debug = console.log), o <= 1 && console.debug("[" + u.getDurationString(new Date - n, 1e3) + "]", "[" + e + "]", t)
            }, log: function (e, t) {
                this.debug(e.msg)
            }, info: function (e, t) {
                o <= 2 && console.info("[" + u.getDurationString(new Date - n, 1e3) + "]", "[" + e + "]", t)
            }, warn: function (e, t) {
                o <= 3 && console.warn("[" + u.getDurationString(new Date - n, 1e3) + "]", "[" + e + "]", t)
            }, error: function (e, t) {
                o <= 4 && console.error("[" + u.getDurationString(new Date - n, 1e3) + "]", "[" + e + "]", t)
            }
        }, d = (u.getDurationString = function (e, t) {
            var i;

            function r(e, t) {
                for (var i = ("" + e).split("."); i[0].length < t;) i[0] = "0" + i[0];
                return i.join(".")
            }

            e < 0 ? (i = !0, e = -e) : i = !1;
            var e = e / (t || 1), t = Math.floor(e / 3600), s = (e -= 3600 * t, Math.floor(e / 60)),
                a = 1e3 * (e -= 60 * s);
            return a -= 1e3 * (e = Math.floor(e)), a = Math.floor(a), (i ? "-" : "") + t + ":" + r(s, 2) + ":" + r(e, 2) + "." + r(a, 3)
        }, u.printRanges = function (e) {
            var t = e.length;
            if (0 < t) {
                for (var i = "", r = 0; r < t; r++) 0 < r && (i += ","), i += "[" + u.getDurationString(e.start(r)) + "," + u.getDurationString(e.end(r)) + "]";
                return i
            }
            return "(empty)"
        }, t.Log = u, c.prototype.getPosition = function () {
            return this.position
        }, c.prototype.getEndPosition = function () {
            return this.buffer.byteLength
        }, c.prototype.getLength = function () {
            return this.buffer.byteLength
        }, c.prototype.seek = function (e) {
            e = Math.max(0, Math.min(this.buffer.byteLength, e));
            return this.position = isNaN(e) || !isFinite(e) ? 0 : e, !0
        }, c.prototype.isEos = function () {
            return this.getPosition() >= this.getEndPosition()
        }, c.prototype.readAnyInt = function (e, t) {
            var i = 0;
            if (this.position + e <= this.buffer.byteLength) {
                switch (e) {
                    case 1:
                        i = t ? this.dataview.getInt8(this.position) : this.dataview.getUint8(this.position);
                        break;
                    case 2:
                        i = t ? this.dataview.getInt16(this.position) : this.dataview.getUint16(this.position);
                        break;
                    case 3:
                        if (t) throw"No method for reading signed 24 bits values";
                        i = this.dataview.getUint8(this.position) << 16, i = (i |= this.dataview.getUint8(this.position + 1) << 8) | this.dataview.getUint8(this.position + 2);
                        break;
                    case 4:
                        i = t ? this.dataview.getInt32(this.position) : this.dataview.getUint32(this.position);
                        break;
                    case 8:
                        if (t) throw"No method for reading signed 64 bits values";
                        i = this.dataview.getUint32(this.position) << 32, i |= this.dataview.getUint32(this.position + 4);
                        break;
                    default:
                        throw"readInt method not implemented for size: " + e
                }
                return this.position += e, i
            }
            throw"Not enough bytes in buffer"
        }, c.prototype.readUint8 = function () {
            return this.readAnyInt(1, !1)
        }, c.prototype.readUint16 = function () {
            return this.readAnyInt(2, !1)
        }, c.prototype.readUint24 = function () {
            return this.readAnyInt(3, !1)
        }, c.prototype.readUint32 = function () {
            return this.readAnyInt(4, !1)
        }, c.prototype.readUint64 = function () {
            return this.readAnyInt(8, !1)
        }, c.prototype.readString = function (e) {
            if (this.position + e <= this.buffer.byteLength) {
                for (var t = "", i = 0; i < e; i++) t += String.fromCharCode(this.readUint8());
                return t
            }
            throw"Not enough bytes in buffer"
        }, c.prototype.readCString = function () {
            for (var e = []; ;) {
                var t = this.readUint8();
                if (0 === t) break;
                e.push(t)
            }
            return String.fromCharCode.apply(null, e)
        }, c.prototype.readInt8 = function () {
            return this.readAnyInt(1, !0)
        }, c.prototype.readInt16 = function () {
            return this.readAnyInt(2, !0)
        }, c.prototype.readInt32 = function () {
            return this.readAnyInt(4, !0)
        }, c.prototype.readInt64 = function () {
            return this.readAnyInt(8, !1)
        }, c.prototype.readUint8Array = function (e) {
            for (var t = new Uint8Array(e), i = 0; i < e; i++) t[i] = this.readUint8();
            return t
        }, c.prototype.readInt16Array = function (e) {
            for (var t = new Int16Array(e), i = 0; i < e; i++) t[i] = this.readInt16();
            return t
        }, c.prototype.readUint16Array = function (e) {
            for (var t = new Int16Array(e), i = 0; i < e; i++) t[i] = this.readUint16();
            return t
        }, c.prototype.readUint32Array = function (e) {
            for (var t = new Uint32Array(e), i = 0; i < e; i++) t[i] = this.readUint32();
            return t
        }, c.prototype.readInt32Array = function (e) {
            for (var t = new Int32Array(e), i = 0; i < e; i++) t[i] = this.readInt32();
            return t
        }, t.MP4BoxStream = c, (l.prototype = {}).getPosition = function () {
            return this.position
        }, l.prototype._realloc = function (e) {
            if (this._dynamicSize) {
                var t = this._byteOffset + this.position + e, i = this._buffer.byteLength;
                if (t <= i) t > this._byteLength && (this._byteLength = t); else {
                    for (i < 1 && (i = 1); i < t;) i *= 2;
                    var e = new ArrayBuffer(i), r = new Uint8Array(this._buffer);
                    new Uint8Array(e, 0, r.length).set(r), this.buffer = e, this._byteLength = t
                }
            }
        }, l.prototype._trimAlloc = function () {
            var e, t, i;
            this._byteLength != this._buffer.byteLength && (e = new ArrayBuffer(this._byteLength), t = new Uint8Array(e), i = new Uint8Array(this._buffer, 0, t.length), t.set(i), this.buffer = e)
        }, l.BIG_ENDIAN = !1, l.LITTLE_ENDIAN = !0, l.prototype._byteLength = 0, Object.defineProperty(l.prototype, "byteLength", {
            get: function () {
                return this._byteLength - this._byteOffset
            }
        }), Object.defineProperty(l.prototype, "buffer", {
            get: function () {
                return this._trimAlloc(), this._buffer
            }, set: function (e) {
                this._buffer = e, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength
            }
        }), Object.defineProperty(l.prototype, "byteOffset", {
            get: function () {
                return this._byteOffset
            }, set: function (e) {
                this._byteOffset = e, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength
            }
        }), Object.defineProperty(l.prototype, "dataView", {
            get: function () {
                return this._dataView
            }, set: function (e) {
                this._byteOffset = e.byteOffset, this._buffer = e.buffer, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._byteOffset + e.byteLength
            }
        }), l.prototype.seek = function (e) {
            e = Math.max(0, Math.min(this.byteLength, e));
            this.position = isNaN(e) || !isFinite(e) ? 0 : e
        }, l.prototype.isEof = function () {
            return this.position >= this._byteLength
        }, l.prototype.mapUint8Array = function (e) {
            this._realloc(+e);
            var t = new Uint8Array(this._buffer, this.byteOffset + this.position, e);
            return this.position += +e, t
        }, l.prototype.readInt32Array = function (e, t) {
            e = null == e ? this.byteLength - this.position / 4 : e;
            var i = new Int32Array(e);
            return l.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, e * i.BYTES_PER_ELEMENT), l.arrayToNative(i, null == t ? this.endianness : t), this.position += i.byteLength, i
        }, l.prototype.readInt16Array = function (e, t) {
            e = null == e ? this.byteLength - this.position / 2 : e;
            var i = new Int16Array(e);
            return l.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, e * i.BYTES_PER_ELEMENT), l.arrayToNative(i, null == t ? this.endianness : t), this.position += i.byteLength, i
        }, l.prototype.readInt8Array = function (e) {
            e = null == e ? this.byteLength - this.position : e;
            var t = new Int8Array(e);
            return l.memcpy(t.buffer, 0, this.buffer, this.byteOffset + this.position, e * t.BYTES_PER_ELEMENT), this.position += t.byteLength, t
        }, l.prototype.readUint32Array = function (e, t) {
            e = null == e ? this.byteLength - this.position / 4 : e;
            var i = new Uint32Array(e);
            return l.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, e * i.BYTES_PER_ELEMENT), l.arrayToNative(i, null == t ? this.endianness : t), this.position += i.byteLength, i
        }, l.prototype.readUint16Array = function (e, t) {
            e = null == e ? this.byteLength - this.position / 2 : e;
            var i = new Uint16Array(e);
            return l.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, e * i.BYTES_PER_ELEMENT), l.arrayToNative(i, null == t ? this.endianness : t), this.position += i.byteLength, i
        }, l.prototype.readUint8Array = function (e) {
            e = null == e ? this.byteLength - this.position : e;
            var t = new Uint8Array(e);
            return l.memcpy(t.buffer, 0, this.buffer, this.byteOffset + this.position, e * t.BYTES_PER_ELEMENT), this.position += t.byteLength, t
        }, l.prototype.readFloat64Array = function (e, t) {
            e = null == e ? this.byteLength - this.position / 8 : e;
            var i = new Float64Array(e);
            return l.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, e * i.BYTES_PER_ELEMENT), l.arrayToNative(i, null == t ? this.endianness : t), this.position += i.byteLength, i
        }, l.prototype.readFloat32Array = function (e, t) {
            e = null == e ? this.byteLength - this.position / 4 : e;
            var i = new Float32Array(e);
            return l.memcpy(i.buffer, 0, this.buffer, this.byteOffset + this.position, e * i.BYTES_PER_ELEMENT), l.arrayToNative(i, null == t ? this.endianness : t), this.position += i.byteLength, i
        }, l.prototype.readInt32 = function (e) {
            e = this._dataView.getInt32(this.position, null == e ? this.endianness : e);
            return this.position += 4, e
        }, l.prototype.readInt16 = function (e) {
            e = this._dataView.getInt16(this.position, null == e ? this.endianness : e);
            return this.position += 2, e
        }, l.prototype.readInt8 = function () {
            var e = this._dataView.getInt8(this.position);
            return this.position += 1, e
        }, l.prototype.readUint32 = function (e) {
            e = this._dataView.getUint32(this.position, null == e ? this.endianness : e);
            return this.position += 4, e
        }, l.prototype.readUint16 = function (e) {
            e = this._dataView.getUint16(this.position, null == e ? this.endianness : e);
            return this.position += 2, e
        }, l.prototype.readUint8 = function () {
            var e = this._dataView.getUint8(this.position);
            return this.position += 1, e
        }, l.prototype.readFloat32 = function (e) {
            e = this._dataView.getFloat32(this.position, null == e ? this.endianness : e);
            return this.position += 4, e
        }, l.prototype.readFloat64 = function (e) {
            e = this._dataView.getFloat64(this.position, null == e ? this.endianness : e);
            return this.position += 8, e
        }, l.endianness = 0 < new Int8Array(new Int16Array([1]).buffer)[0], l.memcpy = function (e, t, i, r, s) {
            e = new Uint8Array(e, t, s), t = new Uint8Array(i, r, s);
            e.set(t)
        }, l.arrayToNative = function (e, t) {
            return t == this.endianness ? e : this.flipArrayEndianness(e)
        }, l.nativeToEndian = function (e, t) {
            return this.endianness == t ? e : this.flipArrayEndianness(e)
        }, l.flipArrayEndianness = function (e) {
            for (var t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength), i = 0; i < e.byteLength; i += e.BYTES_PER_ELEMENT) for (var r = i + e.BYTES_PER_ELEMENT - 1, s = i; s < r; r--, s++) {
                var a = t[s];
                t[s] = t[r], t[r] = a
            }
            return e
        }, l.prototype.failurePosition = 0, String.fromCharCodeUint8 = function (e) {
            for (var t = [], i = 0; i < e.length; i++) t[i] = e[i];
            return String.fromCharCode.apply(null, t)
        }, l.prototype.readString = function (e, t) {
            return null == t || "ASCII" == t ? String.fromCharCodeUint8.apply(null, [this.mapUint8Array(null == e ? this.byteLength - this.position : e)]) : new TextDecoder(t).decode(this.mapUint8Array(e))
        }, l.prototype.readCString = function (e) {
            var t = this.byteLength - this.position, i = new Uint8Array(this._buffer, this._byteOffset + this.position),
                r = t;
            null != e && (r = Math.min(e, t));
            for (var s = 0; s < r && 0 !== i[s]; s++) ;
            var a = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(s)]);
            return null != e ? this.position += r - s : s != t && (this.position += 1), a
        }, Math.pow(2, 32)), b = (l.prototype.readInt64 = function () {
            return this.readInt32() * d + this.readUint32()
        }, l.prototype.readUint64 = function () {
            return this.readUint32() * d + this.readUint32()
        }, l.prototype.readInt64 = function () {
            return this.readUint32() * d + this.readUint32()
        }, l.prototype.readUint24 = function () {
            return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8()
        }, (t.DataStream = l).prototype.save = function (e) {
            var t = new Blob([this.buffer]);
            if (!window.URL || !URL.createObjectURL) throw"DataStream.save: Can't create object URL.";
            var t = window.URL.createObjectURL(t), i = document.createElement("a");
            document.body.appendChild(i), i.setAttribute("href", t), i.setAttribute("download", e), i.setAttribute("target", "_self"), i.click(), window.URL.revokeObjectURL(t)
        }, l.prototype._dynamicSize = !0, Object.defineProperty(l.prototype, "dynamicSize", {
            get: function () {
                return this._dynamicSize
            }, set: function (e) {
                e || this._trimAlloc(), this._dynamicSize = e
            }
        }), l.prototype.shift = function (e) {
            var t = new ArrayBuffer(this._byteLength - e), i = new Uint8Array(t),
                r = new Uint8Array(this._buffer, e, i.length);
            i.set(r), this.buffer = t, this.position -= e
        }, l.prototype.writeInt32Array = function (e, t) {
            if (this._realloc(4 * e.length), e instanceof Int32Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapInt32Array(e.length, t); else for (var i = 0; i < e.length; i++) this.writeInt32(e[i], t)
        }, l.prototype.writeInt16Array = function (e, t) {
            if (this._realloc(2 * e.length), e instanceof Int16Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapInt16Array(e.length, t); else for (var i = 0; i < e.length; i++) this.writeInt16(e[i], t)
        }, l.prototype.writeInt8Array = function (e) {
            if (this._realloc(+e.length), e instanceof Int8Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapInt8Array(e.length); else for (var t = 0; t < e.length; t++) this.writeInt8(e[t])
        }, l.prototype.writeUint32Array = function (e, t) {
            if (this._realloc(4 * e.length), e instanceof Uint32Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapUint32Array(e.length, t); else for (var i = 0; i < e.length; i++) this.writeUint32(e[i], t)
        }, l.prototype.writeUint16Array = function (e, t) {
            if (this._realloc(2 * e.length), e instanceof Uint16Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapUint16Array(e.length, t); else for (var i = 0; i < e.length; i++) this.writeUint16(e[i], t)
        }, l.prototype.writeUint8Array = function (e) {
            if (this._realloc(+e.length), e instanceof Uint8Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapUint8Array(e.length); else for (var t = 0; t < e.length; t++) this.writeUint8(e[t])
        }, l.prototype.writeFloat64Array = function (e, t) {
            if (this._realloc(8 * e.length), e instanceof Float64Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapFloat64Array(e.length, t); else for (var i = 0; i < e.length; i++) this.writeFloat64(e[i], t)
        }, l.prototype.writeFloat32Array = function (e, t) {
            if (this._realloc(4 * e.length), e instanceof Float32Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0) l.memcpy(this._buffer, this.byteOffset + this.position, e.buffer, 0, e.byteLength), this.mapFloat32Array(e.length, t); else for (var i = 0; i < e.length; i++) this.writeFloat32(e[i], t)
        }, l.prototype.writeInt32 = function (e, t) {
            this._realloc(4), this._dataView.setInt32(this.position, e, null == t ? this.endianness : t), this.position += 4
        }, l.prototype.writeInt16 = function (e, t) {
            this._realloc(2), this._dataView.setInt16(this.position, e, null == t ? this.endianness : t), this.position += 2
        }, l.prototype.writeInt8 = function (e) {
            this._realloc(1), this._dataView.setInt8(this.position, e), this.position += 1
        }, l.prototype.writeUint32 = function (e, t) {
            this._realloc(4), this._dataView.setUint32(this.position, e, null == t ? this.endianness : t), this.position += 4
        }, l.prototype.writeUint16 = function (e, t) {
            this._realloc(2), this._dataView.setUint16(this.position, e, null == t ? this.endianness : t), this.position += 2
        }, l.prototype.writeUint8 = function (e) {
            this._realloc(1), this._dataView.setUint8(this.position, e), this.position += 1
        }, l.prototype.writeFloat32 = function (e, t) {
            this._realloc(4), this._dataView.setFloat32(this.position, e, null == t ? this.endianness : t), this.position += 4
        }, l.prototype.writeFloat64 = function (e, t) {
            this._realloc(8), this._dataView.setFloat64(this.position, e, null == t ? this.endianness : t), this.position += 8
        }, l.prototype.writeUCS2String = function (e, t, i) {
            null == i && (i = e.length);
            for (var r = 0; r < e.length && r < i; r++) this.writeUint16(e.charCodeAt(r), t);
            for (; r < i; r++) this.writeUint16(0)
        }, l.prototype.writeString = function (e, t, i) {
            var r = 0;
            if (null == t || "ASCII" == t) if (null != i) {
                for (var s = Math.min(e.length, i), r = 0; r < s; r++) this.writeUint8(e.charCodeAt(r));
                for (; r < i; r++) this.writeUint8(0)
            } else for (r = 0; r < e.length; r++) this.writeUint8(e.charCodeAt(r)); else this.writeUint8Array(new TextEncoder(t).encode(e.substring(0, i)))
        }, l.prototype.writeCString = function (e, t) {
            var i = 0;
            if (null != t) {
                for (var r = Math.min(e.length, t), i = 0; i < r; i++) this.writeUint8(e.charCodeAt(i));
                for (; i < t; i++) this.writeUint8(0)
            } else {
                for (i = 0; i < e.length; i++) this.writeUint8(e.charCodeAt(i));
                this.writeUint8(0)
            }
        }, l.prototype.writeStruct = function (e, t) {
            for (var i = 0; i < e.length; i += 2) {
                var r = e[i + 1];
                this.writeType(r, t[e[i]], t)
            }
        }, l.prototype.writeType = function (e, t, i) {
            var r;
            if ("function" == typeof e) return e(this, t);
            if ("object" == typeof e && !(e instanceof Array)) return e.set(this, t, i);
            var s = null, a = "ASCII", i = this.position;
            switch ("string" == typeof e && /:/.test(e) && (e = (r = e.split(":"))[0], s = parseInt(r[1])), "string" == typeof e && /,/.test(e) && (e = (r = e.split(","))[0], a = parseInt(r[1])), e) {
                case"uint8":
                    this.writeUint8(t);
                    break;
                case"int8":
                    this.writeInt8(t);
                    break;
                case"uint16":
                    this.writeUint16(t, this.endianness);
                    break;
                case"int16":
                    this.writeInt16(t, this.endianness);
                    break;
                case"uint32":
                    this.writeUint32(t, this.endianness);
                    break;
                case"int32":
                    this.writeInt32(t, this.endianness);
                    break;
                case"float32":
                    this.writeFloat32(t, this.endianness);
                    break;
                case"float64":
                    this.writeFloat64(t, this.endianness);
                    break;
                case"uint16be":
                    this.writeUint16(t, l.BIG_ENDIAN);
                    break;
                case"int16be":
                    this.writeInt16(t, l.BIG_ENDIAN);
                    break;
                case"uint32be":
                    this.writeUint32(t, l.BIG_ENDIAN);
                    break;
                case"int32be":
                    this.writeInt32(t, l.BIG_ENDIAN);
                    break;
                case"float32be":
                    this.writeFloat32(t, l.BIG_ENDIAN);
                    break;
                case"float64be":
                    this.writeFloat64(t, l.BIG_ENDIAN);
                    break;
                case"uint16le":
                    this.writeUint16(t, l.LITTLE_ENDIAN);
                    break;
                case"int16le":
                    this.writeInt16(t, l.LITTLE_ENDIAN);
                    break;
                case"uint32le":
                    this.writeUint32(t, l.LITTLE_ENDIAN);
                    break;
                case"int32le":
                    this.writeInt32(t, l.LITTLE_ENDIAN);
                    break;
                case"float32le":
                    this.writeFloat32(t, l.LITTLE_ENDIAN);
                    break;
                case"float64le":
                    this.writeFloat64(t, l.LITTLE_ENDIAN);
                    break;
                case"cstring":
                    this.writeCString(t, s);
                    break;
                case"string":
                    this.writeString(t, a, s);
                    break;
                case"u16string":
                    this.writeUCS2String(t, this.endianness, s);
                    break;
                case"u16stringle":
                    this.writeUCS2String(t, l.LITTLE_ENDIAN, s);
                    break;
                case"u16stringbe":
                    this.writeUCS2String(t, l.BIG_ENDIAN, s);
                    break;
                default:
                    if (3 == e.length) {
                        for (var n = e[1], o = 0; o < t.length; o++) this.writeType(n, t[o]);
                        break
                    }
                    this.writeStruct(e, t)
            }
            null != s && (this.position = i, this._realloc(s), this.position = i + s)
        }, l.prototype.writeUint64 = function (e) {
            var t = Math.floor(e / d);
            this.writeUint32(t), this.writeUint32(4294967295 & e)
        }, l.prototype.writeUint24 = function (e) {
            this.writeUint8((16711680 & e) >> 16), this.writeUint8((65280 & e) >> 8), this.writeUint8(255 & e)
        }, l.prototype.adjustUint32 = function (e, t) {
            var i = this.position;
            this.seek(e), this.writeUint32(t), this.seek(i)
        }, l.prototype.mapInt32Array = function (e, t) {
            this._realloc(4 * e);
            var i = new Int32Array(this._buffer, this.byteOffset + this.position, e);
            return l.arrayToNative(i, null == t ? this.endianness : t), this.position += 4 * e, i
        }, l.prototype.mapInt16Array = function (e, t) {
            this._realloc(2 * e);
            var i = new Int16Array(this._buffer, this.byteOffset + this.position, e);
            return l.arrayToNative(i, null == t ? this.endianness : t), this.position += 2 * e, i
        }, l.prototype.mapInt8Array = function (e) {
            this._realloc(+e);
            var t = new Int8Array(this._buffer, this.byteOffset + this.position, e);
            return this.position += +e, t
        }, l.prototype.mapUint32Array = function (e, t) {
            this._realloc(4 * e);
            var i = new Uint32Array(this._buffer, this.byteOffset + this.position, e);
            return l.arrayToNative(i, null == t ? this.endianness : t), this.position += 4 * e, i
        }, l.prototype.mapUint16Array = function (e, t) {
            this._realloc(2 * e);
            var i = new Uint16Array(this._buffer, this.byteOffset + this.position, e);
            return l.arrayToNative(i, null == t ? this.endianness : t), this.position += 2 * e, i
        }, l.prototype.mapFloat64Array = function (e, t) {
            this._realloc(8 * e);
            var i = new Float64Array(this._buffer, this.byteOffset + this.position, e);
            return l.arrayToNative(i, null == t ? this.endianness : t), this.position += 8 * e, i
        }, l.prototype.mapFloat32Array = function (e, t) {
            this._realloc(4 * e);
            var i = new Float32Array(this._buffer, this.byteOffset + this.position, e);
            return l.arrayToNative(i, null == t ? this.endianness : t), this.position += 4 * e, i
        }, (i.prototype = new l(new ArrayBuffer, 0, l.BIG_ENDIAN)).initialized = function () {
            var e;
            return -1 < this.bufferIndex || (0 < this.buffers.length ? 0 === (e = this.buffers[0]).fileStart ? (this.buffer = e, this.bufferIndex = 0, u.debug("MultiBufferStream", "Stream ready for parsing"), !0) : (u.warn("MultiBufferStream", "The first buffer should have a fileStart of 0"), this.logBufferLevel(), !1) : (u.warn("MultiBufferStream", "No buffer to start parsing from"), this.logBufferLevel(), !1))
        }, ArrayBuffer.concat = function (e, t) {
            u.debug("ArrayBuffer", "Trying to create a new buffer of size: " + (e.byteLength + t.byteLength));
            var i = new Uint8Array(e.byteLength + t.byteLength);
            return i.set(new Uint8Array(e), 0), i.set(new Uint8Array(t), e.byteLength), i.buffer
        }, i.prototype.reduceBuffer = function (e, t, i) {
            var r;
            return (r = new Uint8Array(i)).set(new Uint8Array(e, t, i)), r.buffer.fileStart = e.fileStart + t, r.buffer.usedBytes = 0, r.buffer
        }, i.prototype.insertBuffer = function (e) {
            for (var t = !0, i = 0; i < this.buffers.length; i++) {
                var r = this.buffers[i];
                if (e.fileStart <= r.fileStart) {
                    if (e.fileStart === r.fileStart) {
                        if (e.byteLength > r.byteLength) {
                            this.buffers.splice(i, 1), i--;
                            continue
                        }
                        u.warn("MultiBufferStream", "Buffer (fileStart: " + e.fileStart + " - Length: " + e.byteLength + ") already appended, ignoring")
                    } else e.fileStart + e.byteLength <= r.fileStart || (e = this.reduceBuffer(e, 0, r.fileStart - e.fileStart)), u.debug("MultiBufferStream", "Appending new buffer (fileStart: " + e.fileStart + " - Length: " + e.byteLength + ")"), this.buffers.splice(i, 0, e), 0 === i && (this.buffer = e);
                    t = !1;
                    break
                }
                if (e.fileStart < r.fileStart + r.byteLength) {
                    var r = r.fileStart + r.byteLength - e.fileStart, s = e.byteLength - r;
                    if (!(0 < s)) {
                        t = !1;
                        break
                    }
                    e = this.reduceBuffer(e, r, s)
                }
            }
            t && (u.debug("MultiBufferStream", "Appending new buffer (fileStart: " + e.fileStart + " - Length: " + e.byteLength + ")"), this.buffers.push(e), 0 === i && (this.buffer = e))
        }, i.prototype.logBufferLevel = function (e) {
            for (var t, i, r = [], s = "", a = 0, n = 0, o = 0; o < this.buffers.length; o++) t = this.buffers[o], 0 === o ? (r.push(i = {}), i.start = t.fileStart, i.end = t.fileStart + t.byteLength, s += "[" + i.start + "-") : i.end === t.fileStart ? i.end = t.fileStart + t.byteLength : ((i = {}).start = t.fileStart, s += r[r.length - 1].end - 1 + "], [" + i.start + "-", i.end = t.fileStart + t.byteLength, r.push(i)), a += t.usedBytes, n += t.byteLength;
            0 < r.length && (s += i.end - 1 + "]");
            e = e ? u.info : u.debug;
            0 === this.buffers.length ? e("MultiBufferStream", "No more buffer in memory") : e("MultiBufferStream", this.buffers.length + " stored buffer(s) (" + a + "/" + n + " bytes), continuous ranges: " + s)
        }, i.prototype.cleanBuffers = function () {
            for (var e, t = 0; t < this.buffers.length; t++) (e = this.buffers[t]).usedBytes === e.byteLength && (u.debug("MultiBufferStream", "Removing buffer #" + t), this.buffers.splice(t, 1), t--)
        }, i.prototype.mergeNextBuffer = function () {
            var e, t, i, r;
            return this.bufferIndex + 1 < this.buffers.length && ((e = this.buffers[this.bufferIndex + 1]).fileStart === this.buffer.fileStart + this.buffer.byteLength && (t = this.buffer.byteLength, i = this.buffer.usedBytes, r = this.buffer.fileStart, this.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, e), this.buffer = this.buffers[this.bufferIndex], this.buffers.splice(this.bufferIndex + 1, 1), this.buffer.usedBytes = i, this.buffer.fileStart = r, u.debug("ISOFile", "Concatenating buffer for box parsing (length: " + t + "->" + this.buffer.byteLength + ")"), !0))
        }, i.prototype.findPosition = function (e, t, i) {
            for (var r = null, s = -1, a = !0 === e ? 0 : this.bufferIndex; a < this.buffers.length && (r = this.buffers[a]).fileStart <= t;) s = a, i && (r.fileStart + r.byteLength <= t ? r.usedBytes = r.byteLength : r.usedBytes = t - r.fileStart, this.logBufferLevel()), a++;
            return -1 !== s && (r = this.buffers[s]).fileStart + r.byteLength >= t ? (u.debug("MultiBufferStream", "Found position in existing buffer #" + s), s) : -1
        }, i.prototype.findEndContiguousBuf = function (e) {
            var t, i, e = void 0 !== e ? e : this.bufferIndex, r = this.buffers[e];
            if (this.buffers.length > e + 1) for (t = e + 1; t < this.buffers.length && (i = this.buffers[t]).fileStart === r.fileStart + r.byteLength; t++) r = i;
            return r.fileStart + r.byteLength
        }, i.prototype.getEndFilePositionAfter = function (e) {
            var t = this.findPosition(!0, e, !1);
            return -1 !== t ? this.findEndContiguousBuf(t) : e
        }, i.prototype.addUsedBytes = function (e) {
            this.buffer.usedBytes += e, this.logBufferLevel()
        }, i.prototype.setAllUsedBytes = function () {
            this.buffer.usedBytes = this.buffer.byteLength, this.logBufferLevel()
        }, i.prototype.seek = function (e, t, i) {
            return -1 !== (t = this.findPosition(t, e, i)) ? (this.buffer = this.buffers[t], this.bufferIndex = t, this.position = e - this.buffer.fileStart, u.debug("MultiBufferStream", "Repositioning parser at buffer position: " + this.position), !0) : (u.debug("MultiBufferStream", "Position " + e + " not found in buffered data"), !1)
        }, i.prototype.getPosition = function () {
            if (-1 === this.bufferIndex || null === this.buffers[this.bufferIndex]) throw"Error accessing position in the MultiBufferStream";
            return this.buffers[this.bufferIndex].fileStart + this.position
        }, i.prototype.getLength = function () {
            return this.byteLength
        }, i.prototype.getEndPosition = function () {
            if (-1 === this.bufferIndex || null === this.buffers[this.bufferIndex]) throw"Error accessing position in the MultiBufferStream";
            return this.buffers[this.bufferIndex].fileStart + this.byteLength
        }, t.MultiBufferStream = i, t.MPEG4DescriptorParser = r, {
            ERR_INVALID_DATA: -1,
            ERR_NOT_ENOUGH_DATA: 0,
            OK: 1,
            BASIC_BOXES: ["mdat", "idat", "free", "skip", "meco", "strk"],
            FULL_BOXES: ["hmhd", "nmhd", "iods", "xml ", "bxml", "ipro", "mere"],
            CONTAINER_BOXES: [["moov", ["trak", "pssh"]], ["trak"], ["edts"], ["mdia"], ["minf"], ["dinf"], ["stbl", ["sgpd", "sbgp"]], ["mvex", ["trex"]], ["moof", ["traf"]], ["traf", ["trun", "sgpd", "sbgp"]], ["vttc"], ["tref"], ["iref"], ["mfra", ["tfra"]], ["meco"], ["hnti"], ["hinf"], ["strk"], ["strd"], ["sinf"], ["rinf"], ["schi"], ["trgr"], ["udta", ["kind"]], ["iprp", ["ipma"]], ["ipco"]],
            boxCodes: [],
            fullBoxCodes: [],
            containerBoxCodes: [],
            sampleEntryCodes: {},
            sampleGroupEntryCodes: [],
            trackGroupTypes: [],
            UUIDBoxes: {},
            UUIDs: [],
            initialize: function () {
                b.FullBox.prototype = new b.Box, b.ContainerBox.prototype = new b.Box, b.SampleEntry.prototype = new b.Box, b.TrackGroupTypeBox.prototype = new b.FullBox, b.BASIC_BOXES.forEach(function (e) {
                    b.createBoxCtor(e)
                }), b.FULL_BOXES.forEach(function (e) {
                    b.createFullBoxCtor(e)
                }), b.CONTAINER_BOXES.forEach(function (e) {
                    b.createContainerBoxCtor(e[0], null, e[1])
                })
            },
            Box: function (e, t, i) {
                this.type = e, this.size = t, this.uuid = i
            },
            FullBox: function (e, t, i) {
                b.Box.call(this, e, t, i), this.flags = 0, this.version = 0
            },
            ContainerBox: function (e, t, i) {
                b.Box.call(this, e, t, i), this.boxes = []
            },
            SampleEntry: function (e, t, i, r) {
                b.ContainerBox.call(this, e, t), this.hdr_size = i, this.start = r
            },
            SampleGroupEntry: function (e) {
                this.grouping_type = e
            },
            TrackGroupTypeBox: function (e, t) {
                b.FullBox.call(this, e, t)
            },
            createBoxCtor: function (t, e) {
                b.boxCodes.push(t), b[t + "Box"] = function (e) {
                    b.Box.call(this, t, e)
                }, b[t + "Box"].prototype = new b.Box, e && (b[t + "Box"].prototype.parse = e)
            },
            createFullBoxCtor: function (t, i) {
                b[t + "Box"] = function (e) {
                    b.FullBox.call(this, t, e)
                }, b[t + "Box"].prototype = new b.FullBox, b[t + "Box"].prototype.parse = function (e) {
                    this.parseFullHeader(e), i && i.call(this, e)
                }
            },
            addSubBoxArrays: function (e) {
                if (e) for (var t = (this.subBoxNames = e).length, i = 0; i < t; i++) this[e[i] + "s"] = []
            },
            createContainerBoxCtor: function (t, e, i) {
                b[t + "Box"] = function (e) {
                    b.ContainerBox.call(this, t, e), b.addSubBoxArrays.call(this, i)
                }, b[t + "Box"].prototype = new b.ContainerBox, e && (b[t + "Box"].prototype.parse = e)
            },
            createMediaSampleEntryCtor: function (e, t, i) {
                b.sampleEntryCodes[e] = [], b[e + "SampleEntry"] = function (e, t) {
                    b.SampleEntry.call(this, e, t), b.addSubBoxArrays.call(this, i)
                }, b[e + "SampleEntry"].prototype = new b.SampleEntry, t && (b[e + "SampleEntry"].prototype.parse = t)
            },
            createSampleEntryCtor: function (t, i, e, r) {
                b.sampleEntryCodes[t].push(i), b[i + "SampleEntry"] = function (e) {
                    b[t + "SampleEntry"].call(this, i, e), b.addSubBoxArrays.call(this, r)
                }, b[i + "SampleEntry"].prototype = new b[t + "SampleEntry"], e && (b[i + "SampleEntry"].prototype.parse = e)
            },
            createEncryptedSampleEntryCtor: function (e, t, i) {
                b.createSampleEntryCtor.call(this, e, t, i, ["sinf"])
            },
            createSampleGroupCtor: function (t, e) {
                b[t + "SampleGroupEntry"] = function (e) {
                    b.SampleGroupEntry.call(this, t, e)
                }, b[t + "SampleGroupEntry"].prototype = new b.SampleGroupEntry, e && (b[t + "SampleGroupEntry"].prototype.parse = e)
            },
            createTrackGroupCtor: function (t, e) {
                b[t + "TrackGroupTypeBox"] = function (e) {
                    b.TrackGroupTypeBox.call(this, t, e)
                }, b[t + "TrackGroupTypeBox"].prototype = new b.TrackGroupTypeBox, e && (b[t + "TrackGroupTypeBox"].prototype.parse = e)
            },
            createUUIDBox: function (t, i, r, s) {
                b.UUIDs.push(t), b.UUIDBoxes[t] = function (e) {
                    (i ? b.FullBox : r ? b.ContainerBox : b.Box).call(this, "uuid", e, t)
                }, b.UUIDBoxes[t].prototype = new (i ? b.FullBox : r ? b.ContainerBox : b.Box), s && (b.UUIDBoxes[t].prototype.parse = i ? function (e) {
                    this.parseFullHeader(e), s && s.call(this, e)
                } : s)
            }
        });
        b.initialize(), b.TKHD_FLAG_ENABLED = 1, b.TKHD_FLAG_IN_MOVIE = 2, b.TKHD_FLAG_IN_PREVIEW = 4, b.TFHD_FLAG_BASE_DATA_OFFSET = 1, b.TFHD_FLAG_SAMPLE_DESC = 2, b.TFHD_FLAG_SAMPLE_DUR = 8, b.TFHD_FLAG_SAMPLE_SIZE = 16, b.TFHD_FLAG_SAMPLE_FLAGS = 32, b.TFHD_FLAG_DUR_EMPTY = 65536, b.TFHD_FLAG_DEFAULT_BASE_IS_MOOF = 131072, b.TRUN_FLAGS_DATA_OFFSET = 1, b.TRUN_FLAGS_FIRST_FLAG = 4, b.TRUN_FLAGS_DURATION = 256, b.TRUN_FLAGS_SIZE = 512, b.TRUN_FLAGS_FLAGS = 1024, b.TRUN_FLAGS_CTS_OFFSET = 2048, b.Box.prototype.add = function (e) {
            return this.addBox(new b[e + "Box"])
        }, b.Box.prototype.addBox = function (e) {
            return this.boxes.push(e), this[e.type + "s"] ? this[e.type + "s"].push(e) : this[e.type] = e, e
        }, b.Box.prototype.set = function (e, t) {
            return this[e] = t, this
        }, b.Box.prototype.addEntry = function (e, t) {
            t = t || "entries";
            return this[t] || (this[t] = []), this[t].push(e), this
        }, (t.BoxParser = b).parseUUID = function (e) {
            return b.parseHex16(e)
        }, b.parseHex16 = function (e) {
            for (var t = "", i = 0; i < 16; i++) {
                var r = e.readUint8().toString(16);
                t += 1 === r.length ? "0" + r : r
            }
            return t
        }, b.parseOneBox = function (e, t, i) {
            var r, s, a = e.getPosition(), n = 0;
            if (e.getEndPosition() - a < 8) return u.debug("BoxParser", "Not enough data in stream to parse the type and size of the box"), {code: b.ERR_NOT_ENOUGH_DATA};
            if (i && i < 8) return u.debug("BoxParser", "Not enough bytes left in the parent box to parse a new box"), {code: b.ERR_NOT_ENOUGH_DATA};
            var o = e.readUint32(), l = e.readString(4), d = l;
            if (u.debug("BoxParser", "Found box of type '" + l + "' and size " + o + " at position " + a), n = 8, "uuid" == l) {
                if (e.getEndPosition() - e.getPosition() < 16 || i - n < 16) return e.seek(a), u.debug("BoxParser", "Not enough bytes left in the parent box to parse a UUID box"), {code: b.ERR_NOT_ENOUGH_DATA};
                n += 16, d = s = b.parseUUID(e)
            }
            if (1 == o) {
                if (e.getEndPosition() - e.getPosition() < 8 || i && i - n < 8) return e.seek(a), u.warn("BoxParser", 'Not enough data in stream to parse the extended size of the "' + l + '" box'), {code: b.ERR_NOT_ENOUGH_DATA};
                o = e.readUint64(), n += 8
            } else if (0 === o) if (i) o = i; else if ("mdat" !== l) return u.error("BoxParser", "Unlimited box size not supported for type: '" + l + "'"), r = new b.Box(l, o), {
                code: b.OK,
                box: r,
                size: r.size
            };
            return 0 !== o && o < n ? (u.error("BoxParser", "Box of type " + l + " has an invalid size " + o + " (too small to be a box)"), {
                code: b.ERR_NOT_ENOUGH_DATA,
                type: l,
                size: o,
                hdr_size: n,
                start: a
            }) : 0 !== o && i && i < o ? (u.error("BoxParser", "Box of type '" + l + "' has a size " + o + " greater than its container size " + i), {
                code: b.ERR_NOT_ENOUGH_DATA,
                type: l,
                size: o,
                hdr_size: n,
                start: a
            }) : 0 !== o && a + o > e.getEndPosition() ? (e.seek(a), u.info("BoxParser", "Not enough data in stream to parse the entire '" + l + "' box"), {
                code: b.ERR_NOT_ENOUGH_DATA,
                type: l,
                size: o,
                hdr_size: n,
                start: a
            }) : t ? {
                code: b.OK,
                type: l,
                size: o,
                hdr_size: n,
                start: a
            } : (b[l + "Box"] ? r = new b[l + "Box"](o) : "uuid" !== l ? (u.warn("BoxParser", "Unknown box type: '" + l + "'"), (r = new b.Box(l, o)).has_unparsed_data = !0) : b.UUIDBoxes[s] ? r = new b.UUIDBoxes[s](o) : (u.warn("BoxParser", "Unknown uuid type: '" + s + "'"), (r = new b.Box(l, o)).uuid = s, r.has_unparsed_data = !0), r.hdr_size = n, r.start = a, r.write === b.Box.prototype.write && "mdat" !== r.type && (u.info("BoxParser", "'" + d + "' box writing not yet implemented, keeping unparsed data in memory for later write"), r.parseDataAndRewind(e)), r.parse(e), (i = e.getPosition() - (r.start + r.size)) < 0 ? (u.warn("BoxParser", "Parsing of box '" + d + "' did not read the entire indicated box data size (missing " + -i + " bytes), seeking forward"), e.seek(r.start + r.size)) : 0 < i && (u.error("BoxParser", "Parsing of box '" + d + "' read " + i + " more bytes than the indicated box data size, seeking backwards"), 0 !== r.size && e.seek(r.start + r.size)), {
                code: b.OK,
                box: r,
                size: r.size
            })
        }, b.Box.prototype.parse = function (e) {
            "mdat" != this.type ? this.data = e.readUint8Array(this.size - this.hdr_size) : 0 === this.size ? e.seek(e.getEndPosition()) : e.seek(this.start + this.size)
        }, b.Box.prototype.parseDataAndRewind = function (e) {
            this.data = e.readUint8Array(this.size - this.hdr_size), e.position -= this.size - this.hdr_size
        }, b.FullBox.prototype.parseDataAndRewind = function (e) {
            this.parseFullHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 4, e.position -= this.size - this.hdr_size
        }, b.FullBox.prototype.parseFullHeader = function (e) {
            this.version = e.readUint8(), this.flags = e.readUint24(), this.hdr_size += 4
        }, b.FullBox.prototype.parse = function (e) {
            this.parseFullHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size)
        }, b.ContainerBox.prototype.parse = function (e) {
            for (; e.getPosition() < this.start + this.size;) {
                if ((i = b.parseOneBox(e, !1, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                var t, i = i.box;
                this.boxes.push(i), this.subBoxNames && -1 != this.subBoxNames.indexOf(i.type) ? this[this.subBoxNames[this.subBoxNames.indexOf(i.type)] + "s"].push(i) : this[t = "uuid" !== i.type ? i.type : i.uuid] ? u.warn("Box of type " + t + " already stored in field of this type") : this[t] = i
            }
        }, b.Box.prototype.parseLanguage = function (e) {
            this.language = e.readUint16();
            e = [];
            e[0] = this.language >> 10 & 31, e[1] = this.language >> 5 & 31, e[2] = 31 & this.language, this.languageString = String.fromCharCode(e[0] + 96, e[1] + 96, e[2] + 96)
        }, b.SAMPLE_ENTRY_TYPE_VISUAL = "Visual", b.SAMPLE_ENTRY_TYPE_AUDIO = "Audio", b.SAMPLE_ENTRY_TYPE_HINT = "Hint", b.SAMPLE_ENTRY_TYPE_METADATA = "Metadata", b.SAMPLE_ENTRY_TYPE_SUBTITLE = "Subtitle", b.SAMPLE_ENTRY_TYPE_SYSTEM = "System", b.SAMPLE_ENTRY_TYPE_TEXT = "Text", b.SampleEntry.prototype.parseHeader = function (e) {
            e.readUint8Array(6), this.data_reference_index = e.readUint16(), this.hdr_size += 8
        }, b.SampleEntry.prototype.parse = function (e) {
            this.parseHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size)
        }, b.SampleEntry.prototype.parseDataAndRewind = function (e) {
            this.parseHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 8, e.position -= this.size - this.hdr_size
        }, b.SampleEntry.prototype.parseFooter = function (e) {
            b.ContainerBox.prototype.parse.call(this, e)
        }, b.createMediaSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_HINT), b.createMediaSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_METADATA), b.createMediaSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SUBTITLE), b.createMediaSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SYSTEM), b.createMediaSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_TEXT), b.createMediaSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, function (e) {
            var t;
            this.parseHeader(e), e.readUint16(), e.readUint16(), e.readUint32Array(3), this.width = e.readUint16(), this.height = e.readUint16(), this.horizresolution = e.readUint32(), this.vertresolution = e.readUint32(), e.readUint32(), this.frame_count = e.readUint16(), t = Math.min(31, e.readUint8()), this.compressorname = e.readString(t), t < 31 && e.readString(31 - t), this.depth = e.readUint16(), e.readUint16(), this.parseFooter(e)
        }), b.createMediaSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_AUDIO, function (e) {
            this.parseHeader(e), e.readUint32Array(2), this.channel_count = e.readUint16(), this.samplesize = e.readUint16(), e.readUint16(), e.readUint16(), this.samplerate = e.readUint32() / 65536, this.parseFooter(e)
        }), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "avc1"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "avc2"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "avc3"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "avc4"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "av01"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "hvc1"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "hev1"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "vvc1"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "vvi1"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "vvs1"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "vvcN"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "vp08"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "vp09"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_AUDIO, "mp4a"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_AUDIO, "ac-3"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_AUDIO, "ec-3"), b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_AUDIO, "Opus"), b.createEncryptedSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_VISUAL, "encv"), b.createEncryptedSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_AUDIO, "enca"), b.createEncryptedSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SUBTITLE, "encu"), b.createEncryptedSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SYSTEM, "encs"), b.createEncryptedSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_TEXT, "enct"), b.createEncryptedSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_METADATA, "encm"), b.createBoxCtor("a1lx", function (e) {
            var t = 16 * (1 + (1 & e.readUint8()));
            this.layer_size = [];
            for (var i = 0; i < 3; i++) this.layer_size[i] = 16 == t ? e.readUint16() : e.readUint32()
        }), b.createBoxCtor("a1op", function (e) {
            this.op_index = e.readUint8()
        }), b.createFullBoxCtor("auxC", function (e) {
            this.aux_type = e.readCString();
            var t = this.size - this.hdr_size - (this.aux_type.length + 1);
            this.aux_subtype = e.readUint8Array(t)
        }), b.createBoxCtor("av1C", function (e) {
            var t = e.readUint8();
            if (t >> 7 & !1) u.error("av1C marker problem"); else if (this.version = 127 & t, 1 === this.version) if (t = e.readUint8(), this.seq_profile = t >> 5 & 7, this.seq_level_idx_0 = 31 & t, t = e.readUint8(), this.seq_tier_0 = t >> 7 & 1, this.high_bitdepth = t >> 6 & 1, this.twelve_bit = t >> 5 & 1, this.monochrome = t >> 4 & 1, this.chroma_subsampling_x = t >> 3 & 1, this.chroma_subsampling_y = t >> 2 & 1, this.chroma_sample_position = 3 & t, t = e.readUint8(), this.reserved_1 = t >> 5 & 7, 0 === this.reserved_1) {
                if (this.initial_presentation_delay_present = t >> 4 & 1, 1 === this.initial_presentation_delay_present) this.initial_presentation_delay_minus_one = 15 & t; else if (this.reserved_2 = 15 & t, 0 !== this.reserved_2) return void u.error("av1C reserved_2 parsing problem");
                t = this.size - this.hdr_size - 4;
                this.configOBUs = e.readUint8Array(t)
            } else u.error("av1C reserved_1 parsing problem"); else u.error("av1C version " + this.version + " not supported")
        }), b.createBoxCtor("avcC", function (e) {
            var t, i;
            for (this.configurationVersion = e.readUint8(), this.AVCProfileIndication = e.readUint8(), this.profile_compatibility = e.readUint8(), this.AVCLevelIndication = e.readUint8(), this.lengthSizeMinusOne = 3 & e.readUint8(), this.nb_SPS_nalus = 31 & e.readUint8(), i = this.size - this.hdr_size - 6, this.SPS = [], t = 0; t < this.nb_SPS_nalus; t++) this.SPS[t] = {}, this.SPS[t].length = e.readUint16(), this.SPS[t].nalu = e.readUint8Array(this.SPS[t].length), i -= 2 + this.SPS[t].length;
            for (this.nb_PPS_nalus = e.readUint8(), i--, this.PPS = [], t = 0; t < this.nb_PPS_nalus; t++) this.PPS[t] = {}, this.PPS[t].length = e.readUint16(), this.PPS[t].nalu = e.readUint8Array(this.PPS[t].length), i -= 2 + this.PPS[t].length;
            0 < i && (this.ext = e.readUint8Array(i))
        }), b.createBoxCtor("btrt", function (e) {
            this.bufferSizeDB = e.readUint32(), this.maxBitrate = e.readUint32(), this.avgBitrate = e.readUint32()
        }), b.createBoxCtor("clap", function (e) {
            this.cleanApertureWidthN = e.readUint32(), this.cleanApertureWidthD = e.readUint32(), this.cleanApertureHeightN = e.readUint32(), this.cleanApertureHeightD = e.readUint32(), this.horizOffN = e.readUint32(), this.horizOffD = e.readUint32(), this.vertOffN = e.readUint32(), this.vertOffD = e.readUint32()
        }), b.createBoxCtor("clli", function (e) {
            this.max_content_light_level = e.readUint16(), this.max_pic_average_light_level = e.readUint16()
        }), b.createFullBoxCtor("co64", function (e) {
            var t, i = e.readUint32();
            if (this.chunk_offsets = [], 0 === this.version) for (t = 0; t < i; t++) this.chunk_offsets.push(e.readUint64())
        }), b.createFullBoxCtor("CoLL", function (e) {
            this.maxCLL = e.readUint16(), this.maxFALL = e.readUint16()
        }), b.createBoxCtor("colr", function (e) {
            var t;
            this.colour_type = e.readString(4), "nclx" === this.colour_type ? (this.colour_primaries = e.readUint16(), this.transfer_characteristics = e.readUint16(), this.matrix_coefficients = e.readUint16(), t = e.readUint8(), this.full_range_flag = t >> 7) : "rICC" !== this.colour_type && "prof" !== this.colour_type || (this.ICC_profile = e.readUint8Array(this.size - 4))
        }), b.createFullBoxCtor("cprt", function (e) {
            this.parseLanguage(e), this.notice = e.readCString()
        }), b.createFullBoxCtor("cslg", function (e) {
            0 === this.version && (this.compositionToDTSShift = e.readInt32(), this.leastDecodeToDisplayDelta = e.readInt32(), this.greatestDecodeToDisplayDelta = e.readInt32(), this.compositionStartTime = e.readInt32(), this.compositionEndTime = e.readInt32())
        }), b.createFullBoxCtor("ctts", function (e) {
            var t, i = e.readUint32();
            if (this.sample_counts = [], this.sample_offsets = [], 0 === this.version) for (t = 0; t < i; t++) {
                this.sample_counts.push(e.readUint32());
                var r = e.readInt32();
                r < 0 && u.warn("BoxParser", "ctts box uses negative values without using version 1"), this.sample_offsets.push(r)
            } else if (1 == this.version) for (t = 0; t < i; t++) this.sample_counts.push(e.readUint32()), this.sample_offsets.push(e.readInt32())
        }), b.createBoxCtor("dac3", function (e) {
            var t = e.readUint8(), i = e.readUint8(), e = e.readUint8();
            this.fscod = t >> 6, this.bsid = t >> 1 & 31, this.bsmod = (1 & t) << 2 | i >> 6 & 3, this.acmod = i >> 3 & 7, this.lfeon = i >> 2 & 1, this.bit_rate_code = 3 & i | e >> 5 & 7
        }), b.createBoxCtor("dec3", function (e) {
            var t = e.readUint16();
            this.data_rate = t >> 3, this.num_ind_sub = 7 & t, this.ind_subs = [];
            for (var i = 0; i < this.num_ind_sub + 1; i++) {
                var r = {}, s = (this.ind_subs.push(r), e.readUint8()), a = e.readUint8(), n = e.readUint8();
                r.fscod = s >> 6, r.bsid = s >> 1 & 31, r.bsmod = (1 & s) << 4 | a >> 4 & 15, r.acmod = a >> 1 & 7, r.lfeon = 1 & a, r.num_dep_sub = n >> 1 & 15, 0 < r.num_dep_sub && (r.chan_loc = (1 & n) << 8 | e.readUint8())
            }
        }), b.createFullBoxCtor("dfLa", function (e) {
            var t = [],
                i = ["STREAMINFO", "PADDING", "APPLICATION", "SEEKTABLE", "VORBIS_COMMENT", "CUESHEET", "PICTURE", "RESERVED"];
            for (this.parseFullHeader(e); ;) {
                var r = e.readUint8(), s = Math.min(127 & r, i.length - 1);
                if (s ? e.readUint8Array(e.readUint24()) : (e.readUint8Array(13), this.samplerate = e.readUint32() >> 12, e.readUint8Array(20)), t.push(i[s]), 128 & r) break
            }
            this.numMetadataBlocks = t.length + " (" + t.join(", ") + ")"
        }), b.createBoxCtor("dimm", function (e) {
            this.bytessent = e.readUint64()
        }), b.createBoxCtor("dmax", function (e) {
            this.time = e.readUint32()
        }), b.createBoxCtor("dmed", function (e) {
            this.bytessent = e.readUint64()
        }), b.createBoxCtor("dOps", function (e) {
            if (this.Version = e.readUint8(), this.OutputChannelCount = e.readUint8(), this.PreSkip = e.readUint16(), this.InputSampleRate = e.readUint32(), this.OutputGain = e.readInt16(), this.ChannelMappingFamily = e.readUint8(), 0 !== this.ChannelMappingFamily) {
                this.StreamCount = e.readUint8(), this.CoupledCount = e.readUint8(), this.ChannelMapping = [];
                for (var t = 0; t < this.OutputChannelCount; t++) this.ChannelMapping[t] = e.readUint8()
            }
        }), b.createFullBoxCtor("dref", function (e) {
            var t;
            this.entries = [];
            for (var i = e.readUint32(), r = 0; r < i; r++) {
                if ((t = b.parseOneBox(e, !1, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                t = t.box, this.entries.push(t)
            }
        }), b.createBoxCtor("drep", function (e) {
            this.bytessent = e.readUint64()
        }), b.createFullBoxCtor("elng", function (e) {
            this.extended_language = e.readString(this.size - this.hdr_size)
        }), b.createFullBoxCtor("elst", function (e) {
            this.entries = [];
            for (var t = e.readUint32(), i = 0; i < t; i++) {
                var r = {};
                this.entries.push(r), 1 === this.version ? (r.segment_duration = e.readUint64(), r.media_time = e.readInt64()) : (r.segment_duration = e.readUint32(), r.media_time = e.readInt32()), r.media_rate_integer = e.readInt16(), r.media_rate_fraction = e.readInt16()
            }
        }), b.createFullBoxCtor("emsg", function (e) {
            1 == this.version ? (this.timescale = e.readUint32(), this.presentation_time = e.readUint64(), this.event_duration = e.readUint32(), this.id = e.readUint32(), this.scheme_id_uri = e.readCString(), this.value = e.readCString()) : (this.scheme_id_uri = e.readCString(), this.value = e.readCString(), this.timescale = e.readUint32(), this.presentation_time_delta = e.readUint32(), this.event_duration = e.readUint32(), this.id = e.readUint32());
            var t = this.size - this.hdr_size - (16 + (this.scheme_id_uri.length + 1) + (this.value.length + 1));
            1 == this.version && (t -= 4), this.message_data = e.readUint8Array(t)
        }), b.createFullBoxCtor("esds", function (e) {
            var e = e.readUint8Array(this.size - this.hdr_size), t = new r;
            this.esd = t.parseOneDescriptor(new l(e.buffer, 0, l.BIG_ENDIAN))
        }), b.createBoxCtor("fiel", function (e) {
            this.fieldCount = e.readUint8(), this.fieldOrdering = e.readUint8()
        }), b.createBoxCtor("frma", function (e) {
            this.data_format = e.readString(4)
        }),b.createBoxCtor("ftyp", function (e) {
            var t = this.size - this.hdr_size;
            this.major_brand = e.readString(4), this.minor_version = e.readUint32(), t -= 8, this.compatible_brands = [];
            for (var i = 0; 4 <= t;) this.compatible_brands[i] = e.readString(4), t -= 4, i++
        }),b.createFullBoxCtor("hdlr", function (e) {
            0 === this.version && (e.readUint32(), this.handler = e.readString(4), e.readUint32Array(3), this.name = e.readString(this.size - this.hdr_size - 20), "\0" === this.name[this.name.length - 1] && (this.name = this.name.slice(0, -1)))
        }),b.createBoxCtor("hvcC", function (e) {
            this.configurationVersion = e.readUint8(), i = e.readUint8(), this.general_profile_space = i >> 6, this.general_tier_flag = (32 & i) >> 5, this.general_profile_idc = 31 & i, this.general_profile_compatibility = e.readUint32(), this.general_constraint_indicator = e.readUint8Array(6), this.general_level_idc = e.readUint8(), this.min_spatial_segmentation_idc = 4095 & e.readUint16(), this.parallelismType = 3 & e.readUint8(), this.chroma_format_idc = 3 & e.readUint8(), this.bit_depth_luma_minus8 = 7 & e.readUint8(), this.bit_depth_chroma_minus8 = 7 & e.readUint8(), this.avgFrameRate = e.readUint16(), i = e.readUint8(), this.constantFrameRate = i >> 6, this.numTemporalLayers = (13 & i) >> 3, this.temporalIdNested = (4 & i) >> 2, this.lengthSizeMinusOne = 3 & i, this.nalu_arrays = [];
            for (var t, i, r = e.readUint8(), s = 0; s < r; s++) for (var a = [], n = (this.nalu_arrays.push(a), i = e.readUint8(), a.completeness = (128 & i) >> 7, a.nalu_type = 63 & i, e.readUint16()), o = 0; o < n; o++) {
                var l = {};
                a.push(l), t = e.readUint16(), l.data = e.readUint8Array(t)
            }
        }),b.createFullBoxCtor("iinf", function (e) {
            var t;
            0 === this.version ? this.entry_count = e.readUint16() : this.entry_count = e.readUint32(), this.item_infos = [];
            for (var i = 0; i < this.entry_count; i++) {
                if ((t = b.parseOneBox(e, !1, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                "infe" !== t.box.type && u.error("BoxParser", "Expected 'infe' box, got " + t.box.type), this.item_infos[i] = t.box
            }
        }),b.createFullBoxCtor("iloc", function (e) {
            var t = e.readUint8(),
                i = (this.offset_size = t >> 4 & 15, this.length_size = 15 & t, t = e.readUint8(), this.base_offset_size = t >> 4 & 15, 1 === this.version || 2 === this.version ? this.index_size = 15 & t : this.index_size = 0, this.items = [], 0);
            if (this.version < 2) i = e.readUint16(); else {
                if (2 !== this.version) throw"version of iloc box not supported";
                i = e.readUint32()
            }
            for (var r = 0; r < i; r++) {
                var s = {};
                if (this.items.push(s), this.version < 2) s.item_ID = e.readUint16(); else {
                    if (2 !== this.version) throw"version of iloc box not supported";
                    s.item_ID = e.readUint16()
                }
                switch (1 === this.version || 2 === this.version ? s.construction_method = 15 & e.readUint16() : s.construction_method = 0, s.data_reference_index = e.readUint16(), this.base_offset_size) {
                    case 0:
                        s.base_offset = 0;
                        break;
                    case 4:
                        s.base_offset = e.readUint32();
                        break;
                    case 8:
                        s.base_offset = e.readUint64();
                        break;
                    default:
                        throw"Error reading base offset size"
                }
                var a = e.readUint16();
                s.extents = [];
                for (var n = 0; n < a; n++) {
                    var o = {};
                    if (s.extents.push(o), 1 === this.version || 2 === this.version) switch (this.index_size) {
                        case 0:
                            o.extent_index = 0;
                            break;
                        case 4:
                            o.extent_index = e.readUint32();
                            break;
                        case 8:
                            o.extent_index = e.readUint64();
                            break;
                        default:
                            throw"Error reading extent index"
                    }
                    switch (this.offset_size) {
                        case 0:
                            o.extent_offset = 0;
                            break;
                        case 4:
                            o.extent_offset = e.readUint32();
                            break;
                        case 8:
                            o.extent_offset = e.readUint64();
                            break;
                        default:
                            throw"Error reading extent index"
                    }
                    switch (this.length_size) {
                        case 0:
                            o.extent_length = 0;
                            break;
                        case 4:
                            o.extent_length = e.readUint32();
                            break;
                        case 8:
                            o.extent_length = e.readUint64();
                            break;
                        default:
                            throw"Error reading extent index"
                    }
                }
            }
        }),b.createBoxCtor("imir", function (e) {
            e = e.readUint8();
            this.reserved = e >> 7, this.axis = 1 & e
        }),b.createFullBoxCtor("infe", function (e) {
            if (0 !== this.version && 1 !== this.version || (this.item_ID = e.readUint16(), this.item_protection_index = e.readUint16(), this.item_name = e.readCString(), this.content_type = e.readCString(), this.content_encoding = e.readCString()), 1 === this.version) return this.extension_type = e.readString(4), u.warn("BoxParser", "Cannot parse extension type"), void e.seek(this.start + this.size);
            2 <= this.version && (2 === this.version ? this.item_ID = e.readUint16() : 3 === this.version && (this.item_ID = e.readUint32()), this.item_protection_index = e.readUint16(), this.item_type = e.readString(4), this.item_name = e.readCString(), "mime" === this.item_type ? (this.content_type = e.readCString(), this.content_encoding = e.readCString()) : "uri " === this.item_type && (this.item_uri_type = e.readCString()))
        }),b.createFullBoxCtor("ipma", function (e) {
            var t, i;
            for (entry_count = e.readUint32(), this.associations = [], t = 0; t < entry_count; t++) {
                var r = {},
                    s = (this.associations.push(r), this.version < 1 ? r.id = e.readUint16() : r.id = e.readUint32(), e.readUint8());
                for (r.props = [], i = 0; i < s; i++) {
                    var a = e.readUint8(), n = {};
                    r.props.push(n), n.essential = (128 & a) >> 7 == 1, 1 & this.flags ? n.property_index = (127 & a) << 8 | e.readUint8() : n.property_index = 127 & a
                }
            }
        }),b.createFullBoxCtor("iref", function (e) {
            var t;
            for (this.references = []; e.getPosition() < this.start + this.size;) {
                if ((t = b.parseOneBox(e, !0, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                (t = new (0 === this.version ? b.SingleItemTypeReferenceBox : b.SingleItemTypeReferenceBoxLarge)(t.type, t.size, t.hdr_size, t.start)).write === b.Box.prototype.write && "mdat" !== t.type && (u.warn("BoxParser", t.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), t.parseDataAndRewind(e)), t.parse(e), this.references.push(t)
            }
        }),b.createBoxCtor("irot", function (e) {
            this.angle = 3 & e.readUint8()
        }),b.createFullBoxCtor("ispe", function (e) {
            this.image_width = e.readUint32(), this.image_height = e.readUint32()
        }),b.createFullBoxCtor("kind", function (e) {
            this.schemeURI = e.readCString(), this.value = e.readCString()
        }),b.createFullBoxCtor("leva", function (e) {
            var t = e.readUint8();
            this.levels = [];
            for (var i = 0; i < t; i++) {
                var r = {}, s = ((this.levels[i] = r).track_ID = e.readUint32(), e.readUint8());
                switch (r.padding_flag = s >> 7, r.assignment_type = 127 & s, r.assignment_type) {
                    case 0:
                        r.grouping_type = e.readString(4);
                        break;
                    case 1:
                        r.grouping_type = e.readString(4), r.grouping_type_parameter = e.readUint32();
                        break;
                    case 2:
                    case 3:
                        break;
                    case 4:
                        r.sub_track_id = e.readUint32();
                        break;
                    default:
                        u.warn("BoxParser", "Unknown leva assignement type")
                }
            }
        }),b.createBoxCtor("lsel", function (e) {
            this.layer_id = e.readUint16()
        }),b.createBoxCtor("maxr", function (e) {
            this.period = e.readUint32(), this.bytes = e.readUint32()
        }),b.createBoxCtor("mdcv", function (e) {
            this.display_primaries = [], this.display_primaries[0] = {}, this.display_primaries[0].x = e.readUint16(), this.display_primaries[0].y = e.readUint16(), this.display_primaries[1] = {}, this.display_primaries[1].x = e.readUint16(), this.display_primaries[1].y = e.readUint16(), this.display_primaries[2] = {}, this.display_primaries[2].x = e.readUint16(), this.display_primaries[2].y = e.readUint16(), this.white_point = {}, this.white_point.x = e.readUint16(), this.white_point.y = e.readUint16(), this.max_display_mastering_luminance = e.readUint32(), this.min_display_mastering_luminance = e.readUint32()
        }),b.createFullBoxCtor("mdhd", function (e) {
            1 == this.version ? (this.creation_time = e.readUint64(), this.modification_time = e.readUint64(), this.timescale = e.readUint32(), this.duration = e.readUint64()) : (this.creation_time = e.readUint32(), this.modification_time = e.readUint32(), this.timescale = e.readUint32(), this.duration = e.readUint32()), this.parseLanguage(e), e.readUint16()
        }),b.createFullBoxCtor("mehd", function (e) {
            1 & this.flags && (u.warn("BoxParser", "mehd box incorrectly uses flags set to 1, converting version to 1"), this.version = 1), 1 == this.version ? this.fragment_duration = e.readUint64() : this.fragment_duration = e.readUint32()
        }),b.createFullBoxCtor("meta", function (e) {
            this.boxes = [], b.ContainerBox.prototype.parse.call(this, e)
        }),b.createFullBoxCtor("mfhd", function (e) {
            this.sequence_number = e.readUint32()
        }),b.createFullBoxCtor("mfro", function (e) {
            this._size = e.readUint32()
        }),b.createFullBoxCtor("mvhd", function (e) {
            1 == this.version ? (this.creation_time = e.readUint64(), this.modification_time = e.readUint64(), this.timescale = e.readUint32(), this.duration = e.readUint64()) : (this.creation_time = e.readUint32(), this.modification_time = e.readUint32(), this.timescale = e.readUint32(), this.duration = e.readUint32()), this.rate = e.readUint32(), this.volume = e.readUint16() >> 8, e.readUint16(), e.readUint32Array(2), this.matrix = e.readUint32Array(9), e.readUint32Array(6), this.next_track_id = e.readUint32()
        }),b.createBoxCtor("npck", function (e) {
            this.packetssent = e.readUint32()
        }),b.createBoxCtor("nump", function (e) {
            this.packetssent = e.readUint64()
        }),b.createFullBoxCtor("padb", function (e) {
            var t = e.readUint32();
            this.padbits = [];
            for (var i = 0; i < Math.floor((t + 1) / 2); i++) this.padbits = e.readUint8()
        }),b.createBoxCtor("pasp", function (e) {
            this.hSpacing = e.readUint32(), this.vSpacing = e.readUint32()
        }),b.createBoxCtor("payl", function (e) {
            this.text = e.readString(this.size - this.hdr_size)
        }),b.createBoxCtor("payt", function (e) {
            this.payloadID = e.readUint32();
            var t = e.readUint8();
            this.rtpmap_string = e.readString(t)
        }),b.createFullBoxCtor("pdin", function (e) {
            var t = (this.size - this.hdr_size) / 8;
            this.rate = [], this.initial_delay = [];
            for (var i = 0; i < t; i++) this.rate[i] = e.readUint32(), this.initial_delay[i] = e.readUint32()
        }),b.createFullBoxCtor("pitm", function (e) {
            0 === this.version ? this.item_id = e.readUint16() : this.item_id = e.readUint32()
        }),b.createFullBoxCtor("pixi", function (e) {
            var t;
            for (this.num_channels = e.readUint8(), this.bits_per_channels = [], t = 0; t < this.num_channels; t++) this.bits_per_channels[t] = e.readUint8()
        }),b.createBoxCtor("pmax", function (e) {
            this.bytes = e.readUint32()
        }),b.createFullBoxCtor("prft", function (e) {
            this.ref_track_id = e.readUint32(), this.ntp_timestamp = e.readUint64(), 0 === this.version ? this.media_time = e.readUint32() : this.media_time = e.readUint64()
        }),b.createFullBoxCtor("pssh", function (e) {
            if (this.system_id = b.parseHex16(e), 0 < this.version) {
                var t = e.readUint32();
                this.kid = [];
                for (var i = 0; i < t; i++) this.kid[i] = b.parseHex16(e)
            }
            var r = e.readUint32();
            0 < r && (this.data = e.readUint8Array(r))
        }),b.createFullBoxCtor("clef", function (e) {
            this.width = e.readUint32(), this.height = e.readUint32()
        }),b.createFullBoxCtor("enof", function (e) {
            this.width = e.readUint32(), this.height = e.readUint32()
        }),b.createFullBoxCtor("prof", function (e) {
            this.width = e.readUint32(), this.height = e.readUint32()
        }),b.createContainerBoxCtor("tapt", null, ["clef", "prof", "enof"]),b.createBoxCtor("rtp ", function (e) {
            this.descriptionformat = e.readString(4), this.sdptext = e.readString(this.size - this.hdr_size - 4)
        }),b.createFullBoxCtor("saio", function (e) {
            1 & this.flags && (this.aux_info_type = e.readUint32(), this.aux_info_type_parameter = e.readUint32());
            var t = e.readUint32();
            this.offset = [];
            for (var i = 0; i < t; i++) 0 === this.version ? this.offset[i] = e.readUint32() : this.offset[i] = e.readUint64()
        }),b.createFullBoxCtor("saiz", function (e) {
            1 & this.flags && (this.aux_info_type = e.readUint32(), this.aux_info_type_parameter = e.readUint32()), this.default_sample_info_size = e.readUint8();
            var t = e.readUint32();
            if (this.sample_info_size = [], 0 === this.default_sample_info_size) for (var i = 0; i < t; i++) this.sample_info_size[i] = e.readUint8()
        }),b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_METADATA, "mett", function (e) {
            this.parseHeader(e), this.content_encoding = e.readCString(), this.mime_format = e.readCString(), this.parseFooter(e)
        }),b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_METADATA, "metx", function (e) {
            this.parseHeader(e), this.content_encoding = e.readCString(), this.namespace = e.readCString(), this.schema_location = e.readCString(), this.parseFooter(e)
        }),b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SUBTITLE, "sbtt", function (e) {
            this.parseHeader(e), this.content_encoding = e.readCString(), this.mime_format = e.readCString(), this.parseFooter(e)
        }),b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SUBTITLE, "stpp", function (e) {
            this.parseHeader(e), this.namespace = e.readCString(), this.schema_location = e.readCString(), this.auxiliary_mime_types = e.readCString(), this.parseFooter(e)
        }),b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SUBTITLE, "stxt", function (e) {
            this.parseHeader(e), this.content_encoding = e.readCString(), this.mime_format = e.readCString(), this.parseFooter(e)
        }),b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_SUBTITLE, "tx3g", function (e) {
            this.parseHeader(e), this.displayFlags = e.readUint32(), this.horizontal_justification = e.readInt8(), this.vertical_justification = e.readInt8(), this.bg_color_rgba = e.readUint8Array(4), this.box_record = e.readInt16Array(4), this.style_record = e.readUint8Array(12), this.parseFooter(e)
        }),b.createSampleEntryCtor(b.SAMPLE_ENTRY_TYPE_METADATA, "wvtt", function (e) {
            this.parseHeader(e), this.parseFooter(e)
        }),b.createSampleGroupCtor("alst", function (e) {
            var t, i = e.readUint16();
            for (this.first_output_sample = e.readUint16(), this.sample_offset = [], t = 0; t < i; t++) this.sample_offset[t] = e.readUint32();
            var r = this.description_length - 4 - 4 * i;
            for (this.num_output_samples = [], this.num_total_samples = [], t = 0; t < r / 4; t++) this.num_output_samples[t] = e.readUint16(), this.num_total_samples[t] = e.readUint16()
        }),b.createSampleGroupCtor("avll", function (e) {
            this.layerNumber = e.readUint8(), this.accurateStatisticsFlag = e.readUint8(), this.avgBitRate = e.readUint16(), this.avgFrameRate = e.readUint16()
        }),b.createSampleGroupCtor("avss", function (e) {
            this.subSequenceIdentifier = e.readUint16(), this.layerNumber = e.readUint8();
            var t = e.readUint8();
            this.durationFlag = t >> 7, this.avgRateFlag = t >> 6 & 1, this.durationFlag && (this.duration = e.readUint32()), this.avgRateFlag && (this.accurateStatisticsFlag = e.readUint8(), this.avgBitRate = e.readUint16(), this.avgFrameRate = e.readUint16()), this.dependency = [];
            for (var i = e.readUint8(), r = 0; r < i; r++) {
                var s = {};
                this.dependency.push(s), s.subSeqDirectionFlag = e.readUint8(), s.layerNumber = e.readUint8(), s.subSequenceIdentifier = e.readUint16()
            }
        }),b.createSampleGroupCtor("dtrt", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createSampleGroupCtor("mvif", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createSampleGroupCtor("prol", function (e) {
            this.roll_distance = e.readInt16()
        }),b.createSampleGroupCtor("rap ", function (e) {
            e = e.readUint8();
            this.num_leading_samples_known = e >> 7, this.num_leading_samples = 127 & e
        }),b.createSampleGroupCtor("rash", function (e) {
            if (this.operation_point_count = e.readUint16(), this.description_length !== 2 + (1 === this.operation_point_count ? 2 : 6 * this.operation_point_count) + 9) u.warn("BoxParser", "Mismatch in " + this.grouping_type + " sample group length"), this.data = e.readUint8Array(this.description_length - 2); else {
                if (1 === this.operation_point_count) this.target_rate_share = e.readUint16(); else {
                    this.target_rate_share = [], this.available_bitrate = [];
                    for (var t = 0; t < this.operation_point_count; t++) this.available_bitrate[t] = e.readUint32(), this.target_rate_share[t] = e.readUint16()
                }
                this.maximum_bitrate = e.readUint32(), this.minimum_bitrate = e.readUint32(), this.discard_priority = e.readUint8()
            }
        }),b.createSampleGroupCtor("roll", function (e) {
            this.roll_distance = e.readInt16()
        }),b.SampleGroupEntry.prototype.parse = function (e) {
            u.warn("BoxParser", "Unknown Sample Group type: " + this.grouping_type), this.data = e.readUint8Array(this.description_length)
        },b.createSampleGroupCtor("scif", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createSampleGroupCtor("scnm", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createSampleGroupCtor("seig", function (e) {
            this.reserved = e.readUint8();
            var t = e.readUint8();
            this.crypt_byte_block = t >> 4, this.skip_byte_block = 15 & t, this.isProtected = e.readUint8(), this.Per_Sample_IV_Size = e.readUint8(), this.KID = b.parseHex16(e), this.constant_IV_size = 0, this.constant_IV = 0, 1 === this.isProtected && 0 === this.Per_Sample_IV_Size && (this.constant_IV_size = e.readUint8(), this.constant_IV = e.readUint8Array(this.constant_IV_size))
        }),b.createSampleGroupCtor("stsa", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createSampleGroupCtor("sync", function (e) {
            e = e.readUint8();
            this.NAL_unit_type = 63 & e
        }),b.createSampleGroupCtor("tele", function (e) {
            e = e.readUint8();
            this.level_independently_decodable = e >> 7
        }),b.createSampleGroupCtor("tsas", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createSampleGroupCtor("tscl", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createSampleGroupCtor("vipr", function (e) {
            u.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed")
        }),b.createFullBoxCtor("sbgp", function (e) {
            this.grouping_type = e.readString(4), 1 === this.version ? this.grouping_type_parameter = e.readUint32() : this.grouping_type_parameter = 0, this.entries = [];
            for (var t = e.readUint32(), i = 0; i < t; i++) {
                var r = {};
                this.entries.push(r), r.sample_count = e.readInt32(), r.group_description_index = e.readInt32()
            }
        }),b.createFullBoxCtor("schm", function (e) {
            this.scheme_type = e.readString(4), this.scheme_version = e.readUint32(), 1 & this.flags && (this.scheme_uri = e.readString(this.size - this.hdr_size - 8))
        }),b.createBoxCtor("sdp ", function (e) {
            this.sdptext = e.readString(this.size - this.hdr_size)
        }),b.createFullBoxCtor("sdtp", function (e) {
            var t, i = this.size - this.hdr_size;
            this.is_leading = [], this.sample_depends_on = [], this.sample_is_depended_on = [], this.sample_has_redundancy = [];
            for (var r = 0; r < i; r++) t = e.readUint8(), this.is_leading[r] = t >> 6, this.sample_depends_on[r] = t >> 4 & 3, this.sample_is_depended_on[r] = t >> 2 & 3, this.sample_has_redundancy[r] = 3 & t
        }),b.createFullBoxCtor("senc"),b.createFullBoxCtor("sgpd", function (e) {
            this.grouping_type = e.readString(4), u.debug("BoxParser", "Found Sample Groups of type " + this.grouping_type), 1 === this.version ? this.default_length = e.readUint32() : this.default_length = 0, 2 <= this.version && (this.default_group_description_index = e.readUint32()), this.entries = [];
            for (var t = e.readUint32(), i = 0; i < t; i++) {
                var r = new (b[this.grouping_type + "SampleGroupEntry"] ? b[this.grouping_type + "SampleGroupEntry"] : b.SampleGroupEntry)(this.grouping_type);
                this.entries.push(r), 1 === this.version && 0 === this.default_length ? r.description_length = e.readUint32() : r.description_length = this.default_length, r.write === b.SampleGroupEntry.prototype.write && (u.info("BoxParser", "SampleGroup for type " + this.grouping_type + " writing not yet implemented, keeping unparsed data in memory for later write"), r.data = e.readUint8Array(r.description_length), e.position -= r.description_length), r.parse(e)
            }
        }),b.createFullBoxCtor("sidx", function (e) {
            this.reference_ID = e.readUint32(), this.timescale = e.readUint32(), 0 === this.version ? (this.earliest_presentation_time = e.readUint32(), this.first_offset = e.readUint32()) : (this.earliest_presentation_time = e.readUint64(), this.first_offset = e.readUint64()), e.readUint16(), this.references = [];
            for (var t = e.readUint16(), i = 0; i < t; i++) {
                var r = {}, s = (this.references.push(r), e.readUint32());
                r.reference_type = s >> 31 & 1, r.referenced_size = 2147483647 & s, r.subsegment_duration = e.readUint32(), s = e.readUint32(), r.starts_with_SAP = s >> 31 & 1, r.SAP_type = s >> 28 & 7, r.SAP_delta_time = 268435455 & s
            }
        }),b.SingleItemTypeReferenceBox = function (e, t, i, r) {
            b.Box.call(this, e, t), this.hdr_size = i, this.start = r
        },b.SingleItemTypeReferenceBox.prototype = new b.Box,b.SingleItemTypeReferenceBox.prototype.parse = function (e) {
            this.from_item_ID = e.readUint16();
            var t = e.readUint16();
            this.references = [];
            for (var i = 0; i < t; i++) this.references[i] = e.readUint16()
        },b.SingleItemTypeReferenceBoxLarge = function (e, t, i, r) {
            b.Box.call(this, e, t), this.hdr_size = i, this.start = r
        },b.SingleItemTypeReferenceBoxLarge.prototype = new b.Box,b.SingleItemTypeReferenceBoxLarge.prototype.parse = function (e) {
            this.from_item_ID = e.readUint32();
            var t = e.readUint16();
            this.references = [];
            for (var i = 0; i < t; i++) this.references[i] = e.readUint32()
        },b.createFullBoxCtor("SmDm", function (e) {
            this.primaryRChromaticity_x = e.readUint16(), this.primaryRChromaticity_y = e.readUint16(), this.primaryGChromaticity_x = e.readUint16(), this.primaryGChromaticity_y = e.readUint16(), this.primaryBChromaticity_x = e.readUint16(), this.primaryBChromaticity_y = e.readUint16(), this.whitePointChromaticity_x = e.readUint16(), this.whitePointChromaticity_y = e.readUint16(), this.luminanceMax = e.readUint32(), this.luminanceMin = e.readUint32()
        }),b.createFullBoxCtor("smhd", function (e) {
            this.balance = e.readUint16(), e.readUint16()
        }),b.createFullBoxCtor("ssix", function (e) {
            this.subsegments = [];
            for (var t = e.readUint32(), i = 0; i < t; i++) {
                var r = {};
                this.subsegments.push(r), r.ranges = [];
                for (var s = e.readUint32(), a = 0; a < s; a++) {
                    var n = {};
                    r.ranges.push(n), n.level = e.readUint8(), n.range_size = e.readUint24()
                }
            }
        }),b.createFullBoxCtor("stco", function (e) {
            var t = e.readUint32();
            if (this.chunk_offsets = [], 0 === this.version) for (var i = 0; i < t; i++) this.chunk_offsets.push(e.readUint32())
        }),b.createFullBoxCtor("stdp", function (e) {
            var t = (this.size - this.hdr_size) / 2;
            this.priority = [];
            for (var i = 0; i < t; i++) this.priority[i] = e.readUint16()
        }),b.createFullBoxCtor("sthd"),b.createFullBoxCtor("stri", function (e) {
            this.switch_group = e.readUint16(), this.alternate_group = e.readUint16(), this.sub_track_id = e.readUint32();
            var t = (this.size - this.hdr_size - 8) / 4;
            this.attribute_list = [];
            for (var i = 0; i < t; i++) this.attribute_list[i] = e.readUint32()
        }),b.createFullBoxCtor("stsc", function (e) {
            var t, i = e.readUint32();
            if (this.first_chunk = [], this.samples_per_chunk = [], this.sample_description_index = [], 0 === this.version) for (t = 0; t < i; t++) this.first_chunk.push(e.readUint32()), this.samples_per_chunk.push(e.readUint32()), this.sample_description_index.push(e.readUint32())
        }),b.createFullBoxCtor("stsd", function (e) {
            var t, i, r, s;
            for (this.entries = [], r = e.readUint32(), t = 1; t <= r; t++) {
                if ((i = b.parseOneBox(e, !0, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                b[i.type + "SampleEntry"] ? ((s = new b[i.type + "SampleEntry"](i.size)).hdr_size = i.hdr_size, s.start = i.start) : (u.warn("BoxParser", "Unknown sample entry type: " + i.type), s = new b.SampleEntry(i.type, i.size, i.hdr_size, i.start)), s.write === b.SampleEntry.prototype.write && (u.info("BoxParser", "SampleEntry " + s.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), s.parseDataAndRewind(e)), s.parse(e), this.entries.push(s)
            }
        }),b.createFullBoxCtor("stsg", function (e) {
            this.grouping_type = e.readUint32();
            var t = e.readUint16();
            this.group_description_index = [];
            for (var i = 0; i < t; i++) this.group_description_index[i] = e.readUint32()
        }),b.createFullBoxCtor("stsh", function (e) {
            var t, i = e.readUint32();
            if (this.shadowed_sample_numbers = [], this.sync_sample_numbers = [], 0 === this.version) for (t = 0; t < i; t++) this.shadowed_sample_numbers.push(e.readUint32()), this.sync_sample_numbers.push(e.readUint32())
        }),b.createFullBoxCtor("stss", function (e) {
            var t, i = e.readUint32();
            if (0 === this.version) for (this.sample_numbers = [], t = 0; t < i; t++) this.sample_numbers.push(e.readUint32())
        }),b.createFullBoxCtor("stsz", function (e) {
            var t;
            if (this.sample_sizes = [], 0 === this.version) for (this.sample_size = e.readUint32(), this.sample_count = e.readUint32(), t = 0; t < this.sample_count; t++) 0 === this.sample_size ? this.sample_sizes.push(e.readUint32()) : this.sample_sizes[t] = this.sample_size
        }),b.createFullBoxCtor("stts", function (e) {
            var t, i, r = e.readUint32();
            if (this.sample_counts = [], this.sample_deltas = [], 0 === this.version) for (t = 0; t < r; t++) this.sample_counts.push(e.readUint32()), (i = e.readInt32()) < 0 && (u.warn("BoxParser", "File uses negative stts sample delta, using value 1 instead, sync may be lost!"), i = 1), this.sample_deltas.push(i)
        }),b.createFullBoxCtor("stvi", function (e) {
            var t = e.readUint32();
            this.single_view_allowed = 3 & t, this.stereo_scheme = e.readUint32();
            var i, t = e.readUint32();
            for (this.stereo_indication_type = e.readString(t), this.boxes = []; e.getPosition() < this.start + this.size;) {
                if ((i = b.parseOneBox(e, !1, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                i = i.box, this.boxes.push(i), this[i.type] = i
            }
        }),b.createBoxCtor("styp", function (e) {
            b.ftypBox.prototype.parse.call(this, e)
        }),b.createFullBoxCtor("stz2", function (e) {
            var t, i;
            if (this.sample_sizes = [], 0 === this.version) if (this.reserved = e.readUint24(), this.field_size = e.readUint8(), i = e.readUint32(), 4 === this.field_size) for (t = 0; t < i; t += 2) {
                var r = e.readUint8();
                this.sample_sizes[t] = r >> 4 & 15, this.sample_sizes[t + 1] = 15 & r
            } else if (8 === this.field_size) for (t = 0; t < i; t++) this.sample_sizes[t] = e.readUint8(); else if (16 === this.field_size) for (t = 0; t < i; t++) this.sample_sizes[t] = e.readUint16(); else u.error("BoxParser", "Error in length field in stz2 box")
        }),b.createFullBoxCtor("subs", function (e) {
            var t, i, r, s = e.readUint32();
            for (this.entries = [], t = 0; t < s; t++) {
                var a = {};
                if ((this.entries[t] = a).sample_delta = e.readUint32(), a.subsamples = [], 0 < (r = e.readUint16())) for (i = 0; i < r; i++) {
                    var n = {};
                    a.subsamples.push(n), 1 == this.version ? n.size = e.readUint32() : n.size = e.readUint16(), n.priority = e.readUint8(), n.discardable = e.readUint8(), n.codec_specific_parameters = e.readUint32()
                }
            }
        }),b.createFullBoxCtor("tenc", function (e) {
            var t;
            e.readUint8(), 0 === this.version ? e.readUint8() : (t = e.readUint8(), this.default_crypt_byte_block = t >> 4 & 15, this.default_skip_byte_block = 15 & t), this.default_isProtected = e.readUint8(), this.default_Per_Sample_IV_Size = e.readUint8(), this.default_KID = b.parseHex16(e), 1 === this.default_isProtected && 0 === this.default_Per_Sample_IV_Size && (this.default_constant_IV_size = e.readUint8(), this.default_constant_IV = e.readUint8Array(this.default_constant_IV_size))
        }),b.createFullBoxCtor("tfdt", function (e) {
            1 == this.version ? this.baseMediaDecodeTime = e.readUint64() : this.baseMediaDecodeTime = e.readUint32()
        }),b.createFullBoxCtor("tfhd", function (e) {
            var t = 0;
            this.track_id = e.readUint32(), this.size - this.hdr_size > t && this.flags & b.TFHD_FLAG_BASE_DATA_OFFSET ? (this.base_data_offset = e.readUint64(), t += 8) : this.base_data_offset = 0, this.size - this.hdr_size > t && this.flags & b.TFHD_FLAG_SAMPLE_DESC ? (this.default_sample_description_index = e.readUint32(), t += 4) : this.default_sample_description_index = 0, this.size - this.hdr_size > t && this.flags & b.TFHD_FLAG_SAMPLE_DUR ? (this.default_sample_duration = e.readUint32(), t += 4) : this.default_sample_duration = 0, this.size - this.hdr_size > t && this.flags & b.TFHD_FLAG_SAMPLE_SIZE ? (this.default_sample_size = e.readUint32(), t += 4) : this.default_sample_size = 0, this.size - this.hdr_size > t && this.flags & b.TFHD_FLAG_SAMPLE_FLAGS ? this.default_sample_flags = e.readUint32() : this.default_sample_flags = 0
        }),b.createFullBoxCtor("tfra", function (e) {
            this.track_ID = e.readUint32(), e.readUint24();
            var t = e.readUint8();
            this.length_size_of_traf_num = t >> 4 & 3, this.length_size_of_trun_num = t >> 2 & 3, this.length_size_of_sample_num = 3 & t, this.entries = [];
            for (var i = e.readUint32(), r = 0; r < i; r++) 1 === this.version ? (this.time = e.readUint64(), this.moof_offset = e.readUint64()) : (this.time = e.readUint32(), this.moof_offset = e.readUint32()), this.traf_number = e["readUint" + 8 * (this.length_size_of_traf_num + 1)](), this.trun_number = e["readUint" + 8 * (this.length_size_of_trun_num + 1)](), this.sample_number = e["readUint" + 8 * (this.length_size_of_sample_num + 1)]()
        }),b.createFullBoxCtor("tkhd", function (e) {
            1 == this.version ? (this.creation_time = e.readUint64(), this.modification_time = e.readUint64(), this.track_id = e.readUint32(), e.readUint32(), this.duration = e.readUint64()) : (this.creation_time = e.readUint32(), this.modification_time = e.readUint32(), this.track_id = e.readUint32(), e.readUint32(), this.duration = e.readUint32()), e.readUint32Array(2), this.layer = e.readInt16(), this.alternate_group = e.readInt16(), this.volume = e.readInt16() >> 8, e.readUint16(), this.matrix = e.readInt32Array(9), this.width = e.readUint32(), this.height = e.readUint32()
        }),b.createBoxCtor("tmax", function (e) {
            this.time = e.readUint32()
        }),b.createBoxCtor("tmin", function (e) {
            this.time = e.readUint32()
        }),b.createBoxCtor("totl", function (e) {
            this.bytessent = e.readUint32()
        }),b.createBoxCtor("tpay", function (e) {
            this.bytessent = e.readUint32()
        }),b.createBoxCtor("tpyl", function (e) {
            this.bytessent = e.readUint64()
        }),b.TrackGroupTypeBox.prototype.parse = function (e) {
            this.parseFullHeader(e), this.track_group_id = e.readUint32()
        },b.createTrackGroupCtor("msrc"),b.TrackReferenceTypeBox = function (e, t, i, r) {
            b.Box.call(this, e, t), this.hdr_size = i, this.start = r
        },b.TrackReferenceTypeBox.prototype = new b.Box,b.TrackReferenceTypeBox.prototype.parse = function (e) {
            this.track_ids = e.readUint32Array((this.size - this.hdr_size) / 4)
        },b.trefBox.prototype.parse = function (e) {
            for (var t; e.getPosition() < this.start + this.size;) {
                if ((t = b.parseOneBox(e, !0, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                (t = new b.TrackReferenceTypeBox(t.type, t.size, t.hdr_size, t.start)).write === b.Box.prototype.write && "mdat" !== t.type && (u.info("BoxParser", "TrackReference " + t.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), t.parseDataAndRewind(e)), t.parse(e), this.boxes.push(t)
            }
        },b.createFullBoxCtor("trep", function (e) {
            for (this.track_ID = e.readUint32(), this.boxes = []; e.getPosition() < this.start + this.size;) {
                if ((ret = b.parseOneBox(e, !1, this.size - (e.getPosition() - this.start))).code !== b.OK) return;
                box = ret.box, this.boxes.push(box)
            }
        }),b.createFullBoxCtor("trex", function (e) {
            this.track_id = e.readUint32(), this.default_sample_description_index = e.readUint32(), this.default_sample_duration = e.readUint32(), this.default_sample_size = e.readUint32(), this.default_sample_flags = e.readUint32()
        }),b.createBoxCtor("trpy", function (e) {
            this.bytessent = e.readUint64()
        }),b.createFullBoxCtor("trun", function (e) {
            var t = 0;
            if (this.sample_count = e.readUint32(), this.size - this.hdr_size > (t += 4) && this.flags & b.TRUN_FLAGS_DATA_OFFSET ? (this.data_offset = e.readInt32(), t += 4) : this.data_offset = 0, this.size - this.hdr_size > t && this.flags & b.TRUN_FLAGS_FIRST_FLAG ? (this.first_sample_flags = e.readUint32(), t += 4) : this.first_sample_flags = 0, this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [], this.size - this.hdr_size > t) for (var i = 0; i < this.sample_count; i++) this.flags & b.TRUN_FLAGS_DURATION && (this.sample_duration[i] = e.readUint32()), this.flags & b.TRUN_FLAGS_SIZE && (this.sample_size[i] = e.readUint32()), this.flags & b.TRUN_FLAGS_FLAGS && (this.sample_flags[i] = e.readUint32()), this.flags & b.TRUN_FLAGS_CTS_OFFSET && (0 === this.version ? this.sample_composition_time_offset[i] = e.readUint32() : this.sample_composition_time_offset[i] = e.readInt32())
        }),b.createFullBoxCtor("tsel", function (e) {
            this.switch_group = e.readUint32();
            var t = (this.size - this.hdr_size - 4) / 4;
            this.attribute_list = [];
            for (var i = 0; i < t; i++) this.attribute_list[i] = e.readUint32()
        }),b.createFullBoxCtor("txtC", function (e) {
            this.config = e.readCString()
        }),b.createFullBoxCtor("url ", function (e) {
            1 !== this.flags && (this.location = e.readCString())
        }),b.createFullBoxCtor("urn ", function (e) {
            this.name = e.readCString(), 0 < this.size - this.hdr_size - this.name.length - 1 && (this.location = e.readCString())
        }),b.createUUIDBox("a5d40b30e81411ddba2f0800200c9a66", !0, !1, function (e) {
            this.LiveServerManifest = e.readString(this.size - this.hdr_size).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;")
        }),b.createUUIDBox("d08a4f1810f34a82b6c832d8aba183d3", !0, !1, function (e) {
            this.system_id = b.parseHex16(e);
            var t = e.readUint32();
            0 < t && (this.data = e.readUint8Array(t))
        }),b.createUUIDBox("a2394f525a9b4f14a2446c427c648df4", !0, !1),b.createUUIDBox("8974dbce7be74c5184f97148f9882554", !0, !1, function (e) {
            this.default_AlgorithmID = e.readUint24(), this.default_IV_size = e.readUint8(), this.default_KID = b.parseHex16(e)
        }),b.createUUIDBox("d4807ef2ca3946958e5426cb9e46a79f", !0, !1, function (e) {
            this.fragment_count = e.readUint8(), this.entries = [];
            for (var t = 0; t < this.fragment_count; t++) {
                var i = {}, r = 0, s = 0,
                    s = 1 === this.version ? (r = e.readUint64(), e.readUint64()) : (r = e.readUint32(), e.readUint32());
                i.absolute_time = r, i.absolute_duration = s, this.entries.push(i)
            }
        }),b.createUUIDBox("6d1d9b0542d544e680e2141daff757b2", !0, !1, function (e) {
            1 === this.version ? (this.absolute_time = e.readUint64(), this.duration = e.readUint64()) : (this.absolute_time = e.readUint32(), this.duration = e.readUint32())
        }),b.createFullBoxCtor("vmhd", function (e) {
            this.graphicsmode = e.readUint16(), this.opcolor = e.readUint16Array(3)
        }),b.createFullBoxCtor("vpcC", function (e) {
            var t;
            1 === this.version ? (this.profile = e.readUint8(), this.level = e.readUint8(), t = e.readUint8(), this.bitDepth = t >> 4, this.chromaSubsampling = t >> 1 & 7, this.videoFullRangeFlag = 1 & t, this.colourPrimaries = e.readUint8(), this.transferCharacteristics = e.readUint8(), this.matrixCoefficients = e.readUint8()) : (this.profile = e.readUint8(), this.level = e.readUint8(), t = e.readUint8(), this.bitDepth = t >> 4 & 15, this.colorSpace = 15 & t, t = e.readUint8(), this.chromaSubsampling = t >> 4 & 15, this.transferFunction = t >> 1 & 7, this.videoFullRangeFlag = 1 & t), this.codecIntializationDataSize = e.readUint16(), this.codecIntializationData = e.readUint8Array(this.codecIntializationDataSize)
        }),b.createBoxCtor("vttC", function (e) {
            this.text = e.readString(this.size - this.hdr_size)
        }),b.createFullBoxCtor("vvcC", function (e) {
            var t, i = {
                held_bits: void 0, num_held_bits: 0, stream_read_1_bytes: function (e) {
                    this.held_bits = e.readUint8(), this.num_held_bits = 8
                }, stream_read_2_bytes: function (e) {
                    this.held_bits = e.readUint16(), this.num_held_bits = 16
                }, extract_bits: function (e) {
                    var t = this.held_bits >> this.num_held_bits - e & (1 << e) - 1;
                    return this.num_held_bits -= e, t
                }
            };
            if (i.stream_read_1_bytes(e), i.extract_bits(5), this.lengthSizeMinusOne = i.extract_bits(2), this.ptl_present_flag = i.extract_bits(1), this.ptl_present_flag) {
                if (i.stream_read_2_bytes(e), this.ols_idx = i.extract_bits(9), this.num_sublayers = i.extract_bits(3), this.constant_frame_rate = i.extract_bits(2), this.chroma_format_idc = i.extract_bits(2), i.stream_read_1_bytes(e), this.bit_depth_minus8 = i.extract_bits(3), i.extract_bits(5), i.stream_read_2_bytes(e), i.extract_bits(2), this.num_bytes_constraint_info = i.extract_bits(6), this.general_profile_idc = i.extract_bits(7), this.general_tier_flag = i.extract_bits(1), this.general_level_idc = e.readUint8(), i.stream_read_1_bytes(e), this.ptl_frame_only_constraint_flag = i.extract_bits(1), this.ptl_multilayer_enabled_flag = i.extract_bits(1), this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info), this.num_bytes_constraint_info) {
                    for (o = 0; o < this.num_bytes_constraint_info - 1; o++) {
                        var r = i.extract_bits(6), s = (i.stream_read_1_bytes(e), i.extract_bits(2));
                        this.general_constraint_info[o] = r << 2 | s
                    }
                    this.general_constraint_info[this.num_bytes_constraint_info - 1] = i.extract_bits(6)
                } else i.extract_bits(6);
                for (i.stream_read_1_bytes(e), this.ptl_sublayer_present_mask = 0, t = this.num_sublayers - 2; 0 <= t; --t) {
                    var a = i.extract_bits(1);
                    this.ptl_sublayer_present_mask |= a << t
                }
                for (t = this.num_sublayers; t <= 8 && 1 < this.num_sublayers; ++t) i.extract_bits(1);
                for (t = this.num_sublayers - 2; 0 <= t; --t) this.ptl_sublayer_present_mask & 1 << t && (this.sublayer_level_idc[t] = e.readUint8());
                if (this.ptl_num_sub_profiles = e.readUint8(), this.general_sub_profile_idc = [], this.ptl_num_sub_profiles) for (o = 0; o < this.ptl_num_sub_profiles; o++) this.general_sub_profile_idc.push(e.readUint32());
                this.max_picture_width = e.readUint16(), this.max_picture_height = e.readUint16(), this.avg_frame_rate = e.readUint16()
            }
            this.nalu_arrays = [];
            for (var n = e.readUint8(), o = 0; o < n; o++) {
                var l = [],
                    d = (this.nalu_arrays.push(l), i.stream_read_1_bytes(e), l.completeness = i.extract_bits(1), i.extract_bits(2), l.nalu_type = i.extract_bits(5), 1);
                for (13 != l.nalu_type && 12 != l.nalu_type && (d = e.readUint16()), t = 0; t < d; t++) {
                    var h = e.readUint16();
                    l.push({data: e.readUint8Array(h), length: h})
                }
            }
        }),b.createFullBoxCtor("vvnC", function (e) {
            var t = strm.readUint8();
            this.lengthSizeMinusOne = 3 & t
        }),b.SampleEntry.prototype.isVideo = function () {
            return !1
        },b.SampleEntry.prototype.isAudio = function () {
            return !1
        },b.SampleEntry.prototype.isSubtitle = function () {
            return !1
        },b.SampleEntry.prototype.isMetadata = function () {
            return !1
        },b.SampleEntry.prototype.isHint = function () {
            return !1
        },b.SampleEntry.prototype.getCodec = function () {
            return this.type.replace(".", "")
        },b.SampleEntry.prototype.getWidth = function () {
            return ""
        },b.SampleEntry.prototype.getHeight = function () {
            return ""
        },b.SampleEntry.prototype.getChannelCount = function () {
            return ""
        },b.SampleEntry.prototype.getSampleRate = function () {
            return ""
        },b.SampleEntry.prototype.getSampleSize = function () {
            return ""
        },b.VisualSampleEntry.prototype.isVideo = function () {
            return !0
        },b.VisualSampleEntry.prototype.getWidth = function () {
            return this.width
        },b.VisualSampleEntry.prototype.getHeight = function () {
            return this.height
        },b.AudioSampleEntry.prototype.isAudio = function () {
            return !0
        },b.AudioSampleEntry.prototype.getChannelCount = function () {
            return this.channel_count
        },b.AudioSampleEntry.prototype.getSampleRate = function () {
            return this.samplerate
        },b.AudioSampleEntry.prototype.getSampleSize = function () {
            return this.samplesize
        },b.SubtitleSampleEntry.prototype.isSubtitle = function () {
            return !0
        },b.MetadataSampleEntry.prototype.isMetadata = function () {
            return !0
        },b.decimalToHex = function (e, t) {
            var i = Number(e).toString(16);
            for (t = null == t ? 2 : t; i.length < t;) i = "0" + i;
            return i
        },b.avc1SampleEntry.prototype.getCodec = b.avc2SampleEntry.prototype.getCodec = b.avc3SampleEntry.prototype.getCodec = b.avc4SampleEntry.prototype.getCodec = function () {
            var e = b.SampleEntry.prototype.getCodec.call(this);
            return this.avcC ? e + "." + b.decimalToHex(this.avcC.AVCProfileIndication) + b.decimalToHex(this.avcC.profile_compatibility) + b.decimalToHex(this.avcC.AVCLevelIndication) : e
        },b.hev1SampleEntry.prototype.getCodec = b.hvc1SampleEntry.prototype.getCodec = function () {
            var e = b.SampleEntry.prototype.getCodec.call(this);
            if (this.hvcC) {
                switch (e += ".", this.hvcC.general_profile_space) {
                    case 0:
                        e += "";
                        break;
                    case 1:
                        e += "A";
                        break;
                    case 2:
                        e += "B";
                        break;
                    case 3:
                        e += "C"
                }
                for (var e = e + this.hvcC.general_profile_idc + ".", t = this.hvcC.general_profile_compatibility, i = 0, r = 0; r < 32 && (i |= 1 & t, 31 != r); r++) i <<= 1, t >>= 1;
                e = e + b.decimalToHex(i, 0) + ".", 0 === this.hvcC.general_tier_flag ? e += "L" : e += "H", e += this.hvcC.general_level_idc;
                var s = !1, a = "";
                for (r = 5; 0 <= r; r--) (this.hvcC.general_constraint_indicator[r] || s) && (a = "." + b.decimalToHex(this.hvcC.general_constraint_indicator[r], 0) + a, s = !0);
                e += a
            }
            return e
        },b.vvc1SampleEntry.prototype.getCodec = b.vvi1SampleEntry.prototype.getCodec = function () {
            var e = b.SampleEntry.prototype.getCodec.call(this);
            if (this.vvcC) {
                e += "." + this.vvcC.general_profile_idc, this.vvcC.general_tier_flag ? e += ".H" : e += ".L", e += this.vvcC.general_level_idc;
                var t = "";
                if (this.vvcC.general_constraint_info) {
                    var i, r = [], s = 0,
                        s = (s |= this.vvcC.ptl_frame_only_constraint << 7) | this.vvcC.ptl_multilayer_enabled << 6;
                    for (l = 0; l < this.vvcC.general_constraint_info.length; ++l) s |= this.vvcC.general_constraint_info[l] >> 2 & 63, r.push(s), s && (i = l), s = this.vvcC.general_constraint_info[l] >> 2 & 3;
                    if (void 0 === i) t = ".CA"; else {
                        for (var t = ".C", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", n = 0, o = 0, l = 0; l <= i; ++l) for (n = n << 8 | r[l], o += 8; 5 <= o;) t += a[n >> o - 5 & 31], n &= (1 << (o -= 5)) - 1;
                        o && (t += a[31 & (n <<= 5 - o)])
                    }
                }
                e += t
            }
            return e
        },b.mp4aSampleEntry.prototype.getCodec = function () {
            var e, t, i = b.SampleEntry.prototype.getCodec.call(this);
            return this.esds && this.esds.esd ? (e = this.esds.esd.getOTI(), t = this.esds.esd.getAudioConfig(), i + "." + b.decimalToHex(e) + (t ? "." + t : "")) : i
        },b.stxtSampleEntry.prototype.getCodec = function () {
            var e = b.SampleEntry.prototype.getCodec.call(this);
            return this.mime_format ? e + "." + this.mime_format : e
        },b.vp08SampleEntry.prototype.getCodec = b.vp09SampleEntry.prototype.getCodec = function () {
            var e = b.SampleEntry.prototype.getCodec.call(this), t = this.vpcC.level, i = this.vpcC.bitDepth;
            return e + ".0" + this.vpcC.profile + "." + (t = 0 == t ? "00" : t) + "." + (i = 8 == i ? "08" : i)
        },b.av01SampleEntry.prototype.getCodec = function () {
            var e, t = b.SampleEntry.prototype.getCodec.call(this), i = this.av1C.seq_level_idx_0;
            return 2 === this.av1C.seq_profile && 1 === this.av1C.high_bitdepth ? e = 1 === this.av1C.twelve_bit ? "12" : "10" : this.av1C.seq_profile <= 2 && (e = 1 === this.av1C.high_bitdepth ? "10" : "08"), t + "." + this.av1C.seq_profile + "." + (i = i < 10 ? "0" + i : i) + (this.av1C.seq_tier_0 ? "H" : "M") + "." + e
        },b.Box.prototype.writeHeader = function (e, t) {
            this.size += 8, this.size > d && (this.size += 8), "uuid" === this.type && (this.size += 16), u.debug("BoxWriter", "Writing box " + this.type + " of size: " + this.size + " at position " + e.getPosition() + (t || "")), this.size > d ? e.writeUint32(1) : (this.sizePosition = e.getPosition(), e.writeUint32(this.size)), e.writeString(this.type, null, 4), "uuid" === this.type && e.writeUint8Array(this.uuid), this.size > d && e.writeUint64(this.size)
        },b.FullBox.prototype.writeHeader = function (e) {
            this.size += 4, b.Box.prototype.writeHeader.call(this, e, " v=" + this.version + " f=" + this.flags), e.writeUint8(this.version), e.writeUint24(this.flags)
        },b.Box.prototype.write = function (e) {
            "mdat" === this.type ? this.data && (this.size = this.data.length, this.writeHeader(e), e.writeUint8Array(this.data)) : (this.size = this.data ? this.data.length : 0, this.writeHeader(e), this.data && e.writeUint8Array(this.data))
        },b.ContainerBox.prototype.write = function (e) {
            this.size = 0, this.writeHeader(e);
            for (var t = 0; t < this.boxes.length; t++) this.boxes[t] && (this.boxes[t].write(e), this.size += this.boxes[t].size);
            u.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size)
        },b.TrackReferenceTypeBox.prototype.write = function (e) {
            this.size = 4 * this.track_ids.length, this.writeHeader(e), e.writeUint32Array(this.track_ids)
        },b.avcCBox.prototype.write = function (e) {
            var t;
            for (this.size = 7, t = 0; t < this.SPS.length; t++) this.size += 2 + this.SPS[t].length;
            for (t = 0; t < this.PPS.length; t++) this.size += 2 + this.PPS[t].length;
            for (this.ext && (this.size += this.ext.length), this.writeHeader(e), e.writeUint8(this.configurationVersion), e.writeUint8(this.AVCProfileIndication), e.writeUint8(this.profile_compatibility), e.writeUint8(this.AVCLevelIndication), e.writeUint8(this.lengthSizeMinusOne + 252), e.writeUint8(this.SPS.length + 224), t = 0; t < this.SPS.length; t++) e.writeUint16(this.SPS[t].length), e.writeUint8Array(this.SPS[t].nalu);
            for (e.writeUint8(this.PPS.length), t = 0; t < this.PPS.length; t++) e.writeUint16(this.PPS[t].length), e.writeUint8Array(this.PPS[t].nalu);
            this.ext && e.writeUint8Array(this.ext)
        },b.co64Box.prototype.write = function (e) {
            var t;
            for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.chunk_offsets.length, this.writeHeader(e), e.writeUint32(this.chunk_offsets.length), t = 0; t < this.chunk_offsets.length; t++) e.writeUint64(this.chunk_offsets[t])
        },b.cslgBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 20, this.writeHeader(e), e.writeInt32(this.compositionToDTSShift), e.writeInt32(this.leastDecodeToDisplayDelta), e.writeInt32(this.greatestDecodeToDisplayDelta), e.writeInt32(this.compositionStartTime), e.writeInt32(this.compositionEndTime)
        },b.cttsBox.prototype.write = function (e) {
            var t;
            for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(e), e.writeUint32(this.sample_counts.length), t = 0; t < this.sample_counts.length; t++) e.writeUint32(this.sample_counts[t]), 1 === this.version ? e.writeInt32(this.sample_offsets[t]) : e.writeUint32(this.sample_offsets[t])
        },b.drefBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(e), e.writeUint32(this.entries.length);
            for (var t = 0; t < this.entries.length; t++) this.entries[t].write(e), this.size += this.entries[t].size;
            u.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size)
        },b.elngBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = this.extended_language.length, this.writeHeader(e), e.writeString(this.extended_language)
        },b.elstBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 4 + 12 * this.entries.length, this.writeHeader(e), e.writeUint32(this.entries.length);
            for (var t = 0; t < this.entries.length; t++) {
                var i = this.entries[t];
                e.writeUint32(i.segment_duration), e.writeInt32(i.media_time), e.writeInt16(i.media_rate_integer), e.writeInt16(i.media_rate_fraction)
            }
        },b.emsgBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 16 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1), this.writeHeader(e), e.writeCString(this.scheme_id_uri), e.writeCString(this.value), e.writeUint32(this.timescale), e.writeUint32(this.presentation_time_delta), e.writeUint32(this.event_duration), e.writeUint32(this.id), e.writeUint8Array(this.message_data)
        },b.ftypBox.prototype.write = function (e) {
            this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(e), e.writeString(this.major_brand, null, 4), e.writeUint32(this.minor_version);
            for (var t = 0; t < this.compatible_brands.length; t++) e.writeString(this.compatible_brands[t], null, 4)
        },b.hdlrBox.prototype.write = function (e) {
            this.size = 20 + this.name.length + 1, this.version = 0, this.flags = 0, this.writeHeader(e), e.writeUint32(0), e.writeString(this.handler, null, 4), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeCString(this.name)
        },b.kindBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = this.schemeURI.length + 1 + (this.value.length + 1), this.writeHeader(e), e.writeCString(this.schemeURI), e.writeCString(this.value)
        },b.mdhdBox.prototype.write = function (e) {
            this.size = 20, this.flags = 0, this.version = 0, this.writeHeader(e), e.writeUint32(this.creation_time), e.writeUint32(this.modification_time), e.writeUint32(this.timescale), e.writeUint32(this.duration), e.writeUint16(this.language), e.writeUint16(0)
        },b.mehdBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(e), e.writeUint32(this.fragment_duration)
        },b.mfhdBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(e), e.writeUint32(this.sequence_number)
        },b.mvhdBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 96, this.writeHeader(e), e.writeUint32(this.creation_time), e.writeUint32(this.modification_time), e.writeUint32(this.timescale), e.writeUint32(this.duration), e.writeUint32(this.rate), e.writeUint16(this.volume << 8), e.writeUint16(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32Array(this.matrix), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(this.next_track_id)
        },b.SampleEntry.prototype.writeHeader = function (e) {
            this.size = 8, b.Box.prototype.writeHeader.call(this, e), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint16(this.data_reference_index)
        },b.SampleEntry.prototype.writeFooter = function (e) {
            for (var t = 0; t < this.boxes.length; t++) this.boxes[t].write(e), this.size += this.boxes[t].size;
            u.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size)
        },b.SampleEntry.prototype.write = function (e) {
            this.writeHeader(e), e.writeUint8Array(this.data), this.size += this.data.length, u.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size)
        },b.VisualSampleEntry.prototype.write = function (e) {
            this.writeHeader(e), this.size += 70, e.writeUint16(0), e.writeUint16(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint16(this.width), e.writeUint16(this.height), e.writeUint32(this.horizresolution), e.writeUint32(this.vertresolution), e.writeUint32(0), e.writeUint16(this.frame_count), e.writeUint8(Math.min(31, this.compressorname.length)), e.writeString(this.compressorname, null, 31), e.writeUint16(this.depth), e.writeInt16(-1), this.writeFooter(e)
        },b.AudioSampleEntry.prototype.write = function (e) {
            this.writeHeader(e), this.size += 20, e.writeUint32(0), e.writeUint32(0), e.writeUint16(this.channel_count), e.writeUint16(this.samplesize), e.writeUint16(0), e.writeUint16(0), e.writeUint32(this.samplerate << 16), this.writeFooter(e)
        },b.stppSampleEntry.prototype.write = function (e) {
            this.writeHeader(e), this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1, e.writeCString(this.namespace), e.writeCString(this.schema_location), e.writeCString(this.auxiliary_mime_types), this.writeFooter(e)
        },b.SampleGroupEntry.prototype.write = function (e) {
            e.writeUint8Array(this.data)
        },b.sbgpBox.prototype.write = function (e) {
            this.version = 1, this.flags = 0, this.size = 12 + 8 * this.entries.length, this.writeHeader(e), e.writeString(this.grouping_type, null, 4), e.writeUint32(this.grouping_type_parameter), e.writeUint32(this.entries.length);
            for (var t = 0; t < this.entries.length; t++) {
                var i = this.entries[t];
                e.writeInt32(i.sample_count), e.writeInt32(i.group_description_index)
            }
        },b.sgpdBox.prototype.write = function (e) {
            var t, i;
            for (this.flags = 0, this.size = 12, t = 0; t < this.entries.length; t++) i = this.entries[t], 1 === this.version && (0 === this.default_length && (this.size += 4), this.size += i.data.length);
            for (this.writeHeader(e), e.writeString(this.grouping_type, null, 4), 1 === this.version && e.writeUint32(this.default_length), 2 <= this.version && e.writeUint32(this.default_sample_description_index), e.writeUint32(this.entries.length), t = 0; t < this.entries.length; t++) i = this.entries[t], 1 === this.version && 0 === this.default_length && e.writeUint32(i.description_length), i.write(e)
        },b.sidxBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 20 + 12 * this.references.length, this.writeHeader(e), e.writeUint32(this.reference_ID), e.writeUint32(this.timescale), e.writeUint32(this.earliest_presentation_time), e.writeUint32(this.first_offset), e.writeUint16(0), e.writeUint16(this.references.length);
            for (var t = 0; t < this.references.length; t++) {
                var i = this.references[t];
                e.writeUint32(i.reference_type << 31 | i.referenced_size), e.writeUint32(i.subsegment_duration), e.writeUint32(i.starts_with_SAP << 31 | i.SAP_type << 28 | i.SAP_delta_time)
            }
        },b.smhdBox.prototype.write = function (e) {
            this.version = 0, this.flags = 1, this.size = 4, this.writeHeader(e), e.writeUint16(this.balance), e.writeUint16(0)
        },b.stcoBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 4 + 4 * this.chunk_offsets.length, this.writeHeader(e), e.writeUint32(this.chunk_offsets.length), e.writeUint32Array(this.chunk_offsets)
        },b.stscBox.prototype.write = function (e) {
            var t;
            for (this.version = 0, this.flags = 0, this.size = 4 + 12 * this.first_chunk.length, this.writeHeader(e), e.writeUint32(this.first_chunk.length), t = 0; t < this.first_chunk.length; t++) e.writeUint32(this.first_chunk[t]), e.writeUint32(this.samples_per_chunk[t]), e.writeUint32(this.sample_description_index[t])
        },b.stsdBox.prototype.write = function (e) {
            var t;
            for (this.version = 0, this.flags = 0, this.size = 0, this.writeHeader(e), e.writeUint32(this.entries.length), this.size += 4, t = 0; t < this.entries.length; t++) this.entries[t].write(e), this.size += this.entries[t].size;
            u.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size)
        },b.stshBox.prototype.write = function (e) {
            var t;
            for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.shadowed_sample_numbers.length, this.writeHeader(e), e.writeUint32(this.shadowed_sample_numbers.length), t = 0; t < this.shadowed_sample_numbers.length; t++) e.writeUint32(this.shadowed_sample_numbers[t]), e.writeUint32(this.sync_sample_numbers[t])
        },b.stssBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 4 + 4 * this.sample_numbers.length, this.writeHeader(e), e.writeUint32(this.sample_numbers.length), e.writeUint32Array(this.sample_numbers)
        },b.stszBox.prototype.write = function (e) {
            var t, i = !0;
            if (this.version = 0, (this.flags = 0) < this.sample_sizes.length) for (t = 0; t + 1 < this.sample_sizes.length;) {
                if (this.sample_sizes[t + 1] !== this.sample_sizes[0]) {
                    i = !1;
                    break
                }
                t++
            } else i = !1;
            this.size = 8, i || (this.size += 4 * this.sample_sizes.length), this.writeHeader(e), i ? e.writeUint32(this.sample_sizes[0]) : e.writeUint32(0), e.writeUint32(this.sample_sizes.length), i || e.writeUint32Array(this.sample_sizes)
        },b.sttsBox.prototype.write = function (e) {
            var t;
            for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(e), e.writeUint32(this.sample_counts.length), t = 0; t < this.sample_counts.length; t++) e.writeUint32(this.sample_counts[t]), e.writeUint32(this.sample_deltas[t])
        },b.tfdtBox.prototype.write = function (e) {
            var t = Math.pow(2, 32) - 1;
            this.version = this.baseMediaDecodeTime > t ? 1 : 0, this.flags = 0, this.size = 4, 1 === this.version && (this.size += 4), this.writeHeader(e), 1 === this.version ? e.writeUint64(this.baseMediaDecodeTime) : e.writeUint32(this.baseMediaDecodeTime)
        },b.tfhdBox.prototype.write = function (e) {
            this.version = 0, this.size = 4, this.flags & b.TFHD_FLAG_BASE_DATA_OFFSET && (this.size += 8), this.flags & b.TFHD_FLAG_SAMPLE_DESC && (this.size += 4), this.flags & b.TFHD_FLAG_SAMPLE_DUR && (this.size += 4), this.flags & b.TFHD_FLAG_SAMPLE_SIZE && (this.size += 4), this.flags & b.TFHD_FLAG_SAMPLE_FLAGS && (this.size += 4), this.writeHeader(e), e.writeUint32(this.track_id), this.flags & b.TFHD_FLAG_BASE_DATA_OFFSET && e.writeUint64(this.base_data_offset), this.flags & b.TFHD_FLAG_SAMPLE_DESC && e.writeUint32(this.default_sample_description_index), this.flags & b.TFHD_FLAG_SAMPLE_DUR && e.writeUint32(this.default_sample_duration), this.flags & b.TFHD_FLAG_SAMPLE_SIZE && e.writeUint32(this.default_sample_size), this.flags & b.TFHD_FLAG_SAMPLE_FLAGS && e.writeUint32(this.default_sample_flags)
        },b.tkhdBox.prototype.write = function (e) {
            this.version = 0, this.size = 80, this.writeHeader(e), e.writeUint32(this.creation_time), e.writeUint32(this.modification_time), e.writeUint32(this.track_id), e.writeUint32(0), e.writeUint32(this.duration), e.writeUint32(0), e.writeUint32(0), e.writeInt16(this.layer), e.writeInt16(this.alternate_group), e.writeInt16(this.volume << 8), e.writeUint16(0), e.writeInt32Array(this.matrix), e.writeUint32(this.width), e.writeUint32(this.height)
        },b.trexBox.prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = 20, this.writeHeader(e), e.writeUint32(this.track_id), e.writeUint32(this.default_sample_description_index), e.writeUint32(this.default_sample_duration), e.writeUint32(this.default_sample_size), e.writeUint32(this.default_sample_flags)
        },b.trunBox.prototype.write = function (e) {
            this.version = 0, this.size = 4, this.flags & b.TRUN_FLAGS_DATA_OFFSET && (this.size += 4), this.flags & b.TRUN_FLAGS_FIRST_FLAG && (this.size += 4), this.flags & b.TRUN_FLAGS_DURATION && (this.size += 4 * this.sample_duration.length), this.flags & b.TRUN_FLAGS_SIZE && (this.size += 4 * this.sample_size.length), this.flags & b.TRUN_FLAGS_FLAGS && (this.size += 4 * this.sample_flags.length), this.flags & b.TRUN_FLAGS_CTS_OFFSET && (this.size += 4 * this.sample_composition_time_offset.length), this.writeHeader(e), e.writeUint32(this.sample_count), this.flags & b.TRUN_FLAGS_DATA_OFFSET && (this.data_offset_position = e.getPosition(), e.writeInt32(this.data_offset)), this.flags & b.TRUN_FLAGS_FIRST_FLAG && e.writeUint32(this.first_sample_flags);
            for (var t = 0; t < this.sample_count; t++) this.flags & b.TRUN_FLAGS_DURATION && e.writeUint32(this.sample_duration[t]), this.flags & b.TRUN_FLAGS_SIZE && e.writeUint32(this.sample_size[t]), this.flags & b.TRUN_FLAGS_FLAGS && e.writeUint32(this.sample_flags[t]), this.flags & b.TRUN_FLAGS_CTS_OFFSET && (0 === this.version ? e.writeUint32(this.sample_composition_time_offset[t]) : e.writeInt32(this.sample_composition_time_offset[t]))
        },b["url Box"].prototype.write = function (e) {
            this.version = 0, this.location ? (this.flags = 0, this.size = this.location.length + 1) : (this.flags = 1, this.size = 0), this.writeHeader(e), this.location && e.writeCString(this.location)
        },b["urn Box"].prototype.write = function (e) {
            this.version = 0, this.flags = 0, this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0), this.writeHeader(e), e.writeCString(this.name), this.location && e.writeCString(this.location)
        },b.vmhdBox.prototype.write = function (e) {
            this.version = 0, this.flags = 1, this.size = 8, this.writeHeader(e), e.writeUint16(this.graphicsmode), e.writeUint16Array(this.opcolor)
        },b.cttsBox.prototype.unpack = function (e) {
            for (var t, i = 0, r = 0; r < this.sample_counts.length; r++) for (t = 0; t < this.sample_counts[r]; t++) e[i].pts = e[i].dts + this.sample_offsets[r], i++
        },b.sttsBox.prototype.unpack = function (e) {
            for (var t, i = 0, r = 0; r < this.sample_counts.length; r++) for (t = 0; t < this.sample_counts[r]; t++) e[i].dts = 0 === i ? 0 : e[i - 1].dts + this.sample_deltas[r], i++
        },b.stcoBox.prototype.unpack = function (e) {
            for (var t = 0; t < this.chunk_offsets.length; t++) e[t].offset = this.chunk_offsets[t]
        },b.stscBox.prototype.unpack = function (e) {
            for (var t, i, r = 0, s = 0, a = 0; a < this.first_chunk.length; a++) for (t = 0; t < (a + 1 < this.first_chunk.length ? this.first_chunk[a + 1] : 1 / 0); t++) for (s++, i = 0; i < this.samples_per_chunk[a]; i++) {
                if (!e[r]) return;
                e[r].description_index = this.sample_description_index[a], e[r].chunk_index = s, r++
            }
        },b.stszBox.prototype.unpack = function (e) {
            for (var t = 0; t < this.sample_sizes.length; t++) e[t].size = this.sample_sizes[t]
        },b.DIFF_BOXES_PROP_NAMES = ["boxes", "entries", "references", "subsamples", "items", "item_infos", "extents", "associations", "subsegments", "ranges", "seekLists", "seekPoints", "esd", "levels"],b.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = ["compatible_brands", "matrix", "opcolor", "sample_counts", "sample_counts", "sample_deltas", "first_chunk", "samples_per_chunk", "sample_sizes", "chunk_offsets", "sample_offsets", "sample_description_index", "sample_duration"],b.boxEqualFields = function (e, t) {
            if (e && !t) return !1;
            for (var i in e) if (!(-1 < b.DIFF_BOXES_PROP_NAMES.indexOf(i) || e[i] instanceof b.Box || t[i] instanceof b.Box || void 0 === e[i] || void 0 === t[i] || "function" == typeof e[i] || "function" == typeof t[i] || e.subBoxNames && -1 < e.subBoxNames.indexOf(i.slice(0, 4)) || t.subBoxNames && -1 < t.subBoxNames.indexOf(i.slice(0, 4)) || "data" === i || "start" === i || "size" === i || "creation_time" === i || "modification_time" === i || -1 < b.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(i) || e[i] === t[i])) return !1;
            return !0
        },b.boxEqual = function (e, t) {
            if (!b.boxEqualFields(e, t)) return !1;
            for (var i = 0; i < b.DIFF_BOXES_PROP_NAMES.length; i++) {
                var r = b.DIFF_BOXES_PROP_NAMES[i];
                if (e[r] && t[r] && !b.boxEqual(e[r], t[r])) return !1
            }
            return !0
        },s.prototype.parseSample = function (e) {
            var t, i = {resources: []}, r = new c(e.data.buffer);
            if (e.subsamples && 0 !== e.subsamples.length) {
                if (i.documentString = r.readString(e.subsamples[0].size), 1 < e.subsamples.length) for (t = 1; t < e.subsamples.length; t++) i.resources[t] = r.readUint8Array(e.subsamples[t].size)
            } else i.documentString = r.readString(e.data.length);
            return "undefined" != typeof DOMParser && (i.document = (new DOMParser).parseFromString(i.documentString, "application/xml")), i
        },a.prototype.parseSample = function (e) {
            return new c(e.data.buffer).readString(e.data.length)
        },a.prototype.parseConfig = function (e) {
            e = new c(e.buffer);
            return e.readUint32(), e.readCString()
        },t.XMLSubtitlein4Parser = s,t.Textin4Parser = a;
        k.prototype.setSegmentOptions = function (e, t, i) {
            var r, s = this.getTrackById(e);
            s && (this.fragmentedTracks.push(r = {}), r.id = e, r.user = t, (r.trak = s).nextSample = 0, r.segmentStream = null, r.nb_samples = 1e3, r.rapAlignement = !0, i && (i.nbSamples && (r.nb_samples = i.nbSamples), i.rapAlignement && (r.rapAlignement = i.rapAlignement)))
        }, k.prototype.unsetSegmentOptions = function (e) {
            for (var t = -1, i = 0; i < this.fragmentedTracks.length; i++) this.fragmentedTracks[i].id == e && (t = i);
            -1 < t && this.fragmentedTracks.splice(t, 1)
        }, k.prototype.setExtractionOptions = function (e, t, i) {
            var r, s = this.getTrackById(e);
            s && (this.extractedTracks.push(r = {}), r.id = e, r.user = t, (r.trak = s).nextSample = 0, r.nb_samples = 1e3, r.samples = [], i && i.nbSamples && (r.nb_samples = i.nbSamples))
        }, k.prototype.unsetExtractionOptions = function (e) {
            for (var t = -1, i = 0; i < this.extractedTracks.length; i++) this.extractedTracks[i].id == e && (t = i);
            -1 < t && this.extractedTracks.splice(t, 1)
        }, k.prototype.parse = function () {
            var e, t;
            if (!this.restoreParsePosition || this.restoreParsePosition()) for (; ;) {
                if (this.hasIncompleteMdat && this.hasIncompleteMdat()) {
                    if (this.processIncompleteMdat()) continue;
                    return
                }
                if (this.saveParsePosition && this.saveParsePosition(), (e = b.parseOneBox(this.stream, !1)).code === b.ERR_NOT_ENOUGH_DATA) {
                    if (this.processIncompleteBox) {
                        if (this.processIncompleteBox(e)) continue;
                        return
                    }
                    return
                }
                var i = "uuid" !== (t = e.box).type ? t.type : t.uuid;
                switch (this.boxes.push(t), i) {
                    case"mdat":
                        this.mdats.push(t);
                        break;
                    case"moof":
                        this.moofs.push(t);
                        break;
                    case"moov":
                        this.moovStartFound = !0, 0 === this.mdats.length && (this.isProgressive = !0);
                    default:
                        void 0 !== this[i] && u.warn("ISOFile", "Duplicate Box of type: " + i + ", overriding previous occurrence"), this[i] = t
                }
                this.updateUsedBytes && this.updateUsedBytes(t, e)
            }
        }, k.prototype.checkBuffer = function (e) {
            if (null == e) throw"Buffer must be defined and non empty";
            if (void 0 === e.fileStart) throw"Buffer must have a fileStart property";
            return 0 === e.byteLength ? (u.warn("ISOFile", "Ignoring empty buffer (fileStart: " + e.fileStart + ")"), this.stream.logBufferLevel(), !1) : (u.info("ISOFile", "Processing buffer (fileStart: " + e.fileStart + ")"), e.usedBytes = 0, this.stream.insertBuffer(e), this.stream.logBufferLevel(), !!this.stream.initialized() || (u.warn("ISOFile", "Not ready to start parsing"), !1))
        }, k.prototype.appendBuffer = function (e, t) {
            var i;
            if (this.checkBuffer(e)) return this.parse(), this.moovStartFound && !this.moovStartSent && (this.moovStartSent = !0, this.onMoovStart && this.onMoovStart()), this.moov ? (this.sampleListBuilt || (this.buildSampleLists(), this.sampleListBuilt = !0), this.updateSampleLists(), this.onReady && !this.readySent && (this.readySent = !0, this.onReady(this.getInfo())), this.processSamples(t), this.nextSeekPosition ? (i = this.nextSeekPosition, this.nextSeekPosition = void 0) : i = this.nextParsePosition, this.stream.getEndFilePositionAfter && (i = this.stream.getEndFilePositionAfter(i))) : i = this.nextParsePosition || 0, this.sidx && this.onSidx && !this.sidxSent && (this.onSidx(this.sidx), this.sidxSent = !0), this.meta && (this.flattenItemInfo && !this.itemListBuilt && (this.flattenItemInfo(), this.itemListBuilt = !0), this.processItems && this.processItems(this.onItem)), this.stream.cleanBuffers && (u.info("ISOFile", "Done processing buffer (fileStart: " + e.fileStart + ") - next buffer to fetch should have a fileStart position of " + i), this.stream.logBufferLevel(), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0), u.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize())), i
        }, k.prototype.getInfo = function () {
            var e, t, i, r, s, a, n = {}, o = new Date("1904-01-01T00:00:00Z").getTime();
            if (this.moov) for (n.hasMoov = !0, n.duration = this.moov.mvhd.duration, n.timescale = this.moov.mvhd.timescale, n.isFragmented = null != this.moov.mvex, n.isFragmented && this.moov.mvex.mehd && (n.fragment_duration = this.moov.mvex.mehd.fragment_duration), n.isProgressive = this.isProgressive, n.hasIOD = null != this.moov.iods, n.brands = [], n.brands.push(this.ftyp.major_brand), n.brands = n.brands.concat(this.ftyp.compatible_brands), n.created = new Date(o + 1e3 * this.moov.mvhd.creation_time), n.modified = new Date(o + 1e3 * this.moov.mvhd.modification_time), n.tracks = [], n.audioTracks = [], n.videoTracks = [], n.subtitleTracks = [], n.metadataTracks = [], n.hintTracks = [], n.otherTracks = [], e = 0; e < this.moov.traks.length; e++) {
                if (a = (i = this.moov.traks[e]).mdia.minf.stbl.stsd.entries[0], n.tracks.push(r = {}), r.id = i.tkhd.track_id, r.name = i.mdia.hdlr.name, r.references = [], i.tref) for (t = 0; t < i.tref.boxes.length; t++) r.references.push(s = {}), s.type = i.tref.boxes[t].type, s.track_ids = i.tref.boxes[t].track_ids;
                i.edts && (r.edits = i.edts.elst.entries), r.created = new Date(o + 1e3 * i.tkhd.creation_time), r.modified = new Date(o + 1e3 * i.tkhd.modification_time), r.movie_duration = i.tkhd.duration, r.movie_timescale = n.timescale, r.layer = i.tkhd.layer, r.alternate_group = i.tkhd.alternate_group, r.volume = i.tkhd.volume, r.matrix = i.tkhd.matrix, r.track_width = i.tkhd.width / 65536, r.track_height = i.tkhd.height / 65536, r.timescale = i.mdia.mdhd.timescale, r.cts_shift = i.mdia.minf.stbl.cslg, r.duration = i.mdia.mdhd.duration, r.samples_duration = i.samples_duration, r.codec = a.getCodec(), r.kind = i.udta && i.udta.kinds.length ? i.udta.kinds[0] : {
                    schemeURI: "",
                    value: ""
                }, r.language = i.mdia.elng ? i.mdia.elng.extended_language : i.mdia.mdhd.languageString, r.nb_samples = i.samples.length, r.size = i.samples_size, r.bitrate = 8 * r.size * r.timescale / r.samples_duration, a.isAudio() ? (r.type = "audio", n.audioTracks.push(r), r.audio = {}, r.audio.sample_rate = a.getSampleRate(), r.audio.channel_count = a.getChannelCount(), r.audio.sample_size = a.getSampleSize()) : a.isVideo() ? (r.type = "video", n.videoTracks.push(r), r.video = {}, r.video.width = a.getWidth(), r.video.height = a.getHeight()) : a.isSubtitle() ? (r.type = "subtitles", n.subtitleTracks.push(r)) : a.isHint() ? (r.type = "metadata", n.hintTracks.push(r)) : a.isMetadata() ? (r.type = "metadata", n.metadataTracks.push(r)) : (r.type = "metadata", n.otherTracks.push(r))
            } else n.hasMoov = !1;
            if (n.mime = "", n.hasMoov && n.tracks) {
                for (n.videoTracks && 0 < n.videoTracks.length ? n.mime += 'video/mp4; codecs="' : n.audioTracks && 0 < n.audioTracks.length ? n.mime += 'audio/mp4; codecs="' : n.mime += 'application/mp4; codecs="', e = 0; e < n.tracks.length; e++) 0 !== e && (n.mime += ","), n.mime += n.tracks[e].codec;
                n.mime += '"; profiles="', n.mime += this.ftyp.compatible_brands.join(), n.mime += '"'
            }
            return n
        }, k.prototype.processSamples = function (e) {
            var t;
            if (this.sampleProcessingStarted) {
                if (this.isFragmentationInitialized && null !== this.onSegment) for (t = 0; t < this.fragmentedTracks.length; t++) for (var i = this.fragmentedTracks[t], r = i.trak; r.nextSample < r.samples.length && this.sampleProcessingStarted;) {
                    u.debug("ISOFile", "Creating media fragment on track #" + i.id + " for sample " + r.nextSample);
                    var s = this.createFragment(i.id, r.nextSample, i.segmentStream);
                    if (!s) break;
                    if (i.segmentStream = s, r.nextSample++, (r.nextSample % i.nb_samples == 0 || e || r.nextSample >= r.samples.length) && (u.info("ISOFile", "Sending fragmented data on track #" + i.id + " for samples [" + Math.max(0, r.nextSample - i.nb_samples) + "," + (r.nextSample - 1) + "]"), u.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize()), this.onSegment && this.onSegment(i.id, i.user, i.segmentStream.buffer, r.nextSample, e || r.nextSample >= r.samples.length), i.segmentStream = null, i !== this.fragmentedTracks[t])) break
                }
                if (null !== this.onSamples) for (t = 0; t < this.extractedTracks.length; t++) {
                    var a = this.extractedTracks[t];
                    for (r = a.trak; r.nextSample < r.samples.length && this.sampleProcessingStarted;) {
                        u.debug("ISOFile", "Exporting on track #" + a.id + " sample #" + r.nextSample);
                        var n = this.getSample(r, r.nextSample);
                        if (!n) break;
                        if (r.nextSample++, a.samples.push(n), (r.nextSample % a.nb_samples == 0 || r.nextSample >= r.samples.length) && (u.debug("ISOFile", "Sending samples on track #" + a.id + " for sample " + r.nextSample), this.onSamples && this.onSamples(a.id, a.user, a.samples), a.samples = [], a !== this.extractedTracks[t])) break
                    }
                }
            }
        }, k.prototype.getBox = function (e) {
            e = this.getBoxes(e, !0);
            return e.length ? e[0] : null
        }, k.prototype.getBoxes = function (e, t) {
            var i = [];
            return k._sweep.call(this, e, i, t), i
        }, k._sweep = function (e, t, i) {
            for (var r in this.type && this.type == e && t.push(this), this.boxes) {
                if (t.length && i) return;
                k._sweep.call(this.boxes[r], e, t, i)
            }
        }, k.prototype.getTrackSamplesInfo = function (e) {
            e = this.getTrackById(e);
            return e ? e.samples : void 0
        }, k.prototype.getTrackSample = function (e, t) {
            e = this.getTrackById(e);
            return this.getSample(e, t)
        }, k.prototype.releaseUsedSamples = function (e, t) {
            var i = 0, r = this.getTrackById(e);
            r.lastValidSample || (r.lastValidSample = 0);
            for (var s = r.lastValidSample; s < t; s++) i += this.releaseSample(r, s);
            u.info("ISOFile", "Track #" + e + " released samples up to " + t + " (released size: " + i + ", remaining: " + this.samplesDataSize + ")"), r.lastValidSample = t
        }, k.prototype.start = function () {
            this.sampleProcessingStarted = !0, this.processSamples(!1)
        }, k.prototype.stop = function () {
            this.sampleProcessingStarted = !1
        }, k.prototype.flush = function () {
            u.info("ISOFile", "Flushing remaining samples"), this.updateSampleLists(), this.processSamples(!0), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0)
        }, k.prototype.seekTrack = function (e, t, i) {
            var r, s, a, n, o = 0, l = 0;
            if (0 === i.samples.length) return u.info("ISOFile", "No sample in track, cannot seek! Using time " + u.getDurationString(0, 1) + " and offset: 0"), {
                offset: 0,
                time: 0
            };
            for (r = 0; r < i.samples.length; r++) {
                if (s = i.samples[r], 0 === r) l = 0, n = s.timescale; else if (s.cts > e * s.timescale) {
                    l = r - 1;
                    break
                }
                t && s.is_sync && (o = r)
            }
            for (t && (l = o), e = i.samples[l].cts, i.nextSample = l; i.samples[l].alreadyRead === i.samples[l].size && i.samples[l + 1];) l++;
            return a = i.samples[l].offset + i.samples[l].alreadyRead, u.info("ISOFile", "Seeking to " + (t ? "RAP" : "") + " sample #" + i.nextSample + " on track " + i.tkhd.track_id + ", time " + u.getDurationString(e, n) + " and offset: " + a), {
                offset: a,
                time: e / n
            }
        }, k.prototype.seek = function (e, t) {
            var i, r, s = this.moov, a = {offset: 1 / 0, time: 1 / 0};
            if (this.moov) {
                for (r = 0; r < s.traks.length; r++) i = s.traks[r], (i = this.seekTrack(e, t, i)).offset < a.offset && (a.offset = i.offset), i.time < a.time && (a.time = i.time);
                return u.info("ISOFile", "Seeking at time " + u.getDurationString(a.time, 1) + " needs a buffer with a fileStart position of " + a.offset), a.offset === 1 / 0 ? a = {
                    offset: this.nextParsePosition,
                    time: 0
                } : a.offset = this.stream.getEndFilePositionAfter(a.offset), u.info("ISOFile", "Adjusted seek position (after checking data already in buffer): " + a.offset), a
            }
            throw"Cannot seek: moov not received!"
        }, k.prototype.equal = function (e) {
            for (var t = 0; t < this.boxes.length && t < e.boxes.length;) {
                var i = this.boxes[t], r = e.boxes[t];
                if (!b.boxEqual(i, r)) return !1;
                t++
            }
            return !0
        }, (t.ISOFile = k).prototype.lastBoxStartPosition = 0, k.prototype.parsingMdat = null, k.prototype.nextParsePosition = 0, k.prototype.discardMdatData = !1, k.prototype.processIncompleteBox = function (e) {
            var t;
            return "mdat" === e.type ? (t = new b[e.type + "Box"](e.size), this.parsingMdat = t, this.boxes.push(t), this.mdats.push(t), t.start = e.start, t.hdr_size = e.hdr_size, this.stream.addUsedBytes(t.hdr_size), this.lastBoxStartPosition = t.start + t.size, this.stream.seek(t.start + t.size, !1, this.discardMdatData) ? !(this.parsingMdat = null) : (this.moovStartFound ? this.nextParsePosition = this.stream.findEndContiguousBuf() : this.nextParsePosition = t.start + t.size, !1)) : ("moov" === e.type && (this.moovStartFound = !0, 0 === this.mdats.length && (this.isProgressive = !0)), this.stream.mergeNextBuffer && this.stream.mergeNextBuffer() ? (this.nextParsePosition = this.stream.getEndPosition(), !0) : (!e.type || this.moovStartFound ? this.nextParsePosition = this.stream.getEndPosition() : this.nextParsePosition = this.stream.getPosition() + e.size, !1))
        }, k.prototype.hasIncompleteMdat = function () {
            return null !== this.parsingMdat
        }, k.prototype.processIncompleteMdat = function () {
            var e = this.parsingMdat;
            return this.stream.seek(e.start + e.size, !1, this.discardMdatData) ? (u.debug("ISOFile", "Found 'mdat' end in buffered data"), !(this.parsingMdat = null)) : (this.nextParsePosition = this.stream.findEndContiguousBuf(), !1)
        }, k.prototype.restoreParsePosition = function () {
            return this.stream.seek(this.lastBoxStartPosition, !0, this.discardMdatData)
        }, k.prototype.saveParsePosition = function () {
            this.lastBoxStartPosition = this.stream.getPosition()
        }, k.prototype.updateUsedBytes = function (e, t) {
            this.stream.addUsedBytes && ("mdat" === e.type ? (this.stream.addUsedBytes(e.hdr_size), this.discardMdatData && this.stream.addUsedBytes(e.size - e.hdr_size)) : this.stream.addUsedBytes(e.size))
        }, k.prototype.add = b.Box.prototype.add, k.prototype.addBox = b.Box.prototype.addBox, k.prototype.init = function (e) {
            var e = e || {},
                t = (this.add("ftyp").set("major_brand", e.brands && e.brands[0] || "iso4").set("minor_version", 0).set("compatible_brands", e.brands || ["iso4"]), this.add("moov"));
            return t.add("mvhd").set("timescale", e.timescale || 600).set("rate", e.rate || 65536).set("creation_time", 0).set("modification_time", 0).set("duration", e.duration || 0).set("volume", e.width ? 0 : 256).set("matrix", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set("next_track_id", 1), t.add("mvex"), this
        }, k.prototype.addTrack = function (e) {
            this.moov || this.init(e);
            var t = e || {},
                e = (t.width = t.width || 320, t.height = t.height || 320, t.id = t.id || this.moov.mvhd.next_track_id, t.type = t.type || "avc1", this.moov.add("trak")),
                i = (this.moov.mvhd.next_track_id = t.id + 1, e.add("tkhd").set("flags", b.TKHD_FLAG_ENABLED | b.TKHD_FLAG_IN_MOVIE | b.TKHD_FLAG_IN_PREVIEW).set("creation_time", 0).set("modification_time", 0).set("track_id", t.id).set("duration", t.duration || 0).set("layer", t.layer || 0).set("alternate_group", 0).set("volume", 1).set("matrix", [0, 0, 0, 0, 0, 0, 0, 0, 0]).set("width", t.width << 16).set("height", t.height << 16), e.add("mdia")),
                r = (i.add("mdhd").set("creation_time", 0).set("modification_time", 0).set("timescale", t.timescale || 1).set("duration", t.media_duration || 0).set("language", t.language || "und"), i.add("hdlr").set("handler", t.hdlr || "vide").set("name", t.name || "Track created with MP4Box.js"), i.add("elng").set("extended_language", t.language || "fr-FR"), i.add("minf"));
            if (void 0 !== b[t.type + "SampleEntry"]) {
                var s, a, n, o = new b[t.type + "SampleEntry"], l = (o.data_reference_index = 1, "");
                for (s in b.sampleEntryCodes) for (var d = b.sampleEntryCodes[s], h = 0; h < d.length; h++) if (-1 < d.indexOf(t.type)) {
                    l = s;
                    break
                }
                switch (l) {
                    case"Visual":
                        r.add("vmhd").set("graphicsmode", 0).set("opcolor", [0, 0, 0]), o.set("width", t.width).set("height", t.height).set("horizresolution", 72 << 16).set("vertresolution", 72 << 16).set("frame_count", 1).set("compressorname", t.type + " Compressor").set("depth", 24), t.avcDecoderConfigRecord && (a = new b.avcCBox, n = new c(t.avcDecoderConfigRecord), a.parse(n), o.addBox(a));
                        break;
                    case"Audio":
                        r.add("smhd").set("balance", t.balance || 0), o.set("channel_count", t.channel_count || 2).set("samplesize", t.samplesize || 16).set("samplerate", t.samplerate || 65536);
                        break;
                    case"Hint":
                        r.add("hmhd");
                        break;
                    case"Subtitle":
                        r.add("sthd"), "stpp" === t.type && o.set("namespace", t.namespace || "nonamespace").set("schema_location", t.schema_location || "").set("auxiliary_mime_types", t.auxiliary_mime_types || "");
                        break;
                    default:
                        r.add("nmhd")
                }
                t.description && o.addBox(t.description), t.description_boxes && t.description_boxes.forEach(function (e) {
                    o.addBox(e)
                }), r.add("dinf").add("dref").addEntry((new b["url Box"]).set("flags", 1));
                i = r.add("stbl");
                return i.add("stsd").addEntry(o), i.add("stts").set("sample_counts", []).set("sample_deltas", []), i.add("stsc").set("first_chunk", []).set("samples_per_chunk", []).set("sample_description_index", []), i.add("stco").set("chunk_offsets", []), i.add("stsz").set("sample_sizes", []), this.moov.mvex.add("trex").set("track_id", t.id).set("default_sample_description_index", t.default_sample_description_index || 1).set("default_sample_duration", t.default_sample_duration || 0).set("default_sample_size", t.default_sample_size || 0).set("default_sample_flags", t.default_sample_flags || 0), this.buildTrakSampleLists(e), t.id
            }
        }, b.Box.prototype.computeSize = function (e) {
            e = e || new l;
            e.endianness = l.BIG_ENDIAN, this.write(e)
        }, k.prototype.addSample = function (e, t, i) {
            var i = i || {}, r = {}, e = this.getTrackById(e);
            if (null !== e) return r.number = e.samples.length, r.track_id = e.tkhd.track_id, r.timescale = e.mdia.mdhd.timescale, r.description_index = i.sample_description_index ? i.sample_description_index - 1 : 0, r.description = e.mdia.minf.stbl.stsd.entries[r.description_index], r.data = t, r.size = t.byteLength, r.alreadyRead = r.size, r.duration = i.duration || 1, r.cts = i.cts || 0, r.dts = i.dts || 0, r.is_sync = i.is_sync || !1, r.is_leading = i.is_leading || 0, r.depends_on = i.depends_on || 0, r.is_depended_on = i.is_depended_on || 0, r.has_redundancy = i.has_redundancy || 0, r.degradation_priority = i.degradation_priority || 0, r.offset = 0, r.subsamples = i.subsamples, e.samples.push(r), e.samples_size += r.size, e.samples_duration += r.duration, e.first_dts || (e.first_dts = i.dts), this.processSamples(), e = this.createSingleSampleMoof(r), this.addBox(e), e.computeSize(), e.trafs[0].truns[0].data_offset = e.size + 8, this.add("mdat").data = new Uint8Array(t), r
        }, k.prototype.createSingleSampleMoof = function (e) {
            var t = e.is_sync ? 1 << 25 : 65536, i = new b.moofBox,
                r = (i.add("mfhd").set("sequence_number", this.nextMoofNumber), this.nextMoofNumber++, i.add("traf")),
                s = this.getTrackById(e.track_id);
            return r.add("tfhd").set("track_id", e.track_id).set("flags", b.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), r.add("tfdt").set("baseMediaDecodeTime", e.dts - (s.first_dts || 0)), r.add("trun").set("flags", b.TRUN_FLAGS_DATA_OFFSET | b.TRUN_FLAGS_DURATION | b.TRUN_FLAGS_SIZE | b.TRUN_FLAGS_FLAGS | b.TRUN_FLAGS_CTS_OFFSET).set("data_offset", 0).set("first_sample_flags", 0).set("sample_count", 1).set("sample_duration", [e.duration]).set("sample_size", [e.size]).set("sample_flags", [t]).set("sample_composition_time_offset", [e.cts - e.dts]), i
        }, k.prototype.lastMoofIndex = 0, k.prototype.samplesDataSize = 0, k.prototype.resetTables = function () {
            var e, t;
            for (this.initial_duration = this.moov.mvhd.duration, e = this.moov.mvhd.duration = 0; e < this.moov.traks.length; e++) {
                (t = this.moov.traks[e]).tkhd.duration = 0, t.mdia.mdhd.duration = 0, (t.mdia.minf.stbl.stco || t.mdia.minf.stbl.co64).chunk_offsets = [], (i = t.mdia.minf.stbl.stsc).first_chunk = [], i.samples_per_chunk = [], i.sample_description_index = [], (t.mdia.minf.stbl.stsz || t.mdia.minf.stbl.stz2).sample_sizes = [], (i = t.mdia.minf.stbl.stts).sample_counts = [], i.sample_deltas = [], (i = t.mdia.minf.stbl.ctts) && (i.sample_counts = [], i.sample_offsets = []);
                var i = t.mdia.minf.stbl.stss, i = t.mdia.minf.stbl.boxes.indexOf(i);
                -1 != i && (t.mdia.minf.stbl.boxes[i] = null)
            }
        }, k.initSampleGroups = function (e, t, i, r, s) {
            var a, n, o, l;

            function d(e, t, i) {
                this.grouping_type = e, this.grouping_type_parameter = t, this.sbgp = i, this.last_sample_in_run = -1, this.entry_index = -1
            }

            for (t && (t.sample_groups_info = []), e.sample_groups_info || (e.sample_groups_info = []), n = 0; n < i.length; n++) {
                for (l = i[n].grouping_type + "/" + i[n].grouping_type_parameter, o = new d(i[n].grouping_type, i[n].grouping_type_parameter, i[n]), t && (t.sample_groups_info[l] = o), e.sample_groups_info[l] || (e.sample_groups_info[l] = o), a = 0; a < r.length; a++) r[a].grouping_type === i[n].grouping_type && (o.description = r[a], o.description.used = !0);
                if (s) for (a = 0; a < s.length; a++) s[a].grouping_type === i[n].grouping_type && (o.fragment_description = s[a], o.fragment_description.used = !0, o.is_fragment = !0)
            }
            if (t) {
                if (s) for (n = 0; n < s.length; n++) !s[n].used && 2 <= s[n].version && (l = s[n].grouping_type + "/0", (o = new d(s[n].grouping_type, 0)).is_fragment = !0, t.sample_groups_info[l] || (t.sample_groups_info[l] = o))
            } else for (n = 0; n < r.length; n++) !r[n].used && 2 <= r[n].version && (l = r[n].grouping_type + "/0", o = new d(r[n].grouping_type, 0), e.sample_groups_info[l] || (e.sample_groups_info[l] = o))
        }, k.setSampleGroupProperties = function (e, t, i, r) {
            var s, a, n;
            for (s in t.sample_groups = [], r) t.sample_groups[s] = {}, t.sample_groups[s].grouping_type = r[s].grouping_type, t.sample_groups[s].grouping_type_parameter = r[s].grouping_type_parameter, i >= r[s].last_sample_in_run && (r[s].last_sample_in_run < 0 && (r[s].last_sample_in_run = 0), r[s].entry_index++, r[s].entry_index <= r[s].sbgp.entries.length - 1 && (r[s].last_sample_in_run += r[s].sbgp.entries[r[s].entry_index].sample_count)), r[s].entry_index <= r[s].sbgp.entries.length - 1 ? t.sample_groups[s].group_description_index = r[s].sbgp.entries[r[s].entry_index].group_description_index : t.sample_groups[s].group_description_index = -1, 0 !== t.sample_groups[s].group_description_index && (n = r[s].fragment_description || r[s].description, 0 < t.sample_groups[s].group_description_index ? (a = 65535 < t.sample_groups[s].group_description_index ? (t.sample_groups[s].group_description_index >> 16) - 1 : t.sample_groups[s].group_description_index - 1, n && 0 <= a && (t.sample_groups[s].description = n.entries[a])) : n && 2 <= n.version && 0 < n.default_group_description_index && (t.sample_groups[s].description = n.entries[n.default_group_description_index - 1]))
        }, k.process_sdtp = function (e, t, i) {
            t && (e ? (t.is_leading = e.is_leading[i], t.depends_on = e.sample_depends_on[i], t.is_depended_on = e.sample_is_depended_on[i], t.has_redundancy = e.sample_has_redundancy[i]) : (t.is_leading = 0, t.depends_on = 0, t.is_depended_on = 0, t.has_redundancy = 0))
        }, k.prototype.buildSampleLists = function () {
            for (var e, t = 0; t < this.moov.traks.length; t++) e = this.moov.traks[t], this.buildTrakSampleLists(e)
        }, k.prototype.buildTrakSampleLists = function (e) {
            var t, i, r, s, a, n, o, l, d, h, c, u, p, f, m, g, y, A, b, v, _, w, S, E;
            if (e.samples = [], e.samples_duration = 0, e.samples_size = 0, i = e.mdia.minf.stbl.stco || e.mdia.minf.stbl.co64, r = e.mdia.minf.stbl.stsc, s = e.mdia.minf.stbl.stsz || e.mdia.minf.stbl.stz2, a = e.mdia.minf.stbl.stts, n = e.mdia.minf.stbl.ctts, o = e.mdia.minf.stbl.stss, l = e.mdia.minf.stbl.stsd, d = e.mdia.minf.stbl.subs, u = e.mdia.minf.stbl.stdp, h = e.mdia.minf.stbl.sbgps, c = e.mdia.minf.stbl.sgpds, _ = v = b = A = -1, E = S = w = 0, k.initSampleGroups(e, null, h, c), void 0 !== s) {
                for (t = 0; t < s.sample_sizes.length; t++) {
                    var T = {};
                    T.number = t, T.track_id = e.tkhd.track_id, T.timescale = e.mdia.mdhd.timescale, T.alreadyRead = 0, (e.samples[t] = T).size = s.sample_sizes[t], e.samples_size += T.size, 0 === t ? (p = 0, T.chunk_index = f = 1, T.chunk_run_index = p, y = r.samples_per_chunk[p], g = 0, m = p + 1 < r.first_chunk.length ? r.first_chunk[p + 1] - 1 : 1 / 0) : t < y ? (T.chunk_index = f, T.chunk_run_index = p) : (f++, g = 0, (T.chunk_index = f) <= m || (m = ++p + 1 < r.first_chunk.length ? r.first_chunk[p + 1] - 1 : 1 / 0), T.chunk_run_index = p, y += r.samples_per_chunk[p]), T.description_index = r.sample_description_index[T.chunk_run_index] - 1, T.description = l.entries[T.description_index], T.offset = i.chunk_offsets[T.chunk_index - 1] + g, g += T.size, A < t && (b++, A < 0 && (A = 0), A += a.sample_counts[b]), 0 < t ? (e.samples[t - 1].duration = a.sample_deltas[b], e.samples_duration += e.samples[t - 1].duration, T.dts = e.samples[t - 1].dts + e.samples[t - 1].duration) : T.dts = 0, n ? (v <= t && (_++, v < 0 && (v = 0), v += n.sample_counts[_]), T.cts = e.samples[t].dts + n.sample_offsets[_]) : T.cts = T.dts, o ? (t == o.sample_numbers[w] - 1 ? (T.is_sync = !0, w++) : (T.is_sync = !1, T.degradation_priority = 0), d && d.entries[S].sample_delta + E == t + 1 && (T.subsamples = d.entries[S].subsamples, E += d.entries[S].sample_delta, S++)) : T.is_sync = !0, k.process_sdtp(e.mdia.minf.stbl.sdtp, T, T.number), T.degradation_priority = u ? u.priority[t] : 0, d && d.entries[S].sample_delta + E == t && (T.subsamples = d.entries[S].subsamples, E += d.entries[S].sample_delta), (0 < h.length || 0 < c.length) && k.setSampleGroupProperties(e, T, t, e.sample_groups_info)
                }
                0 < t && (e.samples[t - 1].duration = Math.max(e.mdia.mdhd.duration - e.samples[t - 1].dts, 0), e.samples_duration += e.samples[t - 1].duration)
            }
        }, k.prototype.updateSampleLists = function () {
            var e, t, i, r, s, a, n, o, l, d, h, c;
            if (void 0 !== this.moov) for (; this.lastMoofIndex < this.moofs.length;) if (n = this.moofs[this.lastMoofIndex], this.lastMoofIndex++, "moof" == n.type) for (o = n, e = 0; e < o.trafs.length; e++) {
                for (l = o.trafs[e], d = this.getTrackById(l.tfhd.track_id), h = this.getTrexById(l.tfhd.track_id), t = l.tfhd.flags & b.TFHD_FLAG_SAMPLE_DESC ? l.tfhd.default_sample_description_index : h ? h.default_sample_description_index : 1, i = l.tfhd.flags & b.TFHD_FLAG_SAMPLE_DUR ? l.tfhd.default_sample_duration : h ? h.default_sample_duration : 0, r = l.tfhd.flags & b.TFHD_FLAG_SAMPLE_SIZE ? l.tfhd.default_sample_size : h ? h.default_sample_size : 0, s = l.tfhd.flags & b.TFHD_FLAG_SAMPLE_FLAGS ? l.tfhd.default_sample_flags : h ? h.default_sample_flags : 0, (l.sample_number = 0) < l.sbgps.length && k.initSampleGroups(d, l, l.sbgps, d.mdia.minf.stbl.sgpds, l.sgpds), A = 0; A < l.truns.length; A++) for (var u = l.truns[A], p = 0; p < u.sample_count; p++) {
                    (c = {}).moof_number = this.lastMoofIndex, c.number_in_traf = l.sample_number, l.sample_number++, c.number = d.samples.length, l.first_sample_index = d.samples.length, d.samples.push(c), c.track_id = d.tkhd.track_id, c.timescale = d.mdia.mdhd.timescale, c.description_index = t - 1, c.description = d.mdia.minf.stbl.stsd.entries[c.description_index], c.size = r, u.flags & b.TRUN_FLAGS_SIZE && (c.size = u.sample_size[p]), d.samples_size += c.size, c.duration = i, u.flags & b.TRUN_FLAGS_DURATION && (c.duration = u.sample_duration[p]), d.samples_duration += c.duration, d.first_traf_merged || 0 < p ? c.dts = d.samples[d.samples.length - 2].dts + d.samples[d.samples.length - 2].duration : (l.tfdt ? c.dts = l.tfdt.baseMediaDecodeTime : c.dts = 0, d.first_traf_merged = !0), c.cts = c.dts, u.flags & b.TRUN_FLAGS_CTS_OFFSET && (c.cts = c.dts + u.sample_composition_time_offset[p]), f = s, u.flags & b.TRUN_FLAGS_FLAGS ? f = u.sample_flags[p] : 0 === p && u.flags & b.TRUN_FLAGS_FIRST_FLAG && (f = u.first_sample_flags), c.is_sync = !(f >> 16 & 1), c.is_leading = f >> 26 & 3, c.depends_on = f >> 24 & 3, c.is_depended_on = f >> 22 & 3, c.has_redundancy = f >> 20 & 3, c.degradation_priority = 65535 & f;
                    var f = !!(l.tfhd.flags & b.TFHD_FLAG_BASE_DATA_OFFSET),
                        m = !!(l.tfhd.flags & b.TFHD_FLAG_DEFAULT_BASE_IS_MOOF),
                        g = !!(u.flags & b.TRUN_FLAGS_DATA_OFFSET),
                        f = f ? l.tfhd.base_data_offset : m || 0 === A ? o.start : a;
                    c.offset = 0 === A && 0 === p ? g ? f + u.data_offset : f : a, a = c.offset + c.size, (0 < l.sbgps.length || 0 < l.sgpds.length || 0 < d.mdia.minf.stbl.sbgps.length || 0 < d.mdia.minf.stbl.sgpds.length) && k.setSampleGroupProperties(d, c, c.number_in_traf, l.sample_groups_info)
                }
                if (l.subs) {
                    d.has_fragment_subsamples = !0;
                    for (var y = l.first_sample_index, A = 0; A < l.subs.entries.length; A++) y += l.subs.entries[A].sample_delta, (c = d.samples[y - 1]).subsamples = l.subs.entries[A].subsamples
                }
            }
        }, k.prototype.getSample = function (e, t) {
            var i = e.samples[t];
            if (!this.moov) return null;
            if (i.data) {
                if (i.alreadyRead == i.size) return i
            } else i.data = new Uint8Array(i.size), i.alreadyRead = 0, this.samplesDataSize += i.size, u.debug("ISOFile", "Allocating sample #" + t + " on track #" + e.tkhd.track_id + " of size " + i.size + " (total: " + this.samplesDataSize + ")");
            for (; ;) {
                var r = this.stream.findPosition(!0, i.offset + i.alreadyRead, !1);
                if (!(-1 < r)) return null;
                var s = (r = this.stream.buffers[r]).byteLength - (i.offset + i.alreadyRead - r.fileStart);
                if (i.size - i.alreadyRead <= s) return u.debug("ISOFile", "Getting sample #" + t + " data (alreadyRead: " + i.alreadyRead + " offset: " + (i.offset + i.alreadyRead - r.fileStart) + " read size: " + (i.size - i.alreadyRead) + " full size: " + i.size + ")"), l.memcpy(i.data.buffer, i.alreadyRead, r, i.offset + i.alreadyRead - r.fileStart, i.size - i.alreadyRead), r.usedBytes += i.size - i.alreadyRead, this.stream.logBufferLevel(), i.alreadyRead = i.size, i;
                if (0 == s) return null;
                u.debug("ISOFile", "Getting sample #" + t + " partial data (alreadyRead: " + i.alreadyRead + " offset: " + (i.offset + i.alreadyRead - r.fileStart) + " read size: " + s + " full size: " + i.size + ")"), l.memcpy(i.data.buffer, i.alreadyRead, r, i.offset + i.alreadyRead - r.fileStart, s), i.alreadyRead += s, r.usedBytes += s, this.stream.logBufferLevel()
            }
        }, k.prototype.releaseSample = function (e, t) {
            e = e.samples[t];
            return e.data ? (this.samplesDataSize -= e.size, e.data = null, e.alreadyRead = 0, e.size) : 0
        }, k.prototype.getAllocatedSampleDataSize = function () {
            return this.samplesDataSize
        }, k.prototype.getCodecs = function () {
            for (var e = "", t = 0; t < this.moov.traks.length; t++) 0 < t && (e += ","), e += this.moov.traks[t].mdia.minf.stbl.stsd.entries[0].getCodec();
            return e
        }, k.prototype.getTrexById = function (e) {
            var t;
            if (!this.moov || !this.moov.mvex) return null;
            for (t = 0; t < this.moov.mvex.trexs.length; t++) {
                var i = this.moov.mvex.trexs[t];
                if (i.track_id == e) return i
            }
            return null
        }, k.prototype.getTrackById = function (e) {
            if (void 0 === this.moov) return null;
            for (var t = 0; t < this.moov.traks.length; t++) {
                var i = this.moov.traks[t];
                if (i.tkhd.track_id == e) return i
            }
            return null
        }, k.prototype.items = [], k.prototype.itemsDataSize = 0, k.prototype.flattenItemInfo = function () {
            var e = this.items, t = this.meta;
            if (null != t && void 0 !== t.hdlr && void 0 !== t.iinf) {
                for (l = 0; l < t.iinf.item_infos.length; l++) (r = {}).id = t.iinf.item_infos[l].item_ID, (e[r.id] = r).ref_to = [], r.name = t.iinf.item_infos[l].item_name, 0 < t.iinf.item_infos[l].protection_index && (r.protection = t.ipro.protections[t.iinf.item_infos[l].protection_index - 1]), t.iinf.item_infos[l].item_type ? r.type = t.iinf.item_infos[l].item_type : r.type = "mime", r.content_type = t.iinf.item_infos[l].content_type, r.content_encoding = t.iinf.item_infos[l].content_encoding;
                if (t.iloc) for (l = 0; l < t.iloc.items.length; l++) {
                    var i = t.iloc.items[l], r = e[i.item_ID];
                    switch (0 !== i.data_reference_index && (u.warn("Item storage with reference to other files: not supported"), r.source = t.dinf.boxes[i.data_reference_index - 1]), i.construction_method) {
                        case 0:
                            break;
                        case 1:
                        case 2:
                            u.warn("Item storage with construction_method : not supported")
                    }
                    for (r.extents = [], a = r.size = 0; a < i.extents.length; a++) r.extents[a] = {}, r.extents[a].offset = i.extents[a].extent_offset + i.base_offset, r.extents[a].length = i.extents[a].extent_length, r.extents[a].alreadyRead = 0, r.size += r.extents[a].length
                }
                if (t.pitm && (e[t.pitm.item_id].primary = !0), t.iref) for (l = 0; l < t.iref.references.length; l++) for (var s = t.iref.references[l], a = 0; a < s.references.length; a++) e[s.from_item_ID].ref_to.push({
                    type: s.type,
                    id: s.references[a]
                });
                if (t.iprp) for (var n = 0; n < t.iprp.ipmas.length; n++) for (var o = t.iprp.ipmas[n], l = 0; l < o.associations.length; l++) {
                    var d = o.associations[l];
                    for (void 0 === (r = e[d.id]).properties && (r.properties = {}, r.properties.boxes = []), a = 0; a < d.props.length; a++) {
                        var h = d.props[a];
                        0 < h.property_index && h.property_index - 1 < t.iprp.ipco.boxes.length && (h = t.iprp.ipco.boxes[h.property_index - 1], r.properties[h.type] = h, r.properties.boxes.push(h))
                    }
                }
            }
        }, k.prototype.getItem = function (e) {
            var t;
            if (!this.meta) return null;
            if (!(t = this.items[e]).data && t.size) t.data = new Uint8Array(t.size), t.alreadyRead = 0, this.itemsDataSize += t.size, u.debug("ISOFile", "Allocating item #" + e + " of size " + t.size + " (total: " + this.itemsDataSize + ")"); else if (t.alreadyRead === t.size) return t;
            for (var i = 0; i < t.extents.length; i++) {
                var r = t.extents[i];
                if (r.alreadyRead !== r.length) {
                    var s = this.stream.findPosition(!0, r.offset + r.alreadyRead, !1);
                    if (!(-1 < s)) return null;
                    var a = (s = this.stream.buffers[s]).byteLength - (r.offset + r.alreadyRead - s.fileStart);
                    if (!(r.length - r.alreadyRead <= a)) return u.debug("ISOFile", "Getting item #" + e + " extent #" + i + " partial data (alreadyRead: " + r.alreadyRead + " offset: " + (r.offset + r.alreadyRead - s.fileStart) + " read size: " + a + " full extent size: " + r.length + " full item size: " + t.size + ")"), l.memcpy(t.data.buffer, t.alreadyRead, s, r.offset + r.alreadyRead - s.fileStart, a), r.alreadyRead += a, t.alreadyRead += a, s.usedBytes += a, this.stream.logBufferLevel(), null;
                    u.debug("ISOFile", "Getting item #" + e + " extent #" + i + " data (alreadyRead: " + r.alreadyRead + " offset: " + (r.offset + r.alreadyRead - s.fileStart) + " read size: " + (r.length - r.alreadyRead) + " full extent size: " + r.length + " full item size: " + t.size + ")"), l.memcpy(t.data.buffer, t.alreadyRead, s, r.offset + r.alreadyRead - s.fileStart, r.length - r.alreadyRead), s.usedBytes += r.length - r.alreadyRead, this.stream.logBufferLevel(), t.alreadyRead += r.length - r.alreadyRead, r.alreadyRead = r.length
                }
            }
            return t.alreadyRead === t.size ? t : null
        }, k.prototype.releaseItem = function (e) {
            var t = this.items[e];
            if (t.data) {
                this.itemsDataSize -= t.size, t.data = null;
                for (var i = t.alreadyRead = 0; i < t.extents.length; i++) t.extents[i].alreadyRead = 0;
                return t.size
            }
            return 0
        }, k.prototype.processItems = function (e) {
            for (var t in this.items) {
                t = this.items[t];
                this.getItem(t.id), e && !t.sent && (e(t), t.sent = !0, t.data = null)
            }
        }, k.prototype.hasItem = function (e) {
            for (var t in this.items) {
                t = this.items[t];
                if (t.name === e) return t.id
            }
            return -1
        }, k.prototype.getMetaHandler = function () {
            return this.meta ? this.meta.hdlr.handler : null
        }, k.prototype.getPrimaryItem = function () {
            return this.meta && this.meta.pitm ? this.getItem(this.meta.pitm.item_id) : null
        }, k.prototype.itemToFragmentedTrackFile = function (e) {
            var e = e || {};
            if (null == (e = e.itemId ? this.getItem(e.itemId) : this.getPrimaryItem())) return null;
            var t = new k, i = (t.discardMdatData = !1, {type: e.type, description_boxes: e.properties.boxes}),
                i = (e.properties.ispe && (i.width = e.properties.ispe.image_width, i.height = e.properties.ispe.image_height), t.addTrack(i));
            return i ? (t.addSample(i, e.data), t) : null
        }, k.prototype.write = function (e) {
            for (var t = 0; t < this.boxes.length; t++) this.boxes[t].write(e)
        }, k.prototype.createFragment = function (e, t, i) {
            var e = this.getTrackById(e), r = this.getSample(e, t);
            if (null == r) return r = e.samples[t], this.nextSeekPosition ? this.nextSeekPosition = Math.min(r.offset + r.alreadyRead, this.nextSeekPosition) : this.nextSeekPosition = e.samples[t].offset + r.alreadyRead, null;
            e = i || new l, e.endianness = l.BIG_ENDIAN, t = this.createSingleSampleMoof(r), t.write(e), t.trafs[0].truns[0].data_offset = t.size + 8, u.debug("MP4Box", "Adjusting data_offset with new value " + t.trafs[0].truns[0].data_offset), e.adjustUint32(t.trafs[0].truns[0].data_offset_position, t.trafs[0].truns[0].data_offset), i = new b.mdatBox;
            return i.data = r.data, i.write(e), e
        }, k.writeInitializationSegment = function (e, t, i, r) {
            u.debug("ISOFile", "Generating initialization segment");
            var s, a = new l, n = (a.endianness = l.BIG_ENDIAN, e.write(a), t.add("mvex"));
            for (i && n.add("mehd").set("fragment_duration", i), s = 0; s < t.traks.length; s++) n.add("trex").set("track_id", t.traks[s].tkhd.track_id).set("default_sample_description_index", 1).set("default_sample_duration", r).set("default_sample_size", 0).set("default_sample_flags", 65536);
            return t.write(a), a.buffer
        }, k.prototype.save = function (e) {
            var t = new l;
            t.endianness = l.BIG_ENDIAN, this.write(t), t.save(e)
        }, k.prototype.getBuffer = function () {
            var e = new l;
            return e.endianness = l.BIG_ENDIAN, this.write(e), e.buffer
        }, k.prototype.initializeSegmentation = function () {
            var e, t, i, r;
            for (null === this.onSegment && u.warn("MP4Box", "No segmentation callback set!"), this.isFragmentationInitialized || (this.isFragmentationInitialized = !0, this.nextMoofNumber = 0, this.resetTables()), t = [], e = 0; e < this.fragmentedTracks.length; e++) {
                var s = new b.moovBox;
                s.mvhd = this.moov.mvhd, s.boxes.push(s.mvhd), i = this.getTrackById(this.fragmentedTracks[e].id), s.boxes.push(i), s.traks.push(i), (r = {}).id = i.tkhd.track_id, r.user = this.fragmentedTracks[e].user, r.buffer = k.writeInitializationSegment(this.ftyp, s, this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration : void 0, 0 < this.moov.traks[e].samples.length ? this.moov.traks[e].samples[0].duration : 0), t.push(r)
            }
            return t
        }, b.Box.prototype.printHeader = function (e) {
            this.size += 8, this.size > d && (this.size += 8), "uuid" === this.type && (this.size += 16), e.log(e.indent + "size:" + this.size), e.log(e.indent + "type:" + this.type)
        }, b.FullBox.prototype.printHeader = function (e) {
            this.size += 4, b.Box.prototype.printHeader.call(this, e), e.log(e.indent + "version:" + this.version), e.log(e.indent + "flags:" + this.flags)
        }, b.Box.prototype.print = function (e) {
            this.printHeader(e)
        }, b.ContainerBox.prototype.print = function (e) {
            this.printHeader(e);
            for (var t, i = 0; i < this.boxes.length; i++) this.boxes[i] && (t = e.indent, e.indent += " ", this.boxes[i].print(e), e.indent = t)
        }, k.prototype.print = function (e) {
            e.indent = "";
            for (var t = 0; t < this.boxes.length; t++) this.boxes[t] && this.boxes[t].print(e)
        }, b.mvhdBox.prototype.print = function (e) {
            b.FullBox.prototype.printHeader.call(this, e), e.log(e.indent + "creation_time: " + this.creation_time), e.log(e.indent + "modification_time: " + this.modification_time), e.log(e.indent + "timescale: " + this.timescale), e.log(e.indent + "duration: " + this.duration), e.log(e.indent + "rate: " + this.rate), e.log(e.indent + "volume: " + (this.volume >> 8)), e.log(e.indent + "matrix: " + this.matrix.join(", ")), e.log(e.indent + "next_track_id: " + this.next_track_id)
        }, b.tkhdBox.prototype.print = function (e) {
            b.FullBox.prototype.printHeader.call(this, e), e.log(e.indent + "creation_time: " + this.creation_time), e.log(e.indent + "modification_time: " + this.modification_time), e.log(e.indent + "track_id: " + this.track_id), e.log(e.indent + "duration: " + this.duration), e.log(e.indent + "volume: " + (this.volume >> 8)), e.log(e.indent + "matrix: " + this.matrix.join(", ")), e.log(e.indent + "layer: " + this.layer), e.log(e.indent + "alternate_group: " + this.alternate_group), e.log(e.indent + "width: " + this.width), e.log(e.indent + "height: " + this.height)
        };
        var h = function (e, t) {
            e = void 0 === e || e, t = new k(t);
            return t.discardMdatData = !e, t
        };
        t.createFile = h
    });

    function Xs(e) {
        return e.reduce((e, t) => 256 * e + t)
    }

    function Zs(e) {
        const t = [101, 103, 119, 99], i = e.length - 28, r = e.slice(i, i + t.length);
        return t.every((e, t) => e === r[t])
    }

    I.Log, I.MP4BoxStream, I.DataStream, I.MultiBufferStream, I.MPEG4DescriptorParser, I.BoxParser, I.XMLSubtitlein4Parser, I.Textin4Parser, I.ISOFile, I.createFile;

    class ea {
        constructor() {
            this.s = null, this.a = null, this.l = 0, this.c = 0, this.u = 1 / 0, this.A = !1, this.d = !1, this.r = 4194304, this.n = new Uint8Array([30, 158, 90, 33, 244, 57, 83, 165, 2, 70, 35, 87, 215, 231, 226, 108]), this.t = this.n.slice().reverse()
        }

        destroy() {
            this.s = null, this.a = null, this.l = 0, this.c = 0, this.u = 1 / 0, this.A = !1, this.d = !1, this.r = 4194304, this.n = null, this.t = null
        }

        transport(e) {
            if (!this.s && 50 < this.l) return e;
            if (this.l++, this.d) return e;
            var t = new Uint8Array(e);
            if (this.A) {
                if (!(this.c < this.u)) return this.a && this.s ? (this.a.set(t, this.r), this.s.parse(null, this.r, t.byteLength), this.a.slice(this.r, this.r + t.byteLength)) : (console.error("video_error_2"), this.d = !0, e);
                Zs(t) && this.c++
            } else {
                var i = function (e, t) {
                    var i = function (i, r) {
                        for (let t = 0; t < i.byteLength - r.length; t++) for (let e = 0; e < r.length && i[t + e] === r[e]; e++) if (e === r.length - 1) return t;
                        return null
                    }(e, t);
                    if (i) {
                        const t = Xs(e.slice(i + 16, i + 16 + 8));
                        return [t, Xs(e.slice(i + 24, i + 24 + 8)), e.slice(i + 32, i + 32 + t).map(e => ~e)]
                    }
                    return null
                }(t, this.t);
                if (!i) return e;
                var r = function (e) {
                    try {
                        if ("object" != typeof WebAssembly || "function" != typeof WebAssembly.instantiate) throw null;
                        {
                            const e = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
                            if (!(e instanceof WebAssembly.Module && new WebAssembly.Instance(e) instanceof WebAssembly.Instance)) throw null
                        }
                    } catch (e) {
                        return new Error("video_error_4")
                    }
                    let t;
                    try {
                        t = {
                            env: {
                                __handle_stack_overflow: () => e(new Error("video_error_1")),
                                memory: new WebAssembly.Memory({initial: 256, maximum: 256})
                            }
                        }
                    } catch (e) {
                        return new Error("video_error_5")
                    }
                    return t
                }(e);
                if (r instanceof Error) return console.error(r.message), this.d = !0, e;
                this.A = !0, this.u = i[1], Zs(t) && this.c++, WebAssembly.instantiate(i[2], r).then(e => {
                    if ("function" != typeof (t = e.instance.exports).parse || "object" != typeof t.memory) return this.d = !0, void console.error("video_error_3");
                    var t;
                    this.s = e.instance.exports, this.a = new Uint8Array(this.s.memory.buffer)
                }).catch(e => {
                    this.d = !0, console.error("video_error_6")
                })
            }
            return e
        }
    }

    class ta extends Ur {
        constructor(e) {
            super(e), this.TAG_NAME = "Fmp4Loader", this.player = e, this.mp4Box = I.createFile(), this.tempFmp4List = [], this.offset = 0, this.videoTrackId = null, this.audioTrackId = null, this.isHevc = !1, this.transportDescarmber = null, this.player._opt.isFmp4Private && (this.transportDescarmber = new ea), this._listenMp4Box(), e.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            this.mp4Box && (this.mp4Box.flush(), this.mp4Box = null), this.transportDescarmber && (this.transportDescarmber.destroy(), this.transportDescarmber = null), this.tempFmp4List = [], this.offset = 0, this.videoTrackId = null, this.audioTrackId = null, this.isHevc = !1, this.player.debug.log(this.TAG_NAME, "destroy")
        }

        _listenMp4Box() {
            this.mp4Box.onReady = this.onReady.bind(this), this.mp4Box.onError = this.onError.bind(this), this.mp4Box.onSamples = this.onSamples.bind(this)
        }

        onReady(e) {
            this.player.debug.log(this.TAG_NAME, "onReady", e);
            const t = e.videoTracks[0], i = e.audioTracks[0];
            if (t) {
                this.videoTrackId = t.id;
                const e = this.getSeqHeader(t);
                e && (this.player.debug.log(this.TAG_NAME, "seqHeader", e), this._doDecodeByFmp4(e, 2, 0, !0, 0)), this.mp4Box.setExtractionOptions(t.id)
            }
            if (i) {
                this.audioTrackId = i.id;
                const e = i.audio || {}, t = yt.indexOf(e.sample_rate), a = i.codec.replace("mp4a.40.", "");
                this.mp4Box.setExtractionOptions(i.id);
                var r = {profile: parseInt(a, 10), sampleRate: t, channel: e.channel_count}, s = mt(r);
                this.player.debug.log(this.TAG_NAME, "aacADTSHeader", s, "config", r), this._doDecodeByFmp4(s, 1, 0, !1, 0)
            }
            this.mp4Box.start()
        }

        onError(e) {
            this.player.debug.error(this.TAG_NAME, "mp4Box onError", e)
        }

        onSamples(e, t, i) {
            if (e === this.videoTrackId) for (const e of i) {
                const t = e.data, i = e.is_sync, s = 1e3 * e.cts / e.timescale;
                e.duration, e.timescale, this.player.updateStats({
                    vbps: t.byteLength,
                    dts: s
                }), i && this.calcIframeIntervalTimestamp(s);
                var r = (this.isHevc ? _r : pr)(t, i);
                this.player._opt.isEmitSEI && this.findSei(r, s), this._doDecodeByFmp4(r, 2, s, i, 0)
            } else if (e === this.audioTrackId) for (const e of i) {
                const t = e.data, i = (this.player.updateStats({abps: t.byteLength}), 1e3 * e.cts / e.timescale),
                    a = (e.duration, e.timescale, new Uint8Array(t.byteLength + 2));
                a.set([175, 1], 0), a.set(t, 2), this._doDecodeByFmp4(a, 1, i, !1, 0)
            } else this.player.debug.warn(this.TAG_NAME, "onSamples() trackId error", e)
        }

        getSeqHeader(t) {
            const i = this.mp4Box.getTrackById(t.id);
            for (const t of i.mdia.minf.stbl.stsd.entries) if (t.avcC || t.hvcC) {
                const i = new I.DataStream(void 0, 0, I.DataStream.BIG_ENDIAN);
                let e = [];
                e = t.avcC ? (t.avcC.write(i), [23, 0, 0, 0, 0]) : (this.isHevc = !0, t.hvcC.write(i), [28, 0, 0, 0, 0]);
                const r = new Uint8Array(i.buffer, 8), s = new Uint8Array(e.length + r.length);
                return s.set(e, 0), s.set(r, e.length), s
            }
            return null
        }

        dispatch(e) {
            let t = new Uint8Array(e);
            "string" != typeof e ? "object" == typeof e ? ((t = this.transportDescarmber ? this.transportDescarmber.transport(t) : t).buffer.fileStart = this.offset, this.offset += t.byteLength, this.mp4Box.appendBuffer(t.buffer)) : this.player.debug.warn(this.TAG_NAME, "dispatch()", "data is not object", e) : this.player.debug.warn(this.TAG_NAME, "dispatch()", "data is string", e)
        }

        downloadFmp4File() {
            const e = new Blob(this.tempFmp4List, {type: 'video/mp4; codecs="avc1.640028,mp4a.40.2"'}),
                t = URL.createObjectURL(e), i = document.createElement("a");
            i.href = t, i.download = p() + ".fmp4", i.click(), URL.revokeObjectURL(t)
        }
    }

    class ia extends Ur {
        constructor(e) {
            super(e), s(this, "LOG_NAME", "Mpeg4Loader"), this.player = e, this.player.debug.log(this.LOG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.player.debug.log(this.LOG_NAME, "destroy")
        }
    }

    class ra {
        constructor(e) {
            return new (ra.getLoaderFactory(e))(e)
        }

        static getLoaderFactory(e) {
            var t = e._opt.demuxType;
            return "m7s" === t ? qs : t === H || e.isWebrtcH265() ? $s : t === W ? Ys : t === V ? Js : t === K ? ta : t === $ ? ia : Qs
        }
    }

    class sa extends e {
        constructor(e) {
            super(), this.player = e, this.hasInit = !1, this.isDecodeFirstIIframe = !!C(e._opt.checkFirstIFrame), this.isInitInfo = !1, this.prevTimestamp = null, this.decodeDiffTimestamp = null, this.prevDts = null, this.decoder = null, this.isWidthOrHeightChanged = !1, this.initDecoder(), e.debug.log("Webcodecs", "init")
        }

        destroy() {
            this.decoder && (C(this.isDecodeStateClosed()) && this.decoder.close(), this.decoder = null), this.prevTimestamp = null, this.decodeDiffTimestamp = null, this.prevDts = null, this.hasInit = !1, this.isInitInfo = !1, this.isDecodeFirstIIframe = !1, this.isWidthOrHeightChanged = !1, this.off(), this.player.debug.log("Webcodecs", "destroy")
        }

        initDecoder() {
            const t = this;
            this.decoder = new VideoDecoder({
                output(e) {
                    t.handleDecode(e)
                }, error(e) {
                    t.handleError(e)
                }
            })
        }

        handleDecode(e) {
            this.isInitInfo || (this.player.video.updateVideoInfo({
                width: e.codedWidth,
                height: e.codedHeight
            }), this.player.video.initCanvasViewSize(), this.isInitInfo = !0), this.player.isPlayer() ? (this.player._times.videoStart || (this.player._times.videoStart = p(), this.player.handlePlayToRenderTimes()), this.player.video.render({
                videoFrame: e,
                ts: e.timestamp
            }), this.player.handleRender(), this.player.updateStats({dfps: !0})) : this.player.isPlayback() && (this.player.updateStats({dfps: !0}), C(this.player.playbackPause) ? (this.player.playback.isUseLocalCalculateTime && this.player.playback.increaseLocalTimestamp(), this.player.playback.isUseFpsRender ? this.player.video.pushData({
                videoFrame: e,
                ts: e.timestamp
            }) : this.player.video.render$2({
                videoFrame: e,
                ts: e.timestamp
            })) : !this.player.playback.isPlaybackPauseClearCache && this.player.playback.isCacheBeforeDecodeForFpsRender && this.player.playback.isUseFpsRender && this.player.video.pushData({
                videoFrame: e,
                ts: e.timestamp
            }))
        }

        handleError(e) {
            this.player.debug.error("Webcodecs", "VideoDecoder handleError：", e.code, e);
            const t = e.toString();
            -1 !== t.indexOf("Unsupported configuration") ? this.player.emitError(S.webcodecsUnsupportedConfigurationError, t) : -1 === t.indexOf("Decoder failure") && -1 === t.indexOf("Decoding error") || this.player.emitError(S.webcodecsDecodeError, t)
        }

        decodeVideo(i, r, s, a) {
            if (this.player) if (this.player.isDestroyed()) this.player.debug.warn("Webcodecs", "decodeVideo() player is destroyed"); else if (this.hasInit) if (this.isDecodeFirstIIframe || s || this.player.debug.warn("Webcodecs", "VideoDecoder isDecodeFirstIIframe false and isIframe is false"), !this.isDecodeFirstIIframe && s && (this.isDecodeFirstIIframe = !0), this.isDecodeFirstIIframe) if (this.isDecodeStateClosed()) this.player.debug.warn("Webcodecs", "VideoDecoder isDecodeStateClosed true"); else {
                if (s && 0 === i[1]) {
                    const r = 15 & i[0];
                    let e = {};
                    7 == r ? e = cr(i.slice(5)) : 12 == r && (e = br(i));
                    const a = this.player.video.videoInfo;
                    a && a.width && a.height && e && e.codecWidth && e.codecHeight && (e.codecWidth !== a.width || e.codecHeight !== a.height) && (this.player.debug.warn("Webcodecs", `decodeVideo: video width or height is changed,
                        old width is ${a.width}, old height is ${a.height},
                         new width is ${e.codecWidth}, new height is ${e.codecHeight},
                         and emit change event`), this.isWidthOrHeightChanged = !0, this.player.emitError(S.wcsWidthOrHeightChange))
                }
                if (this.isWidthOrHeightChanged) this.player.debug.warn("Webcodecs", "decodeVideo: video width or height is changed, and return"); else if (ui(i)) this.player.debug.warn("Webcodecs", "decodeVideo and payload is video sequence header so drop this frame"); else if (i.byteLength < 12) this.player.debug.warn("Webcodecs", "decodeVideo and payload is too small , payload length is " + i.byteLength); else {
                    let e = !1, t = (new Date).getTime();
                    this.prevTimestamp || (this.prevTimestamp = t, e = !0);
                    var n = t - this.prevTimestamp,
                        n = (((this.decodeDiffTimestamp = n) < 5 || 500 < n) && !e && this.player.debug.warn("Webcodecs", "decodeVideo diff time is ", n), i.slice(5)),
                        o = new EncodedVideoChunk({data: n, timestamp: r, type: s ? "key" : "delta"});
                    this.player.emit(w.timeUpdate, r), this.player.recorder && this.player.recorder.isRecording && this.player._opt.recordType === u && this.player.recorder.handleAddNaluTrack(n, s, r, a);
                    try {
                        this.decoder.decode(o)
                    } catch (i) {
                        this.player.debug.error("Webcodecs", "VideoDecoder", i);
                        const r = i.toString();
                        -1 === r.indexOf("A key frame is required after configure() or flush()") && -1 === r.indexOf("Cannot call 'decode' on a closed codec") || this.player.emitError(S.webcodecsDecodeError)
                    }
                    this.prevTimestamp = (new Date).getTime()
                }
            } else this.player.debug.warn("Webcodecs", "VideoDecoder isDecodeFirstIIframe false"); else if (s && 0 === i[1]) {
                const r = 15 & i[0];
                if (this.player.video.updateVideoInfo({encTypeCode: r}), 12 == r && !Nt()) {
                    const i = Lt();
                    return this.player.debug.warn("Webcodecs", "WebcodecsDecoder not support hevc decode", i.type, i.version), void this.emit(S.webcodecsH265NotSupport)
                }
                this.player._times.decodeStart || (this.player._times.decodeStart = p());
                let e = null, t = null;
                const l = i.slice(5);
                7 == r ? (e = function (e) {
                    let i = e.subarray(1, 4), r = "avc1.";
                    for (let t = 0; t < 3; t++) {
                        let e = i[t].toString(16);
                        e.length < 2 && (e = "0" + e), r += e
                    }
                    return {codec: r, description: e}
                }(l), t = cr(l)) : 12 == r && ((n = l).subarray(1, 4), e = {
                    codec: "hev1.1.6.L120.90",
                    description: n
                }, t = br(i)), t && t.codecWidth && t.codecHeight && (e.codedHeight = t.codecHeight, e.codedWidth = t.codecWidth), this.player.recorder && this.player._opt.recordType === u && this.player.recorder.initMetaData(i, r);
                try {
                    this.decoder.configure(e), this.hasInit = !0
                } catch (i) {
                    this.player.debug.log("Webcodecs", "configure error", i.code, i)
                }
            }
        }

        getDecodeDiffTimes() {
            return this.decodeDiffTimestamp
        }

        isDecodeStateClosed() {
            return "closed" === this.decoder.state
        }

        isDecodeStateConfigured() {
            return "configured" === this.decoder.state
        }

        isDecodeStateUnConfigured() {
            return "unconfigured" === this.decoder.state
        }
    }

    const aa = {
        play: "播放",
        pause: "暂停",
        audio: "",
        mute: "",
        screenshot: "截图",
        loading: "",
        fullscreen: "全屏",
        fullscreenExit: "退出全屏",
        record: "录制",
        recordStop: "停止录制",
        narrow: "缩小",
        expand: "放大",
        ptz: "操作盘",
        ptzActive: "操作盘激活",
        zoom: "电子放大",
        zoomStop: "关闭电子放大",
        close: "关闭",
        performance: "性能面板",
        performanceActive: "性能面板激活",
        face: "人脸识别",
        faceActive: "人脸识别激活",
        logSave: "保存日志"
    };
    var R = Object.keys(aa).reduce((e, t) => (e[t] = `
    <i class="jessibuca-icon jessibuca-icon-${t}"></i>
    ${aa[t] ? `<span class="icon-title-tips"><span class="icon-title">${aa[t]}</span></span>` : ""}
`, e), {});

    function na(e, t) {
        let i = !1;
        return e.forEach(e => {
            i || e.startTimestamp <= t && e.endTimestamp > t && (i = !0)
        }), i
    }

    function oa(e, t, i) {
        let r = 0 < arguments.length && void 0 !== e ? e : [], s = 1 < arguments.length && void 0 !== t ? t : [],
            a = 2 < arguments.length ? i : void 0;
        const n = r.length, o = s.length, l = Math.max(n, o), d = 2e3, h = Math.ceil(l / d);
        let c = 0, u = 0;
        !function e() {
            let t = "", i = "";
            for (let e = 0; e < d; e++) {
                const a = r[u], d = (a && (t += `
                     <div class="jessibuca-playback-time-minute-one${a.hasRecord ? " active" : ""}${a.isStart ? " start" : ""}" data-has-record="${a.hasRecord}"
                     data-time="${a.timestamp}" data-type="${a.dataType}">
                        <span class="jessibuca-playback-time-title-tips ${u > n - 60 ? "jessibuca-playback-time-title-tips-left" : ""}"><span class="jessibuca-playback-time-title">${a.title}</span></span>
                    </div>
                `), s[u]);
                d && (i += `
                  <div class="jessibuca-playback-time-hour" data-hour="${d.hour}" data-min="${d.min}" data-second="${d.second}"><span class="jessibuca-playback-time-hour-text">${d.title}</span></div>
                `), u += 1
            }
            t && a.$playbackTimeListOne.insertAdjacentHTML("beforeend", t), i && a.$playbackTimeListSecond.insertAdjacentHTML("beforeend", i), (c += 1) < h && (a.rafId = window.requestAnimationFrame(e))
        }()
    }

    function la(e, t) {
        oa(function (e) {
            let i = 0 < arguments.length && void 0 !== e ? e : [], r = [];
            var s, a, n, o = (i[0] || {}).startTimestamp;
            for (let t = 0; t < 1440; t++) {
                var l = t % 60 == 0;
                let e = !1;
                o && (e = na(i, (s = o, a = t, n = void 0, n = Math.floor(a / 60) % 60, a = Math.floor(a % 60), new Date(s).setHours(n, a, 0, 0)))), r.push({
                    title: function (e, t) {
                        let i = "";
                        var r;
                        return -1 < e && (r = Math.floor(e / 60) % 60, e = e % 60, e = Math.round(e), i = r < 10 ? "0" + r + ":" : r + ":", e < 10 && (i += "0"), i += e, c(t) || (t < 10 && (t = "0" + t), i += ":" + t)), i
                    }(t), timestamp: t, dataType: "min", hasRecord: e, isStart: l
                })
            }
            return r
        }(e), function () {
            let i = [];
            for (let t = 0; t < 24; t++) {
                let e = t + ":00";
                t < 10 && (e = "0" + e), i.push({title: e, hour: t, min: 0, second: 0})
            }
            return i
        }(), t)
    }

    function da(e) {
        const t = Math.floor(e / 3600), i = Math.floor((e - 3600 * t) / 60), r = Math.floor(e - 3600 * t - 60 * i);
        return (0 < t ? [t, i, r] : [i, r]).map(e => e < 10 ? "0" + e : String(e)).join(":")
    }

    function ha(e, t, i) {
        const r = e.$playbackProgress, s = r.getBoundingClientRect()["left"],
            a = E((y() ? i.touches[0].clientX : i.pageX) - s, 0, r.clientWidth),
            n = parseInt(a / r.clientWidth * t, 10);
        return {second: n, time: da(n), width: a, percentage: E(a / r.clientWidth, 0, 1)}
    }

    function ca(e, t) {
        t instanceof Element ? e.appendChild(t) : e.insertAdjacentHTML("beforeend", String(t)), e.lastElementChild || e.lastChild
    }

    function U(e, t, i) {
        e.style[t] = i
    }

    function ua(e, t) {
        return e.composedPath && -1 < e.composedPath().indexOf(t)
    }

    function pa(e) {
        let t = !1;
        return e && e.parentNode && (e.parentNode.removeChild(e), t = !0), t
    }

    var fa = (b, v) => {
        const {proxy: s} = b["events"], a = document.createElement("object");
        a.setAttribute("aria-hidden", "true"), a.setAttribute("tabindex", -1), a.type = "text/html", a.data = "about:blank", T(a, {
            display: "block",
            position: "absolute",
            top: "0",
            left: "0",
            height: "100%",
            width: "100%",
            overflow: "hidden",
            pointerEvents: "none",
            zIndex: "-1"
        });
        let e = b.width, t = b.height;
        const i = Ft(() => {
            b.width === e && b.height === t || (e = b.width, t = b.height, b.emit(w.resize), d())
        }, 500), r = (s(a, "load", () => {
            s(a.contentDocument.defaultView, "resize", () => {
                i()
            })
        }), b.$container.appendChild(a), b.on(w.destroy, () => {
            b.$container.removeChild(a)
        }), b.on(w.volumechange, () => {
            var e, t, i;
            0 === (e = b.volume) ? (T(v.$volumeOn, "display", "none"), T(v.$volumeOff, "display", "flex"), T(v.$volumeHandle, "top", "48px")) : v.$volumeHandle && v.$volumePanel && (t = St(v.$volumePanel, "height") || 60, i = St(v.$volumeHandle, "height"), T(v.$volumeHandle, "top", t - (t - i) * e - i + "px"), T(v.$volumeOn, "display", "flex"), T(v.$volumeOff, "display", "none")), v.$volumePanelText && (v.$volumePanelText.innerHTML = parseInt(100 * e))
        }), b.on(w.loading, e => {
            T(v.$loading, "display", e ? "flex" : "none"), (C(b._opt.backgroundLoadingShow) && k(e) || C(e)) && T(v.$poster, "display", "none"), e && T(v.$playBig, "display", "none"), y() || e || b.getRenderType() === Y && C(b._opt.useMSE) && r()
        }), b.on(w.removeLoadingBgImage, () => {
            y() || r()
        }), () => {
            v.$loadingBgImage && v.$loadingBg && v.$loadingBgImage.src && (b.debug && b.debug.log("Control", "remove loading bg image"), v.$loadingBgImage.width = 0, v.$loadingBgImage.height = 0, v.$loadingBgImage.src = "", T(v.$loadingBg, "display", "none"))
        }), n = e => {
            b.fullscreen && ei(e) !== b.$container || o()
        }, o = e => {
            e = Ht(e) ? e : b.fullscreen;
            T(v.$fullscreenExit, "display", e ? "flex" : "none"), T(v.$fullscreen, "display", e ? "none" : "flex")
        }, l = () => b._opt.playType === A && b._opt.playbackConfig.showControl, d = s => {
            y() && v.$controls && b._opt.useWebFullScreen && setTimeout(() => {
                if (b.fullscreen) {
                    const s = l() ? 48 : 38;
                    var e = b.height / 2 - b.width + s / 2, t = b.height / 2 - s / 2;
                    if (v.$controls.style.transform = `translateX(${-e}px) translateY(-${t}px) rotate(-90deg)`, v.$zoomControls) {
                        const s = 156, i = b.width / 2 + 78 - 15;
                        v.$zoomControls.style.transform = `translateX(${-i}px) translateY(${b.height / 2}px) rotate(-90deg)`
                    }
                    if (v.$recording) {
                        const s = 101, r = b.width / 2 + 50.5 - 10;
                        v.$recording.style.transform = `translateX(${-r}px) translateY(${b.height / 2}px) rotate(-90deg)`
                    }
                } else v.$controls.style.transform = "translateX(0) translateY(0) rotate(0)", v.$zoomControls && (v.$zoomControls.style.transform = "translateX(-50%) translateY(0) rotate(0)"), v.$recording && (v.$recording.style.transform = "translateX(-50%) translateY(0) rotate(0)");
                s && s()
            }, 10)
        };
        try {
            g.on("change", n), b.events.destroys.push(() => {
                g.off("change", n)
            })
        } catch (b) {
        }
        b.on(w.webFullscreen, e => {
            y() && (o(e), d(() => {
                c()
            }))
        }), b.on(w.recording, () => {
            b.playing && (T(v.$record, "display", b.recording ? "none" : "flex"), T(v.$recordStop, "display", b.recording ? "flex" : "none"), (b._opt.hasControl || b._opt.isShowRecordingUI) && T(v.$recording, "display", b.recording ? "flex" : "none"))
        }), b.on(w.recordingTimestamp, e => {
            v.$recordingTime && (v.$recordingTime.innerHTML = $t(e))
        }), b.on(w.zooming, () => {
            b.playing && (T(v.$zoom, "display", b.zooming ? "none" : "flex"), T(v.$zoomStop, "display", b.zooming ? "flex" : "none"), (b._opt.hasControl || b._opt.isShowZoomingUI) && T(v.$zoomControls, "display", b.zooming ? "flex" : "none"))
        }), b.on(w.playing, e => {
            h(e)
        });
        const h = t => {
            T(v.$play, "display", t ? "none" : "flex"), T(v.$playBig, "display", t ? "none" : "block"), T(v.$pause, "display", t ? "flex" : "none"), T(v.$screenshot, "display", t ? "flex" : "none"), T(v.$record, "display", t ? "flex" : "none"), T(v.$qualityMenu, "display", t ? "flex" : "none"), T(v.$volume, "display", t ? "flex" : "none"), T(v.$ptz, "display", t ? "flex" : "none"), T(v.$zoom, "display", t ? "flex" : "none"), T(v.$scaleMenu, "display", t ? "flex" : "none"), T(v.$faceDetect, "display", t ? "flex" : "none"), T(v.$controlHtml, "display", t ? "flex" : "none"), b.isPlayback() && T(v.$speedMenu, "display", t ? "flex" : "none"), o(), v.extendBtnList.forEach(e => {
                e.$iconWrap && T(e.$iconWrap, "display", t ? "flex" : "none"), e.$activeIconWrap && T(e.$activeIconWrap, "display", "none")
            }), b._opt.showPerformance ? T(v.$performanceActive, "display", t ? "flex" : "none") : T(v.$performance, "display", t ? "flex" : "none"), T(v.$poster, "display", "none"), T(v.$ptzActive, "display", "none"), T(v.$recordStop, "display", "none"), T(v.$zoomStop, "display", "none"), T(v.$faceDetectActive, "display", "none"), t || (v.$speed && (v.$speed.innerHTML = "0 KB/s"), T(v.$zoomControls, "display", "none"), T(v.$recording, "display", "none"), v.$ptzControl && v.$ptzControl.classList.remove("jessibuca-ptz-controls-show")), c(), t && u()
        }, c = (b.on(w.playbackPause, e => {
            h(!e)
        }), b.on(w.kBps, e => {
            e = function (e) {
                if (null == e || "" === e || 0 === parseFloat(e) || "NaN" === e) return "0 KB/s";
                var t = ["KB/s", "MB/s", "GB/s", "TB/s", "PB/s", "EB/s", "ZB/s", "YB/s"], e = parseFloat(e),
                    i = Math.floor(Math.log(e) / Math.log(1024));
                let r = e / Math.pow(1024, i);
                return (r = r.toFixed(2)) + (t[i] || t[0])
            }(e);
            v.kbpsShow = e, b._opt.showBandwidth && (v.$speed && (v.$speed.innerHTML = e), c())
        }), () => {
            if (l() && b._opt.playbackConfig.controlType === _) {
                let e = v.controlsInnerRect.width - v.controlsLeftRect.width - v.controlsRightRect.width - v.controlsPlaybackBtnsRect.width;
                y() && b.webFullscreen && (e = v.controlsInnerRect.height - v.controlsLeftRect.height - v.controlsRightRect.height - v.controlsPlaybackBtnsRect.height), v.$playbackTimeInner.style.width = e + "px"
            }
        }), u = () => {
            if (l() && b._opt.playbackConfig.controlType === _) {
                var t = v.$playbackCurrentTime.style.left;
                let e = parseInt(t, 10);
                t = v.controlsPlaybackTimeInner.width;
                e = 0 < e - t / 2 ? parseInt(e - t / 2, 10) : 0, v.$playbackTimeInner.scrollLeft = e
            }
        };
        if (l()) {
            const s = () => {
                if (l()) {
                    let e = 0;
                    var t = b.playback && b.playback.playingTimestamp;
                    if (t) {
                        const i = new Date(t), r = i.getHours(), s = i.getMinutes(), a = i.getSeconds();
                        b.playback.is60Min ? e = 60 * r + s : b.playback.is30Min ? e = 2 * (60 * r + s) + parseInt(a / 30, 10) : b.playback.is10Min ? e = 6 * (60 * r + s) + parseInt(a / 10, 10) : b.playback.is5Min ? e = 12 * (60 * r + s) + parseInt(a / 5, 10) : b.playback.is1Min && (e = 60 * (60 * r + s) + parseInt(a, 10)), v.$playbackCurrentTime.style.left = e + "px"
                    }
                }
            }, a = e => {
                v.$playbackNarrow.classList.remove("disabled"), v.$playbackExpand.classList.remove("disabled"), e === Pe && v.$playbackNarrow.classList.add("disabled"), e === Ue && v.$playbackExpand.classList.add("disabled")
            };
            b.on(w.playbackTime, e => {
                if (b._opt.playbackConfig.controlType === _) v.$playbackCurrentTimeText && (v.$playbackCurrentTimeText.innerText = Rt(e, "{h}:{i}:{s}")), s(); else if (b._opt.playbackConfig.controlType === te) {
                    const s = E(e / b.playback.totalDuration, 0, 1);
                    v.$playbackProgressPlayed.style.width = 100 * s + "%", v.$playbackProgressIndicator.style.left = `calc(${100 * s}% - 7px)`, v.$playbackProgressTime.innerText = da(e) + " / " + da(b.playback.totalDuration)
                }
            }), b.on(w.playbackPrecision, (i, r) => {
                v.$playbackTimeScroll.classList.remove(Fe.oneHour, Fe.halfHour, Fe.fiveMin, Fe.tenMin), v.$playbackTimeScroll.classList.add(Fe[i]), v.rafId && (window.cancelAnimationFrame(v.rafId), v.rafId = null), v.changePercisitionInterval && (clearTimeout(v.changePercisitionInterval), v.changePercisitionInterval = null), v.$playbackTimeListOne.innerHTML = "", v.$playbackTimeListSecond.innerHTML = "", v.changePercisitionInterval = setTimeout(() => {
                    switch (v.$playbackTimeListOne.innerHTML = "", v.$playbackTimeListSecond.innerHTML = "", i) {
                        case Pe:
                            la(r, v);
                            break;
                        case Be:
                            t = v, oa(function (e) {
                                let s = 0 < arguments.length && void 0 !== e ? e : [], a = [];
                                var n = (s[0] || {}).startTimestamp;
                                for (let r = 0; r < 1440; r++) {
                                    let e = 60 * r, t = e % 1800 == 0, i = !1;
                                    n && (i = na(s, Yt(n, e))), a.push({
                                        title: qt(e),
                                        timestamp: e,
                                        dataType: "second",
                                        hasRecord: i,
                                        isStart: t
                                    });
                                    var o = 60 * r + 30;
                                    t = o % 1800 == 0, n && (i = na(s, Yt(n, o))), a.push({
                                        title: qt(o),
                                        timestamp: o,
                                        dataType: "second",
                                        hasRecord: i,
                                        isStart: t
                                    })
                                }
                                return a
                            }(r), function () {
                                let r = [];
                                for (let i = 0; i < 24; i++) {
                                    let e = i + ":00", t = i + ":30";
                                    i < 10 && (e = "0" + e, t = "0" + t), r.push({
                                        title: e,
                                        hour: i,
                                        min: 0,
                                        second: 0
                                    }), r.push({title: t, hour: i, min: 30, second: 0})
                                }
                                return r
                            }(), t);
                            break;
                        case"tenMin":
                            t = v, oa(function (e) {
                                let a = 0 < arguments.length && void 0 !== e ? e : [], n = [];
                                var o = (a[0] || {}).startTimestamp;
                                for (let s = 0; s < 144; s++) for (let r = 0; r < 60; r++) {
                                    let e = 10 * r + 600 * s, t = e % 600 == 0, i = !1;
                                    o && (i = na(a, Yt(o, e))), n.push({
                                        title: qt(e),
                                        timestamp: e,
                                        dataType: "second",
                                        isStart: t,
                                        hasRecord: i
                                    })
                                }
                                return n
                            }(r), function () {
                                let r = [];
                                for (let i = 0; i < 24; i++) {
                                    let t = i + ":00";
                                    i < 10 && (t = "0" + t), r.push({title: t, hour: i, min: 0, second: 0});
                                    for (let e = 1; e < 6; e++) {
                                        var s = e + "0";
                                        r.push({title: t.replace(":00", ":" + s), hour: i, min: 10 * e, second: 0})
                                    }
                                }
                                return r
                            }(), t);
                            break;
                        case Ue:
                            e = v, oa(function (e) {
                                let a = 0 < arguments.length && void 0 !== e ? e : [], n = [];
                                var o = (a[0] || {}).startTimestamp;
                                for (let s = 0; s < 288; s++) for (let r = 0; r < 60; r++) {
                                    let e = 5 * r + 300 * s, t = e % 300 == 0, i = !1;
                                    o && (i = na(a, Yt(o, e))), n.push({
                                        title: qt(e),
                                        timestamp: e,
                                        dataType: "second",
                                        isStart: t,
                                        hasRecord: i
                                    })
                                }
                                return n
                            }(r), function () {
                                let r = [];
                                for (let i = 0; i < 24; i++) {
                                    let t = i + ":00";
                                    i < 10 && (t = "0" + t), r.push({
                                        title: t,
                                        hour: i,
                                        min: 0,
                                        second: 0
                                    }), r.push({title: t.replace(":00", ":05"), hour: i, min: 5, second: 0});
                                    for (let e = 1; e < 6; e++) {
                                        var s = e + "0", a = e + "5";
                                        r.push({
                                            title: t.replace(":00", ":" + s),
                                            hour: i,
                                            min: 10 * e,
                                            second: 0
                                        }), r.push({
                                            title: t.replace(":00", ":" + a),
                                            hour: i,
                                            min: 10 * e + 5,
                                            second: 0
                                        })
                                    }
                                }
                                return r
                            }(), e)
                    }
                    var e, t;
                    s(), a(i), u()
                }, 16)
            }), b.on(w.resize, () => {
                c()
            }), b.on(w.playbackTimeScroll, () => {
                u()
            }), c()
        }
        if (b._opt.operateBtns.quality && 0 < b._opt.qualityConfig.length) {
            b.on(w.streamQualityChange, e => {
                s(e)
            });
            const s = i => {
                v.$qualityText.innerText = i, v.$qualityMenuItems.forEach(e => {
                    var t = e.dataset.quality;
                    e.classList.remove("jessibuca-quality-menu-item-active"), t === i && e.classList.add("jessibuca-quality-menu-item-active")
                })
            };
            {
                const p = b._opt.qualityConfig || [];
                let t = "";
                p.forEach(e => {
                    t += `
                    <div class="jessibuca-quality-menu-item" data-quality="${e}">${e}</div>
                `
                }), t && (v.$qualityMenuList.insertAdjacentHTML("beforeend", t), Object.defineProperty(v, "$qualityMenuItems", {value: b.$container.querySelectorAll(".jessibuca-quality-menu-item")}), setTimeout(() => {
                    var e = p[0];
                    b.streamQuality = e
                }, 0))
            }
            b.streamQuality && s(b.streamQuality)
        }
        if (b._opt.operateBtns.scale && 0 < b._opt.scaleConfig.length) {
            b.on(w.viewResizeChange, e => {
                s(e)
            });
            const s = i => {
                var e = b._opt.scaleConfig[i];
                v.$scaleText.innerText = e, v.$scaleMenuItems.forEach(e => {
                    var t = e.dataset.scale;
                    e.classList.remove("jessibuca-scale-menu-item-active"), Bt(t) === Bt(i) && e.classList.add("jessibuca-scale-menu-item-active")
                })
            };
            {
                const f = b._opt.scaleConfig || [];
                let i = "";
                f.forEach((e, t) => {
                    i += `
                    <div class="jessibuca-scale-menu-item" data-scale="${t}">${e}</div>
                `
                }), i && (v.$scaleMenuList.insertAdjacentHTML("beforeend", i), Object.defineProperty(v, "$scaleMenuItems", {value: b.$container.querySelectorAll(".jessibuca-scale-menu-item")}))
            }
            s(b.scaleType)
        }
        if (b.isPlayback() && b._opt.playbackConfig.showRateBtn && 0 < b._opt.playbackConfig.rateConfig.length) {
            b.on(w.playbackRateChange, e => {
                s(e)
            });
            const s = i => {
                var e = b._opt.playbackConfig.rateConfig.find(e => Bt(e.value) === Bt(i));
                e && (v.$speedText.innerText = e.label, v.$speedMenuItems.forEach(e => {
                    var t = e.dataset.speed;
                    e.classList.remove("jessibuca-speed-menu-item-active"), Bt(t) === Bt(i) && e.classList.add("jessibuca-speed-menu-item-active")
                }))
            };
            {
                const m = b._opt.playbackConfig.rateConfig;
                let i = "";
                m.forEach((e, t) => {
                    i += `
                    <div class="jessibuca-speed-menu-item" data-speed="${e.value}">${e.label}</div>
                `
                }), i && (v.$speedMenuList.insertAdjacentHTML("beforeend", i), Object.defineProperty(v, "$speedMenuItems", {value: b.$container.querySelectorAll(".jessibuca-speed-menu-item")}))
            }
            const a = b.playback ? b.playback.playbackRate : 1;
            s(a)
        }
        b.on(w.stats, function () {
            var e, t, i, r, s, a, n, o, l, d, h, c, u, p, f, m, g, y,
                A = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            b._opt.showPerformance ? (T(v.$performancePanel, "display", "block"), v.$performancePanel.innerHTML = "", y = window.performance && window.performance.memory ? window.performance.memory : null, e = b.video && b.video.videoInfo || {}, t = b.audio && b.audio.audioInfo || {}, i = b._times || {}, r = b.getRenderType(), s = b.getCanvasRenderType(), a = b.getDecodeType(), n = b.getDemuxType(), o = b.getStreamType(), l = b.getAudioEngineType(), c = b.getRecordingDuration(), u = b.getRecordingByteLength(), d = b.isAudioPlaybackRateSpeed(), h = b.videoIframeIntervalTs, c = $t(c), u = Mt(u), p = b.isPlayback() ? "录播" : "直播", f = A.isDropping, m = b.control ? b.control.kbpsShow : "0 KB/s", g = b.getVideoPlaybackQuality(), y = `
                <div class="jessibuca-performance-item">
                    <span>版本 "8-23-2023"</span>
                </div>
                ${b._opt.isMulti ? `
                    <div class="jessibuca-performance-item">
                        <span>UUid ${b._opt.debugUuid}</span>
                    </div>
                    ` : ""}
                ${b.isInMulti() ? `
                    <div class="jessibuca-performance-item">
                        <span>窗口下标 ${b._opt.multiIndex}</span>
                    </div>
                    ` : ""}
                ${y ? `
                    <div class="jessibuca-performance-item">
                        <span>内存大小限制 ${Mt(y.jsHeapSizeLimit)}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>可使用的内存 ${Mt(y.totalJSHeapSize)}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>已使用的内存 ${Mt(y.usedJSHeapSize)}</span>
                    </div>
                    ` : ""}
                ${y && y.usedJSHeapSize > y.totalJSHeapSize ? '\n                    <div class="jessibuca-performance-item">\n                        <span>可能内存泄漏 是}</span>\n                    </div>\n                    ' : ""}
                <div class="jessibuca-performance-item">
                    <span>播放模式 ${p}</span>
                </div>
                ${b.isPlayback() ? `
                        <div class="jessibuca-performance-item">
                            <span>播放倍率 ${b.playback.rate}倍</span>
                        </div>
                        <div class="jessibuca-performance-item">
                            <span>播放模式 ${b.playback.isUseFpsRender ? "固定FPS" : "动态FPS"}</span>
                        </div>
                        ${b.playback.isUseFpsRender ? `
                             <div class="jessibuca-performance-item">
                                <span>固定FPS ${b.video.getStreamFps()}</span>
                            </div>
                            ` : ""}
                    ` : ""}
                <div class="jessibuca-performance-item">
                    <span>解封装模式 ${q[n]}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>解码模式 ${a}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>渲染组件 ${r}</span>
                </div>
                ${r === Y ? `
                    <div class="jessibuca-performance-item">
                        <span>渲染引擎 ${s}</span>
                    </div>
                    ` : ""}
                 <div class="jessibuca-performance-item">
                    <span>网络请求组件 ${o}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>视频格式 ${e.encType || "-"}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>视频(宽x高) ${e.width || "-"}x${e.height || "-"}</span>
                </div>
                ${b.isPlayer() ? `
                    <div class="jessibuca-performance-item">
                        <span>视频GOP(ms) ${h || "-"}</span>
                    </div>
                 ` : ""}
                <div class="jessibuca-performance-item">
                    <span>音频格式 ${Se[t.encType] || "-"}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>音频引擎 ${l || "-"}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>音频通道 ${t.channels || "-"}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>音频采样率 ${t.sampleRate || "-"}</span>
                </div>
                ${b.isPlayer() ? `
                    <div class="jessibuca-performance-item">
                        <span>播放器初始化(ms) ${i.playTimestamp}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>开始请求地址(ms) ${i.streamTimestamp}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>请求响应(ms) ${i.streamResponseTimestamp}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>解封装(ms) ${i.demuxTimestamp}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>解码(ms) ${i.decodeTimestamp}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>页面开始渲染(ms) ${i.videoTimestamp}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>初始化到页面渲染(ms) ${i.allTimestamp}</span>
                    </div>
                    ${b.recording ? `
                        <div class="jessibuca-performance-item">
                            <span>视频录制时间 ${c}</span>
                        </div>
                        <div class="jessibuca-performance-item">
                            <span>视频录制大小 ${u}</span>
                        </div>
                    ` : ""}
                ` : ""}
                <div class="jessibuca-performance-item">
                    <span>音频码率(bit) ${A.abps}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>视频码率(bit) ${A.vbps}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>视频帧率(fps) ${A.fps}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>视频峰值帧率(fps) ${A.maxFps}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>解码帧率(fps) ${A.dfps}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>音频缓冲帧 ${A.audioBuffer}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>音频缓冲时长(ms) ${A.audioBufferDelayTs}</span>
                </div>
                ${b.isPlayer() ? `
                        <div class="jessibuca-performance-item">
                            <span>视频待解码帧 ${A.demuxBuffer}</span>
                        </div>
                    ` : `
                         <div class="jessibuca-performance-item">
                            <span>缓存时长(ms) ${A.playbackCacheDataDuration}</span>
                         </div>
                         <div class="jessibuca-performance-item">
                            <span>视频待渲染帧 ${A.playbackVideoBuffer}</span>
                        </div>
                        <div class="jessibuca-performance-item">
                            <span>视频待解码帧 ${A.demuxBuffer}</span>
                        </div>
                        <div class="jessibuca-performance-item">
                            <span>音频待解码帧 ${A.audioDemuxBuffer}</span>
                        </div>
                    `}
                <div class="jessibuca-performance-item">
                    <span>待解封装数据(byte) ${A.flvBuffer}</span>
                </div>
                ${b._opt.useMSE ? `
                    <div class="jessibuca-performance-item">
                        <span>MSE缓冲时长(ms) ${A.mseDelay}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>MSE解码间隔(ms) ${A.mseDecodeDiffTimes}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>MSE解码时间(ms) ${A.mseTs}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>MSE播放模式 ${1 < A.mseDecodePlaybackRate ? "加速" : "正常"}</span>
                    </div>
                    ` : ""}
                ${b._opt.useWCS ? `
                    <div class="jessibuca-performance-item">
                        <span>WCS解码间隔(ms) ${A.wcsDecodeDiffTimes}</span>
                    </div>
                    ` : ""}
                ${b.isOldHls() ? `<div class="jessibuca-performance-item">
                        <span>HLS缓冲时长(ms) ${A.hlsDelay}</span>
                     </div>
                     <div class="jessibuca-performance-item">
                        <span>HLS播放模式 ${1 < A.hlsDecodePlaybackRate ? "加速" : "正常"}</span>
                     </div>
                     ` : ""}
                ${b.isUseHls265() ? `<div class="jessibuca-performance-item">
                        <span>HLS缓冲时长(ms) ${A.hlsDelay}</span>
                     </div>
                     <div class="jessibuca-performance-item">
                        <span>HLS待解码帧 ${A.hlsDemuxLength}</span>
                     </div>
                     <div class="jessibuca-performance-item">
                        <span>HLS待解码视频帧 ${A.hlsDemuxVideoLength}</span>
                     </div>
                     <div class="jessibuca-performance-item">
                        <span>HLS待解码音频帧 ${A.hlsDemuxAudioLength}</span>
                     </div>
                     ` : ""}
                ${b.isPlayer() && g ? `
                    <div class="jessibuca-performance-item">
                        <span>已渲染帧 ${g.renderedVideoFrames}</span>
                    </div>
                     <div class="jessibuca-performance-item">
                        <span>已丢弃帧 ${g.droppedVideoFrames}</span>
                     </div>
                ` : ""}
                ${b.isPlayer() ? `
                    <div class="jessibuca-performance-item">
                        <span>网络延迟(ms) ${A.netBuf}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>缓冲时长(ms) ${A.buf}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>最新缓冲时长(ms) ${A.pushLatestDelay}</span>
                    </div>
                ` : ""}
                ${b._opt.useMSE ? `
                    <div class="jessibuca-performance-item">
                        <span>video显示时间(s) ${A.videoCurrentTime}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>video间隔时间(s) ${A.videoCurrentTimeDiff}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>videoBuffer缓存时间(ms) ${A.mseVideoBufferDelayTime}</span>
                    </div>
                ` : ""}
                <div class="jessibuca-performance-item">
                    <span>视频显示时间(ms) ${A.ts}</span>
                </div>
                ${b._opt.hasAudio && b.isAudioNotMute() ? `
                        <div class="jessibuca-performance-item">
                            <span>音频显示时间(ms) ${A.audioTs}</span>
                        </div>
                        ${b._opt.hasVideo ? `
                            <div class="jessibuca-performance-item">
                                <span>音视频同步时间戳(ms) ${A.ts - A.audioTs}</span>
                            </div>
                            ` : ""}
                        <div class="jessibuca-performance-item">
                            <span>音频播放模式 ${d ? "加速" : "正常"}</span>
                        </div>
                        ` : ""}
                <div class="jessibuca-performance-item">
                    <span>视频解码时间(ms) ${A.dts}</span>
                </div>
                ${b.isPlayer() ? `
                    <div class="jessibuca-performance-item">
                        <span>解码前-解码后延迟(ms) ${A.delayTs}</span>
                    </div>
                    <div class="jessibuca-performance-item">
                        <span>总延迟(网络+解码)(ms) ${A.totalDelayTs}</span>
                    </div>
                ` : ""}
                ${b.isPlayer() && A.isStreamTsMoreThanLocal ? '<div class="jessibuca-performance-item">\n                        <span>是否超过一倍率推流 是</span>\n                    </div>\n                   ' : ""}
                ${b.isPlayer() ? `
                    <div class="jessibuca-performance-item">
                        <span>是否在丢帧 ${f}</span>
                    </div>
                    ` : ""}
                <div class="jessibuca-performance-item">
                    <span>网速 ${m}</span>
                </div>
                <div class="jessibuca-performance-item">
                    <span>播放时长(s) ${$t(A.pTs)}</span>
                </div>
                <div class="jessibuca-performance-item-block"></div>
            `, v.$performancePanel.insertAdjacentHTML("beforeend", y)) : (v.$performancePanel.innerHTML = "", T(v.$performancePanel, "display", "none"))
        }), b.on(w.togglePerformancePanel, e => {
            T(v.$performance, "display", e ? "none" : "flex"), T(v.$performanceActive, "display", e ? "flex" : "none")
        }), b.on(w.faceDetectActive, e => {
            T(v.$faceDetect, "display", e ? "none" : "flex"), T(v.$faceDetectActive, "display", e ? "flex" : "none")
        })
    };

    function ma(e, t) {
        var i, r, t = (t = void 0 === t ? {} : t).insertAt;
        e && "undefined" != typeof document && (i = document.head || document.getElementsByTagName("head")[0], (r = document.createElement("style")).type = "text/css", "top" === t && i.firstChild ? i.insertBefore(r, i.firstChild) : i.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e)))
    }

    ma('@-webkit-keyframes rotation{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@keyframes rotation{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@-webkit-keyframes magentaPulse{0%{background-color:#630030;-webkit-box-shadow:0 0 9px #333}50%{background-color:#a9014b;-webkit-box-shadow:0 0 18px #a9014b}to{background-color:#630030;-webkit-box-shadow:0 0 9px #333}}@keyframes magentaPulse{0%{background-color:#630030;-webkit-box-shadow:0 0 9px #333}50%{background-color:#a9014b;-webkit-box-shadow:0 0 18px #a9014b}to{background-color:#630030;-webkit-box-shadow:0 0 9px #333}}.jessibuca-container .jessibuca-icon{cursor:pointer;width:16px;height:16px;display:inline-block}.jessibuca-container .jessibuca-ptz-controls{position:absolute;width:156px;height:156px;visibility:hidden;opacity:0;border-radius:78px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATgAAAE4BAMAAAA9UfJZAAAAMFBMVEUAAABHcEy0tLRZWVmysrKoqKi1tbWvr6+2traBgYG1tbWWlpa1tbW1tbVUVFS1tbVGCHqkAAAAD3RSTlMzAO9U3LSWySp3aZcVRDUDw823AAAJYUlEQVR42u3d32sbVxYH8EPHxgg/lBsa7SBkukmpSbwLI2KbEPpgZ5MQtwmM0wRMmgdhP6RgEuwlSVnYlmGMYaEvMU1KKX4QNq0pocVmm7CYfRBaQguFpbgPKRSC/4V2LGliO+bulWKrkvVrftyZ+WbxeTRG+nDnnnNmRjP3EpMR6tMH18du/0Xj1tGz5+9cf/DUlPKx5PsTkr8s3eZ1cX7ym1zkuI/f1wTFunNt9fP+FIno7/98/tFY+Y8ffBUlLrmkl2Cr96guTv27BMxP5iLCqUvi68+tpqhJKPNXBH3SjACnfimm/7Wmsl3fI/FP75lh457oPH+1Da3M+1T8481QcT0T7UetevR618LDPdH4hTlyHLGH3LoZEk6d4PlvyVW8pfNeMwzcDwa/kCKXoTzk9tfB455o1mXyEIOa+0PrFvcFt+fIU8QM/k6guOQifzNFHkN5l/flgsOJVHibfMR9l2nhBqem+VXyFZ/xghkMTp3il8lnDPKiGQROhs2lzjEuKcVW1uWk4ybk2Eq63pxk3CK/RZLiJO+Ti/vZXw3ZX1E+kon7jv+JJMY/+Q15uIRWIKmRthZk4VTDTsnFKYZtSsItWiskObq1Pjm4f8gqIrUF5W8ycAl+nAKIT/iCf1zSKFAgkW4/7drifrLmgsHF2k87alvhblFAcbJttWuDU/VtCiyyedMXbjGfCg6n6H1+cHE+TQFGFx/3jksa2xRoZO2cZ9xsUJn6e8aOeMX1aGco4Biw1jzilm0KPNJb3nBxvhI8rrtVTlCLK5ptCiEyBS+474POhr2c+NA9Lqm/QaHEiXzONW42yN5Q2ydG3OLU4MvI7+XEdImbCWvgSkN3zB1O1YYptOhoNnRNcDM2hRjGMTc4VZsOE9fVZOioyYyjUKPJrKPGNW44XFxX41rXEPc4vFTdS9iLTnFJ4wyFHAO2U1zcSoWNU7RLDnFTb1DocaLoDJfgc+HjYo3uTjTArW9TBJHdcYJTtdEocJ0NCnE97nGBIon0RQc4YzgaXIfdHhdBHdmrJuNtceubFFFkdtrhVG0lKlx3XUrsxz22KbIwLrbBTQ1Hhxsotsb18FR0OIWvtcT9Z5sijOyfW+KM6ShxXXYrXMJKRYlTtIUWuLubFGlknrXAGaPR4jrt5riERRFH7XGtwc1sRo3LHGuKi/qo7j+uhJOr9flKMBW4QR2uxk1NR4/rKjbGRdpXG/bXKtxrAEdVHNfTDXHLf0TAvbLVCJfU5hBwMSvXABfPE0To4w1wP25i4DLPG+CmRjFwncV6nIpQSF4UE7MOd7hAIJG+VIe7u4GCG3pWh0uPouA6C/txMFOuetIR3JSrmnQEN+WqJh2BVbmaSreLS+JMudKky9Xg4jYBRXq8BndoEwmXOVKDWx5GwnVs1eD0OSRcLF+N67EIKrS1Klx8GwuXHa/C/biBhRt6XoVbnsbCdW1V4bDyoZIRZZwKlg8iI8wKLl5Aw73oEWXcoQ003NCRCm59GA3XsVPBTa2g4bqLFZyWQsMp1h6uJ09woa/t4tCaV6WBEWSy7qYrQSbrbroS2MVNzUUOAXbWSnel0sU+AUbpsl/gEjYizlgo4w5vI+Kyl8o4xEryopYI3N1hRFzHszJueRQR17lVxqXnEHGxQhmHd06yd15CgBcQlcsIYokCJi69IHDxbUycOGki9toGJm7otMC9/ism7tXfBA6zBperMIHW4HIVJsDrwsrVIYE2CNEibIHDbBDlFkFJ0AYhWkSOemxUnLFGqN2r1L8ItXuV+hfFN1FxmXH6wwYqbuivdAgXd4RQ+36p8xNq3y91flqfRsV17dD6KCquc4eWcXFbtLyCiusu0hQ0bg4VFytSGhdXICOFilNs0nFx+QOcZ5xGsGEd4DzjOC6OH+A847QD3P9jtuJ2CGjcQeP3gYM+2YQ+TYe+wMG+NETGQd+OgL6RA30LDPrm4eu/ouJe/Q37hjX0rX7oH0mgf16C/mEO+idN6B+DoX9Gx34AAfrRDeiHXqAfF0Lt/OUHrVAfUcucRn+4D/qxSOgHSqEfxcV+iBn68W/EV3AqD85Dv3IA/bIG9GsumC8IaSb+q1XYL6VBv84H/SIk9Cuk0C/fQr+2jP3CN/Sr8tCLDEAvzwC9sAX0kiDYi6lAL0MDvYAP9NJH0ItGYS+3Bb1QGVaP2LfEG/TieNDLCmIvyAi9lCX0IqDQy6diLzwLvWQv9GLH0MtER76rRqWxPgdemtwYf9kWdYdeDh97IwHoLRigN6/A3vYDesMU6K1msDfpgd7eiOmjSEf1ZdpSC3ozMuht3LA3wIPeOjDSTRdfKb7M21VCb/QJvUUq9uay0NvyYm9oHFFKdDvaChp6E23s7cehN25nh5G3vE8aZ8LGDdjMIY49zoc9dPpFx7ikHnIh7sjnHOPYTMj36oxjzDlO1UI9Xe9oUICb49iMDTBwzXCqFuKsG2gycM1wYtaFlrCK3mTgmuJU7UzkA9cUx2bDGjpFH2FucUk9pA57onGNa4lj31uhnJzEtA+ZexxLh3KpkykwL7g4D+GUuJuPe8Kx5RCuJtJbzBuuJ/hyMmCtecSx2aBzIqaNMK+4pBHwtU7WznnGiZwI9Oykq1U2tMWxxSD7hKL3MT84VQ/wwGbzpi8c+47fCsp2kt9g/nDsp6AyNqb1Mb+4pBFQKU7bpm8cS/DjQdg+aXT/wTWOzfLL8m2DfITJwLFFS/oZQHf7CecQpxq25GqnGO0nnEMcS2iSq13WWmCycKLaHZebDDeYPBz7mb8tz3aff8Rk4tiivJQd5H1MLo5NyNIN8t6cbJw6ZV2WYys6tTnHCZ2MsRM2k8nHSdG5srnBMTXNr/qzfcYLLmyucEyd8FdR7vNeNzZ3OJZc5G967mTKu7wvx4LDMfYFtz2efMYM/o7LL3OLY080byVlULNusqBx7AeDX3B9aJWH3P6aBY8rpUX+W3e2t3SXqeAZVzq0/JyLmRe7wt0fUs849t8Jzv/u8Ngq/+K8d42FhxODp/P8VQc85VPxjzc9folXHFO/1Lh1rc3BjT0S//SeycLGCd6Sxvm51abDp8xf4dyaNL1/gw+caBhLuvj6O6v36mWn5scEPe+H5hMn4uP3hUEAr63e6y+PYX//qflHY+U/fvCVzw/3ixPD98vSbV4X5ye/yfn+aP+4MvDpg+tjZ4+K8bKOnr1z/cFTU8rH/g92biFxn2S73AAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%;transition:visibility .3s,opacity .3s;right:43px;bottom:135px}.jessibuca-container .jessibuca-ptz-controls.jessibuca-ptz-controls-show{visibility:visible;opacity:1}.jessibuca-container .jessibuca-ptz-bg-active{visibility:hidden;opacity:0;width:156px;height:156px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATgAAAE4CAMAAAD4oR9YAAAAM1BMVEX///////////////////////////9HcEz///////////////////////////////////85yRS0AAAAEXRSTlO5DCgVgZBxAK2fQDRkBR5XTPLKM/gAABnnSURBVHja7F0Jkqs6DGQPO9z/tD8Jq6WWbCCvIjKfzAGmulrW3ooedr6ui+M4TdP++SXPr1l/SdL3aRrHhv7ZyA5qb9xe0L3Am+DrkzeCL/BeX908MezTuPsfOArdgl3KsZuhq99fk/Tx3waum+ByAHua5QbYilkzY1aP728YhrH5InrfBa57OLAtVjpRbYaumex04dq4APeC7vnVSfo/45bXLe33jGscMx3f0A1vyg3t69e2dRL/NeA6wrgdcCvjyPM2U25mXDt9xVD3f/qN0yi3Mm6P20S54vlXtGPS/R3GPSbYOsC4ZAvmJtiaGiL3Zlzx/Ht+Y/KXTJXbqmaqe9za1VYn3N7YpX/OVGev2qduOLIiB7xqOzGuWCiXFVmWtU3368A5lkqeOJI21I5XXaORxVRnxmUTdNnY/4U3riNvHMJts9XRtdXVUttipdzrK/4x7UyY6sK4Gbo+nU21T1zKcd9AGJetlMvyLKvj3zXVfeqQElMljINx3MK4xVQ3xj2Ry7N/6CiMOIfYyVUXWxUyBx7HuZRbcHt9bf/Lb9zsHlzKzabauJaK47iVcC7jJujS33/joKkmxDnM4QiJ4xDjZuT+DXQW3jgxV012qcPuiePhCGfchlv1/P0D6Czmqmuq2gPGkbIS8Q4ZsNU3dGP3Y2+cW1RyKpkrbAnwqhi3iXHFHrU3bFVV5c3vBsCsOALjkXErAW85F3rjFvBm5Kos+TngCOXYG7fA1ojFER7GPUHbmer0tfGPANeROM6pjvDMQSkrsWQ1d564Fbr61964TvSqDa6O0ELmAtvGuc2rrpQrn/aa/qCpYq+6mSpOVhnjWBy38u2JXFl9yL8acg6CV3Ur5yxVZfW4AsRxG+XKssz6n3njVMYR4Eg8sj1yi3tgtroxrpyhG38gc+h8PYddPQ551dVQW5jju2/cG7kXdB946Uy9cbDnQOpxuCCHcq5dHDcht8D2/K67VxPNGtLJd7qDTcgb1zLGbXEcY9z0Fd39GReTzIH1B/2lcxrGTYxjXnXyqxNyef8zpipVlfDsyCCmDkuumhGvWq6W+vyisqxvDJwwOxJQO6fNmjaQcRt0ZdR2dwWOFZViuculNWtgBZjk+DNq1cq45y+Lf5NxE25B3oEyLueFJWqtT+Ciqr8r48jsCAyAG+2Na53MAdQxX16VhHEL4Z7Ilc2dGad28pskaULiEdDlyijjdqa6gBeNtwSu63AnP3V6NUnAG9cu1RHOuL2hVi5qr6+9Za4qV0dCGcfCEfDIufWRFbsZvKy7KeNgW7XHvRqxWfOGLhO6XCrjoiiPb/rGdZ75uGRfj9u3B1sWAEtdLuxVF/Cq9HaMe4A4TptkZYwLqI44rmGDbUe5E8hZcg54zquRbHXu5NN6HKuO7N84YqwbdGV/Q8YF5arUN7CJTNLkgplD5T5xG+OOI2ehAhxv00ocOlpWwhHwljns5uNg6bxCb9wbueSupip6VTnj2jGudSvnOeqrVo6h7vl2nHM2K8AkV1WyfDYDvHUcWF+1VBl3EDlLKdc2dQ6aNbhXw2eAt14Nf+MqFse5rDuS8tucHUmhqaJppYF6B8440h7E8cjhqMTiLtcaAL+ga9jWZb35hpbHceyNI9WRSmHcE7n4jqbqTp2D2nnzgm154mB1hJQy1cwBIpd3twCOrjnEoDsoTZ2jepybb2VKrhpx3zB92Z29Khpl1ZN8MHWzJV1CdYQHJEeqTMbqcfEMW+obLBwES83w7AgvY0YlMNT3N96GcXEHGQdxG2t3CQ5kDkoFeO8esHd4fc193jinAtxvXhUN3Ywz5VAFGM3cENfgVM4x5YICYRumqu5yIVMdJuhaLXMAFWBKOIhbWFBiO44Dg4Usxx/cCrDyxqESMIYuu4lX1fYcGnVaaVmtKXZxHOzW5Bvfqtk3iLAFuVaLew4HluDUzIH1VYMZF+AgLMZxcAYY1uNYBTgrwPDIaqxOQ1p540IchBFTJW9c2ofNAO99Q+sYaugbJ35Vd4sKsPbGqVM33KsWmdpXLeXqufsVNwhH8FyhOh8n74foKb5WVDr0zFky1Rgt+iaJZyJTWErKMynpqsqgVy4q0xv0VTvZq0pJPq5jzn41zzzVET0aCYjmTO05OLaaBEwWqhvSenUkKtVw5P0N96mOpNr2YCPuh4AJCGEAoioDver7628Sx8WAcU2i1eM259AWhZBzuQEJieN07JR6sCHgXoSLnepI7yo9NqgCLE5A6K4hjHGKsVqK49JYEGyBg4XIq2b7FREUx5Xu2LkXOtmz2pJBW5sOqdjJF3sOjHG5fz7OT7n8DtURwjjPtBKtx7VLOa6Q4zh5Wkn8xhvU4xbG9al/s2bAbxwYkJO7XCGME43VIuMc56Dnqi7hpPE4cVopBLnibozTp5X4DHAQ49iwfsCX3IhxYFoJB8C0y7Xr1iwBSZXDulIUjF11G6+qr5aPALlCmTrfyWfQzCEK49xoPMnnjFMaq3QlX9tzQPuq0QFbLeNbMU6cHRn3Sb60HwJ6NXAhKQi61nzpPAbtQaY8jUUgQnRHSodxZSjjoig161W7HePIRGZDJzJHQXiEzE4DpRtSjotCHzkUkhj2qqJi4V54T1S6cWwVp/nhjAP1JQuDhbs4TtFW0spKTgW4UHJVFv4GQpcZA64jkt1xDNS8lDEv9Y3z5KpRGY4biIINMC7e2lxKNFJDqUfQquGZA2yrHoINUM7G6ZX1iVM2RKDUI08dssVUfduDRyI5QDkbFWCnscrWVWV1/RZ2uaRc9UyKL1LO0r7q1qwBm761WsmEUjdge9ApAB9iHHWslq4kMalHTbHQieO0zXKljHmIc4XdOE695yCpsg7eOE7t5B/4Uqv1uDSGKhDYq0r6yQWYj5NnRw5BNxjOHJAKRJB+nJqr4jcuOki4qOzs5qrgulSDJzJHUcyrCNMdOc44ty5nel815KDZ4HTypeoILAEfZJxbCjYkSpVKgZx/IpOfXgnarDkKXWIrHAm7kiTqxw1er+oQzg2Bj32FTcYJ2kpCIx9PK2XMq1ZCz+EM46LYZK4qaCsdmo+TqiOV5FWPITdYLZ2jOqYa/6LN8kJSZT1dxkSTJEYKmZ2/OuI5aIYYh+UzKn3TN9A9mLjL1cl6LexKkqof575xVJWVx3HRefdgUbGQNGs2U2Ul4HYQ60o+HeBzjCtt9VXVqXMpc3DEzh2NzEJSnr7OuG35wUTpPGjqXN3lQgdE0AWRA2sOHls1eO2yh/uqWM1LbUgvQzeatOhR5NZM39QIBNyQbviBVajYItbOYa56knCbrRrUj0vxTn5QVQlOnUtdrjKKztuqpbMEJ27WtCG3BzX9uMPfYqsmlW7SPnRfFeSqwTrAp9641VZtXi1PlX1VN44THzlvPe4k45aZLys9h+7cvuqsAqEpBAm6I9HJN24pZ9oIRzp5XzVUsVCZOnd0Ry4zbu52GdMBDn7j+NVyYXaEneW6+sbNrQcjtwdJCTh4WmlrSLcF3axRZ4AvMC6zxjj9annty1X9M8BoefBMQGKudB5UjnMnMltQV1JuD5JK5jnGTUU52zeke+4cfMJ7ygxwSZuDJ6EbzDEuZF+VNLnczCETlPdkdf3Tj5yhAHhNVdV9VXgJGV9JyqWjjRdS1fWRs6vmRctK1KuiLD/b22q2KyvlWJT1HOPeo3IWqyNwlwtrxJNrlwW69ZNr0qKnoBsfNrWVcH+w9gzIFXxDeisr5cxSrzCusFVWkpVukH7coF/0zQRt0a2QGZ1HLrfAuIfDOL/uiLOTz9UMMiTmtXMOVXmxW/P+OqM6wPBKEmLcbuiGMw4lq9cmIPbewa5iIb3LdYxxKHMouYDcSeRqcxd9+dS5VFWCGZd3e9DtR5+21dbYRd/1EAaagUC6IzDLV7YHj4pSKbmDkZRLnmRNcHeQ3azZdvLJ9qCUOVyhXGVmQUSpx9GWAzNW6Y0DmYMzrbTeHjzxxTeI41zktugXtQezAsRxon7caUt9VZZMMQ7pAPMnjnTyB5lxJHPgU+enGTeajONUHWB46wfW41jmAE79nHerNiYyFeXpBu/keycyM8983CWv+sxWLe2rsgpwH7qRxPuqb7pl6IKe61RPYpcbvefQy3e58LSSbwY4B071CuNKk31VtswlTyuJ+6oZuss1h3HVCTEDluZb7Ks6prqrjijlOLTLxRlXUhng85RLo+77por7qp5c1fUN8I1Tbw9eqce9ArkvA6eqxOOr5UQGgrdVC1l5GszHnYSuNsC4OKgeF6au73S5Mt983IU3bvwqcN3jAe9y9VgkvvHPskp7DuI9h7PfYOGNw3EcH7rx91XRPbNPT2TOEbCNNw7uJOGhG+naD8+5PG/cJcI9gYu/CxuYVuqd+6reHbgBWqrvavlV5LLvAqfdc6AFYElcyW1IS0eScqg7ch65/MvABXW5ElWvZXDiOL2Tz3VHzn7Vt4F7iNuDobMjwp7DUh3hfKs+EQCbAs43O9KgG9KDrK6vMe5qIPdd4NS7XFLi4NxzADf0eEPa8aqX1lV35REjb5zac1geuYVwtfjGbTmXsJH0qf7g14Hz9xzE9iD0qigewTv5F71qaeKNwz0HXI+jb5zLODABQWaAP+MbXA2SbxdH9KlzMjw9jvAUMr72o6363hQ4VyQ+lU+vkH70ALVFM2cnP8f1uOojhLPgVZnWI7y9Enjtcr+TT/qDJdj0LW9tqlgFQtUdYQfNQupxnHE3dw5aripmDgOcOt90gHOpOvKRF85EOCJKPSrVEa/y9D9QLDQEXKco3UiqVPtdrjZIIxNuSEeX+qomc9U+3S/WUIUgvD2o7nJ9UnfECnAPWQUiSOu8HYKERz6oO2IDuE7THcHOATIO9xzQhnT1IcblVhjnagRp8QjZVw1gHOFb9ZnSuY1OvutVe3/86w4Be7XOc6GvetsuF47jAq5dElFWn9a5oJF5YUDOBHCdds9BzRw2xrWy1jl946qrC6tfb0i7uWoKZ0eaoJs1e8LR+6pQPy66GMiNhqaV4ljbc/DqjrTC1fL8n/RVa0ummiI1r0a/yyUPT2dcXBR08s9Cl9gVpdKvEvgO00LB7qta585g4eP7jIuDxEXdaSV87TID91WdiUx67uf011lkHBTea/R6HN1XhTdr0AmROw9Pd1h5euurJvxKEh2e9uyrfnYn38q4vnp7cLchXXuVbtxdLoFx1UVtpWnv0uLNGudquTCROXj2HHI6riRK791zJakjIxDKRGatMI5fu8z81y4vzU5bE2yJmYLyFsc1jaythPcc+CW4j2grGVi71GTQgnLV1tFrQduDUj3uWvwb27p2Sefjel/PAXXy+QywoFh4IZKrTF67lC6I1H6NTHEGOBeWB88LoVm6dimoGaxO1a+RiafOpX3V8r7yGayOuZfPgGsOQhy3V4Fgew7wSlJ5hXG1aY1Msj2IK8B0BAK8cYIIxBXG9bZuD6ZUlCqk5zC0x/Yczh9YtSVK9ZA3pAN6Dqq6vnAo9ANx3Ndl0LazXPK0kq/n4J06F+45XMkc7Ajv0Sy/VzZrpAsiLUnyhZ38fQX4vOqIOXX9o9cutRlgfZfrSuZgTVxU9KrKPQdQOgd3CZB7OO9VzcnZ4pYDHddnkoVSrprlAXe5ynN5gxF1/Vi7ocenp7XdcueJyxSt8wtjhRYku2EcB3Hb1LxqHMb9192VJTmuw7DxSsfxdv/Tvn7TSceiAEpylqYnH/lWsWBRXABMVLHQ8B4cjvWUfN1xTYU6wJEqqy7y1ynBEIGt8ycqBxe2BGh3JEt3hO3HtXjm0KFJ/kHIOTDCmEUM2RFMH9ygn8N+WoNmDpcLZEgfFuz2pQPMKof7eHBME0RsxAVX3OFS1Y/Zj77jtGQ34nLRWjVeHtFF/pOIc2EvRdf1m/2UKy11s+8qtXzmAKQMhiNNTDefqiWtFIlkQqEbNJFuO7g6oqr84p8PC710IxN0R0bK5VIFV2svTx9CnCPTxspm1iiGiBKeptmh26tAYOXpp+y3HSGuqUwnONzIZN7bRAdYp4bDZpee5qq5OsAKcdTQISjykUjmM/aq3lRZK3rH6a5SOMmPZw5BQ47yQ05rvm3NVVXhkLCs0YqF2EN60A4iw8Ev1dtcNXvmsGK+qukh/QIRtEHE06cK1fXtKRfLqoTLRadcw8Ev1ZkTXBXzVdkdt5k1PvtQo/24I604520lvq0EFAvxXLXlytPHpjUXcRU4tTuiJvkx4EbugxHojrRJTn4p5jY3gcspucLQKW0lVnNhFQhF5ir+VhsvgZsN/Tji9cOcVybD6wcOuQ5MuXpxirhyt0tTea9NTPKLEVf7CdzMaZdZbpd0Pw6LZ1wiN7PhWGpwk1Uz/BzQDsSEnOB6vXT+cLscntoB3sQZ4qiaV/qOixjSJYgrBNwwu0OcSYKzzbe1ExwYrF6InFdpVp3EG+IIJSlsnWv9uEQ/DrMH497IcOgt4hNxC9vXv2b5ElhU32fuuF78IQ4r3XyreV3NST5V86K16uG6YRF3iIt1gJscxRbgE9oG88E2oa5fdMu14h9x5pZX2I9DuaGn+nGXmOdw6PHrvh+X9OWagGdNbzCkI5uk7NhpwHliSDf2sIY4wQHl6ZysWvoaqcUz4hLyGUrsfF85QIZIvASsh1zZsYsA54qTDyuHSAViM7wH+x6NarDWeRHiFpHT3HE1g5zldsk6wEDOdiiwJejFJeKYvaqtWEhFqShfFSkWHikaPHZH0qJUxEOvnK9a4CE9ibvACVQsbMLKwWTWGP6qMeKOAW6o3AWOXHHZ/TiD55BGXHZW3UScfqqPVdbGMjSLa1VVcRG+KmRI53fOOxGnn2piedpgSK9GB5h0MssBVzsM3AwdfXPuuFh3ZGLaonBUk3/J9eIfcXDmcC1RLEwotgTvuDzIDY3LwM1z0kMam/1gjcyWjQePq7VscjrE2YuFxNHMLFWB1vlwKDO4rlX1tj7ROidZNc1XzZJPZh/q73O5BPBVo90R5PaTyKqYPVhcdK3iGXHxJB8RRLT14KZYl1FW7RJa5zkf6uw2cJJ8x5kbmcDsx+yO6NglQreInO+Oy9oBNry348qh2M5hFTkH4sysihA3WXNVvAIciQSVtH2d745kdZUYQ9pa1o8QNxzLqO4m+eFcNRk6BLmWiHZ3gK+a+FZH8Y444q9qbuuTmcMLlad7Ee+Iq9gOcNJ7cFqZDjCXOs98AV9m8Y84OFitI7fLK0VcwHPoqZ+Dks+wPtRhEf+IS4kZ1ElqOZrW3CBH+ar2O24U34GT8rmqntWsif24jjFrrCtuEjkD4qC2kpqrjrQ9cpDLZXlIt+I+cEl/VernsB7Zj9PTQZIYKjkX4iCz5go7mYpZY2qdI77qH+M9MtRyGsQZXC5rrzBWnt77OQCNzKB2YIi7ipwDcZXJ5YJS54p32UM/h84WAmZZdZMTBE435LLt3sm2foajbyqtTnKCwCkVCFMlHnKSpkhev4UdYHDHke5IK2cIXKACYbuWm7UqVp7uzDsOI66bzxE4ogKBZg5ZtWqCIR2+4wDiLtl2s84m+VW8ra+YNXZ3BHaA4VwVvn8vjcipEJezr8/UDOgOMDeYYv24ZGXvtzuS0Y9jO8AT3QHmnPzhz9G4OZs5QKIvFgJW40FYqraAWRP4OQSRK4qbM55Dxpeqd4B/uiNTmj1oVg5ZhZbvKZdi1mBHMyIuanPydXdk97GW4U28GZqFSjdL8h2nkgN+x7E7bo+40rj50AHOkTq3NYIQ4tpolRXKi36/Q0rj5m2uWkV81ZS6/hRvK/XRyIHRHIby95v/d1y9WEk1lmW1uVx4XekWua4SOSHiKuZnZu3HYXV9yh6EPIc74NojBuQe9uMqUz+ujp4jI+2dt6w7Qp3ghuw+krNaNctBrwYqaNB7MHgAdyk/h5K+pdfx4GzusoafKujHRR3gDu/HhfpxfxF3lTMGbrZtCdB+XIi4KDegmQPagbh1zsufIY4QV2ltJcVXDTn5EeKKuFyqcmgrOWng9g05pZG5RFvnd8SNtDuiPKRbw9H3/ztumkVOjrg5ra2kEIe7IxBx4e7IA3DjMwf3eMfhh9xovH/73dZ5n9cBHrpFzhs4hbhgB5iqeaH5IGDWtCazZuhnOXHg5jmdVX9mDte0u9TjAQz9HB6Iu4zPHt2v7kgNe+cb3FbqeVa9qBfw39C1jZw9cMBDmr7jwqHDylzL+5Sfw2V9wcn9Iy5qZFoTaZRV9b7+k1nB55Sr2gEOaysFiFO+tCSrhqsj2yzyjyAu3lYCHnojyap85gAdfV9wu3l+x2V0R36INSvWAUbvuMvzydRprWogTmfVO+AI4uB+XF/JvxK4UHekMZRucHdkQhsQvdqPuwGurV95cl+LhUR3hPfjTN5lkFa78bUH97StdEdcOJC277h0bvgO24ty6RkQV5OtG5Pn0GIy19S8/OCeKofojlu47gjVT+4/EjZvdu9grnq1uVxAB1il1beEzRtBJJQICv1VMeKU93a0OzItbzq5k90RgLhl+XGCqy3ERdYrO0fftXnb2T3VqjfE5aigMbf3YANirN54co93XMjJT20rhWteP5Hrr/NbT+7xjoPMctOzJkqq6/Luk3u84+7vuGUBSzeBweoE3yPTm8Hm444LiA5gyMXuuJU56G3NR07uAXHVwwo5fgBTf1Xo2rjVnzq7r6yK1LwSr5HHHTdt9fy5k5/R7XLcJdX7FbeOy2dP7trPweQ57FRZx7r6+Mndq3ldEzrAY938ysl9uiQ1cJNVa2SO16X6tZP/dj8uDqJW2VfM/O/ftf7FmPkK3OMZ3MAu8G3T6ytiTTU7OK8jxMlfuN1idg/X91/9VUZ81WOVo8P+Bw+0DogP6NDPAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-up{transform:rotate(-90deg)}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-left{transform:rotate(180deg)}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-down{transform:rotate(90deg)}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-left-up{transform:rotate(-135deg)}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-right-up{transform:rotate(-45deg)}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-left-down{transform:rotate(135deg)}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-right-down{transform:rotate(45deg)}.jessibuca-container .jessibuca-ptz-bg-active.jessibuca-ptz-bg-active-show{visibility:visible;opacity:1}.jessibuca-container .jessibuca-ptz-control{position:absolute;left:53px;top:53px;width:50px;height:50px;background:#fff;border-radius:50%;transition:left .3s,top .3s}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-left{left:33px}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-up{top:33px}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-right{left:73px}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-down{top:73px}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-left-up{top:39px;left:39px}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-left-down{left:39px;top:67px}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-right-up{top:39px;left:67px}.jessibuca-container .jessibuca-ptz-control.jessibuca-ptz-control-right-down{top:67px;left:67px}.jessibuca-container .jessibuca-ptz-icon{position:relative}.jessibuca-container .jessibuca-ptz-icon:hover .icon-title-tips{visibility:visible;opacity:1}.jessibuca-container .jessibuca-ptz-btns{display:block;position:absolute;left:0;top:156px;width:156px;box-sizing:border-box;padding:0 30px}.jessibuca-container .jessibuca-ptz-btns .jessibuca-ptz-btn{display:flex;justify-content:space-between}.jessibuca-container .jessibuca-ptz-expand .jessibuca-ptz-expand-icon{display:inline-block;width:28px;height:28px;cursor:pointer;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAANlBMVEVfX19fX19fX19fX19fX19fX19fX19HcExfX19fX19fX1/////Pz8+oqKjCwsKhoaHn5+eWlpaOqTaDAAAAC3RSTlP/3CaKxwJiAELtp4ri/s4AAACuSURBVCjPfZPREoUgCERXBdPRyv7/Z6/Z1aQp9oWJMyYLiKUrOIpAJBdGCldgbzBkPM/QEoTI3jBEPBRDhwEvChe08Q1Ge0ImvIq4Qj8ljrLdH77CyQPWlCdHC0Q1e9rmmuC+oQN9Q4LwcQg40L6eyqm0uEpXSUqe3fKpkkqL+Y/o+07SrahNEO0T0LBsvOitf4xsLqiNTB32wtqaVKosGLO2mhUrS93+PZ4D99wPqzMJVcbEyA8AAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-expand:hover .jessibuca-ptz-expand-icon{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAM1BMVEVHcEyZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZn////i4uLZ2dnIyMjExMS8vLy+iXNeAAAACnRSTlMAYomLxwEm9+NCLo6DKwAAALNJREFUKM99k9kWgyAMRIMmEMLm/39tKaVKFJkXl3sYJ4sAXeQ3ZOcYd0+gRYblFBuFLYoS2ot5lpvYn8zJQ65TO2GVNmdCmQq/qczw4gjpejD14BgmhziEIvCjVRlPioftHW6A7xBB1a8CCUMvsuSqEkPM7eZX6h8GrQ67bYpNIbRL6rb4/k2EfVXKsgmqfQrW9qnGq96a28jGQG1ky2HXpVysyYyeDIhWq7le6ua9P36HD6+2GRi8iBZBAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-narrow .jessibuca-ptz-narrow-icon{display:inline-block;width:28px;height:28px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAM1BMVEVHcExfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1/9/f2/v7/y8vLUObqxAAAADXRSTlMA3IrE6SZi9wI+y0gNXAn3CgAAAI5JREFUKM+Fk1kOwyAMBQ04bJHT3P+0JVUMNMWv8zvSk1cipfjAKXHwhR7k6KTjYp7dVuWLug1XWB5wz96T/JD2O3Phmv0k5ypL6lVVFIPYpLOka5WKSSFvS0/BloHYlkza5HkMzrvVLo8ZlRr7mtFYWBBsBQ4BjC//GTxcGVw2PpOVHQ6fJj7qS4936OoN2K4e5yE6N1UAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%;cursor:pointer}.jessibuca-container .jessibuca-ptz-narrow:hover .jessibuca-ptz-narrow-icon{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcBAMAAACAI8KnAAAAJ1BMVEVHcEyZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZn+/v7X19ckk9ihAAAACnRSTlMA9+NCAsuKJsRiPv/2GwAAAJlJREFUGNNjYAAC5gxFoTYDBijw1FoFBIumQHjsUavAYGkBmGu0CgqUwRqlYNyFIO2Fq+BAnIGBJQrBXerAwLkKCUxgYELmKjBYIXMXM2Qhc5cxdCFzVzBoIXMXMYAcsRsMdgEdgs4FKT4DBqdAitGMQrMIzRkojlRB9wKaB9G8z+CMGjgshjCuMCjoWNxRAxYt2KGRYgJiAQAnZcjElaB/xwAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-aperture-far .jessibuca-ptz-aperture-icon{display:inline-block;width:28px;height:28px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAASFBMVEVHcExfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1////9fX1+kpKRzc3ODg4PFxcW1tbXW1tbk5OT29vaVlZVmZmZ8vCMFAAAADHRSTlMAxGJ5Mssm9+NCiYtiH91SAAABAklEQVQoz41T7Q6DIAyEJQooUL55/zddhVazzZjdHyqXXo8DhWCYTWqltNyN+MZLuxP69UGti/vAsl6c0e4L+tQ2yv1AEbvecMhO5cXdYhk+6aO3WGrNAMwentlMz/ZAKIlNoRsqY2wtFWu9t8wasc0iYVN0LkQfrG1zbxNyrIBcntOQrH1Ukkb60QcxYF1xMA2dh8zWj6ZDsLCsIrL4Ds5Hm9FMbCEROWUB0COaLXEIZJKV7CKybGO7UuxjxY2C/TkMbxboKBQCxgMN6MCJQ6Ch/QjOZg/B13LGx8FDTe3IFvl+Bc9XBi3UWoex68qeL/vxmdyxyvz3NJ8f9dDef36HN7koIK2LjxB0AAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%;cursor:pointer}.jessibuca-container .jessibuca-ptz-aperture-far:hover .jessibuca-ptz-aperture-icon{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAOVBMVEVHcEyZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZn+/v6cnJzr6+u/v7+xsbGlpaXNzc3b29vqh7uRAAAAC3RSTlMAyRjKA59J/3PzPhe1wxwAAAD2SURBVCjPjZPrssMgCIR1mkYtisD7P+zBCyZpM5mzv5hs0M8VnZvaok9BlXzc3FXbO5z0vtifFC5Kn8OL4UfxwVvuHm61d5Z0b6ZGZZwZpQAUosWsjVZntVS1sH3ZFo1IRVYfGXgx+VGwNkkIVbhq9/jm3cAhaNv1Uk3IA8mNn7D3kbQeWK3TLH2jCthrDFcTMwUWaKiClc9mJtJWhS3SF5BpJqMQW1b3xwnkDahMoHYomkeJRgSENA/MFsKML7fgoCBVbGvM+Cx4JcKWbWHKK/h1ZYS1Jy/nK3u8bB3KhzG5deMxtfv3aO7/Heq+9ms8h9fxHP4AHzAWU9zlWNgAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-aperture-near .jessibuca-ptz-aperture-icon{display:inline-block;width:28px;height:28px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAQlBMVEVHcExfX19fX19fX19fX19fX19fX19fX19fX19fX19fX1////9fX1+FhYWbm5vz8/Nzc3OwsLDi4uLDw8PW1tZmZmYgm6a+AAAAC3RSTlMAYmOLx4kn9+NCIVJiPGAAAAD+SURBVCjPjVPttoMgDMOJAqOU8uH7v+qKFN2c597lF5LTJg1VqQG3aGuM1bNTV0wWDtjpg3pq+IB+npyzcIE9ejsDXzDCrjccs+tOariF3n2OLyw5xko0vh9MDjNb9Q0hp2GK3cixlIApe4/JD9appR8SFxWAUFLg6n63iB1irnY1Jv0mlrok7nUdcZRa1YeshxBA9iijChlxI6iZEaBgSEL2tkRcymPGGJpqlbZ6uDg0WR/F0DwuMpxDkYwiIXA8hO2uMJdGCCK6teB8RQoY8xGfevQjxYQt25qoRwDT25MRBjZ7GtP/P/afa3LHmrflXa+ruf661Hvv+et3eAF6Fh3v+sSUGgAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%;cursor:pointer}.jessibuca-container .jessibuca-ptz-aperture-near:hover .jessibuca-ptz-aperture-icon{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAM1BMVEWZmZmZmZmZmZmZmZmZmZmZmZmZmZlHcEyZmZmZmZn///+qqqq9vb3z8/PMzMzo6Oja2tpXGg+mAAAACnRSTlP/JomLxwJiAONCr+rW2wAAAOtJREFUKM99U9sWhCAInEpLBS///7WLEWy7p9O8qEzCMBIOQ15DAlLYsoegS9yFMKQ93skl4Adh+ZI54Q8pG5nxgKzkgkcsk4zhmQxRyN1OPHqtncjOu5AuppcJ6s1EHTA1YzC3Wgq3YmzGqpsmlwZAo7F8oLEVKoeE6+TbSxK0JJ/3FLOwFnUxzXuoltYDDMLoAlmYXLAWIrkqbdZKs+q4KBfkNV1uwGaBim9TdLWS3R7iGRvCNTPB7JvGlc5EXK8cKbrxooint73RzXh7Msl6Oj/uT/b62O9j8sj6gMXX0Xwf6jP3Zr9DtNAHTYMMXrXSK0YAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-focus-far .jessibuca-ptz-focus-icon{display:inline-block;width:28px;height:28px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAPFBMVEVHcExfX19fX19fX19fX19fX19fX19fX19fX19fX19fX1////92dnbs7OyFhYWjo6Pe3t7Ly8uxsbG8vLyG+Q0EAAAAC3RSTlMAiWJjx9wm/0Lti7mfpe0AAADaSURBVCjPfVMJDoQgDERFC/bg8P9/XUSO6CqTqA0TptNDpSrMpC2A1btRT8wrNKzzjdo03KC3zhkLD9imbeAFhd3sG2kvZQ2v0NknfGBJZKkhBM9MxOxDKBV1N4iHi0TRHYjN01Qi7/kK2PtyNDU7DAEJgDAAN0u1jsQEFEkcVVmrqjeXrkWRmC67eqbgG7bJyvkQSQkvUvec7szpek6t9ubWJSK/uJVSm+APzHKCh++DWWuH4plQKNYOpfappcjy2VvJn9744cjGwx6uyXjBxqs5Xuqsvf/9Dj8rLhRg+bQ5VAAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%;cursor:pointer}.jessibuca-container .jessibuca-ptz-focus-far:hover .jessibuca-ptz-focus-icon{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAOVBMVEWZmZmZmZmZmZmZmZmZmZmZmZmZmZlHcEyZmZmZmZmZmZn///+xsbGoqKjt7e309PTExMTQ0NDe3t774OlGAAAAC3RSTlP/itxixwImAELtp8B2gZgAAADmSURBVCjPjZMLjsUgCEVpq60G8Lf/xQ62gvNeOmZuUiWeKHC1cKnC5iJAdFuwJXgmf+xg2g//G54OPuTOCUOEL8WgMMCLwgPP+Abj2aF38CrnBR7whw6Bo4fWUk7MMrQ2OrpAq0GspTLLgKg1wTailNITZA0EaTkZGjIAY5NwlATah5CGRMJYj50tFtlWiapsLvAPRdtL/WOmET7QzZyl5ywzp7NWsjBJ1odsragJqeJ9HGFNZoLaJw71hMTm0O7NeDE1Z6YsU5rGL69sedmXXz0ToW8PzA/oV09T8OJR32fb7+B17Qe3WwtC9PVbHAAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-focus-near .jessibuca-ptz-focus-icon{display:inline-block;width:28px;height:28px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAARVBMVEVHcExfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1/////t7e2dnZ3W1tbGxsa3t7eDg4Oqqqri4uKTk5NImu/5AAAADXRSTlMAYieJ3MvE/0Lti4oh87zNagAAAOtJREFUKM+NU1sOwyAMY30FtoWS8Lj/UZe2gWpVh2aJH1wcO0mNqbDj4gDc8rLmiscEDdPji3rP8IX5fXLWwQWuaVu4gbKDuyPdsJMz3GLefcIPbJ6PDCEAFDlUAJiORM3NigQFAXAFlqOeRhWJyFFIHxNGvRrN0mp470U++3axGM2RAmXcXqKnkDSN0a9WIk5Sa01MpDXBQAdVtrA8lBhFnnKpsmoo5VBrhszV0KuJ5N2tP92O50iQjpzcctravoihdoi0Q1NrfN56m0VWzFBoje+OrD/s7pr0F0yUr6s5/LvUu/bz+B2ep+IHdMIV2SUZfCsAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%;cursor:pointer}.jessibuca-container .jessibuca-ptz-focus-near:hover .jessibuca-ptz-focus-icon{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAAAQlBMVEVHcEyZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZn////c3Nz09PTp6enR0dHFxcW7u7uwsLAUKT0cAAAADXRSTlMA3IrE6WIm9wI+y0gNQZpqdwAAAOdJREFUKM99U9GShCAMQ8BF3Cmlpfz/r15dAe88l8zwQiQkoRrTEa3zIXhno7lhWxcYWNbtN/fa4Q/218VFDzf4of0O8A/h3TQfOGU/ytsOj9gPVyt8warkmYEQQAgABYDxTKROz88koS6AVIB1fRCNbSI1cVUy15Jq27LGjTtyzipPeWw40/IXQkrHyZSRmqw3LaQgctFNKYzYyGACfEXossLMojFEj7J0WfdwJ3dD9uY2X25tL0Hj45mTR87Y66u9IQFsDS1bL57o7JbUDNIofvpk08eej8kTe3Hz0ZwP9UFfv8OgfgBUByCEUZhYtAAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-ptz-arrow{cursor:pointer;position:absolute;width:0;height:0}.jessibuca-container .jessibuca-ptz-arrow-up{left:71px;top:15px;border:7px solid transparent;border-bottom:10px solid #fff}.jessibuca-container .jessibuca-ptz-arrow-right{top:71px;right:15px;border:7px solid transparent;border-left:10px solid #fff}.jessibuca-container .jessibuca-ptz-arrow-left{left:15px;top:71px;border:7px solid transparent;border-right:10px solid #fff}.jessibuca-container .jessibuca-ptz-arrow-down{left:71px;bottom:15px;border:7px solid transparent;border-top:10px solid #fff}.jessibuca-container .jessibuca-ptz-arrow-left-up{transform:rotate(45deg);left:32px;top:33px;border:7px solid transparent;border-right:10px solid #fff}.jessibuca-container .jessibuca-ptz-arrow-right-up{transform:rotate(-45deg);right:32px;top:33px;border:7px solid transparent;border-left:10px solid #fff}.jessibuca-container .jessibuca-ptz-arrow-left-down{transform:rotate(45deg);left:32px;bottom:33px;border:7px solid transparent;border-top:10px solid #fff}.jessibuca-container .jessibuca-ptz-arrow-right-down{transform:rotate(-45deg);right:32px;bottom:33px;border:7px solid transparent;border-top:10px solid #fff}.jessibuca-container .jessibuca-loading-bg{display:none}.jessibuca-container .jessibuca-loading-bg,.jessibuca-container .jessibuca-poster{position:absolute;z-index:10;left:0;top:0;right:0;bottom:0;height:100%;width:100%;background-position:50%;background-repeat:no-repeat;background-size:contain;pointer-events:none}.jessibuca-container .jessibuca-play-big{position:absolute;display:none;height:100%;width:100%;background:rgba(0,0,0,.4)}.jessibuca-container .jessibuca-play-big:after{cursor:pointer;content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:block;width:48px;height:48px;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAIVBMVEVHcEzMzMzMzMzNzc3MzMzPz8/Nzc3MzMzMzMzMzMzMzMzLVn6fAAAACnRSTlMA+duduRUwSGSD8toSsAAAAI9JREFUOMvV07ENgzAQhWG3lLSp6MwCViYIRSpG8AiM4FWMaPymDBKESMF/cQ0S136F353vnLuo3gp1kOYEoCXW4LFKIZAnqAXYICeASoAdzgG+cApwgF4EfwF+oDkCqIwA6gnyAKA8AaizQhsBAjzuqUHofInGIQbjRxXjMrTJuHDestR4Bng4eGrN0929PqNfzC6h06weAAAAAElFTkSuQmCC");background-repeat:no-repeat;background-position:50%}.jessibuca-container .jessibuca-play-big:hover:after{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAJFBMVEVHcEz///////////////////////////////////////////8Uel1nAAAAC3RSTlMA+rbVFUecgC7rYhEEz+4AAACbSURBVDjL1dMhDsJAEIXhdeiGpKYWQVKDWc8ReojFc4ReAlPFFQazad7lIGkb0jK/WEPSsZ+YN5mZEP5UrZIP0vgE0Kv3oPlIJlAk8AJM4ASYwAkww2+ABfQg0ImgugPYsfNBVl99kA0AsjOArAPQpRTGHiBB8whxM0y+3skXNltsvMYriIWrpWPA80mFJ5qL3gAfB1/tcAt7rzdiV+HEgs1oBgAAAABJRU5ErkJggg==")}.jessibuca-container .jessibuca-recording{display:none;position:absolute;box-sizing:border-box;left:50%;top:0;padding:0 3px;transform:translateX(-50%);justify-content:space-around;align-items:center;width:101px;height:20px;background:#000;opacity:1;border-radius:0 0 8px 8px;z-index:1}.jessibuca-container .jessibuca-recording .jessibuca-recording-red-point{width:8px;height:8px;background:#ff1f1f;border-radius:50%;-webkit-animation:magentaPulse 1s linear infinite;animation:magentaPulse 1s linear infinite}.jessibuca-container .jessibuca-recording .jessibuca-recording-time{font-size:14px;font-weight:500;color:#ddd}.jessibuca-container .jessibuca-recording .jessibuca-recording-stop{height:100%}.jessibuca-container .jessibuca-recording .jessibuca-icon-recordStop{width:16px;height:16px;cursor:pointer}.jessibuca-container .jessibuca-zoom-controls{display:none;position:absolute;box-sizing:border-box;left:50%;top:0;padding:0 3px;transform:translateX(-50%);justify-content:space-around;align-items:center;width:156px;height:30px;background:#000;opacity:1;border-radius:0 0 8px 8px;z-index:1}.jessibuca-container .jessibuca-zoom-controls .jessibuca-icon{vertical-align:top}.jessibuca-container .jessibuca-zoom-controls .jessibuca-zoom-narrow{width:16px;height:16px;cursor:pointer}.jessibuca-container .jessibuca-zoom-controls .jessibuca-zoom-tips{font-size:14px;font-weight:500;color:#ddd}.jessibuca-container .jessibuca-zoom-controls .jessibuca-zoom-expand,.jessibuca-container .jessibuca-zoom-controls .jessibuca-zoom-stop2{width:16px;height:16px;cursor:pointer}.jessibuca-container .jessibuca-loading{display:none;flex-direction:column;justify-content:center;align-items:center;position:absolute;z-index:20;left:0;top:0;right:0;bottom:0;width:100%;height:100%;pointer-events:none}.jessibuca-container .jessibuca-loading-text{line-height:20px;font-size:13px;color:#fff;margin-top:10px}.jessibuca-container .jessibuca-controls{background-color:#161616;box-sizing:border-box;display:flex;flex-direction:column;justify-content:flex-end;position:absolute;z-index:40;left:0;right:0;bottom:0;height:38px;width:100%;padding-left:13px;padding-right:13px;font-size:14px;color:#fff;opacity:0;visibility:hidden;transition:all .2s ease-in-out;-webkit-user-select:none;-moz-user-select:none;user-select:none;transition:width .5s ease-in}.jessibuca-container .jessibuca-controls .jessibuca-controls-item{position:relative;display:flex;justify-content:center;padding:0 8px}.jessibuca-container .jessibuca-controls .jessibuca-controls-item:hover .icon-title-tips{visibility:visible;opacity:1}.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-face,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-face-active,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-fullscreen,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-fullscreen-exit,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-icon-audio,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-microphone-close,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-pause,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-performance,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-performance-active,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-play,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-ptz,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-ptz-active,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-quality-menu,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-record,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-record-stop,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-scale-menu,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-screenshot,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-speed-menu,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-template-menu,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-volume,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-zoom,.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-zoom-stop{display:none}.jessibuca-container .jessibuca-controls .jessibuca-controls-item.jessibuca-speed{padding:0}.jessibuca-container .jessibuca-controls .jessibuca-controls-item-html{position:relative;display:none;justify-content:center}.jessibuca-container .jessibuca-controls .jessibuca-playback-control-time{position:relative;justify-content:center;padding:0 8px}.jessibuca-container .jessibuca-controls .jessibuca-icon-audio,.jessibuca-container .jessibuca-controls .jessibuca-icon-mute{z-index:1}.jessibuca-container .jessibuca-controls .jessibuca-controls-bottom{display:flex;justify-content:space-between;height:100%}.jessibuca-container .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-left,.jessibuca-container .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-right{display:flex;align-items:center}.jessibuca-container.jessibuca-controls-show .jessibuca-controls{opacity:1;visibility:visible}.jessibuca-container.jessibuca-controls-show-auto-hide .jessibuca-controls{opacity:.8;visibility:visible;display:none}.jessibuca-container.jessibuca-hide-cursor *{cursor:none!important}.jessibuca-container .jessibuca-icon-loading{width:50px;height:50px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8BAMAAADI0sRBAAAAIVBMVEVHcEx4eHh4eHh4eHh4eHh3d3d4eHh4eHh4eHh4eHh4eHiqaCaRAAAACnRSTlMAikwX3CxpwZ7zIGi5xgAAAZ9JREFUOMt9lb9Lw0AUx2Njqm4iGEqmEnBxslKUdhJctFMVcW5wKZ0CLpJJQRw6iVqQbg3FtPdX+l5+XHJ3796bQj557773fe8ujtOI+6jz5p84dHjTkYD4+RhT9CIRZWRPJr1bChnbY532GhT4oUpbI6HEuqvgIH9544dh9J4/rpr0Ms8oV3zMNT7X1MXSmaznzfHjM4n72moe5n8ryYrW9rKRvgf0S93JA7yKa9lbzUg3keJb8OVCtwkrFmoO4MnsAuj5rGqnZg+GZXUXkl9NjEui9n3YA9XgpMgakLXz6ujMTIgrCkPVv0Jil8KgKQN/wRN69hLcb1vrbR2nQkxwiZTGQ5Teb7TO8PUaS8Q03sE+zkjP8qbjzgJtEhRbV4gnlkOFeM7hDYNdxPbiYFvKSHN6L2NmY5WzMYPtplZdTxncRvn2sI+DHIoug22jWMaA12Y7BrXzrG8BX32XPMDKWVzw1bdMOnH1KNqNi8toqn7JGumZnStXLi0e4tcP6R3I635Nc/mzsMxl9aux9b78UVmn2pve8u6eR50j9c0/ywzyVl5+z84AAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%;-webkit-animation:rotation 1s linear infinite;animation:rotation 1s linear infinite}.jessibuca-container .jessibuca-icon-screenshot{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAJFBMVEVHcEzMzMzMzMzMzMzMzMzNzc3MzMzMzMzNzc3Nzc3MzMzMzMwv5ahDAAAAC3RSTlMAW+8S2UGVwyyZnOTRhEMAAAEfSURBVDjLzZKxbsJADIYdBQpsSCyVMlXAdEuQYGKpWFk6dWHJgsQ7sMDSpUv3PgITAQT0f7ly57ucQ45KXRAZot+/89k+X4ju9KzL4XOhlm3pR0enYrWViSRPXQIQSASkRSkIJEFRimYCuQAHSW89IOv6SH5TCsuAj68Ab1wDzqkAzqoC7AUAPtgsABgkBBgkCJiNHehGok//KRVsHqd+3Dj1/vukt3AH/Jj05s5/AmyZhFVWXDls44iVvfQWkCvgxU6g9ZdJfCLvjJbYaT3GvjOY4mQSG3SJGjhr/Y1Xohp+TGKqqzexZ/1GVGdNCitt6R8zVvb9d+JmKdl8o5sPWbtxT6zFuJcDQtk92MNmYiXHquYlZlVt1j4P6cd7fgHFW7Nhqu29TwAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-screenshot:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAALVBMVEVHcEz////////////////////////////////////////////////////////NXt0CAAAADnRSTlMAWe+X2TINXUYZvctoYyuS2NgAAAEVSURBVDjLzZKhDsJADIZLCAsEg8WgEGCWGSwCgZxB4MgEAonB8wQEXoBH4BEWXgPJgEBG0mdgR3u77raRYAgnlq+9+/t3TQF+dKbZcJXSYSnzlViT457lRScKmBqILSFA3GoO8S4E+Ex5JiSJ4CbVdyOQdZNomX9D4dl+ko3NC8vFFmhPy8FIsi0ZlwLBW/LY5BxYYreUSgoFAEmhB5Rc9OCbUoXmTmDadQKTn4y6A/XTaoSKdb6KyGU6RJ7eHgpb3ABinAoil303xB6vQnRahNhXvMdre+fzOgxVrokX4jHAnBh8PALU8Eq8BqgTg/vePF8tpuPy9/NFaalSc273RizarYqfkswjifNMQ/TyTGMv4v87L+ks5gqDbc9OAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-play{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAIVBMVEVHcEzMzMzMzMzNzc3MzMzPz8/Nzc3MzMzMzMzMzMzMzMzLVn6fAAAACnRSTlMA+duduRUwSGSD8toSsAAAAI9JREFUOMvV07ENgzAQhWG3lLSp6MwCViYIRSpG8AiM4FWMaPymDBKESMF/cQ0S136F353vnLuo3gp1kOYEoCXW4LFKIZAnqAXYICeASoAdzgG+cApwgF4EfwF+oDkCqIwA6gnyAKA8AaizQhsBAjzuqUHofInGIQbjRxXjMrTJuHDestR4Bng4eGrN0929PqNfzC6h06weAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-play:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAJFBMVEVHcEz///////////////////////////////////////////8Uel1nAAAAC3RSTlMA+rbVFUecgC7rYhEEz+4AAACbSURBVDjL1dMhDsJAEIXhdeiGpKYWQVKDWc8ReojFc4ReAlPFFQazad7lIGkb0jK/WEPSsZ+YN5mZEP5UrZIP0vgE0Kv3oPlIJlAk8AJM4ASYwAkww2+ABfQg0ImgugPYsfNBVl99kA0AsjOArAPQpRTGHiBB8whxM0y+3skXNltsvMYriIWrpWPA80mFJ5qL3gAfB1/tcAt7rzdiV+HEgs1oBgAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-pause{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAFVBMVEVHcEzMzMzHx8fMzMzMzMzOzs7MzMz4IlKVAAAABnRSTlMA6xIU1hVqIuOVAAAAMUlEQVQ4y2NgGFYgLS3RAEQziQFZoxKjEqMSaBJpEAkgIw1ZQlBQRAEs4QhkDeIMDgAWx1gMHyIL4wAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-pause:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAFVBMVEVHcEz///////////////////////+3ygHaAAAABnRSTlMA7OgSFBXMmAA4AAAAM0lEQVQ4y2NgGFYgLS3JAUQzi6WlJY5KjEqMSqBJpEEkgIw0ZAklJSUDsISikpLQIM7gAJjhWp6XcaOxAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-record{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAHlBMVEVHcEzGxsbMzMzMzMzLy8vMzMzMzMzNzc3MzMzMzMxEZ/aQAAAACXRSTlMADPKKKeBxlV6neZ4mAAAArUlEQVQ4y2NgGDZgJhpowCURAJeYpIQENJEkCgWRgCeShAGyjfgl2EqwS7BFToZJiLg4ICTEImdOh0pwRM6cDJcIjpw5E6aDFeh8B5gECBCUYAkKCoMbNXNSOlyCgUEQ4apJJmxIEkjOVWFgxi4RgEsikGQJnEYp4pLA6VxUDyJLIAUJcRLIwY7qXKSIQvOHWCQODzKIleBPPjgTHM4kijNR48oGkajiYUMykwMAAfmZhUjBISQAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-record:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAJ1BMVEVHcEz///////////////////////////////////////////////8NopmKAAAADHRSTlMA8gyMLeRw1x2DBpWGN2QDAAAAt0lEQVQ4y2NgGDbgDBpIwCVRAJc4KIgEZM4EwCU2KSEBHySJCcg29iBJGCBLgHUs24FdYlnNYZiESksDXKJALebMaagES8yZw3CJypgzZ2A6WIHOd4BJgABMgh2XBEtpaBjcqDMHs+ESDFyLEK46aMGGkEB2rgQDJ3aJAFwSUSRL4DQKp+VHcTkXxYMoEkhBQpwEcrCjSCBHFJo/1GIO408MOJMPzgSHM4niTNS4skENqnjYkMzkAEgzyFpeX6L3AAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-recordStop{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAOVBMVEVHcEz///////////////////////////////////////////////////////////////////////99PJZNAAAAEnRSTlMAMPndsnZj1CSYPcmL6wsdoU80pOJLAAABu0lEQVRIx5VV26KEIAhMA++p9f8fezatFDPr8LSrjMxwiWlqzRuMYKW0ENH46c3WuGyVLXEduuO83UyK59fl1jX5EEUXD9DOaSh43XEP5zUIdZ4pAecTofVnWSt3ip4rx7N61vjnY1D30CpH4QQR8vsP+RA5Rs3KpjfMU/pMim/LgbvH7DF2F8sU0owqapKLqgnhuGWwImUagn2zhUX6WQQoYkXG9WxSAJd700/ygsCpAoliaDsPiG48GM1X5Ft/06sfp8DrDE+3DpekWjxM6366fgEcnklC+AIIWYQmPEeAaUmjFOnhCLDfxZRH+w1gU5b/DYjfNcyJ0p7dxX8B+FwxQVtvAGB5ig0d5gFA5KbzS91hI8CenvlHflfN/XvzJQnxbBEko1gbvVnPii+FadSVRUEaYylQfJtpLB+aRG4LY/80yKdUbCraM0lozGR4ewZ0Wtnj1iC7hjWKNnjYmR62W15cLlL3+2pyMR09jccyuyUrHKsvthc5xsY1iWJ0Xk3t+2XP7AnWwrAQmBH6asXubmL1Z5Lz6o992jWiu9lnMSiQsK27FS9NxhCumZgB2fTBPFsFolhZr5B/D3o9sJAI6skAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-recordStop:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAMFBMVEVHcEwimP0imPwimP8imPwimP0imPsimP0imfsimPwimP0imPwimf8imPwimPwimPxLmg1rAAAAD3RSTlMA15sisGUvdz3szYwMT8H+hDJEAAABx0lEQVQ4y3WUO08CQRCADxBQchBiMDE24KswFlw0Wtig/oHzUWglJBZWio3GDjUxlhhrEzT+ABMrO2iptLLVRluDggI+xtmdXW73LkxxNzvfzuzszNwZhhDzdOxqaPGgYrgkOgFczh90ezAJQmpL2v6OHYnqk2aWxOTtAnu/O/Y5XNZXmTZjo3ot7aESwLdFeqAM0MoJkMf9ltwVQJ9PcQN0UFIJogvdJgLQVFMsAlxyBaPmVBDCE8W7qd+2SDsx0q4OwhSrCG134W54jDfKLjDNxaL8/9AAMM/solptRnoALBbwEPWYrOEzLnrZsTGoMW+fBHG2SiLPUNI6KMOH8QS/XsCMBYQekIEv7NGZF/Rht2yqmA4i3UG9O0iTqgMfhirDhRdU8XJZqqEO8tDAqje8IIt1r+I5HmBjfD9AxQ1MgJQRpc6GJRALHOAS1WRlhMs4VaSFzwIWzCUF3op71kdNsNs/FDCuA58YqCQl7IhN3WbDnlLtfjnuON515WM17c7w41QPOuBIzDT5wqi0T4ESGV3gjtTjkuPATwHoX9+cPRlmmvJ57YAir2qKy459QL/UhrS/uAu3xf8KiX3DI+b22t6jc9F/qfaum9E1pJ4AAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-fullscreen{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAALVBMVEVHcEzMzMzOzs7Pz8/MzMzMzMzNzc3MzMzMzMzMzMzMzMzMzMzNzc3MzMzMzMxdHBitAAAADnRSTlMA8AwGYt0aUcg+til5kgmZywUAAAGWSURBVDjL1VM9SwNBEB12IcGkMagxNktQSZFCYimIJAqKpZ3Vco3YBYs0NkKQgBg4ECtLFSFVCGgQrERBsLayPE0Ip7n5De73BdKLTrE3ezPvze6+GYDfsAQKy/Rz0i/OZJjY9XREuohTKulS+ZFGiADfyZXU5uHktI44VH5apDx554aXwJqloiIwiEsStAjCAsRNF1jCmGqa4Vc+BvS4JkjwzyPE6xiwzsxxeTbZxqjkANSWZFkoIj5bQBl4aBDfkPDNpeRRialB+SRAFz8UU1sAaEUjSCDoJ7iukZJ1V+c01bFczM1pWaa+a0Rp7MHn4V8Z1R9vLLCv9WjKdVFfk77JP+bZdz35YAfKXx6KhKp93abUYVbrj49g9aAYSuFCLbPUwzdCsYEWTloXgw1oGwQbENeuKwxzXhxwAADRMFd+zzRc6AAASY6RH8VjUHaXTrlOpDgCUP3gelc01e2d+f16cWbnQ46BGCRNVsWAWQJVw2xGfUXVv2k1OsLfazXqblzS99u1FwKFvBJioXBY2+r82U75Ab7O0ypVV0wKAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-fullscreen:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAANlBMVEVHcEz///////////////////////////////////////////////////////////////////+GUsxbAAAAEXRSTlMA3clDHfdfDQbsVG00u4Cqkr04dRsAAAGaSURBVEjH7VXLdsQgCPUBAROdjP//s1UTDUxsz3TRTc+wC94bHsLVmP9hkE8LIdvgupt2tFhcpy2CMZyVxNePEoqDp4hwEGz5PTqWoZNzLrmD9riltBEYzzpZQ8bweXy56Qy6Tivsp5JQYtawuMH3eJlSxIJtdSSa4xer4lMB89pK23mKrwjZVpsRzLq35vEE3+r26h6w5EKppcp3fP2lIpTPWJvoXoobeNI1sM3haHvx56tu2sdElJ54GbnPQ7RZ1sCpl8qPEMXBNQ8vN82jNbzLCPzGSDOZj/2Bqd19R1rELIEbDFrUJfKYdlALbDuDMko/hz7t8DqtCfr8h1Vt4rn7eh/6Ph37ch20aW8McsfGCOXzcr+GOlQG1rJ2HSHUDO/4Mu01qVAqTCpCJfgZ3phTS2pKm5aZOMUbs7Q6nk6L8UzRh6W78jH+gD/VRxHokPuNgUGTaPPR+zDR1mrlvcGgwkAVacSbeoN4Z0rb5/6XLrW/2GTLk2NhXHRKzrqAt9cD4rr4ddvae0NAYgOICdZyvPj4UYRf2BdfbB8iWvnTUwAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-fullscreenExit{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAG1BMVEVHcEzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMxi4XDRAAAACHRSTlMAf3WqJmy+7azWNnMAAADNSURBVDjLxZQ9E4IwDIaLfMzCOTDSOz07OjLir5CR0dmJFVHIzzZtnMzbOzcyZHnuaXpJWmO2ji4GhpAzzZeQzw8FKCj1pMHss9OgpwsGOS0YGOcVUMPsfBVkmJoVCBJW0FFB6SFIaMKAlRGDnEiDkuM00lP3SmL6H5QSh+iIr9ZWVWntUV9Z4qWbHAWrhcUYNLC4Wwm3xb1r2mOQYoVn2EKFAVb81KHiQQq6L3vSUoMBUmSzgCKbVeiL3eTp3Odf8H1sxRAZZNZt/Vt8AHcPQbiQQVF+AAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-fullscreenExit:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAJ1BMVEVHcEz///////////////////////////////////////////////8NopmKAAAADHRSTlMAe4Fzh7MZbKPtN8gpX19xAAAA3klEQVQ4y8XUIQ7CQBAF0CWhKQHDGtQKQFcURUgqEARBED0Aoqp3IKnoATAEW8MNOACmhQYKcyi6uyjmr+aLqXj56bSbVoh/J3HBxcw0ZfA2c3FiQLGeQcWh1lOVDDJTAeCbCgAR6QqCDj0xCEU5Bl2BIALKMwhdKjGILRUYfCIOEynlvABANk64M5jabJxHfJY2I76yzYu/ZCc0s1WbNYAQ3jxqwMoGHoqWGHpUQajEgcYYcKWFtjLE4FGJQewoxODRDQOqKPPcHl9sfzSXa/0L349tEDsOsp/8+2/xAY+BZBY9KhM5AAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-audio{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAIVBMVEVHcEzKysrMzMzMzMzMzMzMzMzMzMzMzMzMzMzNzc3MzMz8gU00AAAACnRSTlMAL0jMZKt96hGJsSKv1QAAAJ9JREFUOMvN078KQFAYBfCbJEw2q6SUyWxTnsJT2JTJ6D38Gb6n5PpT6BwbuaNfTnz3fEp9fZwAP7czD0MsGCzBYJcEYsGwBEHQQRB0EII1CMAWdAOzyJUvJ4jyDVyZVHKGpj9guEI2IuhaDFadYnCkIm9I+kPgn8t+kI7kOsT72HcwQnJR9Gofy8DrwwtHK8pLzdeALg5fNb6cdJ1fOjOGYrl5CLFcggAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-audio:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAJ1BMVEVHcEz///////////////////////////////////////////////8NopmKAAAADHRSTlMAL0TQf2frEaZYt8E+idL4AAAAnUlEQVQ4y2NgoDdgUcAuzr4Hh4TaGQHsBp3BLsG+BoeE2hnsEkCDsEqADMIqATIImwTYICwSEIPQJFhnBjKInUGSUA2CSPCcOcIwB1ki5xRM4iiDDrKEzQlsEuUF2CVY0jbgkDhjMLQkEkj0IM4gQQ1EHMHOOXMiakRpTiQQtXgTA+7kgzvB4UyiuBM17myAM+Pgzmq4MyfO7EwjAAAEf+BAxqI/agAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-mute{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAMFBMVEVHcEzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMztXryaAAAAD3RSTlMAHd4P7ztyiy1OnKhdx7uY2gyAAAAB8ElEQVQ4y72Uu0vDQBzHE45C3SJFaSGjUEiRpJRCBifXokkpSv0DfOBrEKxUUSoFH9ClFAUfU7c4OARRCs5WjThIsJuDlLo4ldvPe8SYxGyCt1zgw+dev+8vHPcvYybvfCR2OgUv2CoLdI62bUn3gq5UJxOomZofXPUNrIChJRklfcDSiKK2bYQ6PiCaREk0EQoYPFYa3F73F+DGsBJLmAjBAMBKakG15KAxqIhd2KuK5reRccBDNbqGJhfSlnNc/kBh4OY+vaoR5QrRC0afKgxMrKdXNKI8yxRENpyd+i0VA6wMm5IOBmORCwfAFjGwolofevbuPrvpGhRgpVaqiJflrLuUQQFRToS9l894EMDe7q6yL7/G5wMATc5mQCiAvQo3HAbwLtyYHQZgTxhohgGUa/CP12EA16W2/Ou4ZEj1dNG9oPMkZGiwJWQ8j+huPoJy9Z/XHTfUFSbAURveCtE5px5vs7hQDKS25FSDn2KR5Up1/lRmIHne7BvKd82LMRJbSjr5M40lmaYZ5/PRpiCpizjJyk+CwOGOzACLpSdz02QxkiuRhd8dNOwkV7zl2YX1mcySKJrQiPkXY9klSt6rkJPRwIlmzrcWSGyzHuTb11V/N0y/S6SdwdCR4m/47OIN7XOQCfwJwHGp8IcfyRdBLEZK4Uxp6wAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-mute:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAP1BMVEVHcEz///////////////////////////////////////////////////////////////////////////////9KjZoYAAAAFHRSTlMAbk2o8o0P5TsGnVojFi/XHcV9urLaq0oAAAIQSURBVEjH3ZZZkqswDEXxLM8T+1/rkw0BuwM0f131+IvDyZVk6SrL8p88QCHp8UAnWmoWoG8AwQRN4/vOiqwUuwWqiob646MMhEW+KnMLMIXffgiZoODBusb7kCzjByF7OOszkOyp4amJ7fWVPwCN6BpyWRypvANPCvi7u4aTXe13YI+KkYA5bMRTSMlLnSyGwisSH40B0FJOrKVB6iAw2U7sGgPgQ/DTPQjitCOZT4Q6gWCtGwGFbSM34ENUNSpAKTACmC31rnRgJwjDdkFAJpfkAsZcAJvCSVQB2FaWWKdB/ATMAHwIUYL21lRBZRDiC5AnsBHBUqxEyaraFMoz0AnvHNa6xDWS34FGgNf6PYAEZoCt+BroUWFVbeb5HbCqSvB2cToyca+Adjlycdawt0C/HeyScl1W/w3gsU3aAd7JF8AuAN6isr7NAogXAFeq59Ec7ifAm49hF8wCMWfVNXAeCAkjEGuBr6R5ZGJzBrl4gGniBME+w8aMMyCsNZtfaemnmYaAQ6I3Rz0fnDhHJxc93Vrr7sHWjP3XRtTba2L3EkdFVaPC6YmXxKI9DGF1YPLdiwfD2r37cL5nDVw+uKzU5K27hsXCXPtyC2uyyl0D0p2TY7VaIvFYWU0Dm8TdOXmrVp52HG4lU4K/N38PpS/Kw70dbmb/sC0WCcQwNNzzjrzUj7veUyIIyL/4m/EP8V829O8zh5EAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-ptz{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAM1BMVEVHcEzMzMzMzMzMzMzMzMzMzMzNzc3MzMzNzc3MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMxDm1AzAAAAEXRSTlMAHqw+E8It/gjxc03jhGDTlgAjE2kAAAI6SURBVEjHpVbZkoQgDBwg3Of/f+12gtfMbK1Yy4NampCju4Ov1y8ruNyyo9fyCibVlNW6vUu29GpWQwTVdPTernqwffHex0WP4Nro3k+PrMKCvew/PcZ95aoNsY9yua+cGxTZsnf2K7ch4CAdGnWwYx/5LgKZCgxGdrhH3BeqNmnwviFXPZbQJmcM25HJ5n7/Pczr2QqksMJfO7BJOHLKLWFdMiL1QXYRwFagMklb4GB1zS7s8Le3fqH7Q28tVLkKdIzeaOJB2OKtY8KfTQCUa4++dNsLbrqpTR7xguHGt8hfg8P+seuaEkNdBjahzOD7g1cHP21SL2LtMNBKMdTRJjffTX1wVgrsEb1ITJU6QknwYJAcQky2cE02NbzPp70KyKggtpu9xM7Ik+CBIqY+8FrYyRUkrs+MEm1TG6tG9LZxNDNFGDue63TYGgIHqUUcuNhvhyZtn5LnlDq3Juxa4noCuX0scErOpNMDCrVcHPCS5rFGuQR9KZpxnB6CQ0ZO+AIBcTPk3UdbTx1L7jLEEHsMW7ZYm8NlIFyxn8+xdL7MURYEhzd5k2N2TabxIAORwC2r00QQfNSgrnqTJfh7cDmDu9ggtV0EZFr7kGu4KAxtNDln406TLwF9iZCIwn9EfjPuncRHYm5x3NfK3cFAS5kWxljSnTFlPHBAUFg5HsCCVOd9cdwXq+027un2QJlMjqISJutCDceRtTTuT4+1Q3HWHR8cu0fh9sGvADTYH9iLah/9nPz5+/MDJnQfoIVoAnQAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-ptz:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAQlBMVEVHcEz////////////////////////////////////////////////////////////////////////////////////1bZCPAAAAFXRSTlMAeVoYDS1pBiPv4/g6lkzO2qSxvoixscijAAACi0lEQVRIx51W2ZLcIAwcLnPf+P9/NS2wp5xkq0ziF3ZRC3R0i/l8fvi04oxx89n+RBi1sqB38TKw7lw7lNzDa3U0e57bHhJ4d567HlqGC08eLAj9Gv8XD4/OwtsdhlfCW2s9LfWtuNrMhG1uLWP17Xh14LF4m8dx1OJ9jkm85YCYch5JzDVy81on3MFYkpTNYGmHHloYI+aqlNhlh5ZSvmH1AyBUwPcMX+u/clW3XYvA2YgRGXyZIZX6PXv0l3GlV9Jp9FKcK7mytJIg8xEeBdaBtV4P8tAixexnp73tY7ZBkrk9WEL8t7ZUDqtIA3jXa8sODSeUVqw5aztT+g4QeNAgM0PGTA0+EmfVeUvU0CEW4hX+lt/zseE7jJKDSmi0EUKBhr7EAMKPvNjOA9Fz4Yk/CFgcGRSdkYOHCLRxQfzKRN5SB/b5Ot8SzzQiKqcb6ipFdCfi1JI84OBdxzarhJ8RkpxHOQszl7bpn0GpmnXq6R4OfTkwwlyUWzeQg7rSLNhNUzEUEqJF3DMHeeXgqRIaYwHimLKipK8hMZOYVfJ5oKtIFSgXk5z4KcNx3GOIPGYfPigh9YGHBNQKVKbZhxMnqq+OHfWBHARZfWm1dnfSXfJuXInplse8wy39zkisdQ5kuLY+Bpc5hwGiH8Mx1rE24DFaLqXkfrNVkjk+8JPTPF0bUw+R9MCVuA8ks/xDyF/9orMqpBQeiob5RbIbmv7/TxvoX1Oqa914TsYg7QUWx8Y7R89JQY8mY6Dat1G5GARuMOgYHY9cbL1vNvc++fk67olLk4nrQSl7457OPqdeKn+vEwm4LPzW87DyXvqIyei9znHS+cZz9SxV+Qf8nNbjn37NkDx4+PmCXzHOLUMtjgmUAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-ptzActive{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAANlBMVEVHcEwgmv8imPwimPwhmP8imP8imPwimPwmmf8imPwimPwhmP0imPwimPwimPwimPsimP0imPoLqfILAAAAEnRSTlMADprCJBnU/gXwh3LiUKxAXjJ/ELXKAAACbklEQVRIx5VW2bbjIAwLa1jM9v8/O7Iht+09MwPlpS2VwLZkJ9f1lxVG1joPdZ0u1ZIxurhv8DH6dMpQI5t439GAEc7xYPgTRnAtV7plReRhd5kDP8+fd+wzt70yPhIJzWT7/6DCJCAYLReZPMIuJC4pClSktHqbNpJO1aTmmAme3cvtWs9NSfq52CPhnJNjlbVHwgmWSWGHeQHcKFjj7fygwidf2fa4mbVOuladcnsoDn9/CKKAWf6HEtpANiJvUp9Fgr0SvocPP/sqjOCK9ktpyCAo4Kt/d4n4/6baseNKAt5XrauPN1A4ZLAd30RUI4kNfELVx+yd3lrXYIg1Bp/B/dGs5N8mPsJoVyiwkofQSlm+K9aiwmoQMDoI4wefoK/rhkESrSuV+BR2i6HZH9juLzxCtBmn6rFmB66gNJQwBOSxncT/N3FAlxAoLQfJDy2+6rMLI3aznl9fhOcGSdZzoNhex2K3TXJEVe3M4Zb6QhHuJc5BWakYIqqietcPw6FK+EHofUHRqtLEQ5X8dKVENXXgEpLOpcjwkFI30YFVHE8fyx2ShZJ/ydTKlZwZ4BCOv/af9uMi0DILe4kieynScgPbhai+DRDckTT6N6zJpI3HMghM3BMg+q9pHmwrbR0Q0D5wc0JHPy0E5Ur7Nf3Rk68LnR0NHfO28/T5P4cNr+uLFR7eEdiNxvMRbd5Onlqsis4iIVdme4di3akWOz+3T0aUnFWHa8QZrO51NO69MeLPafrNuBenxel/3d21j8k/jyxf+75OQabFxOtuT94G3Lpjzb0zBn2Dl0ep/waPidQ/p/XB60Dp7e8F/QO7WSJg4zEzdwAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-ptzActive:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAANlBMVEVHcExru/9ru/9qu/9ru/9ru/9ru/9ru/9svP9ruv9ru/9ru/9ru/9ru/9ru/9ru/9ru/9ru/+3uxEqAAAAEnRSTlMA5q0cR/PC/ggSKtN5OIhaa5izIOiAAAACV0lEQVRIx5VW2ZLjMAiMToNu/f/PboNsJ5PaKWv8kKRkWkDTQF6v/zyUfO+JX9sP1dKKd/v2acQcm992kbo1R4il7iHIif0BRNtCUOozH4cikAdt2YfjRLTnzN15/8I85wFCI2xDzlnyMLO7R0aFoTzbFGB+jIkYLkyePvmW8d2fs2ZfZuv8It9s6zvV5uSr2LmKb9oVh37QvpjYOcf8fcO3Cb1jGqOU0SvTTd6X2KUBLgKdLzaiDtE2n+isTh8/+AX7E6/Vh/NNSyfVm10RXIe1nxXRapmsDQB7SMnkmE0IxgqvUn0jteEf1T2CHXgr0gjZllGk1HoJL7lD7fRpD20CgJcwQ6EdSh3lLK0zVfuqz2WvPlPJh7HqnCQ4MysxoAYQE0vHub/toRuqzRy5pEUvbg62MzlJQn1MHBe1x7WSAddpNDSN1c9wRMhKfi2jrICwAIsQvHkD7Al41bOrBNC1Y7QdmSg15LDokGETJB/imxYJKfmFMDqI3FjUkDS3NSEDjBaxknRYSb+4nj4kC43W2OKrkqGB8jV2Fq03YiWbhHQTpUV1mMHXWYf8HlNX7ZUQRC6iwBAIK0r0ILr1UxqKsPattAkhwSIiMl76bT/Ft/TbTy2jHQoM7Cz9isHVMb6GILl0H4DGivbw7xNc8rAtiJn3O/qvD6JT/wgs7Y370ZSdWmbZWEKiG1lXImldW7Q1jGMbZW9tUVKZmGjjGvf+EXAqzWiX5OfFSHVp/zjbfGPc3whdcbTF67V2N1e79qYMru2/AnzVYFsdWFt/+nOypv8vQvoHou4gOtSrG5EAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-performance{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAnUExURUdwTM7OzszMzM3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzW8hQDoAAAAMdFJOUwC/gO8ra6tUQNmVEKtAA1gAAAE4SURBVDjLzZMhT8RAEIWnpS3tXcWdQ6wgOJIKfFdUICv6AyruB5w4EuSJCwRXgUBWkGArLsEi6JVuaZkfxawguSWz/p7azLdtdt97C3ASagp+PpeXPDjHVx7McMWDCBc8qPCZB4m44YFIeOBh+ckCf9z+sCCYqi8WvA/5Nwu26cfA+JRBs4h7WmX/tr9AXcQHAPdgzEPZh5idTQBOZ3zyiModISKQGxZ7dd85E0SKfMGjM7vXeI/5AE5LvrwpcK9IOrQYB5BlCsFIvjzgrkaSjsBZbmC9XsGsAxfn8gKXpL9sSlnQFBwFTTuaKWXgI5Ar+sfHTrW6DUDO+2jEEtCNQ9wL6gNujMvvdFS3eugxGT51fBXxTvF1wLLngbT0BGphKalAy0MQ3Z4Ha2V7UoMFJKkFVAWcvH4B0OJfd9YsTl0AAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-performance:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAzUExURUdwTP///////////////////////////////////////////////////////////////8/RimEAAAAQdFJOUwD2qdfrViyAwW2XORBGtSCsD6SyAAABN0lEQVRIx+2VzQ7DIAyDYfxToH7/p10CbQ+T2s33Rb1MijM3/qDG/EurolD9zSNRggBU0hFelMABmenfADhGkJDhGUFGgiX6I1AAQlDgZK/td8ELtQORiTmIq42I2bYdCD8NjzPmYQxO+rbn2S5qzEUF6YjkgcJude56X3s0SoL7LRAeylyaVPiFq0Jyx230mpeXmXVOHssRbhackhCq25Sny++xcBW1n6Snqw6BTgrqRP6kzfDcgmRLGonDWSf2OecwB491dOrEVZpNsxiyiHzWJ0Z+BbBwzaoWVb49HrqVfSkxHen7WNznLhzl8xpQlT3E9oHUtYaufB+7NY9g9ctbjFfj/h1DwXUrzDltMn1Ql9M814EQWPLmEBg4R7JSzpFQxTmSBMkLvJKOhFHfKEEnv3L/+qw3DuMPzAFH9pIAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-performanceActive{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURUdwTBGW2xKV2hKW3BKW2xGW3BKW2xGW3BGW2xKW2xKV3RGW2xGW2xGW3BKW2+P2IvgAAAAOdFJOUwC/gCvzq1RAleURc9VmrA9rXAAAAT9JREFUOMvNkzFLw1AUhU+SxtTahnZyC+IsIeAenDuE/oJQcS/FTYTi6hKcHYpDZ/EXBME95BeURpM0Me39Db4Mgk/u23umcL8kvHfOucBBKEr5eW95xoMjeuBBlyY86NOQBwt654HrPPHAca/YuUHrDQsG9eybBWa1+GLBqvS3LJiNX0vGJw/R0N6LJ+/f6x9I3uwG0D+luRU0FnmdCtBy6ZM7KvQdjgXwJYuNZVNrFfqF8IX+nFm/oBvyS2iZ8OWxgH4u1IZmU4kgfoa5E77c0jwhoTYCbTRFGE7QrXFCveCURkK/2cRBCp2gFYiyWk7Jw4AgXOmQZMAqa9uAeCP+JsViihtb9OKIPtBUuvy8jeqyHRpMhvc5X0W6Lvg60HrPg0DREySOoqQJKRbByRWbExaqlSoVwB0rwCLFwesHquttxhcsa64AAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-performanceActive:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAnUExURUdwTH3G63zE6n3G7H3F633G7H3F633G633F7H3F7HvG7H3G7H3F6xOzy+EAAAAMdFJOUwC/hKbvK0BT2XURZct0z00AAAE3SURBVDjLzZMhU8NAEIX3LiSUNqI1qBMMChFRgYxAd07E4CI6HQwzEUXgKjC4CH5ABAKJyA+oaHqBJO3+KPaYYSZh9nyfyuyXu7l77x3ASSgu+flYX/HgHOc8kC4wwikPMnzhQaTueKAiHvi43bFg0m4OLPBM9sWCjyb9ZsHm8NkwPiUQT8MjfSX/fn+F/C3syJf9YB7oLsDkjIaiHix5QCNbGBmAFPve+3lXi/0viLB3ZnmDz5g2ICry5daAvCbZhSE2oIsFeC35ssJljiQbgZitIY7nIGu4wLG+xBnpL5tClxQhCANR1Q5TSmCCQK7YjftOVbYNUOxot0EsHl0uwHdFfcD14PJLG9W9HfpMho81X0V8MnwdcHvkgS4cBcqVo6QKHQ9B1a6XY1zAcSiIFg6QlXDy+gEd714RcAqEowAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-face{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAeUExURUdwTL+/v76+vsDAwL+/v7+/v7+/v8DAwL+/v7+/v96T4QgAAAAJdFJOUwBAgSCbs9hZap+hQJoAAADvSURBVDjLY2AYRkAJCAygbEZBQUEBKJtpJhDAOJpA9kSYxESgKphuIaBuhASqyYzESjC2hDRilQBZ64BFgm2qMLPYNCwSkQpAwlMBWYIRzJsKYrKCxZSRncKSDFYzBSNY2MD2MqRhSFgqgClPAwwJBxwSbAk4jGKZDCKZp2JIsEOcOx0ztjQDYL5ENwsYJKrTsMSvGSgepzVg2pE5qSikPRPT8sopBuDod0ATZ54JsbZyBrJgAVAp1Ax2oPXMykjxYQaLA2CMoERUZQDMrgBUCc8CKIdzAvHJhyQJpLQLSu0TCaV2lPwBSu0KQy+LAwBuJj5UbruNggAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-face:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAnUExURUdwTP///////////////////////////////////////////////w2imYoAAAAMdFJOUwBAgBvfrFmcw4wrbtGliFoAAAD2SURBVDjLY2AYRkAJCAygbEZBQUEBKJvpDBDAODpA9kGYxEGgKphuIaBuhASqyYzESjBu79yIVWIP0NoCLBIsR4WZJY5gkYiZACRqFJAlGMG8EyAmK1hMGdkp7M4gkus4RrCwBIApFwwJmwlgqsYAQ6IAIrEAwygHHEaxngJbfhRDgg0sxHoMM7Z0AmC+RAPsJ4S5NE5gid8VoHg8sgHTDh/PzM60HkzLc44bgKMf3RKuMwoQ+dNIgswJDAycUDPYjhgwMCsjxYcJLA6AMYISUTkBMLsaUCVqEqAcngPEJx+SJJDSLii1HySU2lHyByi1Kwy9LA4AqflRBKNSA88AAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-faceActive{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAhUExURUdwTBCT2xKV2hGY2hKW2xGW2xGW2xGW2xKX3BGX3BKW23povfoAAAAKdFJOUwBAgRybs9hZLG6hrV9tAAAA80lEQVQ4y2NgGEZACQgMoGxGQUFBASibaRUQwDhaQPZCmMRCoCqYbiGgboQEqsmMxEowTgmZiFViFtBaBywSbEuFmcWWYZGIUgASXgrIEoxg3lIQkxUspozsFJZkEMmxBCNY2MD2MqRhSFgpgCkvAwwJBxwSbAk4jGJZAbZ8KYYEO8S5yzFjSysA5kt0s5YKc6guwxK/baB4XDYB045Vi4pCyrMwLa9aYgCOfgc0cY5VEGurViIJMhcAlULNYF9mwMCsjBQfZrA4AMYISkRVBcDsCkCV8CqAcrgWEJ98SJJASrug1L6QUGpHyR+g1K4w9LI4ALk0RHtSETFcAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-faceActive:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAhUExURUdwTHzD63zE6n7H7H3F7H3F633G63zF7H3G7H3F7H3F68TinBIAAAAKdFJOUwBAgR+Z31ipwW4yAjb9AAAA+UlEQVQ4y2NgGEZACQgMoGxGQUFBASibaRUQwDhaQPZCmMRCoCqYbiGgboQEqsmMxEowTmmZiFViFtBaBywSrMuFmSWWYpGoUgASXgrIEowgHtsKEJMDLKaM7BSWYLCaJRjBwloAploxJKwUwJSXAYYE2KUMVRgSrAFgKhTDKPbFIJJ5OYYEG1iIfRlmbGkVwHyJBlhWCDNrrMASvxageFw6AdOOqKCklrQuTMuzlhiAo98BTZx5FcTarJXIgglApVBr2ZYaMDArI8WHKSwOgDGCElFZBTC7GlAlvBKgHK4FxCcfkiSQ0i4otS8klNpR8gcotSsMvSwOAIs+RIlIrewIAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-logSave{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAA1RJREFUaEPtmT1oFEEUx9/bFLFKJzG2WiknZObFxlO8RtFC8SuFWlrYGBtRRNCghV9YmFQWgoVaaAS1ULRRRKvbmYBBQezVYBOIGFMkT0ZuYXPufOxdspuDO7jibmfe/H/z3sy8eYvQ4R/scP3QBSjbg8EemJyc3La4uHgUETcx82YAWNum+N8A8IWZrxLR41ZtBQForUeY+Xarg/j6MfMVIrroa5f13AuglOJWDLfQ56aU8mzefk4ApdR9ADiW12ir7RFxXAgxkqe/FUBrvYeZXzQbY+bh3t7ed5VKZTrPQM2eNHYQ8VGGjTtSypOhtq0AcRyPIeKptCEppTfkbAM3AxhbcRwfyYJg5nEiCvKEVZBS6hUA7EoEIeJ+IcTz0JlpbpcFYNrYIBDxlhDijG88lwd+IGJ/YoCZ1xPRd5/BUA/Mzc31VavVWRcEM18jovOuMV0eWLL7tBM+RoBS6isAbEzERFFUHRwc/JD8dnjishDikg2iSIAJADiU8uhdIjqRFuZYEweI6Gmuc8AWs6EhVK/XR3t6eg4zMyKiEQ/MvOSwQsS3iHhhZmbmY61W++UIp/dSyu2FAmit3zDzTjMoItaFEFuVUt8AYCB0ElLtZqWUfYUCZHlQKXUQAJ60AAC2Nbhia8AWglprAoB7jYQwmGXVACSKzRqJomgLAJjvBh/JqgPwCQ7dRAoPIZ/w5HkXIHQGQlOHvCd56PjdEOpoD6TShT/MfD19OXeFQCPnOYeIaxYWFiaGhoZGQ9Pv5nZthVA6XWjkOsMJRGj+b/IhIURtVQCkIUJvYKUCONLf/+67tjuw+T+rLlTYLmSDCDmwbOIbF6CgC1Vba8B3m3JBuMQXDuC4iGQy+MSXAhAKESK+NAAfRKj4UgFsEHnElw5gBGit9wFAUqy9kbco1vY2Gsfxsha2QrbV1K42gIimAPDvw8zTRLQuy0ZhpcU8AMZ7zPws1ee1lHJ3LoDlLu7mAcioZFuLvYWV130AU1NT/fPz8zuyqtWIuFcI8TKXBxo7QaEvOCyQD6SUx20T4K33F/iKKVOj7yrqBWhsiSv6ki8zNBBPCyHGfKEXBGCMrMBr1mZtPxHxEzN/jqLoYbr07oIIBvDNRFnPuwBlzXwybsd74C95KWhPrxIhsgAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-logSave:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAthJREFUaEPtmTuMTUEYx3//TrWdeLRUJCrReISGUBCvLVAqNGiEiASh8IoClUKyBQqPBAWhsREqnYRE9NgoV0T3yci5m9mzc2bmnHvvOXuTO8ktbs7MN//ffPP45hsx4kUjrp8xQNcezPaAmW0EDgFrgLXA0j7F/wG+AlckPW5qKwvAzE4At5p2ktHusqTzGfUWVEkCmJk1MdygzQ1Jp+u2iwKY2X3gcF2jfdS/I8l5O7tUApjZTuBlwNIk8E7STHYvQMCTzs6jgI27ko7l2o4B3AaO+4YkJadcVcdlAGfLzA5WQGR7IgbwGtjuCdoj6UXuyJTrhQBcnQjETUmnUv3FAH4CyzwDKyX9SBnM9QAwIWk2AXFV0tlYnzGAebtPP9OnEPkNWO2J2STpQ+9/xBOXJF2ogmgT4Amw3xNyT9JRX1gEYq+kZyGIoQGY2UXgAPyPt5x4V8qH1TRwDvgk6XdkOr2XtLltgLfA1qLTj5I2mNl3YEWDdTQraaJtgAVryMz2AU8bAFC1Boc5hYKbgJmtB6aKgDCbZdEAeLuOWyPrit+qFMmiA0gJrjr4yu1an0Ip4Z6Hss6hMUBu6FD3JB9PodwRGGkPeOHCX+CafzmPDUAR85wBlrgwQ5LbUueV3AHsaxGbmR8uOAGTPYga8f+0pG2LBWAOosYNrFOAqith6L5bdQee81optG7nHIjE8DlnVlB8EVa3AxCJ4VMAleJbB2gAERXfCUANiKT4zgAyILLEdwoQgcgW3zlAIWA30EvWXq+bFBvESTzQxFZqSyqdAe7i7xIAvTIjaXnIRmupxZoAznvPvTZvJO2oCzDQ5G5NgPKbRGWyt7X0egrAzFwedktFtnqXpFe1PFAsxLYfOEIaH0g6UjUAyXx/i09MQY2pq2gSoPDEsB/5QuJPSnLrMFqyAAqIQT+zloX9Aj4DX4CHfuo9RpANkBqJrr6PAboa+V6/I++Bf0in3kCazcMZAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-zoom{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAkUExURUdwTMDAwL+/v7+/v7+/v76+vr+/v7+/v7+/v7+/v7+/v7+/vxtcv/AAAAALdFJOUwBVdZCpGdZE7C3B0wnY6AAAAV9JREFUOMt1lDtPwzAQx20ghGwVsHVJhQRDlsywWKqEULsw8FhRJ2iWiglGGJvFCw8xIVVCSEwkKU25L4ftpOHs2Cclsu7v370smxCLecRh+xOH8Ja5kGEs/6dtYf1XONcWZurbwwRCQjYZ9l7uHAPAOBHpI1QC/QSY9g84ldmnAn7Z3htwsfZnvSe54eJd5hlcC7gccxTwSETZEr5+714vLRdfkFraVNtetXLpR7ha+mkHCV1Y/q8ZOW8AgDkecsIaAEIcGbIGyLUq4KcBYl0o7QAB4FZACBMrQKpaJOCZQqyAIhgayYEpgD1DZghXCvBTNJFKmCvgzmhcCEsBwMjSRx6BslYftRX0JLYKrAsLqzDC54EFMwvy58QhMM8hFNq0UpwET+sLC9/4BmEBTytyRCIbDoAEiR1Qp1dbRxfoyv9g3ogaKVuXhVZZbtqX6Ez6H23PxG4CM259QDwt/h8ABfK8nDqSAAAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-zoom:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAzUExURUdwTP///////////////////////////////////////////////////////////////8/RimEAAAAQdFJOUwCCyreU7KZVRCDaZnETLwj6WaYVAAABUUlEQVRIx5WV2Q6EIAxFoVBWxf7/184AOnGUsvTBqDmXrqRCzNou1kwGtyZIQNuiD0P6evWTURFUMtIoPO+iVoGIZPkMqkdKA0jZgoJ6suQc2EoiGBldOoQ9HSDk5+GTs1Fqo9IlcEpvNv3qv0MBhSalIFSv3+MCJCY8fUaCxasycrMu9dp5VTUhubXZ6CqsAvn66ZAsx+e8fON37oT3bZ4aiRU0kDlavGSrQI95HPBZACt8FuCL16IruBVkzBeBW+CLYHvyfiDQd96IpHpOMqP++fAq9VMQ7rwrM5+6gjwG/3y/D/m8ylPYpvpAeqO7DfvwMPO9D6jnBabG56YFZx77fEjD+9AyLdYEhp8nxoNh5wmJtfY8AS+wzIZZrJNcC4h3wV8IH1p87Iyfnc6XVaAd7ICHAsebw97zgDSxZ/yvViiPuYUfTe650knM2+7Ywz9yOCklzohLOwAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-zoomStop{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAzUExURUdwTP///////////////////////////////////////////////////////////////8/RimEAAAAQdFJOUwDjmTC6Y0KBVakX8s8iC3JYR1wyAAABVUlEQVRIx62V2baFIAiGcwJRS97/aU/Zbtht0VzrcJOuvl/AAabpXy1RF0F/m2h2PX5mzucEuO9gMon1MY7KlG8w4LImC1XFQmxDGVkm1DYpXi0qS1gXTEGzKoqNS1ajAxPqJDikFLcFS+aukYJffRfXnAj9kYUXFVi86wzzPjuCFRXBwS3KaC/Pt02Ww7uf1jz3BVYtX/OsyDQFDn7yswPXb+Ovs39eJJWwxrOXV4thgC+//QBf/uMAXwAa4AuRBvgdWR58CB2B+eaRG5e8QO7Jn2sIAvzhbdsDnXzev8q0BengGXv8EciH3y1CY5++yI/BRNx82g/La7lc7b0Am/tUC6n3HoZ4SbDyy5BgzSNivV6wbPXeIPOpHlOU+CjkTQKvQOpXdRdJvn+5xttWQa4EZUOzluonT6+q72X6Zb0+T/lNhQd7hg9vm8LWUhW5gT4iN7c/0ZUo8Q3AttYAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-zoomStop:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAqUExURUdwTBKV2hGW2xKW2xKW2xKW2xGV3BGW2xGW3BGX2xKW3BKW2xCX2xKW2yDN61kAAAANdFJOUwCAVKxm3T/DmhrxKw97YQBGAAABaklEQVQ4y2NgIA6wGqCLMCqAqV4HdIm9F0Ek22UMM9hiG4AkVzQDA+cmx+YyJJnDlw8wMNQaNpfevbu0QgxJgrN3JQPD3VvhjU57kESnOZqvvXuJgcEXxVFMEkDt1w11gZYwoVgue3d5SzaQSgCydZG1TMkBU8vBuq9guBcqNBNDgj0GQrMEb0CVYEmA2ViANRQZ795tQPZduADciXcVUNSthGu4hGrAJawagBIXsWoAClzGqgEocRWrBqDIrQNQDTPRXZ8A0cB41wBNQgGiQfbubTQJAagGDB0GIA0OsnevbkCTCADiu4J374ahW34JqAEIbiXMRJOAgkvMKJYgJBx6717AKiF4F4eOu+jxgQCXGHBIKPDgkBC8JYCURJDtQHYWN4oEcvpZiyR+C9lZtkgSKKG1CyGOGrxItleixjrcLFBWRAYcMIkG9NQMiY67N7AlcxAQwMwA6SBxM2xZQ3jtVRPsRQ83sg8ACMIUxzzE8wsAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-close{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAeUExURUdwTM3Nzc7Ozs7Ozs3Nzc3NzcrKys3Nzc3Nzc3NzePZJxkAAAAJdFJOUwCtKdPBGAmNTt3jdDcAAADfSURBVDjL1dOxDoIwEADQgwR07GTCZtI/IGHgAzBhM9EPkMTB0Y3V0ZXIcn/rtRR6pefgSKeSu3ellyvA9lZ/5F9p/3K7PZY8oPG5BD6MpPUSgIITzdIStifAshjRQV1PCFT8TxaicTzzwEwINOEdHVmDmcTAkRhMhMAp7iQRjcMtDhCp8SA1v0ARGIIK/gnkv0p1OBTS4QRUIpE7DiYYXTBrzcld3JIrAarXrps4AVNwRSZgExoJmIyAaAdsShUMn/JF2fh4YEkpAcgvnuwYCIb6EbbbP4PsDfLD2dD6Av1qTvAQlzUTAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-close:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAeUExURUdwTP///////////////////////////////////8kBMKEAAAAJdFJOUwCt0igUwJdJePGbgLgAAADcSURBVDjL1ZMxEoIwFESTCaOWFDapqeicnAALTiANnaWlnVewDTMW/7b+aCAb8jkAVIHN2/lsNkrt73lf8M08nnF1pAYFR/dFmAAx7SIoi4iDbRrWDMAuQFzmmxAGbjjJgjj6dCjMCAND/o8RWQMzUgIRKYE/wsC5TJIRR74rBUZaqqXwLZEXT0WTDGwLW1aavJWQir9qadw++NgykWoMNtcykh8Q5EECgr5C+jjpGjHjPGhPU5eVzyfPJitfnUyhPg6ywMKZ7BygcYcsPCj1Kc8uXYPqpeSLs6PnC4w8S+8OJ9MLAAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-narrow{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAzUExURUdwTP///////////////////////////////////////////////////////////////8/RimEAAAAQdFJOUwAyqXf5Hu1TZxDRmrxFjN7ZJa7NAAABXElEQVRIx92VS5KFIAxFgfALoLL/1XaVKPBCQteb9KAzM3Ik3FyiUv8rQqo0MsrL0VQmfJDWa1/5OPn1x1hxFWNMsv3ZsN/vJZy6ZVzoJWam/rcemA+pXwQWoLQXSZN8fAiaDy1dxKMlkvZsdiaIuC3pWPmgKccAIDToYk5x6ykahpF209B3i2sBtAic6wlHRRhHQJhrOghQOAeWyTaRAM1h9ELcq9AuInYVqMXzMBqwO2QC3IU7y5X0+MLYKa44nSFQlR5foxvxYVlN+3CIfbhvhUcKGHE42NX6G7O+do0rYHYbVGTuAz+BCjcHMn9zh/M8stsySp3CoAn8PHFFHJjPl2qa3jiYrBXY7tzIGRwi6mg+nbgQs++8t+tQDnyDNrEQev2fVJt3hIoE8dl1AYXWHrkzvkScJRdHizsiAASNtEk7S/NtXUbs70RSXxKgviPKFz99bVIB9SfxA8uZLAsxki39AAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-narrow:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAnUExURUdwTMzMzMzMzM3NzczMzM7Ozs3NzczMzMzMzMzMzMzMzMzMzMzMzH6OaiEAAAAMdFJOUwBv7U2hEB4zt9NZixFhg1cAAAF+SURBVDjLY2CgF+CacwYKXFHEWXtg4mcOLUCWKDqDAKeRxJnBIhounWDaASFRAzJiO5CR5QNkHUHYoAPkioKZ7CAZAZgEB5AzHcpmBLKPwyRszpw5gWzsSRgbaNIEFIfAXAxkJiBcsgeh7MyZg0hu50RYcuaMAqqnTsMlNiAHgw7c9jNnCpAl9sCtPHMISEQJgoAwxPUGUAmgL9h1IEHYAPYJ1L2g0OGEhi3QfTHwQAFJMCECPQhFggUqAfRCDkIC5DwnSPwJoNhxKICBgS0NBEDuXAN3Ptx5EOADVgiRcEBOGIhIOHPmGJIEIyJMkeMJ7I2jiPhASkw9CJN9kKKZgfsM3G6QZoS79iClH+YzCPsyQL5EVnVmMpgVDQ7kwzAJcEDNNgsNXwINfAOEZ0FASQeWsA8jeQoVwLVUwoVUULUwrISJJ6xB1cJgDcpshxoDGLhgEQYDbIaCUqUMkPhAziRIGRUkcRJbFl6DS4LrDGoyR9HSgFWC3bORnFIEAI39IME59Pz6AAAAAElFTkSuQmCC") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-expand{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURUdwTM3NzczMzMzMzMzMzMzMzMvLy8vLy8zMzMzMzMzMzMzMzMzMzMzMzMzMzAmiiJAAAAAOdFJOUwAqre7XQBoOxWGeiHNRIXj5WAAAAcNJREFUOMu1VLtKQ0EQ3Ygx5FEIPhpFVLAIaNAUPkACWliGYGEpMWKjIKktJGBjIWIhiAgSRGwESWkhwcpGEAUtRJCYmBjFzDc4szv7uCpYOcXd2T07u2fOzF4h/jLf01H/xdzP9a4koFWi2W/rs8A26UXWwNiEu+5PWADyDnDorMOrPSwo7x186DjYJm/GAM84q+9JzkUKMRnQtkv2Y+j3MtCM/pTeFcHJO/s3nguJCM/QG7MMKaRggBSN99NyJ97ypoEPmSVAjsZ1gE8NyB0hgBcaw4Ywq9AEUKUxgEenGUi5EXTJjgIqdGlnBqCxkFb0FS2o42cXSOFEHPfM69yhzLKQIbEepieIbVgDNSEWXSDiAKsGwKNadA0L7lGUz/LmBia2uaXKk+c80p48iro6nE+IMxdY31sGcq4kPlMQK16NN5S1iJQ6EZNKIKmGKZS8bCUqp9jEw0J7VVtaPInFJdGU8NLObGMhT11MITJua9DT6ONuJWlGNdBGIg0R9271fFp1j0oFx0+vj1nJER3SDl4zIYGYs1h0Q4JJA5z43RCLDKi8cvYZntNy/Er1KpSch7j0uH+X1VKUfv1J+I1a/2xf3OKDpNnEfRYAAAAASUVORK5CYII=") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-icon-expand:hover{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAA5UExURUdwTP///////////////////////////////////////////////////////////////////////308lk0AAAASdFJOUwBFnl8nDsur9hnq2jeLum17VecmAZgAAAGgSURBVEjH1VbZdsUgCIz7boz//7Fto3FBzLk9fSpvUUdgGDDH8WfjV6JKqZC8+eR0kLmZVky8H/cxA7PpBSJoRsyy3XliM24UP8/y1iQW1tljUIl479mQvlv5utptAzE8NMTC5kPkCdZV3VAA4OpFfHGdKoJhCTixJ0NPe7pki9eo3hbGtbLkOwXSqY6ueQgI6PXxN11dASWAEwL6DRQ4LIlLABgEUGIg3UWJycyAvl89DBRHyOxIG+emeLgMNxNRYQLUCJnLWj9lzzqKzsJY7fbloVDjoJw4AUrOYZH2HZXRgKYGSJ8DSkgGdl3YhlThhkoZC8pFGWt1CWzVH0rMsa10jTTNhWMvAAlKf4CUoDT40hFACgF8K5jzAdR4cxVmtX9LZWmgLngTFIMNb5EZQNAWVcgUIHmPoOhkesbPCY+bOs+XAeEedfp5xjxSsXBY8qcJsiKtlZIbHhe+RWQbaUqBylmGK8Lld1sQQuEHbdAbxHFhTqhprK8IccLAFRnrJLGXLkjdnqLTgMrir53xF2OMcLFq4Rf/B0RjQvin9gVLNDmYNA/hrAAAAABJRU5ErkJggg==") no-repeat 50%;background-size:100% 100%}.jessibuca-container .jessibuca-menu-icon-text,.jessibuca-container .jessibuca-quality-icon-text,.jessibuca-container .jessibuca-scale-icon-text,.jessibuca-container .jessibuca-speed-icon-text{font-size:14px;min-width:30px;height:20px;line-height:20px;cursor:pointer;text-align:center}.jessibuca-container .jessibuca-speed{box-sizing:border-box;text-align:center;font-size:14px;color:#fff;width:90px}.jessibuca-container .jessibuca-menu-list,.jessibuca-container .jessibuca-quality-menu-list,.jessibuca-container .jessibuca-scale-menu-list,.jessibuca-container .jessibuca-speed-menu-list{position:absolute;left:50%;bottom:100%;visibility:hidden;opacity:0;transform:translateX(-50%);transition:visibility .3s,opacity .3s;background-color:rgba(0,0,0,.5);border-radius:4px;overflow:hidden;width:-webkit-max-content;width:-moz-max-content;width:max-content}.jessibuca-container .jessibuca-menu-list.jessibuca-menu-shown,.jessibuca-container .jessibuca-menu-list.jessibuca-quality-menu-shown,.jessibuca-container .jessibuca-menu-list.jessibuca-scale-menu-shown,.jessibuca-container .jessibuca-menu-list.jessibuca-speed-menu-shown,.jessibuca-container .jessibuca-quality-menu-list.jessibuca-menu-shown,.jessibuca-container .jessibuca-quality-menu-list.jessibuca-quality-menu-shown,.jessibuca-container .jessibuca-quality-menu-list.jessibuca-scale-menu-shown,.jessibuca-container .jessibuca-quality-menu-list.jessibuca-speed-menu-shown,.jessibuca-container .jessibuca-scale-menu-list.jessibuca-menu-shown,.jessibuca-container .jessibuca-scale-menu-list.jessibuca-quality-menu-shown,.jessibuca-container .jessibuca-scale-menu-list.jessibuca-scale-menu-shown,.jessibuca-container .jessibuca-scale-menu-list.jessibuca-speed-menu-shown,.jessibuca-container .jessibuca-speed-menu-list.jessibuca-menu-shown,.jessibuca-container .jessibuca-speed-menu-list.jessibuca-quality-menu-shown,.jessibuca-container .jessibuca-speed-menu-list.jessibuca-scale-menu-shown,.jessibuca-container .jessibuca-speed-menu-list.jessibuca-speed-menu-shown{visibility:visible;opacity:1}.jessibuca-container .icon-title-tips{pointer-events:none;position:absolute;left:50%;bottom:100%;visibility:hidden;opacity:0;transform:translateX(-50%);transition:visibility .3s ease 0s,opacity .3s ease 0s;background-color:rgba(0,0,0,.5);border-radius:4px}.jessibuca-container .icon-title{display:inline-block;padding:5px 10px;font-size:12px;white-space:nowrap;color:#fff}.jessibuca-container .jessibuca-quality-menu{padding:8px 0}.jessibuca-container .jessibuca-menu-item,.jessibuca-container .jessibuca-quality-menu-item,.jessibuca-container .jessibuca-scale-menu-item,.jessibuca-container .jessibuca-speed-menu-item{display:block;height:25px;line-height:25px;margin:0;padding:0 10px;cursor:pointer;font-size:14px;text-align:center;width:50px;color:hsla(0,0%,100%,.5);transition:color .3s,background-color .3s}.jessibuca-container .jessibuca-menu-item:hover,.jessibuca-container .jessibuca-quality-menu-item:hover,.jessibuca-container .jessibuca-scale-menu-item:hover,.jessibuca-container .jessibuca-speed-menu-item:hover{background-color:hsla(0,0%,100%,.2)}.jessibuca-container .jessibuca-menu-item:focus,.jessibuca-container .jessibuca-quality-menu-item:focus,.jessibuca-container .jessibuca-scale-menu-item:focus,.jessibuca-container .jessibuca-speed-menu-item:focus{outline:none}.jessibuca-container .jessibuca-menu-item.jessibuca-menu-item-active,.jessibuca-container .jessibuca-menu-item.jessibuca-quality-menu-item-active,.jessibuca-container .jessibuca-menu-item.jessibuca-scale-menu-item-active,.jessibuca-container .jessibuca-menu-item.jessibuca-speed-menu-item-active,.jessibuca-container .jessibuca-quality-menu-item.jessibuca-menu-item-active,.jessibuca-container .jessibuca-quality-menu-item.jessibuca-quality-menu-item-active,.jessibuca-container .jessibuca-quality-menu-item.jessibuca-scale-menu-item-active,.jessibuca-container .jessibuca-quality-menu-item.jessibuca-speed-menu-item-active,.jessibuca-container .jessibuca-scale-menu-item.jessibuca-menu-item-active,.jessibuca-container .jessibuca-scale-menu-item.jessibuca-quality-menu-item-active,.jessibuca-container .jessibuca-scale-menu-item.jessibuca-scale-menu-item-active,.jessibuca-container .jessibuca-scale-menu-item.jessibuca-speed-menu-item-active,.jessibuca-container .jessibuca-speed-menu-item.jessibuca-menu-item-active,.jessibuca-container .jessibuca-speed-menu-item.jessibuca-quality-menu-item-active,.jessibuca-container .jessibuca-speed-menu-item.jessibuca-scale-menu-item-active,.jessibuca-container .jessibuca-speed-menu-item.jessibuca-speed-menu-item-active{color:#2298fc}.jessibuca-container .jessibuca-volume-panel-wrap{position:absolute;left:50%;bottom:100%;visibility:hidden;opacity:0;transform:translateX(-50%) translateY(22%);transition:visibility .3s,opacity .3s;background-color:rgba(0,0,0,.5);border-radius:4px;height:120px;width:50px;overflow:hidden}.jessibuca-container .jessibuca-volume-panel-wrap.jessibuca-volume-panel-wrap-show{visibility:visible;opacity:1}.jessibuca-container .jessibuca-volume-panel{cursor:pointer;position:absolute;top:21px;height:60px;width:50px;overflow:hidden}.jessibuca-container .jessibuca-volume-panel-text{position:absolute;left:0;top:0;width:50px;height:20px;line-height:20px;text-align:center;color:#fff;font-size:12px}.jessibuca-container .jessibuca-volume-panel-handle{position:absolute;top:48px;left:50%;width:12px;height:12px;border-radius:12px;margin-left:-6px;background:#fff}.jessibuca-container .jessibuca-volume-panel-handle:before{bottom:-54px;background:#fff}.jessibuca-container .jessibuca-volume-panel-handle:after{bottom:6px;background:hsla(0,0%,100%,.2)}.jessibuca-container .jessibuca-volume-panel-handle:after,.jessibuca-container .jessibuca-volume-panel-handle:before{content:"";position:absolute;display:block;left:50%;width:3px;margin-left:-1px;height:60px}.jessibuca-container.jessibuca-fullscreen-web .jessibuca-controls{width:100vh}.jessibuca-container.jessibuca-fullscreen-web .jessibuca-play-big:after{transform:translate(-50%,-50%) rotate(270deg)}.jessibuca-container.jessibuca-fullscreen-web .jessibuca-loading{flex-direction:row}.jessibuca-container.jessibuca-fullscreen-web .jessibuca-loading-text{transform:rotate(270deg)}.jessibuca-container .jessibuca-contextmenus{display:none;flex-direction:column;position:absolute;z-index:120;left:10px;top:10px;min-width:200px;padding:5px 0;background-color:rgba(0,0,0,.9);border-radius:3px}.jessibuca-container .jessibuca-contextmenus .jessibuca-contextmenu{cursor:pointer;font-size:12px;display:block;color:#fff;padding:10px 15px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-shadow:0 0 2px rgba(0,0,0,.5);border-bottom:1px solid hsla(0,0%,100%,.1)}.jessibuca-container .jessibuca-contextmenus .jessibuca-contextmenu a{color:#fff;text-decoration:none}.jessibuca-container .jessibuca-contextmenus .jessibuca-contextmenu span{display:inline-block;padding:0 7px}.jessibuca-container .jessibuca-contextmenus .jessibuca-contextmenu span.art-current,.jessibuca-container .jessibuca-contextmenus .jessibuca-contextmenu span:hover{color:var(--theme)}.jessibuca-container .jessibuca-contextmenus .jessibuca-contextmenu:hover{background-color:hsla(0,0%,100%,.1)}.jessibuca-container .jessibuca-contextmenus .jessibuca-contextmenu:last-child{border-bottom:none}.jessibuca-container.jessibuca-contextmenus-show .jessibuca-contextmenus{display:flex}.jessibuca-container-playback .jessibuca-controls{height:48px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center{flex:1;display:flex;box-sizing:border-box;justify-content:space-between;font-size:12px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time{box-sizing:border-box;flex:1;position:relative;height:100%}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-inner{width:300px;height:100%;overflow-y:hidden;overflow-x:auto}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-current-time{position:absolute;left:0;top:0;height:15px;width:1px;background-color:red;text-align:center;z-index:1}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-current-time-text{position:absolute;box-sizing:border-box;padding:0 5px;width:60px;left:-25px;top:15px;border:1px solid red;height:15px;line-height:15px;cursor:move;background-color:#fff;color:#000;-webkit-user-select:none;-moz-user-select:none;user-select:none}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-scroll{position:relative;width:1440px;margin:0 auto}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-scroll.one-hour{width:1440px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-scroll.half-hour{width:2880px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-scroll.ten-min{width:8640px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-scroll.five-min{width:17280px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-scroll.one-min{width:86400px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-time-list{position:relative;background-color:#ccc;height:48px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-day{height:100%;overflow:hidden}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-one-wrap{height:8px;z-index:1}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-second-wrap{height:25px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-controls-playback-btns{display:flex;align-items:center}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute-one,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-second-one{float:left;width:1px;height:8px;margin:0;cursor:default;position:relative;z-index:1}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute-one.active,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-second-one.active{background-color:orange;cursor:pointer}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute-one.start,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-second-one.start{background-color:#999}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute-one:hover .jessibuca-playback-time-title-tips,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-second-one:hover .jessibuca-playback-time-title-tips{visibility:visible;opacity:1}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-title-tips{pointer-events:none;position:absolute;left:0;top:100%;visibility:hidden;opacity:0;transform:translateX(13%);transition:visibility .3s ease 0s,opacity .3s ease 0s;background-color:#000;border-radius:4px;z-index:1}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-title-tips.jessibuca-playback-time-title-tips-left{transform:translateX(-100%)}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-title-tips .jessibuca-playback-time-title{display:inline-block;padding:2px 5px;font-size:12px;white-space:nowrap;color:#fff}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-hour,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute{float:left;position:relative;width:60px;box-sizing:border-box;border-top:1px solid #999;-webkit-user-select:none;-moz-user-select:none;user-select:none;text-align:left;height:25px;line-height:25px}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-hour:first-child,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute:first-child{border-left:0}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-hour:first-child .jessibuca-playback-time-hour-text,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute:first-child .jessibuca-playback-time-hour-text{left:0}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-hour:after,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute:after{content:"";position:absolute;left:0;top:-8px;width:1px;height:14px;background-color:#999}.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-hour-text,.jessibuca-container-playback .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-center .jessibuca-playback-time-minute-text{position:absolute;left:-13px}.jessibuca-container-playback .jessibuca-playback-expand.disabled .jessibuca-icon-expand,.jessibuca-container-playback .jessibuca-playback-narrow.disabled .jessibuca-icon-narrow{cursor:no-drop}.jessibuca-container-playback .jessibuca-control-progress-simple{position:absolute;box-sizing:border-box;left:0;top:-2px;width:100%;display:flex;flex-direction:row;align-items:center;height:8px;cursor:pointer}.jessibuca-container-playback .jessibuca-control-progress-simple:hover{top:0;align-items:flex-start}.jessibuca-container-playback .jessibuca-control-progress-simple:hover .jessibuca-control-progress-inner{height:100%}.jessibuca-container-playback .jessibuca-control-progress-simple:hover .jessibuca-control-progress-inner .jessibuca-progress-indicator{transform:scale(1);visibility:visible}.jessibuca-container-playback .jessibuca-control-progress-inner{display:flex;align-items:center;position:relative;height:50%;width:100%;transition:all .2s ease;background:hsla(0,0%,100%,.5)}.jessibuca-container-playback .jessibuca-progress-hover{display:none;width:0}.jessibuca-container-playback .jessibuca-progress-played{position:absolute;left:0;top:0;right:0;bottom:0;height:100%;width:0;background-color:orange}.jessibuca-container-playback .jessibuca-progress-indicator{visibility:hidden;align-items:center;justify-content:center;position:absolute;z-index:40;border-radius:50%;transform:scale(.1);transition:transform .1s ease-in-out}.jessibuca-container-playback .jessibuca-progress-indicator .jessibuca-icon{width:100%;height:100%;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.jessibuca-container-playback .jessibuca-progress-indicator:hover{transform:scale(1.2)!important}.jessibuca-container-playback .jessibuca-progress-tip{display:none;position:absolute;z-index:50;top:-25px;left:0;height:20px;padding:0 5px;line-height:20px;color:#fff;font-size:12px;text-align:center;background:rgba(0,0,0,.7);border-radius:3px;font-weight:700;white-space:nowrap}.jessibuca-container-playback.jessibuca-fullscreen-web .jessibuca-controls .jessibuca-controls-bottom .jessibuca-controls-playback-time-inner{overflow-y:auto}.jessibuca-zoom-control{cursor:-webkit-grab;cursor:grab}.jessibuca-performance-panel{position:absolute;box-sizing:border-box;z-index:10000;left:0;top:0;padding:5px;font-size:10px;background:rgba(0,0,0,.2);color:#fff;max-height:100%;overflow-y:auto;display:none}.jessibuca-performance-panel .jessibuca-performance-item{display:flex;align-items:center;margin-top:3px;color:#fff}.jessibuca-performance-panel .jessibuca-performance-item-block{height:10px}');

    class ga {
        constructor(e) {
            var t, i, r, s, a, n;
            this.player = e, this.extendBtnList = [], r = this, (i = e)._opt.hasControl && i._opt.controlAutoHide ? i.$container.classList.add("jessibuca-controls-show-auto-hide") : i.$container.classList.add("jessibuca-controls-show"), s = i._opt, a = s.operateBtns, n = `
        <div class="jessibuca-controls-center">
            <div class="jessibuca-controls-playback-time">
                <div class="jessibuca-controls-playback-time-inner">
                    <div class="jessibuca-controls-playback-time-scroll">
                        <div class="jessibuca-controls-playback-time-list">
                            <div class="jessibuca-playback-time-day">
                                <div class="jessibuca-playback-time-one-wrap"></div>
                                <div class="jessibuca-playback-time-second-wrap"></div>
                            </div>
                        </div>
                        <div class="jessibuca-controls-playback-current-time">
                            <div class="jessibuca-controls-playback-current-time-text">00:00:00</div>
                        </div>
                    </div>
                </div>
            </div>
            ${s.playbackConfig.showPrecisionBtn ? `
                <div class="jessibuca-controls-playback-btns">
                <div class="jessibuca-controls-item jessibuca-playback-narrow">${R.narrow}</div>
                <div class="jessibuca-controls-item jessibuca-playback-expand">${R.expand}</div>
            </div>
            ` : ""}
        </div>
    `, i.$container.insertAdjacentHTML("beforeend", `
            ${s.background ? `<div class="jessibuca-poster" style="background-image: url(${s.background})"></div>` : ""}
            <div class="jessibuca-loading-bg">
                <img class="jessibuca-loading-bg-image" src="" alt="">
            </div>
            ${s.loadingIcon ? `
            <div class="jessibuca-loading">
                ${R.loading}
                <div class="jessibuca-loading-text">${s.loadingText}</div>
            </div>
            ` : ""}
            ${s.hasControl && a.play ? '<div class="jessibuca-play-big"></div>' : ""}
            ${s.hasControl && a.ptz ? `
            <div class="jessibuca-ptz-controls">
                <div class="jessibuca-ptz-bg-active"></div>
                <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-up" data-arrow="up"></div>
                <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-right" data-arrow="right"></div>
                <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-down" data-arrow="down"></div>
                <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-left" data-arrow="left"></div>
                ${s.ptzMoreArrowShow ? '\n                    <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-left-up" data-arrow="left-up"></div>\n                    <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-right-up" data-arrow="right-up"></div>\n                    <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-left-down" data-arrow="left-down"></div>\n                    <div class="jessibuca-ptz-arrow jessibuca-ptz-arrow-right-down" data-arrow="right-down"></div>\n                    ' : ""}
                <div class="jessibuca-ptz-control"></div>
                <div class="jessibuca-ptz-btns">
                    ${s.ptzZoomShow ? '\n                            <div class="jessibuca-ptz-btn">\n                                <div class="jessibuca-ptz-expand jessibuca-ptz-icon">\n                                    <i class="jessibuca-ptz-expand-icon"></i>\n                                    <span class="icon-title-tips">\n                                        <span class="icon-title">缩放+</span>\n                                    </span>\n                                </div>\n                                <div class="jessibuca-ptz-narrow jessibuca-ptz-icon">\n                                    <i class="jessibuca-ptz-narrow-icon"></i>\n                                    <span class="icon-title-tips">\n                                        <span class="icon-title">缩放-</span>\n                                    </span>\n                                </div>\n                            </div>\n                            ' : ""}
                    ${s.ptzApertureShow ? '\n                            <div class="jessibuca-ptz-btn">\n                                <div class="jessibuca-ptz-aperture-far jessibuca-ptz-icon">\n                                    <i class="jessibuca-ptz-aperture-icon"></i>\n                                    <span class="icon-title-tips">\n                                        <span class="icon-title">光圈+</span>\n                                    </span>\n                                </div>\n                                <div class="jessibuca-ptz-aperture-near jessibuca-ptz-icon">\n                                    <i class="jessibuca-ptz-aperture-icon"></i>\n                                    <span class="icon-title-tips">\n                                        <span class="icon-title">光圈-</span>\n                                    </span>\n                                </div>\n                            </div>\n                            ' : ""}
                    ${s.ptzFocusShow ? '\n                            <div class="jessibuca-ptz-btn">\n                                <div class="jessibuca-ptz-focus-far jessibuca-ptz-icon">\n                                    <i class="jessibuca-ptz-focus-icon"></i>\n                                    <span class="icon-title-tips">\n                                        <span class="icon-title">聚焦+</span>\n                                    </span>\n                                </div>\n                                <div class="jessibuca-ptz-focus-near jessibuca-ptz-icon">\n                                    <i class="jessibuca-ptz-focus-icon"></i>\n                                    <span class="icon-title-tips">\n                                        <span class="icon-title">聚焦-</span>\n                                    </span>\n                                </div>\n                            </div>\n                            ' : ""}
                </div>
            </div>
            ` : ""}
           ${s.hasVideo ? `
            <div class="jessibuca-zoom-controls">
                <div class="jessibuca-zoom-narrow">${R.narrow}</div>
                <div class="jessibuca-zoom-tips">电子放大</div>
                <div class="jessibuca-zoom-expand">${R.expand}</div>
                <div class="jessibuca-zoom-stop2">${R.zoomStop}</div>
            </div>
            <div class="jessibuca-recording">
                <div class="jessibuca-recording-red-point"></div>
                <div class="jessibuca-recording-time">00:00:00</div>
                <div class="jessibuca-recording-stop">${R.recordStop}</div>
            </div>
           ` : ""}

            ${s.hasControl ? `
                <div class="jessibuca-controls">
                    <div class="jessibuca-controls-bottom">
                        <div class="jessibuca-controls-left">
                            ${s.showBandwidth ? '<div class="jessibuca-controls-item jessibuca-speed"></div>' : ""}
                            <div class="jessibuca-playback-control-time"></div>
                            <div class="jessibuca-controls-item-html">${s.controlHtml}</div>
                        </div>
                        ${s.playType === A && s.playbackConfig.showControl && s.playbackConfig.controlType === _ ? n : ""}
                        ${s.playType === A && s.playbackConfig.showControl && s.playbackConfig.controlType === te ? '\n        <div class="jessibuca-control-progress-simple">\n            <div class="jessibuca-control-progress-inner">\n                <div class="jessibuca-progress-hover"></div>\n                <div class="jessibuca-progress-played"></div>\n                <div class="jessibuca-progress-indicator"></div>\n                <div class="jessibuca-progress-tip">00:00</div>\n            </div>\n        </div>\n    ' : ""}
                        <div class="jessibuca-controls-right">
                            ${s.playType === A && s.playbackConfig.showRateBtn ? '\n                                 <div class="jessibuca-controls-item-wrap">\n                                    <div class="jessibuca-controls-item jessibuca-speed-menu">\n                                        <div class="jessibuca-speed-icon-text"></div>\n                                        <div class="jessibuca-speed-menu-list"></div>\n                                    </div>\n                                 </div>\n                             ' : ""}
                             ${a.close ? `<div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-close">${R.close}</div></div>` : ""}
                             ${a.logSave ? `<div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-logSave">${R.logSave}</div></div>` : ""}
                             ${a.performance ? `<div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-performance">${R.performance}</div><div class="jessibuca-controls-item jessibuca-performance-active">${R.performanceActive}</div></div>` : ""}
                             ${a.aiFace ? `<div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-face">${R.face}</div><div class="jessibuca-controls-item jessibuca-face-active">${R.faceActive}</div></div>` : ""}
                             ${a.quality ? '\n                                 <div class="jessibuca-controls-item-wrap">\n                                    <div class="jessibuca-controls-item jessibuca-quality-menu">\n                                        <div class="jessibuca-quality-icon-text"></div>\n                                        <div class="jessibuca-quality-menu-list"></div>\n                                    </div>\n                                 </div>\n                             ' : ""}
                             ${a.scale ? '\n                                 <div class="jessibuca-controls-item-wrap">\n                                    <div class="jessibuca-controls-item jessibuca-scale-menu">\n                                        <div class="jessibuca-scale-icon-text"></div>\n                                        <div class="jessibuca-scale-menu-list"></div>\n                                     </div>\n                                 </div>\n                             ' : ""}
                             ${a.audio ? `
                                <div class="jessibuca-controls-item-wrap">
                                    <div class="jessibuca-controls-item jessibuca-volume">
                                         ${R.audio}
                                         ${R.mute}
                                         <div class="jessibuca-volume-panel-wrap">
                                              <div class="jessibuca-volume-panel">
                                                     <div class="jessibuca-volume-panel-handle"></div>
                                              </div>
                                              <div class="jessibuca-volume-panel-text"></div>
                                         </div>
                                     </div>
                                </div>
                             ` : ""}
                             ${a.play ? `<div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-play">${R.play}</div><div class="jessibuca-controls-item jessibuca-pause">${R.pause}</div></div>` : ""}
                             ${a.screenshot ? `<div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-screenshot">${R.screenshot}</div></div>` : ""}
                             ${a.record ? ` <div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-record">${R.record}</div><div class="jessibuca-controls-item jessibuca-record-stop">${R.recordStop}</div></div>` : ""}
                             ${a.ptz ? ` <div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-ptz">${R.ptz}</div><div class="jessibuca-controls-item jessibuca-ptz-active">${R.ptzActive}</div></div>` : ""}
                             ${a.zoom ? ` <div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-zoom">${R.zoom}</div><div class="jessibuca-controls-item jessibuca-zoom-stop">${R.zoomStop}</div></div>` : ""}
                             ${a.fullscreen ? `<div class="jessibuca-controls-item-wrap"><div class="jessibuca-controls-item jessibuca-fullscreen">${R.fullscreen}</div><div class="jessibuca-controls-item jessibuca-fullscreen-exit">${R.fullscreenExit}</div></div>` : ""}
                        </div>
                    </div>
                </div>
            ` : ""}
             <div class="jessibuca-performance-panel"></div>
             <div class="jessibuca-contextmenus"></div>
        `), Object.defineProperty(r, "$poster", {value: i.$container.querySelector(".jessibuca-poster")}), Object.defineProperty(r, "$loadingBg", {value: i.$container.querySelector(".jessibuca-loading-bg")}), Object.defineProperty(r, "$loadingBgImage", {value: i.$container.querySelector(".jessibuca-loading-bg-image")}), Object.defineProperty(r, "$loading", {value: i.$container.querySelector(".jessibuca-loading")}), Object.defineProperty(r, "$loadingText", {value: i.$container.querySelector(".jessibuca-loading-text")}), Object.defineProperty(r, "$play", {value: i.$container.querySelector(".jessibuca-play")}), Object.defineProperty(r, "$playBig", {value: i.$container.querySelector(".jessibuca-play-big")}), Object.defineProperty(r, "$recording", {value: i.$container.querySelector(".jessibuca-recording")}), Object.defineProperty(r, "$recordingTime", {value: i.$container.querySelector(".jessibuca-recording-time")}), Object.defineProperty(r, "$recordingStop", {value: i.$container.querySelector(".jessibuca-recording-stop")}), Object.defineProperty(r, "$pause", {value: i.$container.querySelector(".jessibuca-pause")}), Object.defineProperty(r, "$controls", {value: i.$container.querySelector(".jessibuca-controls")}), Object.defineProperty(r, "$controlsInner", {value: i.$container.querySelector(".jessibuca-controls-bottom")}), Object.defineProperty(r, "$controlsLeft", {value: i.$container.querySelector(".jessibuca-controls-left")}), Object.defineProperty(r, "$controlsRight", {value: i.$container.querySelector(".jessibuca-controls-right")}), Object.defineProperty(r, "$volume", {value: i.$container.querySelector(".jessibuca-volume")}), Object.defineProperty(r, "$volumePanelWrap", {value: i.$container.querySelector(".jessibuca-volume-panel-wrap")}), Object.defineProperty(r, "$volumePanelText", {value: i.$container.querySelector(".jessibuca-volume-panel-text")}), Object.defineProperty(r, "$volumePanel", {value: i.$container.querySelector(".jessibuca-volume-panel")}), Object.defineProperty(r, "$volumeHandle", {value: i.$container.querySelector(".jessibuca-volume-panel-handle")}), Object.defineProperty(r, "$volumeOn", {value: i.$container.querySelector(".jessibuca-icon-audio")}), Object.defineProperty(r, "$volumeOff", {value: i.$container.querySelector(".jessibuca-icon-mute")}), Object.defineProperty(r, "$fullscreen", {value: i.$container.querySelector(".jessibuca-fullscreen")}), Object.defineProperty(r, "$fullscreenExit", {value: i.$container.querySelector(".jessibuca-fullscreen-exit")}), Object.defineProperty(r, "$record", {value: i.$container.querySelector(".jessibuca-record")}), Object.defineProperty(r, "$recordStop", {value: i.$container.querySelector(".jessibuca-record-stop")}), Object.defineProperty(r, "$screenshot", {value: i.$container.querySelector(".jessibuca-screenshot")}), Object.defineProperty(r, "$speed", {value: i.$container.querySelector(".jessibuca-speed")}), Object.defineProperty(r, "$controlHtml", {value: i.$container.querySelector(".jessibuca-controls-item-html")}), Object.defineProperty(r, "$playbackTime", {value: i.$container.querySelector(".jessibuca-controls-playback-time")}), Object.defineProperty(r, "$playbackTimeInner", {value: i.$container.querySelector(".jessibuca-controls-playback-time-inner")}), Object.defineProperty(r, "$playbackTimeScroll", {value: i.$container.querySelector(".jessibuca-controls-playback-time-scroll")}), Object.defineProperty(r, "$playbackTimeList", {value: i.$container.querySelector(".jessibuca-controls-playback-time-list")}), Object.defineProperty(r, "$playbackTimeListOne", {value: i.$container.querySelector(".jessibuca-playback-time-one-wrap")}), Object.defineProperty(r, "$playbackTimeListSecond", {value: i.$container.querySelector(".jessibuca-playback-time-second-wrap")}), Object.defineProperty(r, "$playbackCurrentTime", {value: i.$container.querySelector(".jessibuca-controls-playback-current-time")}), Object.defineProperty(r, "$playbackCurrentTimeText", {value: i.$container.querySelector(".jessibuca-controls-playback-current-time-text")}), Object.defineProperty(r, "$controlsPlaybackBtns", {value: i.$container.querySelector(".jessibuca-controls-playback-btns")}), Object.defineProperty(r, "$playbackNarrow", {value: i.$container.querySelector(".jessibuca-playback-narrow")}), Object.defineProperty(r, "$playbackExpand", {value: i.$container.querySelector(".jessibuca-playback-expand")}), Object.defineProperty(r, "$ptz", {value: i.$container.querySelector(".jessibuca-ptz")}), Object.defineProperty(r, "$ptzActive", {value: i.$container.querySelector(".jessibuca-ptz-active")}), Object.defineProperty(r, "$ptzControl", {value: i.$container.querySelector(".jessibuca-ptz-controls")}), Object.defineProperty(r, "$ptzBgActive", {value: i.$container.querySelector(".jessibuca-ptz-bg-active")}), Object.defineProperty(r, "$ptzControlCircular", {value: i.$container.querySelector(".jessibuca-ptz-control")}), Object.defineProperty(r, "$ptzArrows", {value: i.$container.querySelectorAll(".jessibuca-ptz-arrow")}), Object.defineProperty(r, "$ptzExpand", {value: i.$container.querySelector(".jessibuca-ptz-expand")}), Object.defineProperty(r, "$ptzNarrow", {value: i.$container.querySelector(".jessibuca-ptz-narrow")}), Object.defineProperty(r, "$ptzApertureFar", {value: i.$container.querySelector(".jessibuca-ptz-aperture-far")}), Object.defineProperty(r, "$ptzApertureNear", {value: i.$container.querySelector(".jessibuca-ptz-aperture-near")}), Object.defineProperty(r, "$ptzFocusFar", {value: i.$container.querySelector(".jessibuca-ptz-focus-far")}), Object.defineProperty(r, "$ptzFocusNear", {value: i.$container.querySelector(".jessibuca-ptz-focus-near")}), Object.defineProperty(r, "$qualityText", {value: i.$container.querySelector(".jessibuca-quality-icon-text")}), Object.defineProperty(r, "$qualityMenu", {value: i.$container.querySelector(".jessibuca-quality-menu")}), Object.defineProperty(r, "$qualityMenuList", {value: i.$container.querySelector(".jessibuca-quality-menu-list")}), Object.defineProperty(r, "$scaleText", {value: i.$container.querySelector(".jessibuca-scale-icon-text")}), Object.defineProperty(r, "$scaleMenu", {value: i.$container.querySelector(".jessibuca-scale-menu")}), Object.defineProperty(r, "$scaleMenuList", {value: i.$container.querySelector(".jessibuca-scale-menu-list")}), Object.defineProperty(r, "$zoom", {value: i.$container.querySelector(".jessibuca-zoom")}), Object.defineProperty(r, "$zoomStop", {value: i.$container.querySelector(".jessibuca-zoom-stop")}), Object.defineProperty(r, "$zoomNarrow", {value: i.$container.querySelector(".jessibuca-zoom-narrow")}), Object.defineProperty(r, "$zoomExpand", {value: i.$container.querySelector(".jessibuca-zoom-expand")}), Object.defineProperty(r, "$zoomStop2", {value: i.$container.querySelector(".jessibuca-zoom-stop2")}), Object.defineProperty(r, "$close", {value: i.$container.querySelector(".jessibuca-close")}), Object.defineProperty(r, "$zoomControls", {value: i.$container.querySelector(".jessibuca-zoom-controls")}), Object.defineProperty(r, "$performancePanel", {value: i.$container.querySelector(".jessibuca-performance-panel")}), Object.defineProperty(r, "$performance", {value: i.$container.querySelector(".jessibuca-performance")}), Object.defineProperty(r, "$performanceActive", {value: i.$container.querySelector(".jessibuca-performance-active")}), Object.defineProperty(r, "$faceDetect", {value: i.$container.querySelector(".jessibuca-face")}), Object.defineProperty(r, "$faceDetectActive", {value: i.$container.querySelector(".jessibuca-face-active")}), Object.defineProperty(r, "$contextmenus", {value: i.$container.querySelector(".jessibuca-contextmenus")}), Object.defineProperty(r, "$speedText", {value: i.$container.querySelector(".jessibuca-speed-icon-text")}), Object.defineProperty(r, "$speedMenu", {value: i.$container.querySelector(".jessibuca-speed-menu")}), Object.defineProperty(r, "$speedMenuList", {value: i.$container.querySelector(".jessibuca-speed-menu-list")}), Object.defineProperty(r, "$logSave", {value: i.$container.querySelector(".jessibuca-logSave")}), Object.defineProperty(r, "$playbackProgress", {value: i.$container.querySelector(".jessibuca-control-progress-simple")}), Object.defineProperty(r, "$playbackProgressTip", {value: i.$container.querySelector(".jessibuca-progress-tip")}), Object.defineProperty(r, "$playbackProgressHover", {value: i.$container.querySelector(".jessibuca-progress-hover")}), Object.defineProperty(r, "$playbackProgressPlayed", {value: i.$container.querySelector(".jessibuca-progress-played")}), Object.defineProperty(r, "$playbackProgressIndicator", {value: i.$container.querySelector(".jessibuca-progress-indicator")}), Object.defineProperty(r, "$playbackProgressTime", {value: i.$container.querySelector(".jessibuca-playback-control-time")}), 0 < e._opt.extendOperateBtns.length && e._opt.extendOperateBtns.forEach(e => {
                this.addExtendBtn(e)
            }), t = this, Object.defineProperty(t, "controlsRect", {get: () => t.$controls.getBoundingClientRect()}), Object.defineProperty(t, "controlsInnerRect", {get: () => t.$controlsInner.getBoundingClientRect()}), Object.defineProperty(t, "controlsLeftRect", {get: () => t.$controlsLeft.getBoundingClientRect()}), Object.defineProperty(t, "controlsRightRect", {get: () => t.$controlsRight.getBoundingClientRect()}), Object.defineProperty(t, "controlsPlaybackTimeInner", {get: () => t.$playbackTimeInner && t.$playbackTimeInner.getBoundingClientRect() || {}}), Object.defineProperty(t, "controlsPlaybackBtnsRect", {get: () => t.$controlsPlaybackBtns && t.$controlsPlaybackBtns.getBoundingClientRect() || {width: 0}}), fa(e, this);
            {
                var o = e, l = this;
                const p = o["events"]["proxy"], f = o._opt, m = f.operateBtns;

                function d(e) {
                    var {bottom: t, height: i} = l.$volumePanel.getBoundingClientRect(),
                        r = l.$volumeHandle.getBoundingClientRect()["height"];
                    return E(t - e.y - r / 2, 0, i - r / 2) / (i - r)
                }

                if (xt() && p(window, ["click", "contextmenu"], e => {
                    -1 < e.composedPath().indexOf(o.$container) ? l.isFocus = !0 : l.isFocus = !1
                }), p(window, "orientationchange", () => {
                    setTimeout(() => {
                        o.resize()
                    }, 300)
                }), p(l.$controls, "click", e => {
                    e.stopPropagation()
                }), m.play && (p(l.$pause, "click", e => {
                    f.playType === A && f.playbackConfig.uiUsePlaybackPause ? o.playbackPause = !0 : b(m.pauseFn) ? m.pauseFn() : o.pauseForControl()
                }), p(l.$play, "click", e => {
                    f.playType === A && o.playbackPause ? o.playbackPause = !1 : b(m.playFn) ? m.playFn() : o.playForControl().then(() => {
                        o.resumeAudioAfterPause()
                    })
                })), p(l.$playBig, "click", e => {
                    f.playType === A && o.playbackPause ? o.playbackPause = !1 : b(m.playFn) ? m.playFn() : o.playForControl().then(() => {
                        o.resumeAudioAfterPause()
                    })
                }), m.screenshot && p(l.$screenshot, "click", e => {
                    e.stopPropagation(), b(m.screenshotFn) ? m.screenshotFn() : o.video.screenshot()
                }), m.audio && (xt() && (p(l.$volume, "mouseover", () => {
                    l.$volumePanelWrap.classList.add("jessibuca-volume-panel-wrap-show")
                }), p(l.$volume, "mouseout", () => {
                    l.$volumePanelWrap.classList.remove("jessibuca-volume-panel-wrap-show")
                }), p(l.$volumePanel, "click", e => {
                    e.stopPropagation(), o.volume = d(e)
                }), p(l.$volumeHandle, "mousedown", () => {
                    l.isVolumeDroging = !0
                }), p(l.$volumeHandle, "mousemove", e => {
                    l.isVolumeDroging && (o.volume = d(e))
                }), p(document, "mouseup", () => {
                    l.isVolumeDroging && (l.isVolumeDroging = !1)
                })), p(l.$volumeOn, "click", e => {
                    e.stopPropagation(), T(l.$volumeOn, "display", "none"), T(l.$volumeOff, "display", "block");
                    e = o.volume;
                    o.volume = 0, o._lastVolume = xt() ? e : 1
                }), p(l.$volumeOff, "click", e => {
                    e.stopPropagation(), T(l.$volumeOn, "display", "block"), T(l.$volumeOff, "display", "none"), o.volume = xt() ? o.lastVolume || .5 : 1
                })), m.record && (p(l.$record, "click", e => {
                    e.stopPropagation(), b(m.recordFn) ? m.recordFn() : o.recording = !0
                }), p(l.$recordStop, "click", e => {
                    e.stopPropagation(), b(m.recordStopFn) ? m.recordStopFn() : o.recording = !1
                })), p(l.$recordingStop, "click", e => {
                    e.stopPropagation(), b(m.recordStopFn) ? m.recordStopFn() : o.recording = !1
                }), m.fullscreen && (p(l.$fullscreen, "click", e => {
                    e.stopPropagation(), b(m.fullscreenFn) ? m.fullscreenFn() : o.fullscreen = !0
                }), p(l.$fullscreenExit, "click", e => {
                    e.stopPropagation(), b(m.fullscreenExitFn) ? m.fullscreenExitFn() : o.fullscreen = !1
                })), m.ptz) {
                    if (p(l.$ptz, "click", e => {
                        e.stopPropagation(), T(l.$ptzActive, "display", "flex"), T(l.$ptz, "display", "none"), l.$ptzControl.classList.add("jessibuca-ptz-controls-show")
                    }), p(l.$ptzActive, "click", e => {
                        e.stopPropagation(), T(l.$ptz, "display", "flex"), T(l.$ptzActive, "display", "none"), l.$ptzControl.classList.remove("jessibuca-ptz-controls-show")
                    }), l.$ptzArrows.forEach(e => {
                        if (f.ptzClickType === Z) p(e, "click", e => {
                            e.stopPropagation();
                            e = e.currentTarget.dataset.arrow;
                            l.$ptzBgActive.classList.add("jessibuca-ptz-bg-active-show"), l.$ptzBgActive.classList.add("jessibuca-ptz-bg-active-" + e), l.$ptzControlCircular.classList.add("jessibuca-ptz-control-" + e), o.emit(w.ptz, pi(e)), setTimeout(() => {
                                l.$ptzBgActive.classList.remove("jessibuca-ptz-bg-active-show"), Oe.forEach(e => {
                                    l.$ptzBgActive.classList.remove("jessibuca-ptz-bg-active-" + e), l.$ptzControlCircular.classList.remove("jessibuca-ptz-control-" + e)
                                }), o.emit(w.ptz, Ne)
                            }, 1e3 * f.ptzStopEmitDelay)
                        }); else if (f.ptzClickType === ee) {
                            let t = !1;
                            p(e, "mousedown", e => {
                                e.stopPropagation(), t = !0;
                                e = e.currentTarget.dataset.arrow;
                                l.$ptzBgActive.classList.add("jessibuca-ptz-bg-active-show"), l.$ptzBgActive.classList.add("jessibuca-ptz-bg-active-" + e), l.$ptzControlCircular.classList.add("jessibuca-ptz-control-" + e), o.emit(w.ptz, pi(e))
                            });
                            const i = () => {
                                t = !1, l.$ptzBgActive.classList.remove("jessibuca-ptz-bg-active-show"), Oe.forEach(e => {
                                    l.$ptzBgActive.classList.remove("jessibuca-ptz-bg-active-" + e), l.$ptzControlCircular.classList.remove("jessibuca-ptz-control-" + e)
                                }), o.emit(w.ptz, Ne)
                            };
                            p(e, "mouseup", e => {
                                e.stopPropagation(), t && i()
                            }), p(window, "mouseup", e => {
                                e.stopPropagation(), t && i()
                            })
                        }
                    }), f.ptzZoomShow) if (f.ptzClickType === Z) p(l.$ptzExpand, "click", e => {
                        e.stopPropagation(), o.emit(w.ptz, ze), setTimeout(() => {
                            o.emit(w.ptz, Ne)
                        }, 1e3 * f.ptzStopEmitDelay)
                    }), p(l.$ptzNarrow, "click", e => {
                        e.stopPropagation(), o.emit(w.ptz, Ge), setTimeout(() => {
                            o.emit(w.ptz, Ne)
                        }, 1e3 * f.ptzStopEmitDelay)
                    }); else if (f.ptzClickType === ee) {
                        let t = !1, i = !1;
                        p(l.$ptzExpand, "mousedown", e => {
                            e.stopPropagation(), t = !0, o.emit(w.ptz, ze)
                        }), p(l.$ptzNarrow, "mousedown", e => {
                            e.stopPropagation(), i = !0, o.emit(w.ptz, Ge)
                        });
                        const m = () => {
                            t = !1, i = !1, o.emit(w.ptz, Ne)
                        };
                        p(l.$ptzExpand, "mouseup", e => {
                            e.stopPropagation(), t && m()
                        }), p(l.$ptzNarrow, "mouseup", e => {
                            e.stopPropagation(), i && m()
                        }), p(window, "mouseup", e => {
                            e.stopPropagation(), (t || i) && m()
                        })
                    }
                    if (f.ptzApertureShow) if (f.ptzClickType === Z) p(l.$ptzApertureFar, "click", e => {
                        e.stopPropagation(), o.emit(w.ptz, He), setTimeout(() => {
                            o.emit(w.ptz, je)
                        }, 1e3 * f.ptzStopEmitDelay)
                    }), p(l.$ptzApertureNear, "click", e => {
                        e.stopPropagation(), o.emit(w.ptz, We), setTimeout(() => {
                            o.emit(w.ptz, je)
                        }, 1e3 * f.ptzStopEmitDelay)
                    }); else if (f.ptzClickType === ee) {
                        let t = !1, i = !1;
                        p(l.$ptzApertureFar, "mousedown", e => {
                            e.stopPropagation(), t = !0, o.emit(w.ptz, He)
                        }), p(l.$ptzApertureNear, "mousedown", e => {
                            e.stopPropagation(), i = !0, o.emit(w.ptz, We)
                        });
                        const m = () => {
                            t = !1, i = !1, o.emit(w.ptz, je)
                        };
                        p(l.$ptzApertureFar, "mouseup", e => {
                            e.stopPropagation(), t && m()
                        }), p(l.$ptzApertureNear, "mouseup", e => {
                            e.stopPropagation(), i && m()
                        }), p(window, "mouseup", e => {
                            e.stopPropagation(), (t || i) && m()
                        })
                    }
                    if (f.ptzFocusShow) if (f.ptzClickType === Z) p(l.$ptzFocusFar, "click", e => {
                        e.stopPropagation(), o.emit(w.ptz, Ve), setTimeout(() => {
                            o.emit(w.ptz, je)
                        }, 1e3 * f.ptzStopEmitDelay)
                    }), p(l.$ptzFocusNear, "click", e => {
                        e.stopPropagation(), o.emit(w.ptz, Ke), setTimeout(() => {
                            o.emit(w.ptz, je)
                        }, 1e3 * f.ptzStopEmitDelay)
                    }); else if (f.ptzClickType === ee) {
                        let t = !1, i = !1;
                        p(l.$ptzFocusFar, "mousedown", e => {
                            e.stopPropagation(), t = !0, o.emit(w.ptz, Ve)
                        }), p(l.$ptzFocusNear, "mousedown", e => {
                            e.stopPropagation(), i = !0, o.emit(w.ptz, Ke)
                        });
                        const m = () => {
                            t = !1, i = !1, o.emit(w.ptz, je)
                        };
                        p(l.$ptzFocusFar, "mouseup", e => {
                            e.stopPropagation(), t && m()
                        }), p(l.$ptzFocusNear, "mouseup", e => {
                            e.stopPropagation(), i && m()
                        }), p(window, "mouseup", e => {
                            e.stopPropagation(), (t || i) && m()
                        })
                    }
                }
                if (m.performance && (p(l.$performance, "click", e => {
                    e.stopPropagation(), o.togglePerformancePanel(!0)
                }), p(l.$performanceActive, "click", e => {
                    e.stopPropagation(), o.togglePerformancePanel(!1)
                })), m.logSave && p(l.$logSave, "click", e => {
                    e.stopPropagation(), o.downloadMemoryLog()
                }), m.aiFace && (p(l.$faceDetect, "click", e => {
                    e.stopPropagation(), o.faceDetect(!0)
                }), p(l.$faceDetectActive, "click", e => {
                    e.stopPropagation(), o.faceDetect(!1)
                })), o._opt.hasControl && o._opt.controlAutoHide) {
                    p(o.$container, "mouseover", () => {
                        o.fullscreen || (T(l.$controls, "display", "block"), f())
                    }), p(o.$container, "mousemove", () => {
                        o.$container && l.$controls && (o.fullscreen, "none" === l.$controls.style.display && (T(l.$controls, "display", "block"), f()))
                    }), p(o.$container, "mouseout", () => {
                        m(), T(l.$controls, "display", "none")
                    });
                    let e = null;
                    const f = () => {
                        m(), e = setTimeout(() => {
                            T(l.$controls, "display", "none")
                        }, 5e3)
                    }, m = () => {
                        e && (clearTimeout(e), e = null)
                    }
                }
                o._opt.playType === A && (n = o._opt.playbackConfig.controlType, o._opt.playbackConfig.showRateBtn && (p(l.$speedMenu, "mouseover", () => {
                    l.$speedMenuList.classList.add("jessibuca-speed-menu-shown")
                }), p(l.$speedMenu, "mouseout", () => {
                    l.$speedMenuList.classList.remove("jessibuca-speed-menu-shown")
                }), p(l.$speedMenuList, "click", e => {
                    const t = ei(e);
                    if (t.matches("div.jessibuca-speed-menu-item")) {
                        const e = t.dataset;
                        o.emit(w.playbackPreRateChange, e.speed)
                    }
                })), n === _ ? (p(l.$playbackNarrow, "click", e => {
                    e.stopPropagation(), o.playback && o.playback.narrowPrecision()
                }), p(l.$playbackExpand, "click", e => {
                    e.stopPropagation(), o.playback && o.playback.expandPrecision()
                }), p(l.$playbackTimeList, "click", e => {
                    const t = ei(e);
                    t.matches("div.jessibuca-playback-time-minute-one") && o.playback && o.playback.seek(t.dataset)
                }), o._opt.playbackConfig.supportWheel && p(l.$playbackTimeInner, "wheel", e => {
                    e.preventDefault(), 0 < (e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3) ? o.playback && o.playback.expandPrecision() : o.playback && o.playback.narrowPrecision()
                })) : n === te && (l.isDroging = !1, p(l.$playbackProgress, "click", i => {
                    if (i.target !== l.$playbackProgressIndicator) {
                        let e = 0, t = 0;
                        t = o.isInWebFullscreen() ? (e = i.touches[0].clientY / o.height) * o.playback.totalDuration : (i = ha(l, o.playback.totalDuration, i), e = i.percentage, i.second), o.playback && o.playback.seek({time: t})
                    }
                }), p(l.$playbackProgress, "mousemove", e => {
                    T(l.$playbackProgressTip, "display", "block");
                    var {width: e, time: t} = ha(l, o.playback.totalDuration, e),
                        t = (l.$playbackProgressTip.innerHTML = t, l.$playbackProgressTip.clientWidth);
                    e <= t / 2 ? T(l.$playbackProgressTip, "left", 0) : e > l.$playbackProgress.clientWidth - t / 2 ? T(l.$playbackProgressTip, "left", l.$playbackProgress - t + "px") : T(l.$playbackProgressTip, "left", e - t / 2 + "px")
                }), p(l.$playbackProgress, "mouseout", () => {
                    T(l.$playbackProgressTip, "display", "none")
                }), p(l.$playbackProgressIndicator, "mousedown", e => {
                    l.isDroging = !0
                }), p(l.$playbackProgress, "mousemove", e => {
                    var t;
                    l.isDroging && ({
                        second: e,
                        percentage: t
                    } = ha(l, o.playback.totalDuration, e), o.playback && o.playback.seek({time: e}))
                }), p(l.$playbackProgress, "mouseup", e => {
                    l.isDroging && (l.isDroging = !1)
                }))), m.quality && (p(l.$qualityMenu, "mouseover", () => {
                    l.$qualityMenuList.classList.add("jessibuca-quality-menu-shown")
                }), p(l.$qualityMenu, "mouseout", () => {
                    l.$qualityMenuList.classList.remove("jessibuca-quality-menu-shown")
                }), p(l.$qualityMenuList, "click", e => {
                    const t = ei(e);
                    if (t.matches("div.jessibuca-quality-menu-item")) {
                        const e = t.dataset;
                        o.streamQuality = e.quality
                    }
                })), m.scale && (p(l.$scaleMenu, "mouseover", () => {
                    l.$scaleMenuList.classList.add("jessibuca-scale-menu-shown")
                }), p(l.$scaleMenu, "mouseout", () => {
                    l.$scaleMenuList.classList.remove("jessibuca-scale-menu-shown")
                }), p(l.$scaleMenuList, "click", e => {
                    const t = ei(e);
                    if (t.matches("div.jessibuca-scale-menu-item")) {
                        const e = t.dataset;
                        o.setScaleMode(e.scale)
                    }
                })), m.zoom && (p(l.$zoom, "click", e => {
                    e.stopPropagation(), o.zooming = !0
                }), p(l.$zoomStop, "click", e => {
                    e.stopPropagation(), o.zooming = !1
                })), p(l.$zoomExpand, "click", e => {
                    e.stopPropagation(), o.zoom && o.zoom.expandPrecision()
                }), p(l.$zoomNarrow, "click", e => {
                    e.stopPropagation(), o.zoom && o.zoom.narrowPrecision()
                }), p(l.$zoomStop2, "click", e => {
                    e.stopPropagation(), o.zooming = !1
                }), m.close && p(l.$close, "click", e => {
                    e.stopPropagation(), o.doDestroy()
                })
            }
            if (e._opt.hotKey) {
                var h = e, c = this;
                const g = h["events"]["proxy"], y = {};

                function u(e, t) {
                    y[e] ? y[e].push(t) : y[e] = [t]
                }

                u(27, () => {
                    h.fullscreen && (h.fullscreen = !1)
                }), u(38, () => {
                    h.volume += .05
                }), u(40, () => {
                    h.volume -= .05
                }), g(window, "keydown", e => {
                    if (c.isFocus) {
                        const c = document.activeElement.tagName.toUpperCase(),
                            t = document.activeElement.getAttribute("contenteditable");
                        if ("INPUT" !== c && "TEXTAREA" !== c && "" !== t && "true" !== t) {
                            const c = y[e.keyCode];
                            c && (e.preventDefault(), c.forEach(e => e()))
                        }
                    }
                })
            }
            this.btnIndex = 0, this.initLoadingBackground(), this.kbpsShow = "0 KB/s", this.player.debug.log("Control", "init")
        }

        destroy() {
            var e;
            this.$performancePanel && (this.$performancePanel.innerHTML = "", pa(this.$performancePanel) || (e = this.player.$container.querySelector(".jessibuca-performance-panel")) && this.player.$container && this.player.$container.removeChild(e)), this.$poster && !pa(this.$poster) && (e = this.player.$container.querySelector(".jessibuca-poster")) && this.player.$container && this.player.$container.removeChild(e), this.$loading && !pa(this.$loading) && (e = this.player.$container.querySelector(".jessibuca-loading")) && this.player.$container && this.player.$container.removeChild(e), this.$loadingBg && !pa(this.$loadingBg) && (e = this.player.$container.querySelector(".jessibuca-loading-bg")) && this.player.$container && this.player.$container.removeChild(e), this.$controls && !pa(this.$controls) && (e = this.player.$container.querySelector(".jessibuca-controls")) && this.player.$container && this.player.$container.removeChild(e), this.$playBig && !pa(this.$playBig) && (e = this.player.$container.querySelector(".jessibuca-play-big")) && this.player.$container && this.player.$container.removeChild(e), this.$recording && !pa(this.$recording) && (e = this.player.$container.querySelector(".jessibuca-recording")) && this.player.$container && this.player.$container.removeChild(e), this.$ptzControl && !pa(this.$ptzControl) && (e = this.player.$container.querySelector(".jessibuca-ptz-controls")) && this.player.$container && this.player.$container.removeChild(e), this.$zoomControls && !pa(this.$zoomControls) && (e = this.player.$container.querySelector(".jessibuca-zoom-controls")) && this.player.$container && this.player.$container.removeChild(e), this.$contextmenus && (this.$contextmenus.innerHTML = "", pa(this.$contextmenus) || (e = this.player.$container.querySelector(".jessibuca-contextmenus")) && this.player.$container && this.player.$container.removeChild(e)), this.btnIndex = 0, this.extendBtnList = [], this.kbpsShow = "0 KB/s", this.player.$container && (this.player.$container.classList.remove("jessibuca-controls-show-auto-hide"), this.player.$container.classList.remove("jessibuca-controls-show")), this.player.debug.log("Control", "destroy")
        }

        getBtnIndex() {
            return this.btnIndex++
        }

        autoSize() {
            const e = this.player, t = (e.$container.style.padding = "0 0", e.width), i = e.height, r = t / i,
                s = e.video.$videoElement.width / e.video.$videoElement.height;
            if (r > s) {
                const r = (t - i * s) / 2;
                e.$container.style.padding = `0 ${r}px`
            } else {
                const r = (i - t / s) / 2;
                e.$container.style.padding = r + "px 0"
            }
        }

        initLoadingBackground() {
            const e = this.player;
            e._opt.loadingBackground && e._opt.loadingBackgroundWidth && e._opt.loadingBackgroundHeight && (e.debug.log("Control", "initLoadingBackground()"), "default" === this.player._opt.aspectRatio || y() ? e.getRenderType() !== Y && e.getRenderType() !== J || this._initLoadingBackground() : this._initLoadingBackgroundForRatio(), U(this.$loadingBg, "display", "block"), e._opt.loadingBackground = "", e._opt.loadingBackgroundWidth = 0, e._opt.loadingBackgroundHeight = 0)
        }

        _initLoadingBackgroundForRatio() {
            const e = this.player._opt.aspectRatio.split(":").map(Number);
            let t = this.player.width, i = this.player.height;
            var r = this.player._opt;
            let s = 0;
            r.hasControl && !r.controlAutoHide && (s = r.playType === A ? 48 : 38, i -= s);
            var r = this.player._opt.loadingBackgroundWidth, a = this.player._opt.loadingBackgroundHeight, n = r / a,
                o = e[0] / e[1];
            if (this.$loadingBgImage.src = this.player._opt.loadingBackground, o < n) {
                const e = o * a / r;
                this.$loadingBgImage.style.width = 100 * e + "%", this.$loadingBgImage.style.height = `calc(100% - ${s}px)`, this.$loadingBgImage.style.padding = `0 ${(t - t * e) / 2}px`
            } else {
                const e = r / o / a;
                this.$loadingBgImage.style.width = "100%", this.$loadingBgImage.style.height = `calc(${100 * e}% - ${s}px)`, this.$loadingBgImage.style.padding = (i - i * e) / 2 + "px 0"
            }
        }

        _initLoadingBackgroundForCanvas() {
            var e = this.player._opt;
            let t = this.player.width, i = this.player.height;
            if (e.hasControl && !e.controlAutoHide) {
                const r = e.playType === A ? 48 : 38;
                y() && this.player.fullscreen && e.useWebFullScreen ? t -= r : i -= r
            }
            let r = {width: this.player._opt.loadingBackgroundWidth, height: this.player._opt.loadingBackgroundHeight},
                s = r.width, a = r.height;
            var n = e.rotate, o = (t - s) / 2, l = (i - a) / 2,
                d = (270 !== n && 90 !== n || (s = r.height, a = r.width), t / s), h = i / a;
            let c = h < d ? h : d,
                u = (e.isResize || d != h && (c = d + "," + h), "scale(" + (c = e.isFullResize ? h < d ? d : h : c) + ")");
            "none" === e.mirrorRotate && n && (u += " rotate(" + n + "deg)"), "level" === e.mirrorRotate ? u += " rotateY(180deg)" : "vertical" === e.mirrorRotate && (u += " rotateX(180deg)"), this.$loadingBgImage.src = this.player._opt.loadingBackground, this.$loadingBgImage.style.height = r.height + "px", this.$loadingBgImage.style.width = r.width + "px", this.$loadingBgImage.style.padding = "0", this.$loadingBgImage.style.transform = u, this.$loadingBgImage.style.left = o + "px", this.$loadingBgImage.style.top = l + "px", this.$loadingBgImage.style.display = "block"
        }

        _initLoadingBackground() {
            var e = this.player;
            let t = e.height;
            var i = e._opt;
            i.hasControl && !i.controlAutoHide && (t -= i.playType === A ? 48 : 38);
            let r = e.width, s = t;
            var a = i.rotate;
            270 !== a && 90 !== a || (r = t, s = e.width), this.$loadingBgImage.width = r, this.$loadingBgImage.height = s, this.$loadingBgImage.src = e._opt.loadingBackground;
            let n = (e.width - r) / 2, o = (t - s) / 2, l = "contain",
                d = (i.isResize || (l = "fill"), i.isFullResize && (l = "none"), "");
            "none" === i.mirrorRotate && a && (d += " rotate(" + a + "deg)"), "level" === i.mirrorRotate ? d += " rotateY(180deg)" : "vertical" === i.mirrorRotate && (d += " rotateX(180deg)"), this.player._opt.videoRenderSupportScale && (this.$loadingBgImage.style.objectFit = l), this.$loadingBgImage.style.transform = d, this.$loadingBgImage.style.padding = "0", this.$loadingBgImage.style.left = n + "px", this.$loadingBgImage.style.top = o + "px"
        }

        _validateExtendBtn(t) {
            let e = !0;
            return t.name || (this.player.debug.warn("Control", "extend button name is required"), e = !1), e && -1 !== this.extendBtnList.findIndex(e => e.name === t.name) && (this.player.debug.warn("Control", `extend button name: ${t.name} is already exist`), e = !1), e && !t.icon && (this.player.debug.warn("Control", "extend button icon is required"), e = !1), e
        }

        addExtendBtn() {
            let t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            var e = di(st);
            if (t = Object.assign({}, e, t), this._validateExtendBtn(t)) {
                const i = t.name || "", r = this.$controlsRight, s = t.activeIcon && t.activeClick, a = `
            <div class="jessibuca-controls-item-wrap jessibuca-controls-item-wrap-${i}">
               ${t.icon ? `<div class="jessibuca-controls-item jessibuca-control-extend-${i}">
                                <i class="jessibuca-icon jessibuca-icon-extend-${i}"></i>
                                ${t.iconTitle ? `
                                            <span class="icon-title-tips"><span class="icon-title">${t.iconTitle}</span></span>
                                            ` : ""}
                                </div>` : ""}
               ${t.activeIcon ? `<div class="jessibuca-controls-item jessibuca-control-extend-${i}-active">
                                <i class="jessibuca-icon jessibuca-icon-extend-${i}-active"></i>
                                ${t.activeIconTitle ? `
                                            <span class="icon-title-tips"><span class="icon-title">${t.activeIconTitle}</span></span>
                                            ` : ""}
                            </div>` : ""}
               </div>
            `, n = Array.from(r.children)[t.index],
                    o = (n ? n.insertAdjacentHTML("beforebegin", a) : ca(r, a), r.querySelector(".jessibuca-controls-item-wrap-" + i)),
                    l = t.icon ? r.querySelector(".jessibuca-icon-extend-" + i) : null,
                    d = t.icon ? r.querySelector(".jessibuca-control-extend-" + i) : null,
                    h = t.activeIcon ? r.querySelector(`.jessibuca-icon-extend-${i}-active`) : null,
                    c = t.activeIcon ? r.querySelector(`.jessibuca-control-extend-${i}-active`) : null, {proxy: u} = this.player["events"];
                t.icon && (U(l, "background", `url(${t.icon}) no-repeat center`), U(l, "background-size", "100% 100%"), U(d, "display", "none"), t.iconHover && (u(l, "mouseover", () => {
                    U(l, "background", `url(${t.iconHover}) no-repeat center`), U(l, "background-size", "100% 100%")
                }), u(l, "mouseout", () => {
                    U(l, "background", `url(${t.icon}) no-repeat center`), U(l, "background-size", "100% 100%")
                }))), t.activeIcon && (U(h, "background", `url(${t.activeIcon}) no-repeat center`), U(h, "background-size", "100% 100%"), U(c, "display", "none"), t.activeIconHover && (u(h, "mouseover", () => {
                    U(h, "background", `url(${t.activeIconHover}) no-repeat center`), U(h, "background-size", "100% 100%")
                }), u(h, "mouseout", () => {
                    U(h, "background", `url(${t.activeIcon}) no-repeat center`), U(h, "background-size", "100% 100%")
                }))), t.click && l && u(l, "click", e => {
                    e.preventDefault(), s && (U(d, "display", "none"), U(c, "display", "flex")), this.player.isInMulti() ? t.click.call(this.player, e, this.player._opt.multiIndex) : t.click.call(this.player, e)
                }), t.activeClick && h && u(h, "click", e => {
                    e.preventDefault(), U(d, "display", "flex"), U(c, "display", "none"), this.player.isInMulti() ? t.activeClick.call(this.player, e, this.player._opt.multiIndex) : t.activeClick.call(this.player, e)
                }), this.extendBtnList.push({name: i, $iconContainer: o, $iconWrap: d, $activeIconWrap: c})
            }
        }

        updateLoadingText(e) {
            this.$loadingText && (this.$loadingText.innerText = e)
        }

        getExtendBtnList() {
            return this.extendBtnList
        }
    }

    ma(".jessibuca-container{position:relative;width:100%;height:100%;overflow:hidden}.jessibuca-container.jessibuca-fullscreen-web{position:fixed;z-index:9999;left:0;top:0;right:0;bottom:0;width:100vw!important;height:100vh!important;background:#000}");

    class F {
        static init() {
            for (var e in F.types = {
                avc1: [],
                avcC: [],
                hvc1: [],
                hvcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                mvex: [],
                mvhd: [],
                sdtp: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
                smhd: []
            }, F.types) F.types.hasOwnProperty(e) && (F.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
            let t = F.constants = {};
            t.FTYP = new Uint8Array([105, 115, 111, 109, 0, 0, 0, 1, 105, 115, 111, 109, 97, 118, 99, 49]), t.STSD_PREFIX = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), t.STTS = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t.STSC = t.STCO = t.STTS, t.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), t.HDLR_VIDEO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), t.HDLR_AUDIO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), t.DREF = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), t.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
        }

        static box(e) {
            let t = 8, i = null, r = Array.prototype.slice.call(arguments, 1), s = r.length;
            for (let e = 0; e < s; e++) t += r[e].byteLength;
            (i = new Uint8Array(t))[0] = t >>> 24 & 255, i[1] = t >>> 16 & 255, i[2] = t >>> 8 & 255, i[3] = 255 & t, i.set(e, 4);
            let a = 8;
            for (let e = 0; e < s; e++) i.set(r[e], a), a += r[e].byteLength;
            return i
        }

        static generateInitSegment(e) {
            let t = F.box(F.types.ftyp, F.constants.FTYP), i = F.moov(e),
                r = new Uint8Array(t.byteLength + i.byteLength);
            return r.set(t, 0), r.set(i, t.byteLength), r
        }

        static moov(e) {
            var t = F.mvhd(e.timescale, e.duration), i = F.trak(e), e = F.mvex(e);
            return F.box(F.types.moov, t, i, e)
        }

        static mvhd(e, t) {
            return F.box(F.types.mvhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]))
        }

        static trak(e) {
            return F.box(F.types.trak, F.tkhd(e), F.mdia(e))
        }

        static tkhd(e) {
            var t = e.id, i = e.duration, r = e.presentWidth, e = e.presentHeight;
            return F.box(F.types.tkhd, new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, 0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >>> 8 & 255, 255 & r, 0, 0, e >>> 8 & 255, 255 & e, 0, 0]))
        }

        static mdia(e) {
            return F.box(F.types.mdia, F.mdhd(e), F.hdlr(e), F.minf(e))
        }

        static mdhd(e) {
            var t = e.timescale, e = e.duration;
            return F.box(F.types.mdhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, 85, 196, 0, 0]))
        }

        static hdlr(e) {
            e = "audio" === e.type ? F.constants.HDLR_AUDIO : F.constants.HDLR_VIDEO;
            return F.box(F.types.hdlr, e)
        }

        static minf(e) {
            var t = "audio" === e.type ? F.box(F.types.smhd, F.constants.SMHD) : F.box(F.types.vmhd, F.constants.VMHD);
            return F.box(F.types.minf, t, F.dinf(), F.stbl(e))
        }

        static dinf() {
            return F.box(F.types.dinf, F.box(F.types.dref, F.constants.DREF))
        }

        static stbl(e) {
            return F.box(F.types.stbl, F.stsd(e), F.box(F.types.stts, F.constants.STTS), F.box(F.types.stsc, F.constants.STSC), F.box(F.types.stsz, F.constants.STSZ), F.box(F.types.stco, F.constants.STCO))
        }

        static stsd(e) {
            return "audio" === e.type ? F.box(F.types.stsd, F.constants.STSD_PREFIX, F.mp4a(e)) : "avc" === e.videoType ? F.box(F.types.stsd, F.constants.STSD_PREFIX, F.avc1(e)) : F.box(F.types.stsd, F.constants.STSD_PREFIX, F.hvc1(e))
        }

        static mp4a(e) {
            var t = e.channelCount, i = e.audioSampleRate,
                t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t, 0, 16, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, 0, 0]);
            return F.box(F.types.mp4a, t, F.esds(e))
        }

        static esds(e) {
            var e = e.config || [], t = e.length,
                t = new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e).concat([6, 1, 2]));
            return F.box(F.types.esds, t)
        }

        static avc1(e) {
            var t = e.avcc, i = e.codecWidth, e = e.codecHeight,
                i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, e >>> 8 & 255, 255 & e, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 255, 255]);
            return F.box(F.types.avc1, i, F.box(F.types.avcC, t))
        }

        static hvc1(e) {
            var t = e.avcc, i = e.codecWidth, e = e.codecHeight,
                i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, e >>> 8 & 255, 255 & e, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 255, 255]);
            return F.box(F.types.hvc1, i, F.box(F.types.hvcC, t))
        }

        static mvex(e) {
            return F.box(F.types.mvex, F.trex(e))
        }

        static trex(e) {
            e = e.id, e = new Uint8Array([0, 0, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]);
            return F.box(F.types.trex, e)
        }

        static moof(e, t) {
            return F.box(F.types.moof, F.mfhd(e.sequenceNumber), F.traf(e, t))
        }

        static mfhd(e) {
            e = new Uint8Array([0, 0, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e]);
            return F.box(F.types.mfhd, e)
        }

        static traf(e, t) {
            var i = e.id,
                i = F.box(F.types.tfhd, new Uint8Array([0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i])),
                t = F.box(F.types.tfdt, new Uint8Array([0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t])),
                r = F.sdtp(e), e = F.trun(e, r.byteLength + 16 + 16 + 8 + 16 + 8 + 8);
            return F.box(F.types.traf, i, t, e, r)
        }

        static sdtp(e) {
            let t = new Uint8Array(5), i = e.flags;
            return t[4] = i.isLeading << 6 | i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy, F.box(F.types.sdtp, t)
        }

        static trun(e, t) {
            let i = new Uint8Array(28);
            t += 36, i.set([0, 0, 15, 1, 0, 0, 0, 1, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0);
            var t = e.duration, r = e.size, s = e.flags, e = e.cts;
            return i.set([t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, s.isLeading << 2 | s.dependsOn, s.isDependedOn << 6 | s.hasRedundancy << 4 | s.isNonSync, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e], 12), F.box(F.types.trun, i)
        }

        static mdat(e) {
            return F.box(F.types.mdat, e)
        }
    }

    F.init();

    class ya extends e {
        constructor(e) {
            super(), this.player = e, this.isAvc = !0, this.mediaSource = new window.MediaSource, this.sourceBuffer = null, this.hasInit = !1, this.isInitInfo = !1, this.cacheTrack = {}, this.timeInit = !1, this.sequenceNumber = 0, this.dropping = !1, this.firstRenderTime = null, this.$videoElement = null, this.mediaSourceAppendBufferFull = !1, this.mediaSourceAppendBufferError = !1, this.mediaSourceAddSourceBufferError = !1, this.mediaSourceError = !1, this.isDecodeFirstIIframe = !!C(e._opt.checkFirstIFrame), this.prevTimestamp = null, this.decodeDiffTimestamp = null, this.prevDts = null, this.prevPayloadBufferSize = 0, this.isWidthOrHeightChanged = !1, this.prevTs = null, this.mediaSourceObjectURL = window.URL.createObjectURL(this.mediaSource), this.eventListenList = [], this.tempFmp4List = [], e._opt.mseUseCanvasRender ? (this.$videoElement = document.createElement("video"), this.$videoElement.src = this.mediaSourceObjectURL, this.initVideoEvents()) : (this.player.video.$videoElement.src = this.mediaSourceObjectURL, this.$videoElement = this.player.video.$videoElement), this._bindMediaSourceEvents(), e.debug.log("MediaSource", "init")
        }

        destroy() {
            this.stop(), this.eventListenList.length && (this.eventListenList.forEach(e => e()), this.eventListenList = []), this.tempFmp4List = [], this.mediaSource = null, this.sourceBuffer = null, this.hasInit = !1, this.isInitInfo = !1, this.sequenceNumber = 0, this.cacheTrack = {}, this.timeInit = !1, this.mediaSourceAppendBufferFull = !1, this.mediaSourceAppendBufferError = !1, this.mediaSourceAddSourceBufferError = !1, this.mediaSourceError = !1, this.isDecodeFirstIIframe = !1, this.prevTimestamp = null, this.prevDts = null, this.prevPayloadBufferSize = 0, this.prevTs = null, this.firstRenderTime = null, this.isWidthOrHeightChanged = !1, this.dropping = !1, this.$videoElement && (this.player._opt.mseUseCanvasRender && this.$videoElement.src && (this.$videoElement.src = "", this.$videoElement.removeAttribute("src")), this.$videoElement = null), this.mediaSourceObjectURL && (window.URL.revokeObjectURL(this.mediaSourceObjectURL), this.mediaSourceObjectURL = null), this.off(), this.player.debug.log("MediaSource", "destroy")
        }

        get state() {
            return this.mediaSource && this.mediaSource.readyState
        }

        get isStateOpen() {
            return "open" === this.state
        }

        get isStateClosed() {
            return "closed" === this.state
        }

        get isStateEnded() {
            return "ended" === this.state
        }

        get duration() {
            return this.mediaSource && this.mediaSource.duration || -1
        }

        set duration(e) {
            this.mediaSource.duration = e
        }

        _bindMediaSourceEvents() {
            const {proxy: e} = this.player["events"], t = e(this.mediaSource, "sourceopen", () => {
                this.player && this.player.emit(w.mseSourceOpen)
            }), i = e(this.mediaSource, "sourceclose", () => {
                this.player && this.player.emit(w.mseSourceClose)
            }), r = e(this.mediaSource, "sourceended", () => {
                this.player && this.player.emit(w.mseSourceended)
            });
            if (this.eventListenList.push(t, i, r), this.player.isPlayer) {
                const s = e(this.$videoElement, Qe, e => {
                    this._handleUpdatePlaybackRate(), !this.player._opt.mseUseCanvasRender || this.player.checkIsInRender() ? this.player.handleRender() : (e = parseInt(e.timeStamp, 10), this.player.debug.warn("MediaSource", `mseUseCanvasRender is true and $videoElement ts is ${e}, but not in render`))
                }), t = e(this.$videoElement, Xe, () => {
                    this.player.debug.log("MediaSource", "video playback Rate change", this.$videoElement && this.$videoElement.playbackRate)
                });
                this.eventListenList.push(s, t)
            }
        }

        initVideoEvents() {
            const e = this.player.events["proxy"], t = e(this.$videoElement, Ye, () => {
                this.player.debug.log("MediaSource", "video canplay"), this.$videoElement.play().then(() => {
                    this.player.emit(w.removeLoadingBgImage), this.player.debug.log("MediaSource", "video play")
                }).catch(e => {
                    this.player.debug.error("MediaSource", "video play error ", e), this.player.emitError(S.mediaSourceUseCanvasRenderPlayFailed, e)
                })
            }), i = e(this.$videoElement, Je, () => {
                this.player.debug.log("MediaSource", "video waiting")
            }), r = e(this.$videoElement, Qe, e => {
                e = parseInt(e.timeStamp, 10);
                this.player.emit(w.videoTimeUpdate, e), this.$videoElement.paused && (this.player.debug.warn("MediaSource", "video is paused and next try to replay"), this.$videoElement.play().then(() => {
                    this.player.debug.log("MediaSource", "video is paused and replay success")
                }).catch(e => {
                    this.player.debug.warn("MediaSource", "video is paused and replay error ", e)
                }))
            });
            this.eventListenList.push(t, i, r)
        }

        decodeVideo(t, i, r, s) {
            const e = this.player;
            if (e) if (this.player.isDestroyed()) this.player.debug.warn("MediaSource", "decodeVideo() player is destroyed"); else if (this.hasInit) if (this.isDecodeFirstIIframe || r || this.player.debug.warn("MediaSource", "VideoDecoder isDecodeFirstIIframe false and isIframe is false"), !this.isDecodeFirstIIframe && r && (this.isDecodeFirstIIframe = !0), this.isDecodeFirstIIframe) {
                if (r && 0 === t[1]) {
                    const i = 15 & t[0];
                    let e = {};
                    7 == i ? e = cr(t.slice(5)) : 12 == i && (e = br(t));
                    const s = this.player.video.videoInfo;
                    s && s.width && s.height && e && e.codecWidth && e.codecHeight && (e.codecWidth !== s.width || e.codecHeight !== s.height) && (this.player.debug.warn("MediaSource", `
                        decodeVideo: video width or height is changed,
                        old width is ${s.width}, old height is ${s.height},
                        new width is ${e.codecWidth}, new height is ${e.codecHeight},
                        and emit change event`), this.isWidthOrHeightChanged = !0, this.player.emitError(S.mseWidthOrHeightChange))
                }
                if (this.isWidthOrHeightChanged) this.player.debug.warn("MediaSource", "decodeVideo: video width or height is changed, and return"); else if (ui(t)) this.player.debug.warn("MediaSource", "decodeVideo and payload is video sequence header so drop this frame"); else if (t.byteLength < 12) this.player.debug.warn("MediaSource", "decodeVideo and payload is too small , payload length is " + t.byteLength); else {
                    null === this.firstRenderTime && (this.firstRenderTime = i);
                    let e = i - this.firstRenderTime;
                    if (e < 0 && (this.player.debug.warn("MediaSource", `decodeVideo
                     local dts is < 0 , ts is ${i} and prevTs is ${this.prevTs},
                     firstRenderTime is ${this.firstRenderTime} and mseCorrectTimeDuration is ` + this.player._opt.mseCorrectTimeDuration), e = null === this.prevDts ? 0 : this.prevDts + this.player._opt.mseCorrectTimeDuration, this._checkTsIsMaxDiff(i))) return this.player.debug.warn("MediaSource", `decodeVideo is max diff , ts is ${i} and prevTs is ${this.prevTs}, diff is ` + (this.prevTs - i)), void this.emit(S.mediaSourceTsIsMaxDiff);
                    if (null !== this.prevDts && e <= this.prevDts) {
                        if (this.player.debug.warn("MediaSource", `
                    decodeVideo dts is less than(or equal) prev dts ,
                    dts is ${e} and prev dts is ${this.prevDts} ，
                    and now ts is ${i} and prev ts is ${this.prevTs} ，
                    and diff is ${i - this.prevTs} and firstRenderTime is ${this.firstRenderTime}，
                    and mseCorrectTimeDuration is ${this.player._opt.mseCorrectTimeDuration},
                    and prevPayloadBufferSize is ${this.prevPayloadBufferSize} and payload size is ` + t.byteLength), e === this.prevDts && this.prevPayloadBufferSize === t.byteLength) return void this.player.debug.warn("MediaSource", "decodeVideo dts is equal to prev dts and payload size is equal to prev payload size so drop this frame");
                        if (e = this.prevDts + this.player._opt.mseCorrectTimeDuration, this._checkTsIsMaxDiff(i)) return this.player.debug.warn("MediaSource", `decodeVideo is max diff , ts is ${i} and prevTs is ${this.prevTs}, diff is ${this.prevTs - i} and emit replay`), void this.emit(S.mediaSourceTsIsMaxDiff)
                    }
                    this._decodeVideo(t, e, r, s, i), this.prevDts = e, this.prevPayloadBufferSize = t.byteLength, this.prevTs = i, this.player.getRenderType() === J && this.player.video && this.player.video.doAddContentToWatermark()
                }
            } else this.player.debug.warn("MediaSource", "decodeVideo isDecodeFirstIIframe false"); else if (r && 0 === t[1]) {
                const s = 15 & t[0];
                (e.video.updateVideoInfo({encTypeCode: s}), 12 != s || Ot()) ? (e._times.decodeStart || (e._times.decodeStart = p()), this.hasInit = this._decodeConfigurationRecord(t, i, r, s)) : this.emit(S.mediaSourceH265NotSupport)
            } else this.player.debug.warn("MediaSource", `decodeVideo has not init , isIframe is ${r} , payload is ` + t[1])
        }

        _checkTsIsMaxDiff(e) {
            return 0 < this.prevTs && e < this.prevTs && 36e5 < this.prevTs - e
        }

        _decodeConfigurationRecord(e, t, i, r) {
            let s = e.slice(5), a = {};
            if (7 === r ? a = cr(s) : 12 === r && (a = br(e)), this.player.recorder && this.player._opt.recordType === u && this.player.recorder.initMetaData(e, r), 0 === a.codecWidth && 0 === a.codecHeight) return this.player.debug.warn("MediaSource", "_decodeConfigurationRecord", a), this.emit(S.mediaSourceDecoderConfigurationError), !1;
            e = {
                id: 1,
                type: "video",
                timescale: 1e3,
                duration: 0,
                avcc: s,
                codecWidth: a.codecWidth,
                codecHeight: a.codecHeight,
                videoType: a.videoType
            }, e = F.generateInitSegment(e);
            return this.isAvc = 7 === r, this.appendBuffer(e.buffer), this.sequenceNumber = 0, this.cacheTrack = {}, !(this.timeInit = !1)
        }

        _decodeVideo(e, s, t, i, a) {
            const n = this.player;
            let r = e.slice(5), o = r.byteLength, l = (new Date).getTime(), d = !1;
            this.prevTimestamp || (this.prevTimestamp = l, d = !0);
            e = l - this.prevTimestamp;
            500 < (this.decodeDiffTimestamp = e) && !d && n.debug.warn("MediaSource", `_decodeVideo now time is ${l} and prev time is ${this.prevTimestamp}, diff time is ${e} ms`);
            const h = this.$videoElement, c = n._opt.videoBufferDelay + n._opt.videoBuffer;
            if (1 < h.buffered.length && (this.removeBuffer(h.buffered.start(0), h.buffered.end(0)), this.timeInit = !1), this.dropping && this.cacheTrack.id && s - this.cacheTrack.dts > c) n.debug.warn("MediaSource", "dropping time is ", s - this.cacheTrack.dts), this.dropping = !1, this.cacheTrack = {}; else if (this.cacheTrack.id && s >= this.cacheTrack.dts) {
                let e = 8 + this.cacheTrack.size, t = new Uint8Array(e),
                    i = (t[0] = e >>> 24 & 255, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = 255 & e, t.set(F.types.mdat, 4), t.set(this.cacheTrack.data, 8), this.cacheTrack.duration = s - this.cacheTrack.dts, this.player.recorder && this.player.recorder.isRecording && this.player._opt.recordType === u && this.player.recorder.handleAddFmp4Track(this.cacheTrack), F.moof(this.cacheTrack, this.cacheTrack.dts)),
                    r = new Uint8Array(i.byteLength + t.byteLength);
                r.set(i, 0), r.set(t, i.byteLength), this.appendBuffer(r.buffer), n.emit(w.timeUpdate, a), n.videoTimestamp = a, n.updateStats({
                    fps: !0,
                    ts: a,
                    mseTs: s
                }), n._times.videoStart || (n._times.videoStart = p(), n.handlePlayToRenderTimes())
            } else n.debug.log("MediaSource", `timeInit set false , cacheTrack = {} now dts is ${s}, and ts is ${a} cacheTrack dts is ` + (this.cacheTrack && this.cacheTrack.dts)), this.timeInit = !1, this.cacheTrack = {};
            this.cacheTrack || (this.cacheTrack = {}), this.cacheTrack.id = 1, this.cacheTrack.sequenceNumber = ++this.sequenceNumber, this.cacheTrack.size = o, this.cacheTrack.dts = s, this.cacheTrack.cts = i, this.cacheTrack.isKeyframe = t, this.cacheTrack.data = r, this.cacheTrack.flags = {
                isLeading: 0,
                dependsOn: t ? 2 : 1,
                isDependedOn: t ? 1 : 0,
                hasRedundancy: 0,
                isNonSync: t ? 0 : 1
            }, this.timeInit || 1 !== h.buffered.length || (n.debug.log("MediaSource", "timeInit set true"), this.timeInit = !0, h.currentTime = h.buffered.end(0)), !this.isInitInfo && 0 < h.videoWidth && 0 < h.videoHeight && (n.debug.log("MediaSource", `updateVideoInfo: ${h.videoWidth},` + h.videoHeight), n.video.updateVideoInfo({
                width: h.videoWidth,
                height: h.videoHeight
            }), n.video.initCanvasViewSize(), this.isInitInfo = !0), n._opt.mseUseCanvasRender && n.video.render({
                $video: h,
                ts: s
            }), this.prevTimestamp = (new Date).getTime()
        }

        appendBuffer(r) {
            const {debug: s, events: {proxy: e}} = this.player;
            if (this.mediaSourceAddSourceBufferError) s.warn("MediaSource", "this.mediaSourceAddSourceBufferError is true"); else {
                if (null === this.sourceBuffer) {
                    var t = this.isAvc ? Ie : Re;
                    try {
                        this.sourceBuffer = this.mediaSource.addSourceBuffer(t)
                    } catch (r) {
                        return s.error("MediaSource", "this.mediaSource.addSourceBuffer()", r.code, r), this.player.emitError(S.mseAddSourceBufferError, r), void (this.mediaSourceAddSourceBufferError = !0)
                    }
                    if (this.sourceBuffer) {
                        const r = e(this.sourceBuffer, "error", e => {
                            this.player.emitError(S.mseSourceBufferError, e)
                        }), s = e(this.sourceBuffer, "updateend", () => {
                        });
                        this.eventListenList.push(r, s)
                    }
                }
                if (this.mediaSourceAppendBufferFull) s.warn("MediaSource", "this.mediaSourceAppendBufferFull is true"); else if (this.mediaSourceAppendBufferError) s.warn("MediaSource", "this.mediaSourceAppendBufferError is true"); else if (!1 === this.sourceBuffer.updating && this.isStateOpen) try {
                    let e = r;
                    if (0 < this.tempFmp4List.length) {
                        s.log("MediaSource", `this.tempFmp4List.length = ${this.tempFmp4List.length} and merge buffer`);
                        let t = 0;
                        this.tempFmp4List.push(r);
                        for (let e = 0; e < this.tempFmp4List.length; e++) t += this.tempFmp4List[e].byteLength;
                        const a = new Uint8Array(t);
                        let i = 0;
                        for (let e = 0; e < this.tempFmp4List.length; e++) {
                            const s = new Uint8Array(this.tempFmp4List[e]);
                            a.set(s, i), i += this.tempFmp4List[e].byteLength
                        }
                        e = a, this.tempFmp4List = []
                    }
                    this.sourceBuffer.appendBuffer(e)
                } catch (r) {
                    s.error("MediaSource", "this.sourceBuffer.appendBuffer()", r.code, r), 22 === r.code ? (this.stop(), this.mediaSourceAppendBufferFull = !0, this.emit(S.mediaSourceFull)) : 11 === r.code ? (this.stop(), this.mediaSourceAppendBufferError = !0, this.emit(S.mediaSourceAppendBufferError)) : (s.error("MediaSource", "appendBuffer error", r), this.player.emitError(w.mseSourceBufferError, r))
                } else this.isStateClosed ? this.player.emitError(S.mseSourceBufferError, "mediaSource is not attached to video or mediaSource is closed") : this.isStateEnded ? this.player.emitError(S.mseSourceBufferError, "mediaSource is end") : k(this.sourceBuffer.updating) && (s.log("MediaSource", "mseSourceBufferBusy"), this.tempFmp4List.push(r))
            }
        }

        getSourceBufferUpdating() {
            return this.sourceBuffer && this.sourceBuffer.updating
        }

        stop() {
            this.removeSourceBuffer(), this.endOfStream(), this.abortSourceBuffer()
        }

        dropSourceBuffer(e) {
            const t = this.$videoElement;
            this.dropping = e, 0 < t.buffered.length && 1 < t.buffered.end(0) - t.currentTime && (this.player.debug.warn("MediaSource", "dropSourceBuffer", `$video.buffered.end(0) is ${t.buffered.end(0)} - $video.currentTime ` + t.currentTime), t.currentTime = t.buffered.end(0))
        }

        checkSourceBufferDelay() {
            const e = this.$videoElement;
            let t = 0;
            return (t = 0 < e.buffered.length ? e.buffered.end(e.buffered.length - 1) - e.currentTime : t) < 0 && (this.player.debug.warn("MediaSource", `checkSourceBufferDelay end(0) is ${e.buffered.end(0)} - currentTime is ${e.currentTime} and  result < 0 and result is ` + t), t = 0), t
        }

        getDecodeDiffTimes() {
            return this.decodeDiffTimestamp
        }

        removeBuffer(e, t) {
            if (this.isStateOpen && !1 === this.sourceBuffer.updating) try {
                this.sourceBuffer.remove(e, t)
            } catch (e) {
                this.player.debug.warn("MediaSource", "removeBuffer() error", e)
            } else this.player.debug.warn("MediaSource", "removeBuffer() this.isStateOpen is", this.isStateOpen, "this.sourceBuffer.updating", this.sourceBuffer.updating)
        }

        endOfStream() {
            if (this.isStateOpen && this.$videoElement && 1 <= this.$videoElement.readyState) try {
                this.player.debug.log("MediaSource", "endOfStream()"), this.mediaSource.endOfStream()
            } catch (e) {
                this.player.debug.warn("MediaSource", "endOfStream() error", e)
            }
        }

        abortSourceBuffer() {
            this.isStateOpen && this.sourceBuffer && (this.player.debug.log("MediaSource", "abortSourceBuffer()"), this.sourceBuffer.abort()), this.sourceBuffer = null
        }

        removeSourceBuffer() {
            if (!this.isStateClosed && this.mediaSource && this.sourceBuffer) try {
                this.player.debug.log("MediaSource", "removeSourceBuffer()"), this.mediaSource.removeSourceBuffer(this.sourceBuffer)
            } catch (e) {
                this.player.debug.warn("MediaSource", "removeSourceBuffer() error", e)
            }
        }

        _handleUpdatePlaybackRate() {
            if (this.$videoElement) {
                const s = this.$videoElement;
                var t = (this.player._opt.videoBuffer + this.player._opt.videoBufferDelay) / 1e3;
                const a = s.buffered;
                a.length && a.start(0);
                var i = a.length ? a.end(a.length - 1) : 0;
                let e = s.currentTime;
                var r = i - e, t = Math.max(5, 3 + t),
                    t = (this.player.updateStats({mseVideoBufferDelayTime: r}), t < r ? (this.player.debug.warn("MediaSource", `handleUpdatePlaybackRate and buffered is ${i} and current is ${e} , delay buffer is more than ${t} is ${r} and new time is ` + i), s.currentTime = i, e = s.currentTime) : r < 0 && (this.player.debug.warn("MediaSource", `handleUpdatePlaybackRate and delay buffer is ${i} - current is ${e} = ${r} < 0 and check video is paused : ${s.paused} `), s.paused && s.play()), this._getPlaybackRate(i - e));
                s.playbackRate !== t && (this.player.debug.warn("MediaSource", `handleUpdatePlaybackRate and buffered is ${i} and current time is ${e} and delay is ${i - e}  set playbackRate is ${t} `), s.playbackRate = t)
            }
        }

        getDecodePlaybackRate() {
            let e = 0;
            var t = this.$videoElement;
            return e = t ? t.playbackRate : e
        }

        _getPlaybackRate(e) {
            var t = this.$videoElement, i = this.player._opt.videoBuffer, r = i + this.player._opt.videoBufferDelay;
            return e *= 1e3, 1 === t.playbackRate ? r < e ? 1.2 : 1 : e <= i ? 1 : t.playbackRate
        }
    }

    const Aa = () => "wakeLock" in navigator && -1 === window.navigator.userAgent.indexOf("Samsung") && C(Dt());

    class ba {
        constructor(e) {
            this.player = e, this.enabled = !1, Aa() ? (this.player.debug.log("NoSleep", "Native Wake Lock API supported."), this._wakeLock = null, this.handleVisibilityChange = () => {
                null !== this._wakeLock && "visible" === document.visibilityState && this.enable()
            }, document.addEventListener("visibilitychange", this.handleVisibilityChange), document.addEventListener("fullscreenchange", this.handleVisibilityChange)) : (this.player.debug.log("NoSleep", "Native Wake Lock API not supported. so use video element."), this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("title", "No Sleep"), this.noSleepVideo.setAttribute("playsinline", ""), this._addSourceToVideo(this.noSleepVideo, "webm", "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQRChYECGFOAZwEAAAAAABLfEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHYTbuMU6uEElTDZ1OsggGXTbuMU6uEHFO7a1OsghLJ7AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmsirXsYMPQkBNgI1MYXZmNTguNDUuMTAwV0GNTGF2ZjU4LjQ1LjEwMESJiECzmgAAAAAAFlSua0C5rgEAAAAAAABO14EBc8WI9UhIq9EDJPCcgQAitZyDdW5khoVWX1ZQOIOBASPjg4QF9eEA4AEAAAAAAAAbsIIBQLqB8FSwggElVLqB8FWwiFW3gQFVuIECrgEAAAAAAABZ14ECc8WIUEWPA9J/iJ6cgQAitZyDdW5khoZBX09QVVNWqoNjLqBWu4QExLQAg4EC4ZGfgQG1iEDncAAAAAAAYmSBIGOik09wdXNIZWFkAQE4AYC7AAAAAAASVMNnQcJzcwEAAAAAAACXY8CAZ8gBAAAAAAAAFUWji01BSk9SX0JSQU5ERIeEaXNvbWfIAQAAAAAAABZFo41NSU5PUl9WRVJTSU9ORIeDNTEyZ8gBAAAAAAAAJ0WjkUNPTVBBVElCTEVfQlJBTkRTRIeQaXNvbWlzbzJhdmMxbXA0MWfIAQAAAAAAABpFo4dFTkNPREVSRIeNTGF2ZjU4LjQ1LjEwMHNzAQAAAAAAAIZjwItjxYj1SEir0QMk8GfIAQAAAAAAAB5Fo4xIQU5ETEVSX05BTUVEh4xWaWRlb0hhbmRsZXJnyAEAAAAAAAAhRaOHRU5DT0RFUkSHlExhdmM1OC45MS4xMDAgbGlidnB4Z8iiRaOIRFVSQVRJT05Eh5QwMDowMDowNS4wMDcwMDAwMDAAAHNzAQAAAAAAAIdjwItjxYhQRY8D0n+InmfIAQAAAAAAAB5Fo4xIQU5ETEVSX05BTUVEh4xTb3VuZEhhbmRsZXJnyAEAAAAAAAAiRaOHRU5DT0RFUkSHlUxhdmM1OC45MS4xMDAgbGlib3B1c2fIokWjiERVUkFUSU9ORIeUMDA6MDA6MDUuMDE4MDAwMDAwAAAfQ7Z1T2TngQCjh4IAAID4//6jQKSBAAeAMBIAnQEqQAHwAABHCIWFiIWEiAICAAYWBPcGgWSfa9ubJzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh69AD+/6tQgKOHggAVgPj//qOHggApgPj//qOHggA9gPj//qOHggBRgPj//qOHggBlgPj//qOegQBrANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCAHmA+P/+o4eCAI2A+P/+o4eCAKGA+P/+o4eCALWA+P/+o4eCAMmA+P/+o56BAM8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IA3YD4//6jh4IA8YD4//6jh4IBBYD4//6jh4IBGYD4//6jh4IBLYD4//6jnoEBMwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggFBgPj//qOHggFVgPj//qOHggFpgPj//qOHggF9gPj//qOHggGRgPj//qOegQGXANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCAaWA+P/+o4eCAbmA+P/+o4eCAc2A+P/+o4eCAeGA+P/+o4eCAfWA+P/+o56BAfsA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4ICCYD4//6jh4ICHYD4//6jh4ICMYD4//6jh4ICRYD4//6jh4ICWYD4//6jnoECXwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggJtgPj//qOHggKBgPj//qOHggKVgPj//qOHggKpgPj//qOHggK9gPj//qOegQLDANECAAUQEBRgAGFgv9AAIgAQzX61yT5xzAAAo4eCAtGA+P/+o4eCAuWA+P/+o4eCAvmA+P/+o4eCAw2A+P/+o4eCAyGA+P/+o56BAycA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IDNYD4//6jh4IDSYD4//6jh4IDXYD4//6jh4IDcYD4//6jh4IDhYD4//6jnoEDiwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggOZgPj//qOHggOtgPj//qOHggPBgPj//qOHggPVgPj//qOHggPpgPj//qOegQPvANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCA/2A+P/+o4eCBBGA+P/+o4eCBCWA+P/+o4eCBDmA+P/+o4eCBE2A+P/+o56BBFMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IEiID4//6jh4IEnID4//6jh4IEsID4//6jnoEEtwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggTEgPj//qOHggTYgPj//qOHggTsgPj//qOHggUAgPj//qOHggUUgPj//qOegQUbANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCBSiA+P/+o4eCBTyA+P/+o4eCBVCA+P/+o4eCBWSA+P/+o4eCBXiA+P/+o56BBX8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IFjID4//6jh4IFoID4//6jh4IFtID4//6jh4IFyID4//6jh4IF3ID4//6jnoEF4wDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggXwgPj//qOHggYEgPj//qOHggYYgPj//qOHggYsgPj//qOHggZAgPj//qOegQZHANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCBlSA+P/+o4eCBmiA+P/+o4eCBnyA+P/+o4eCBpCA+P/+o4eCBqSA+P/+o56BBqsA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IGuID4//6jh4IGzID4//6jh4IG4ID4//6jh4IG9ID4//6jh4IHCID4//6jnoEHDwDRAgAFEBAUYABhYL/QACIAEM1+tck+ccwAAKOHggccgPj//qOHggcwgPj//qOHggdEgPj//qOHggdYgPj//qOHggdsgPj//qOegQdzANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCB4CA+P/+o4eCB5SA+P/+o4eCB6iA+P/+o4eCB7yA+P/+o4eCB9CA+P/+o56BB9cA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IH5ID4//6jh4IH+ID4//6jh4IIDID4//6jh4IIIID4//6jh4IINID4//6jnoEIOwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgghIgPj//qOHgghcgPj//qOHgghwgPj//qOHggiEgPj//qOegQifANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCCMCA+P/+o4eCCNSA+P/+o4eCCOiA+P/+o4eCCPyA+P/+o56BCQMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IJEID4//6jh4IJJID4//6jh4IJOID4//6jh4IJTID4//6jh4IJYID4//6jnoEJZwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggl0gPj//qOHggmIgPj//qOHggmcgPj//qOHggmwgPj//qOHggnEgPj//qOegQnLANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCCdiA+P/+o4eCCeyA+P/+o4eCCgCA+P/+o4eCChSA+P/+o4eCCiiA+P/+o56BCi8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IKPID4//6jh4IKUID4//6jh4IKZID4//6jh4IKeID4//6jh4IKjID4//6jnoEKkwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggqggPj//qOHggq0gPj//qOHggrIgPj//qOHggrcgPj//qOHggrwgPj//qOegQr3ANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCCwSA+P/+o4eCCxiA+P/+o4eCCyyA+P/+o4eCC0CA+P/+o4eCC1SA+P/+o56BC1sA0QIABRAQFGAAYWC/0AAiABDNfrXJPnHMAACjh4ILaID4//6jh4ILfID4//6jh4ILkID4//6jh4ILpID4//6jh4ILuID4//6jnoELvwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggvMgPj//qOHggvggPj//qOHggv0gPj//qOHggwIgPj//qOHggwcgPj//qOegQwjANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCDDCA+P/+o4eCDESA+P/+o4eCDFiA+P/+o4eCDGyA+P/+o4eCDICA+P/+o56BDIcA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IMlID4//6jh4IMqID4//6jh4IMvID4//6jh4IM0ID4//6jnoEM6wDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgg0MgPj//qOHgg0ggPj//qOHgg00gPj//qOHgg1IgPj//qOegQ1PANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCDVyA+P/+o4eCDXCA+P/+o4eCDYSA+P/+o4eCDZiA+P/+o4eCDayA+P/+o56BDbMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4INwID4//6jh4IN1ID4//6jh4IN6ID4//6jh4IN/ID4//6jh4IOEID4//6jnoEOFwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgg4kgPj//qOHgg44gPj//qOHgg5MgPj//qOHgg5ggPj//qOHgg50gPj//qOegQ57ANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCDoiA+P/+o4eCDpyA+P/+o4eCDrCA+P/+o4eCDsSA+P/+o4eCDtiA+P/+o56BDt8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IO7ID4//6jh4IPAID4//6jh4IPFID4//6jh4IPKID4//6jh4IPPID4//6jnoEPQwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgg9QgPj//qOHgg9kgPj//qOHgg94gPj//qOHgg+MgPj//qOHgg+ggPj//qOegQ+nANECAAUQEBRgAGFgv9AAIgAQzX61yT5xzAAAo4eCD7SA+P/+o4eCD8iA+P/+o4eCD9yA+P/+o4eCD/CA+P/+o4eCEASA+P/+o56BEAsA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IQGID4//6jh4IQLID4//6jh4IQQID4//6jh4IQVID4//6jh4IQaID4//6jnoEQbwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHghB8gPj//qOHghCQgPj//qOHghCkgPj//qOHghC4gPj//qOHghDMgPj//qOegRDTANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCEOCA+P/+o4eCEPSA+P/+o4eCEQiA+P/+o56BETcA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IRQ4D4//6jh4IRV4D4//6jh4IRa4D4//6jh4IRf4D4//6jh4IRk4D4//6jnoERmwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHghGngPj//qOHghG7gPj//qOHghHPgPj//qOHghHjgPj//qOHghH3gPj//qOegRH/ANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCEguA+P/+o4eCEh+A+P/+o4eCEjOA+P/+o4eCEkeA+P/+o4eCEluA+P/+o56BEmMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4ISb4D4//6jh4ISg4D4//6jh4ISl4D4//6jh4ISq4D4//6jh4ISv4D4//6jnoESxwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHghLTgPj//qOHghLngPj//qOHghL7gPj//qOHghMPgPj//qOHghMjgPj//qOegRMrANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCEzeA+P/+o4eCE0uA+P/+o4eCE1+A+P/+o4eCE3OA+P/+oAEAAAAAAAAPoYeCE4cA+P/+daKDB/KBHFO7a5G7j7OBB7eK94EB8YIDX/CBDA=="), this._addSourceToVideo(this.noSleepVideo, "mp4", "data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACORtZGF03gIATGF2YzU4LjM1LjEwMAACMEAOAAACcQYF//9t3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE2MSByMzAyNyA0MTIxMjc3IC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAyMCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTAgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTcgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0wIHdlaWdodHA9MCBrZXlpbnQ9MjUwIGtleWludF9taW49MTAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIzLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IGlwX3JhdGlvPTEuNDAgYXE9MToxLjAwAIAAAADvZYiED/JigADD7JycnJycnJycnJycnJycnJycnJ11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111114BGCAHARggBwEYIAcBGCAHARggBwAAAAdBmjgf4BLYARggBwEYIAcBGCAHARggBwAAAAdBmlQH+AS2ARggBwEYIAcBGCAHARggBwAAAAdBmmA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZqAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZqgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZrAP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0Ga4D/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbAD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbID/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBm0A/wCWwARggBwEYIAcBGCAHAAAAB0GbYD/AJbABGCAHARggBwEYIAcAAAAHQZuAP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GboD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbwD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0Gb4D/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBmgA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmiA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmkA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZpgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZqAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZqgP8AlsAEYIAcBGCAHARggBwAAAAdBmsA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmuA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmwA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZsgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZtAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZtgP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GbgD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GboD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbwD/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBm+A/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmgA/wCWwARggBwEYIAcAAAAHQZogP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GaQD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GaYD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GagD/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBmqA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmsA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmuA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZsAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZsgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZtAP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GbYD/AJbABGCAHARggBwAAAAdBm4A/wCWwARggBwEYIAcBGCAHARggBwAAAAdBm6A/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZvAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZvgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZoAO8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GaIDfAJbABGCAHARggBwEYIAcBGCAHAAAMxm1vb3YAAABsbXZoZAAAAAAAAAAAAAAAAAAAA+gAABOgAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAPLdHJhawAAAFx0a2hkAAAAAwAAAAAAAAAAAAAAAQAAAAAAABOIAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAElVVUA8AAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAAATiAAAAAAAAQAAAAADQ21kaWEAAAAgbWRoZAAAAAAAAAAAAAAAAAAAKAAAAMgAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAu5taW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAKuc3RibAAAAKpzdHNkAAAAAAAAAAEAAACaYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAFAAPAASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADRhdmNDAULAC//hABxnQsAL2QFB+/8ACwAMEAAAAwAQAAADAUDxQqSAAQAFaMuDyyAAAAAQcGFzcAAAAAsAAAAMAAAAGHN0dHMAAAAAAAAAAQAAADIAAAQAAAAAFHN0c3MAAAAAAAAAAQAAAAEAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAA3HN0c3oAAAAAAAAAAAAAADIAAANoAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAANhzdGNvAAAAAAAAADIAAABFAAADwQAAA9wAAAP3AAAEFgAABDEAAARMAAAEawAABIYAAAShAAAEwAAABNcAAATuAAAFDQAABSgAAAVDAAAFYgAABX0AAAWYAAAFtwAABdIAAAXtAAAGBAAABh8AAAY6AAAGWQAABnQAAAaPAAAGrgAABskAAAbkAAAHAwAABx4AAAcxAAAHUAAAB2sAAAeGAAAHpQAAB8AAAAfbAAAH+gAACBUAAAgwAAAITwAACGIAAAh9AAAInAAACLcAAAjSAAAI8QAACCV0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAAE6AAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAABOIAAAEAAABAAAAAAedbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAACsRAADYVRVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAAHSG1pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAHDHN0YmwAAABqc3RzZAAAAAAAAAABAAAAWm1wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAACsRAAAAAAANmVzZHMAAAAAA4CAgCUAAgAEgICAF0AVAAAAAAENiAAABVQFgICABRIIVuUABoCAgAECAAAAYHN0dHMAAAAAAAAACgAAAC8AAAQAAAAAAQAACtUAAAAsAAAEAAAAAAEAAArWAAAALAAABAAAAAABAAAK1QAAACwAAAQAAAAAAQAACtUAAAAaAAAEAAAAAAEAAAH/AAABzHN0c2MAAAAAAAAAJQAAAAEAAAABAAAAAQAAAAIAAAAFAAAAAQAAAAMAAAAEAAAAAQAAAAUAAAAFAAAAAQAAAAYAAAAEAAAAAQAAAAgAAAAFAAAAAQAAAAkAAAAEAAAAAQAAAAsAAAAFAAAAAQAAAAwAAAADAAAAAQAAAA4AAAAFAAAAAQAAAA8AAAAEAAAAAQAAABEAAAAFAAAAAQAAABIAAAAEAAAAAQAAABQAAAAFAAAAAQAAABUAAAAEAAAAAQAAABcAAAADAAAAAQAAABgAAAAEAAAAAQAAABoAAAAFAAAAAQAAABsAAAAEAAAAAQAAAB0AAAAFAAAAAQAAAB4AAAAEAAAAAQAAACAAAAAFAAAAAQAAACEAAAAEAAAAAQAAACIAAAACAAAAAQAAACMAAAAFAAAAAQAAACQAAAAEAAAAAQAAACYAAAAFAAAAAQAAACcAAAAEAAAAAQAAACkAAAAFAAAAAQAAACoAAAAEAAAAAQAAACwAAAAFAAAAAQAAAC0AAAACAAAAAQAAAC4AAAAEAAAAAQAAAC8AAAAFAAAAAQAAADAAAAAEAAAAAQAAADIAAAAFAAAAAQAAADMAAAAEAAAAAQAAA1xzdHN6AAAAAAAAAAAAAADSAAAAFQAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAA3HN0Y28AAAAAAAAAMwAAADAAAAOtAAADzAAAA+cAAAQCAAAEIQAABDwAAARXAAAEdgAABJEAAASsAAAEywAABOIAAAT5AAAFGAAABTMAAAVOAAAFbQAABYgAAAWjAAAFwgAABd0AAAX4AAAGDwAABioAAAZFAAAGZAAABn8AAAaaAAAGuQAABtQAAAbvAAAHDgAABykAAAc8AAAHWwAAB3YAAAeRAAAHsAAAB8sAAAfmAAAIBQAACCAAAAg7AAAIWgAACG0AAAiIAAAIpwAACMIAAAjdAAAI/AAAABpzZ3BkAQAAAHJvbGwAAAACAAAAAf//AAAAHHNiZ3AAAAAAcm9sbAAAAAEAAADSAAAAAQAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTguMjAuMTAw"), Object.assign(this.noSleepVideo.style, {
                position: "absolute",
                left: "-100%",
                top: "-100%"
            }), document.querySelector("body").append(this.noSleepVideo), this.handleNoSleepVideoTimeUpdate = () => {
                this.noSleepVideo && 4 < this.noSleepVideo.currentTime && (this.noSleepVideo.currentTime = 1)
            }, this.noSleepVideo.addEventListener("timeupdate", this.handleNoSleepVideoTimeUpdate))
        }

        destroy() {
            if (this._wakeLock && (this._wakeLock.release(), this._wakeLock = null), this.noSleepVideo) {
                this.handleNoSleepVideoTimeUpdate && this.noSleepVideo.removeEventListener("timeupdate", this.handleNoSleepVideoTimeUpdate);
                try {
                    this.noSleepVideo.parentNode && this.noSleepVideo.parentNode.removeChild(this.noSleepVideo)
                } catch (e) {
                    this.player.debug.warn("NoSleep", "Failed to remove noSleepVideo element.")
                }
                this.noSleepVideo = null
            }
            this.handleVisibilityChange && (document.removeEventListener("visibilitychange", this.handleVisibilityChange), document.removeEventListener("fullscreenchange", this.handleVisibilityChange))
        }

        _addSourceToVideo(e, t, i) {
            var r = document.createElement("source");
            r.src = i, r.type = "video/" + t, e.appendChild(r)
        }

        get isEnabled() {
            return this.enabled
        }

        enable() {
            const t = this.player.debug;
            return Aa() ? navigator.wakeLock.request("screen").then(e => {
                this._wakeLock = e, this.enabled = !0, t.log("wakeLock", "Wake Lock active."), this._wakeLock.addEventListener("release", () => {
                    t.log("wakeLock", "Wake Lock released.")
                })
            }).catch(e => {
                throw this.enabled = !1, t.warn("wakeLock", e.name + ", " + e.message), e
            }) : this.noSleepVideo.play().then(e => (t.log("wakeLock", "noSleepVideo Wake Lock active."), this.enabled = !0, e)).catch(e => {
                throw t.warn("wakeLock", `noSleepVideo ${e.name}, ` + e.message), this.enabled = !1, e
            })
        }

        disable() {
            Aa() ? (this._wakeLock && this._wakeLock.release(), this._wakeLock = null) : this.noSleepVideo && this.noSleepVideo.pause(), this.enabled = !1, this.player.debug.log("wakeLock", "Disabling wake lock.")
        }
    }

    var r = pt(ft(function (e, t) {
        "undefined" != typeof window && (e.exports = (() => {
            var i = {
                "./src/config.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        enableStreamingMode: () => function (e) {
                            var t = e.loader;
                            t !== f.default && t !== p.default ? (y.logger.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1) : (0, f.fetchSupported)() && (e.loader = f.default, e.progressive = !0, e.enableSoftwareAES = !0, y.logger.log("[config]: Progressive streaming enabled, using FetchLoader"))
                        }, hlsDefaultConfig: () => _, mergeConfig: () => function (e, t) {
                            if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                            if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                            if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                            return A({}, e, t)
                        }
                    });
                    var t = i("./src/controller/abr-controller.ts"),
                        r = i("./src/controller/audio-stream-controller.ts"),
                        s = i("./src/controller/audio-track-controller.ts"),
                        a = i("./src/controller/subtitle-stream-controller.ts"),
                        n = i("./src/controller/subtitle-track-controller.ts"),
                        o = i("./src/controller/buffer-controller.ts"),
                        l = i("./src/controller/timeline-controller.ts"),
                        d = i("./src/controller/cap-level-controller.ts"), h = i("./src/controller/fps-controller.ts"),
                        c = i("./src/controller/eme-controller.ts"), u = i("./src/controller/cmcd-controller.ts"),
                        p = i("./src/utils/xhr-loader.ts"), f = i("./src/utils/fetch-loader.ts"),
                        m = i("./src/utils/cues.ts"), g = i("./src/utils/mediakeys-helper.ts"),
                        y = i("./src/utils/logger.ts");

                    function A() {
                        return (A = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    function b(t, e) {
                        var i, r = Object.keys(t);
                        return Object.getOwnPropertySymbols && (i = Object.getOwnPropertySymbols(t), e && (i = i.filter(function (e) {
                            return Object.getOwnPropertyDescriptor(t, e).enumerable
                        })), r.push.apply(r, i)), r
                    }

                    function v(r) {
                        for (var e = 1; e < arguments.length; e++) {
                            var s = null != arguments[e] ? arguments[e] : {};
                            e % 2 ? b(Object(s), !0).forEach(function (e) {
                                var t, i;
                                t = r, e = s[i = e], (i = function () {
                                    var e = function (e) {
                                        if ("object" != typeof e || null === e) return e;
                                        var t = e[Symbol.toPrimitive];
                                        if (void 0 === t) return String(e);
                                        t = t.call(e, "string");
                                        if ("object" != typeof t) return t;
                                        throw new TypeError("@@toPrimitive must return a primitive value.")
                                    }(i);
                                    return "symbol" == typeof e ? e : String(e)
                                }()) in t ? Object.defineProperty(t, i, {
                                    value: e,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : t[i] = e
                            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(s)) : b(Object(s)).forEach(function (e) {
                                Object.defineProperty(r, e, Object.getOwnPropertyDescriptor(s, e))
                            })
                        }
                        return r
                    }

                    var _ = v(v({
                        autoStartLoad: !0,
                        startPosition: -1,
                        defaultAudioCodec: void 0,
                        debug: !1,
                        capLevelOnFPSDrop: !1,
                        capLevelToPlayerSize: !1,
                        ignoreDevicePixelRatio: !1,
                        initialLiveManifestSize: 1,
                        maxBufferLength: 30,
                        backBufferLength: 1 / 0,
                        maxBufferSize: 6e7,
                        maxBufferHole: .1,
                        highBufferWatchdogPeriod: 2,
                        nudgeOffset: .1,
                        nudgeMaxRetry: 3,
                        maxFragLookUpTolerance: .25,
                        liveSyncDurationCount: 3,
                        liveMaxLatencyDurationCount: 1 / 0,
                        liveSyncDuration: void 0,
                        liveMaxLatencyDuration: void 0,
                        maxLiveSyncPlaybackRate: 1,
                        liveDurationInfinity: !1,
                        liveBackBufferLength: null,
                        maxMaxBufferLength: 600,
                        enableWorker: !0,
                        enableSoftwareAES: !0,
                        manifestLoadingTimeOut: 1e4,
                        manifestLoadingMaxRetry: 1,
                        manifestLoadingRetryDelay: 1e3,
                        manifestLoadingMaxRetryTimeout: 64e3,
                        startLevel: void 0,
                        levelLoadingTimeOut: 1e4,
                        levelLoadingMaxRetry: 4,
                        levelLoadingRetryDelay: 1e3,
                        levelLoadingMaxRetryTimeout: 64e3,
                        fragLoadingTimeOut: 2e4,
                        fragLoadingMaxRetry: 6,
                        fragLoadingRetryDelay: 1e3,
                        fragLoadingMaxRetryTimeout: 64e3,
                        startFragPrefetch: !1,
                        fpsDroppedMonitoringPeriod: 5e3,
                        fpsDroppedMonitoringThreshold: .2,
                        appendErrorMaxRetry: 3,
                        loader: p.default,
                        fLoader: void 0,
                        pLoader: void 0,
                        xhrSetup: void 0,
                        licenseXhrSetup: void 0,
                        licenseResponseCallback: void 0,
                        abrController: t.default,
                        bufferController: o.default,
                        capLevelController: d.default,
                        fpsController: h.default,
                        stretchShortVideoTrack: !1,
                        maxAudioFramesDrift: 1,
                        forceKeyFrameOnDiscontinuity: !0,
                        abrEwmaFastLive: 3,
                        abrEwmaSlowLive: 9,
                        abrEwmaFastVoD: 3,
                        abrEwmaSlowVoD: 9,
                        abrEwmaDefaultEstimate: 5e5,
                        abrBandWidthFactor: .95,
                        abrBandWidthUpFactor: .7,
                        abrMaxWithRealBitrate: !1,
                        maxStarvationDelay: 4,
                        maxLoadingDelay: 4,
                        minAutoBitrate: 0,
                        emeEnabled: !1,
                        widevineLicenseUrl: void 0,
                        drmSystems: {},
                        drmSystemOptions: {},
                        requestMediaKeySystemAccessFunc: g.requestMediaKeySystemAccess,
                        testBandwidth: !0,
                        progressive: !1,
                        lowLatencyMode: !0,
                        cmcd: void 0,
                        enableDateRangeMetadataCues: !0,
                        enableEmsgMetadataCues: !0,
                        enableID3MetadataCues: !0
                    }, {
                        cueHandler: m.default,
                        enableWebVTT: !0,
                        enableIMSC1: !0,
                        enableCEA708Captions: !0,
                        captionsTextTrack1Label: "English",
                        captionsTextTrack1LanguageCode: "en",
                        captionsTextTrack2Label: "Spanish",
                        captionsTextTrack2LanguageCode: "es",
                        captionsTextTrack3Label: "Unknown CC",
                        captionsTextTrack3LanguageCode: "",
                        captionsTextTrack4Label: "Unknown CC",
                        captionsTextTrack4LanguageCode: "",
                        renderTextTracksNatively: !0
                    }), {}, {
                        subtitleStreamController: a.SubtitleStreamController,
                        subtitleTrackController: n.default,
                        timelineController: l.TimelineController,
                        audioStreamController: r.default,
                        audioTrackController: s.default,
                        emeController: c.default,
                        cmcdController: u.default
                    })
                }, "./src/controller/abr-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => l});
                    var v = i("./src/polyfills/number.ts"), r = i("./src/utils/ewma-bandwidth-estimator.ts"),
                        A = i("./src/events.ts"), s = i("./src/errors.ts"), o = i("./src/types/loader.ts"),
                        _ = i("./src/utils/logger.ts");

                    function a(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function n(e) {
                        this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0;
                        e = (this.hls = e).config;
                        this.bwEstimator = new r.default(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate), this.registerListeners()
                    }

                    (t = n.prototype).registerListeners = function () {
                        var e = this.hls;
                        e.on(A.Events.FRAG_LOADING, this.onFragLoading, this), e.on(A.Events.FRAG_LOADED, this.onFragLoaded, this), e.on(A.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.on(A.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(A.Events.ERROR, this.onError, this)
                    }, t.unregisterListeners = function () {
                        var e = this.hls;
                        e.off(A.Events.FRAG_LOADING, this.onFragLoading, this), e.off(A.Events.FRAG_LOADED, this.onFragLoaded, this), e.off(A.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.off(A.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(A.Events.ERROR, this.onError, this)
                    }, t.destroy = function () {
                        this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null
                    }, t.onFragLoading = function (e, t) {
                        var i = t.frag;
                        i.type !== o.PlaylistLevelType.MAIN || this.timer || (this.fragCurrent = i, this.partCurrent = null != (i = t.part) ? i : null, this.timer = self.setInterval(this.onCheck, 100))
                    }, t.onLevelLoaded = function (e, t) {
                        var i = this.hls.config;
                        t.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD)
                    }, t._abandonRulesCheck = function () {
                        var e = this.fragCurrent, t = this.partCurrent, i = this.hls, r = i.autoLevelEnabled,
                            s = i.media;
                        if (e && s) {
                            var a = (t || e).stats, n = (t || e).duration;
                            if (a.aborted || a.loaded && a.loaded === a.total || 0 === e.level) return this.clearTimer(), void (this._nextAutoLevel = -1);
                            if (r && !s.paused && s.playbackRate && s.readyState) {
                                r = i.mainForwardBufferInfo;
                                if (null !== r) {
                                    var o = performance.now() - a.loading.start, s = Math.abs(s.playbackRate);
                                    if (!(o <= 500 * n / s)) {
                                        var l = a.loaded && a.loading.first, d = this.bwEstimator.getEstimate(),
                                            h = i.levels, c = i.minAutoLevel, u = h[e.level],
                                            u = a.total || Math.max(a.loaded, Math.round(n * u.maxBitrate / 8)),
                                            p = l ? 1e3 * a.loaded / o : 0, u = p ? (u - a.loaded) / p : 8 * u / d,
                                            f = r.len / s;
                                        if (!(u <= f)) {
                                            for (var m = Number.POSITIVE_INFINITY, g = e.level - 1; c < g; g--) {
                                                var y = h[g].maxBitrate;
                                                if ((m = p ? n * y / (6.4 * p) : n * y / d) < f) break
                                            }
                                            u <= m || (_.logger.warn("Fragment " + e.sn + (t ? " part " + t.index : "") + " of level " + e.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + g + "\n      Current BW estimate: " + ((0, v.isFiniteNumber)(d) ? (d / 1024).toFixed(3) : "Unknown") + " Kb/s\n      Estimated load time for current fragment: " + u.toFixed(3) + " s\n      Estimated load time for the next fragment: " + m.toFixed(3) + " s\n      Time to underbuffer: " + f.toFixed(3) + " s"), i.nextLoadLevel = g, l && this.bwEstimator.sample(o, a.loaded), this.clearTimer(), (e.loader || e.keyLoader) && (this.fragCurrent = this.partCurrent = null, e.abortRequests()), i.trigger(A.Events.FRAG_LOAD_EMERGENCY_ABORTED, {
                                                frag: e,
                                                part: t,
                                                stats: a
                                            }))
                                        }
                                    }
                                }
                            }
                        }
                    }, t.onFragLoaded = function (e, t) {
                        var i, r, s, a, n = t.frag, t = t.part;
                        n.type === o.PlaylistLevelType.MAIN && (0, v.isFiniteNumber)(n.sn) && (i = (t || n).stats, s = (t || n).duration, this.clearTimer(), this.lastLoadedFragLevel = n.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate && (r = ((a = this.hls.levels[n.level]).loaded ? a.loaded.bytes : 0) + i.loaded, s = (a.loaded ? a.loaded.duration : 0) + s, a.loaded = {
                            bytes: r,
                            duration: s
                        }, a.realBitrate = Math.round(8 * r / s)), n.bitrateTest && (a = {
                            stats: i,
                            frag: n,
                            part: t,
                            id: n.type
                        }, this.onFragBuffered(A.Events.FRAG_BUFFERED, a)))
                    }, t.onFragBuffered = function (e, t) {
                        var i, r = t.frag, t = t.part, t = (t || r).stats;
                        t.aborted || r.type !== o.PlaylistLevelType.MAIN || "initSegment" === r.sn || (i = t.parsing.end - t.loading.start, this.bwEstimator.sample(i, t.loaded), t.bwEstimate = this.bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = i / 1e3 : this.bitrateTestDelay = 0)
                    }, t.onError = function (e, t) {
                        var i;
                        if ((null == (i = t.frag) ? void 0 : i.type) === o.PlaylistLevelType.MAIN) if (t.type === s.ErrorTypes.KEY_SYSTEM_ERROR) this.clearTimer(); else switch (t.details) {
                            case s.ErrorDetails.FRAG_LOAD_ERROR:
                            case s.ErrorDetails.FRAG_LOAD_TIMEOUT:
                            case s.ErrorDetails.KEY_LOAD_ERROR:
                            case s.ErrorDetails.KEY_LOAD_TIMEOUT:
                                this.clearTimer()
                        }
                    }, t.clearTimer = function () {
                        self.clearInterval(this.timer), this.timer = void 0
                    }, t.getNextABRAutoLevel = function () {
                        var e = this.fragCurrent, t = this.partCurrent, i = this.hls, r = i.maxAutoLevel, s = i.config,
                            a = i.minAutoLevel, n = i.media, t = t ? t.duration : e ? e.duration : 0,
                            e = n && 0 !== n.playbackRate ? Math.abs(n.playbackRate) : 1,
                            n = this.bwEstimator ? this.bwEstimator.getEstimate() : s.abrEwmaDefaultEstimate,
                            i = i.mainForwardBufferInfo, i = (i ? i.len : 0) / e,
                            e = this.findBestLevel(n, a, r, i, s.abrBandWidthFactor, s.abrBandWidthUpFactor);
                        if (0 <= e) return e;
                        _.logger.trace((i ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
                        var o, l = t ? Math.min(t, s.maxStarvationDelay) : s.maxStarvationDelay,
                            d = s.abrBandWidthFactor, h = s.abrBandWidthUpFactor;
                        return i || (o = this.bitrateTestDelay) && (l = (t ? Math.min(t, s.maxLoadingDelay) : s.maxLoadingDelay) - o, _.logger.trace("bitrate test took " + Math.round(1e3 * o) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * l) + " ms"), d = h = 1), e = this.findBestLevel(n, a, r, i + l, d, h), Math.max(e, 0)
                    }, t.findBestLevel = function (e, t, i, r, s, a) {
                        for (var n, o = this.fragCurrent, l = this.partCurrent, d = this.lastLoadedFragLevel, h = this.hls.levels, c = h[d], u = !(null == c || null == (n = c.details) || !n.live), p = null == c ? void 0 : c.codecSet, f = l ? l.duration : o ? o.duration : 0, m = i; t <= m; m--) {
                            var g = h[m];
                            if (g && (!p || g.codecSet === p)) {
                                var y, g = g.details,
                                    g = (l ? null == g ? void 0 : g.partTarget : null == g ? void 0 : g.averagetargetduration) || f,
                                    A = h[m].maxBitrate, b = A * g / (y = m <= d ? s * e : a * e);
                                if (_.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + m + "/" + Math.round(y) + "/" + A + "/" + g + "/" + r + "/" + b), A < y && (0 == b || !(0, v.isFiniteNumber)(b) || u && !this.bitrateTestDelay || b < r)) return m
                            }
                        }
                        return -1
                    }, a((t = n).prototype, [{
                        key: "nextAutoLevel", get: function () {
                            var e = this._nextAutoLevel, t = this.bwEstimator;
                            if (-1 !== e && !t.canEstimate()) return e;
                            t = this.getNextABRAutoLevel();
                            return -1 !== e && this.hls.levels[t].loadError ? e : t = -1 !== e ? Math.min(e, t) : t
                        }, set: function (e) {
                            this._nextAutoLevel = e
                        }
                    }]), Object.defineProperty(t, "prototype", {writable: !1});
                    const l = n
                }, "./src/controller/audio-stream-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => _});
                    var s, a = i("./src/polyfills/number.ts"), u = i("./src/controller/base-stream-controller.ts"),
                        p = i("./src/events.ts"), n = i("./src/utils/buffer-helper.ts"),
                        o = i("./src/controller/fragment-tracker.ts"), r = i("./src/types/level.ts"),
                        h = i("./src/types/loader.ts"), f = i("./src/loader/fragment.ts"),
                        c = i("./src/demux/chunk-cache.ts"), m = i("./src/demux/transmuxer-interface.ts"),
                        g = i("./src/types/transmuxer.ts"), l = i("./src/controller/fragment-finders.ts"),
                        d = i("./src/utils/discontinuities.ts"), y = i("./src/errors.ts");

                    function A() {
                        return (A = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    function b(e, t) {
                        return (b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function v(e, t, i) {
                        return (e = s.call(this, e, t, i, "[audio-stream-controller]") || this).videoBuffer = null, e.videoTrackCC = -1, e.waitingVideoCC = -1, e.audioSwitch = !1, e.trackId = -1, e.waitingData = null, e.mainDetails = null, e.bufferFlushed = !1, e.cachedTrackLoadedData = null, e._registerListeners(), e
                    }

                    s = u.default, t = s, (i = v).prototype = Object.create(t.prototype), b(i.prototype.constructor = i, t), (i = v.prototype).onHandlerDestroying = function () {
                        this._unregisterListeners(), this.mainDetails = null
                    }, i._registerListeners = function () {
                        var e = this.hls;
                        e.on(p.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(p.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(p.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(p.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(p.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(p.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(p.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(p.Events.ERROR, this.onError, this), e.on(p.Events.BUFFER_RESET, this.onBufferReset, this), e.on(p.Events.BUFFER_CREATED, this.onBufferCreated, this), e.on(p.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(p.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(p.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, i._unregisterListeners = function () {
                        var e = this.hls;
                        e.off(p.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(p.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(p.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(p.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(p.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(p.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(p.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(p.Events.ERROR, this.onError, this), e.off(p.Events.BUFFER_RESET, this.onBufferReset, this), e.off(p.Events.BUFFER_CREATED, this.onBufferCreated, this), e.off(p.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(p.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(p.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, i.onInitPtsFound = function (e, t) {
                        var i = t.frag, r = t.id, t = t.initPTS;
                        "main" === r && (r = i.cc, this.initPTS[i.cc] = t, this.log("InitPTS for cc: " + r + " found from main: " + t), this.videoTrackCC = r, this.state === u.State.WAITING_INIT_PTS && this.tick())
                    }, i.startLoad = function (e) {
                        if (!this.levels) return this.startPosition = e, void (this.state = u.State.STOPPED);
                        var t = this.lastCurrentTime;
                        this.stopLoad(), this.setInterval(100), (this.fragLoadError = 0) < t && -1 === e ? (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)), e = t, this.state = u.State.IDLE) : (this.loadedmetadata = !1, this.state = u.State.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                    }, i.doTick = function () {
                        switch (this.state) {
                            case u.State.IDLE:
                                this.doTickIdle();
                                break;
                            case u.State.WAITING_TRACK:
                                var e = this.levels, t = this.trackId,
                                    t = null == e || null == (e = e[t]) ? void 0 : e.details;
                                if (t) {
                                    if (this.waitForCdnTuneIn(t)) break;
                                    this.state = u.State.WAITING_INIT_PTS
                                }
                                break;
                            case u.State.FRAG_LOADING_WAITING_RETRY:
                                e = performance.now(), t = this.retryDate;
                                (!t || t <= e || null != (t = this.media) && t.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = u.State.IDLE);
                                break;
                            case u.State.WAITING_INIT_PTS:
                                var i, r, e = this.waitingData;
                                e ? (t = e.frag, i = e.part, r = e.cache, e = e.complete, void 0 !== this.initPTS[t.cc] ? (this.waitingData = null, this.waitingVideoCC = -1, this.state = u.State.FRAG_LOADING, i = {
                                    frag: t,
                                    part: i,
                                    payload: r.flush(),
                                    networkDetails: null
                                }, this._handleFragmentLoadProgress(i), e && s.prototype._handleFragmentLoadComplete.call(this, i)) : this.videoTrackCC !== this.waitingVideoCC ? (this.log("Waiting fragment cc (" + t.cc + ") cancelled because video is at cc " + this.videoTrackCC), this.clearWaitingFragment()) : (r = this.getLoadPosition(), e = n.BufferHelper.bufferInfo(this.mediaBuffer, r, this.config.maxBufferHole), (0, l.fragmentWithinToleranceTest)(e.end, this.config.maxFragLookUpTolerance, t) < 0 && (this.log("Waiting fragment cc (" + t.cc + ") @ " + t.start + " cancelled because another fragment at " + e.end + " is needed"), this.clearWaitingFragment()))) : this.state = u.State.IDLE
                        }
                        this.onTickEnd()
                    }, i.clearWaitingFragment = function () {
                        var e = this.waitingData;
                        e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = u.State.IDLE)
                    }, i.resetLoadingState = function () {
                        this.clearWaitingFragment(), s.prototype.resetLoadingState.call(this)
                    }, i.onTickEnd = function () {
                        var e = this.media;
                        e && e.readyState && (this.lastCurrentTime = e.currentTime)
                    }, i.doTickIdle = function () {
                        var e = this.hls, t = this.levels, i = this.media, r = this.trackId, s = e.config;
                        if (t && t[r] && (i || !this.startFragRequested && s.startFragPrefetch)) {
                            s = t[r].details;
                            if (!s || s.live && this.levelLastLoaded !== r || this.waitForCdnTuneIn(s)) this.state = u.State.WAITING_TRACK; else {
                                t = this.mediaBuffer || this.media, r = (this.bufferFlushed && t && (this.bufferFlushed = !1, this.afterBufferFlushed(t, f.ElementaryStreamTypes.AUDIO, h.PlaylistLevelType.AUDIO)), this.getFwdBufferInfo(t, h.PlaylistLevelType.AUDIO));
                                if (null !== r) {
                                    t = this.audioSwitch;
                                    if (!t && this._streamEnded(r, s)) return e.trigger(p.Events.BUFFER_EOS, {type: "audio"}), void (this.state = u.State.ENDED);
                                    var a, n,
                                        e = this.getFwdBufferInfo(this.videoBuffer || this.media, h.PlaylistLevelType.MAIN);
                                    r.len >= this.getMaxBufferLength(null == e ? void 0 : e.len) && !t || (a = s.fragments[0].start, n = r.end, t && i && (n = t = this.getLoadPosition(), s.PTSKnown && t < a && (r.end > a || r.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = a + .05)), e && n > e.end + s.targetduration || !(e && e.len || !r.len) || ((t = this.getNextFragment(n, s)) ? this.loadFragment(t, s, n) : this.bufferFlushed = !0))
                                }
                            }
                        }
                    }, i.getMaxBufferLength = function (e) {
                        var t = s.prototype.getMaxBufferLength.call(this);
                        return e ? Math.max(t, e) : t
                    }, i.onMediaDetaching = function () {
                        this.videoBuffer = null, s.prototype.onMediaDetaching.call(this)
                    }, i.onAudioTracksUpdated = function (e, t) {
                        t = t.audioTracks;
                        this.resetTransmuxer(), this.levels = t.map(function (e) {
                            return new r.Level(e)
                        })
                    }, i.onAudioTrackSwitching = function (e, t) {
                        var i = !!t.url, t = (this.trackId = t.id, this.fragCurrent);
                        t && t.abortRequests(), this.fragCurrent = null, this.clearWaitingFragment(), i ? this.setInterval(100) : this.resetTransmuxer(), i ? (this.audioSwitch = !0, this.state = u.State.IDLE) : this.state = u.State.STOPPED, this.tick()
                    }, i.onManifestLoading = function () {
                        this.mainDetails = null, this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1
                    }, i.onLevelLoaded = function (e, t) {
                        this.mainDetails = t.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(p.Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
                    }, i.onAudioTrackLoaded = function (e, t) {
                        if (null != this.mainDetails) {
                            var i = this.levels, r = t.details, s = t.id;
                            if (i) {
                                this.log("Track " + s + " loaded [" + r.startSN + "," + r.endSN + "],duration:" + r.totalduration);
                                var i = i[s], a = 0;
                                if (r.live || null != (n = i.details) && n.live) {
                                    var n = this.mainDetails;
                                    if (r.fragments[0] || (r.deltaUpdateFailed = !0), r.deltaUpdateFailed || !n) return;
                                    a = !i.details && r.hasProgramDateTime && n.hasProgramDateTime ? ((0, d.alignMediaPlaylistByPDT)(r, n), r.fragments[0].start) : this.alignPlaylists(r, i.details)
                                }
                                i.details = r, this.levelLastLoaded = s, this.startFragRequested || !this.mainDetails && r.live || this.setStartPosition(i.details, a), this.state !== u.State.WAITING_TRACK || this.waitForCdnTuneIn(r) || (this.state = u.State.IDLE), this.tick()
                            } else this.warn("Audio tracks were reset while loading level " + s)
                        } else this.cachedTrackLoadedData = t
                    }, i._handleFragmentLoadProgress = function (e) {
                        var t, i, r, s, a = e.frag, n = e.part, e = e.payload, o = this.config, l = this.trackId,
                            d = this.levels;
                        d ? (d = d[l], console.assert(d, "Audio track is defined on fragment load progress"), t = d.details, console.assert(t, "Audio track details are defined on fragment load progress"), o = o.defaultAudioCodec || d.audioCodec || "mp4a.40.2", d = (d = this.transmuxer) || (this.transmuxer = new m.default(this.hls, h.PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this))), i = this.initPTS[a.cc], r = null == (r = a.initSegment) ? void 0 : r.data, void 0 !== i ? (s = n ? n.index : -1, s = new g.ChunkMetadata(a.level, a.sn, a.stats.chunkCount, e.byteLength, s, -1 !== s), d.push(e, r, o, "", a, n, t.totalduration, !1, s, i)) : (this.log("Unknown video PTS for cc " + a.cc + ", waiting for video PTS before demuxing audio frag " + a.sn + " of [" + t.startSN + " ," + t.endSN + "],track " + l), (this.waitingData = this.waitingData || {
                            frag: a,
                            part: n,
                            cache: new c.default,
                            complete: !1
                        }).cache.push(new Uint8Array(e)), this.waitingVideoCC = this.videoTrackCC, this.state = u.State.WAITING_INIT_PTS)) : this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + a.sn + " of level " + a.level + " will not be buffered")
                    }, i._handleFragmentLoadComplete = function (e) {
                        this.waitingData ? this.waitingData.complete = !0 : s.prototype._handleFragmentLoadComplete.call(this, e)
                    }, i.onBufferReset = function () {
                        this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
                    }, i.onBufferCreated = function (e, t) {
                        var i = t.tracks.audio;
                        i && (this.mediaBuffer = i.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null)
                    }, i.onFragBuffered = function (e, t) {
                        var i = t.frag, t = t.part;
                        i.type === h.PlaylistLevelType.AUDIO ? this.fragContextChanged(i) ? this.warn("Fragment " + i.sn + (t ? " p: " + t.index : "") + " of level " + i.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch) : ("initSegment" !== i.sn && (this.fragPrevious = i, this.audioSwitch && (this.audioSwitch = !1, this.hls.trigger(p.Events.AUDIO_TRACK_SWITCHED, {id: this.trackId}))), this.fragBufferedComplete(i, t)) : this.loadedmetadata || i.type !== h.PlaylistLevelType.MAIN || null != (t = this.videoBuffer || this.media) && t.buffered.length && (this.loadedmetadata = !0)
                    }, i.onError = function (e, t) {
                        if (t.type !== y.ErrorTypes.KEY_SYSTEM_ERROR) switch (t.details) {
                            case y.ErrorDetails.FRAG_LOAD_ERROR:
                            case y.ErrorDetails.FRAG_LOAD_TIMEOUT:
                            case y.ErrorDetails.FRAG_PARSING_ERROR:
                            case y.ErrorDetails.KEY_LOAD_ERROR:
                            case y.ErrorDetails.KEY_LOAD_TIMEOUT:
                                this.onFragmentOrKeyLoadError(h.PlaylistLevelType.AUDIO, t);
                                break;
                            case y.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
                            case y.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
                                this.state !== u.State.ERROR && this.state !== u.State.STOPPED && (this.state = t.fatal ? u.State.ERROR : u.State.IDLE, this.warn(t.details + " while loading frag, switching to " + this.state + " state"));
                                break;
                            case y.ErrorDetails.BUFFER_FULL_ERROR:
                                var i, r;
                                "audio" !== t.parent || this.state !== u.State.PARSING && this.state !== u.State.PARSED || (i = !0, (i = (r = this.getFwdBufferInfo(this.mediaBuffer, h.PlaylistLevelType.AUDIO)) && .5 < r.len ? !this.reduceMaxBufferLength(r.len) : i) && (this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, s.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.resetLoadingState())
                        } else this.onFragmentOrKeyLoadError(h.PlaylistLevelType.AUDIO, t)
                    }, i.onBufferFlushed = function (e, t) {
                        t.type === f.ElementaryStreamTypes.AUDIO && (this.bufferFlushed = !0, this.state === u.State.ENDED && (this.state = u.State.IDLE))
                    }, i._handleTransmuxComplete = function (e) {
                        var t = this.hls, i = e.remuxResult, e = e.chunkMeta, r = this.getCurrentContext(e);
                        if (!r) return this.warn("The loading context changed while buffering fragment " + e.sn + " of level " + e.level + ". This chunk will not be buffered."), void this.resetStartWhenNotLoaded(e.level);
                        var s, a, n, o = r.frag, l = r.part, r = r.level.details, d = i.audio, h = i.text, c = i.id3,
                            i = i.initSegment;
                        !this.fragContextChanged(o) && r && (this.state = u.State.PARSING, this.audioSwitch && d && this.completeAudioSwitch(), null != i && i.tracks && (this._bufferInitSegment(i.tracks, o, e), t.trigger(p.Events.FRAG_PARSING_INIT_SEGMENT, {
                            frag: o,
                            id: "audio",
                            tracks: i.tracks
                        })), d && (i = d.startPTS, a = d.endPTS, n = d.startDTS, s = d.endDTS, l && (l.elementaryStreams[f.ElementaryStreamTypes.AUDIO] = {
                            startPTS: i,
                            endPTS: a,
                            startDTS: n,
                            endDTS: s
                        }), o.setElementaryStreamInfo(f.ElementaryStreamTypes.AUDIO, i, a, n, s), this.bufferFragmentData(d, o, l, e)), null != c && null != (i = c.samples) && i.length && (a = A({
                            id: "audio",
                            frag: o,
                            details: r
                        }, c), t.trigger(p.Events.FRAG_PARSING_METADATA, a)), h && (n = A({
                            id: "audio",
                            frag: o,
                            details: r
                        }, h), t.trigger(p.Events.FRAG_PARSING_USERDATA, n)))
                    }, i._bufferInitSegment = function (e, t, i) {
                        var r;
                        this.state === u.State.PARSING && (e.video && delete e.video, (r = e.audio) && (r.levelCodec = r.codec, r.id = "audio", this.log("Init audio buffer, container:" + r.container + ", codecs[parsed]=[" + r.codec + "]"), this.hls.trigger(p.Events.BUFFER_CODECS, e), null != (e = r.initSegment) && e.byteLength && (r = {
                            type: "audio",
                            frag: t,
                            part: null,
                            chunkMeta: i,
                            parent: t.type,
                            data: e
                        }, this.hls.trigger(p.Events.BUFFER_APPENDING, r)), this.tick()))
                    }, i.loadFragment = function (e, t, i) {
                        var r = this.fragmentTracker.getState(e);
                        this.fragCurrent = e, !this.audioSwitch && r !== o.FragmentState.NOT_LOADED && r !== o.FragmentState.PARTIAL || ("initSegment" === e.sn ? this._loadInitSegment(e, t) : t.live && !(0, a.isFiniteNumber)(this.initPTS[e.cc]) ? (this.log("Waiting for video PTS in continuity counter " + e.cc + " of live stream before loading audio fragment " + e.sn + " of level " + this.trackId), this.state = u.State.WAITING_INIT_PTS) : (this.startFragRequested = !0, s.prototype.loadFragment.call(this, e, t, i)))
                    }, i.completeAudioSwitch = function () {
                        var e = this.hls, t = this.media, i = this.trackId;
                        t && (this.log("Switching audio track : flushing all audio"), s.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.audioSwitch = !1, e.trigger(p.Events.AUDIO_TRACK_SWITCHED, {id: i})
                    };
                    const _ = v
                }, "./src/controller/audio-track-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => h});
                    var s, l = i("./src/events.ts"), r = i("./src/errors.ts"),
                        t = i("./src/controller/base-playlist-controller.ts"), a = i("./src/types/loader.ts");

                    function n(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function o(e, t) {
                        return (o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function d(e) {
                        return (e = s.call(this, e, "[audio-track-controller]") || this).tracks = [], e.groupId = null, e.tracksInGroup = [], e.trackId = -1, e.trackName = "", e.selectDefaultTrack = !0, e.registerListeners(), e
                    }

                    s = t.default, i = s, (t = d).prototype = Object.create(i.prototype), o(t.prototype.constructor = t, i), (t = d.prototype).registerListeners = function () {
                        var e = this.hls;
                        e.on(l.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(l.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(l.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(l.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(l.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(l.Events.ERROR, this.onError, this)
                    }, t.unregisterListeners = function () {
                        var e = this.hls;
                        e.off(l.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(l.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(l.Events.LEVEL_LOADING, this.onLevelLoading, this), e.off(l.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(l.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(l.Events.ERROR, this.onError, this)
                    }, t.destroy = function () {
                        this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, s.prototype.destroy.call(this)
                    }, t.onManifestLoading = function () {
                        this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.trackName = "", this.selectDefaultTrack = !0
                    }, t.onManifestParsed = function (e, t) {
                        this.tracks = t.audioTracks || []
                    }, t.onAudioTrackLoaded = function (e, t) {
                        var i, r = t.id, s = t.details, a = this.tracksInGroup[r];
                        a ? (i = a.details, a.details = t.details, this.log("audioTrack " + r + " loaded [" + s.startSN + "-" + s.endSN + "]"), r === this.trackId && (this.retryCount = 0, this.playlistLoaded(r, t, i))) : this.warn("Invalid audio track id " + r)
                    }, t.onLevelLoading = function (e, t) {
                        this.switchLevel(t.level)
                    }, t.onLevelSwitching = function (e, t) {
                        this.switchLevel(t.level)
                    }, t.switchLevel = function (e) {
                        var t, i, e = this.hls.levels[e];
                        null != e && e.audioGroupIds && (t = e.audioGroupIds[e.urlId], this.groupId !== t && (this.groupId = t, e = this.tracks.filter(function (e) {
                            return !t || e.groupId === t
                        }), this.selectDefaultTrack && !e.some(function (e) {
                            return e.default
                        }) && (this.selectDefaultTrack = !1), i = {audioTracks: this.tracksInGroup = e}, this.log("Updating audio tracks, " + e.length + ' track(s) found in "' + t + '" group-id'), this.hls.trigger(l.Events.AUDIO_TRACKS_UPDATED, i), this.selectInitialTrack()))
                    }, t.onError = function (e, t) {
                        s.prototype.onError.call(this, e, t), !t.fatal && t.context && t.context.type === a.PlaylistContextType.AUDIO_TRACK && t.context.id === this.trackId && t.context.groupId === this.groupId && this.retryLoadingOrFail(t)
                    }, t.setAudioTrack = function (e) {
                        var t, i, r, s, a, n, o = this.tracksInGroup;
                        e < 0 || e >= o.length ? this.warn("Invalid id passed to audio-track controller") : (this.clearTimer(), t = o[this.trackId], this.log("Now switching to audio-track index " + e), i = (o = o[e]).id, r = void 0 === (r = o.groupId) ? "" : r, s = o.name, a = o.type, n = o.url, this.trackId = e, this.trackName = s, this.selectDefaultTrack = !1, this.hls.trigger(l.Events.AUDIO_TRACK_SWITCHING, {
                            id: i,
                            groupId: r,
                            name: s,
                            type: a,
                            url: n
                        }), o.details && !o.details.live || (e = this.switchParams(o.url, null == t ? void 0 : t.details), this.loadPlaylist(e)))
                    }, t.selectInitialTrack = function () {
                        var e = this.tracksInGroup,
                            e = (console.assert(e.length, "Initial audio track should be selected when tracks are known"), this.trackName),
                            e = this.findTrackId(e) || this.findTrackId();
                        -1 !== e ? this.setAudioTrack(e) : (this.warn("No track found for running audio group-ID: " + this.groupId), this.hls.trigger(l.Events.ERROR, {
                            type: r.ErrorTypes.MEDIA_ERROR,
                            details: r.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
                            fatal: !0
                        }))
                    }, t.findTrackId = function (e) {
                        for (var t = this.tracksInGroup, i = 0; i < t.length; i++) {
                            var r = t[i];
                            if ((!this.selectDefaultTrack || r.default) && (!e || e === r.name)) return r.id
                        }
                        return -1
                    }, t.loadPlaylist = function (e) {
                        s.prototype.loadPlaylist.call(this);
                        var t = this.tracksInGroup[this.trackId];
                        if (this.shouldLoadTrack(t)) {
                            var i = t.id, r = t.groupId, t = t.url;
                            if (e) try {
                                t = e.addDirectives(t)
                            } catch (e) {
                                this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
                            }
                            this.log("loading audio-track playlist for id: " + i), this.clearTimer(), this.hls.trigger(l.Events.AUDIO_TRACK_LOADING, {
                                url: t,
                                id: i,
                                groupId: r,
                                deliveryDirectives: e || null
                            })
                        }
                    }, n((i = d).prototype, [{
                        key: "audioTracks", get: function () {
                            return this.tracksInGroup
                        }
                    }, {
                        key: "audioTrack", get: function () {
                            return this.trackId
                        }, set: function (e) {
                            this.selectDefaultTrack = !1, this.setAudioTrack(e)
                        }
                    }]), Object.defineProperty(i, "prototype", {writable: !1});
                    const h = d
                }, "./src/controller/base-playlist-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => s});
                    var o = i("./src/types/level.ts"), m = i("./src/controller/level-helper.ts"),
                        l = i("./src/utils/logger.ts"), r = i("./src/errors.ts"),
                        s = ((t = a.prototype).destroy = function () {
                            this.clearTimer(), this.hls = this.log = this.warn = null
                        }, t.onError = function (e, t) {
                            !t.fatal || t.type !== r.ErrorTypes.NETWORK_ERROR && t.type !== r.ErrorTypes.KEY_SYSTEM_ERROR || this.stopLoad()
                        }, t.clearTimer = function () {
                            clearTimeout(this.timer), this.timer = -1
                        }, t.startLoad = function () {
                            this.canLoad = !0, this.retryCount = 0, this.requestScheduled = -1, this.loadPlaylist()
                        }, t.stopLoad = function () {
                            this.canLoad = !1, this.clearTimer()
                        }, t.switchParams = function (e, t) {
                            var i = null == t ? void 0 : t.renditionReports;
                            if (i) for (var r = 0; r < i.length; r++) {
                                var s, a = i[r], n = void 0;
                                try {
                                    n = new self.URL(a.URI, t.url).href
                                } catch (e) {
                                    l.logger.warn("Could not construct new URL for Rendition Report: " + e), n = a.URI || ""
                                }
                                if (n === e.slice(-n.length)) return n = parseInt(a["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn), a = parseInt(a["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex), this.hls.config.lowLatencyMode && (s = Math.min(t.age - t.partTarget, t.targetduration), 0 <= a && s > t.partTarget && (a += 1)), new o.HlsUrlParameters(n, 0 <= a ? a : void 0, o.HlsSkip.No)
                            }
                        }, t.loadPlaylist = function (e) {
                            -1 === this.requestScheduled && (this.requestScheduled = self.performance.now())
                        }, t.shouldLoadTrack = function (e) {
                            return this.canLoad && e && !!e.url && (!e.details || e.details.live)
                        }, t.playlistLoaded = function (e, t, i) {
                            var r = this, s = t.details, a = t.stats, n = self.performance.now(),
                                o = a.loading.first ? Math.max(0, n - a.loading.first) : 0;
                            if (s.advancedDateTime = Date.now() - o, s.live || null != i && i.live) {
                                if (s.reloaded(i), i && this.log("live playlist " + e + " " + (s.advanced ? "REFRESHED " + s.lastPartSn + "-" + s.lastPartIndex : "MISSED")), i && 0 < s.fragments.length && (0, m.mergeDetails)(i, s), this.canLoad && s.live) {
                                    var l, o = void 0, d = void 0;
                                    if (s.canBlockReload && s.endSN && s.advanced) {
                                        var h = this.hls.config.lowLatencyMode, c = s.lastPartSn, u = s.endSN,
                                            p = s.lastPartIndex, f = c === u,
                                            c = (-1 !== p ? (o = f ? u + 1 : c, d = f ? h ? 0 : p : p + 1) : o = u + 1, s.age),
                                            p = c + s.ageHeader, u = Math.min(p - s.partTarget, 1.5 * s.targetduration);
                                        if (0 < u && (i && u > i.tuneInGoal ? (this.warn("CDN Tune-in goal increased from: " + i.tuneInGoal + " to: " + u + " with playlist age: " + s.age), u = 0) : (o += p = Math.floor(u / s.targetduration), void 0 !== d && (d += Math.round(u % s.targetduration / s.partTarget)), this.log("CDN Tune-in age: " + s.ageHeader + "s last advanced " + c.toFixed(2) + "s goal: " + u + " skip sn " + p + " to part " + d)), s.tuneInGoal = u), l = this.getDeliveryDirectives(s, t.deliveryDirectives, o, d), h || !f) return void this.loadPlaylist(l)
                                    } else l = this.getDeliveryDirectives(s, t.deliveryDirectives, o, d);
                                    i = this.hls.mainForwardBufferInfo, c = i ? i.end - i.len : 0, p = 1e3 * (s.edge - c), u = (0, m.computeReloadInterval)(s, p), h = (s.updated ? n > this.requestScheduled + u && (this.requestScheduled = a.loading.start) : this.requestScheduled = -1, void 0 !== o && s.canBlockReload ? this.requestScheduled = a.loading.first + u - (1e3 * s.partTarget || 1e3) : this.requestScheduled = (-1 === this.requestScheduled ? n : this.requestScheduled) + u, this.requestScheduled - n), h = Math.max(0, h);
                                    this.log("reload live playlist " + e + " in " + Math.round(h) + " ms"), this.timer = self.setTimeout(function () {
                                        return r.loadPlaylist(l)
                                    }, h)
                                }
                            } else this.clearTimer()
                        }, t.getDeliveryDirectives = function (e, t, i, r) {
                            var s = (0, o.getSkipValue)(e, i);
                            return null != t && t.skip && e.deltaUpdateFailed && (i = t.msn, r = t.part, s = o.HlsSkip.No), new o.HlsUrlParameters(i, r, s)
                        }, t.retryLoadingOrFail = function (e) {
                            var t, i = this, r = this.hls.config, s = this.retryCount < r.levelLoadingMaxRetry;
                            return s ? (this.requestScheduled = -1, this.retryCount++, -1 < e.details.indexOf("LoadTimeOut") && null != (t = e.context) && t.deliveryDirectives ? (this.warn("retry playlist loading #" + this.retryCount + ' after "' + e.details + '"'), this.loadPlaylist()) : (t = Math.min(Math.pow(2, this.retryCount) * r.levelLoadingRetryDelay, r.levelLoadingMaxRetryTimeout), this.timer = self.setTimeout(function () {
                                return i.loadPlaylist()
                            }, t), this.warn("retry playlist loading #" + this.retryCount + " in " + t + ' ms after "' + e.details + '"'))) : (this.warn('cannot recover from error "' + e.details + '"'), this.clearTimer(), e.fatal = !0), s
                        }, a);

                    function a(e, t) {
                        this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.retryCount = 0, this.log = void 0, this.warn = void 0, this.log = l.logger.log.bind(l.logger, t + ":"), this.warn = l.logger.warn.bind(l.logger, t + ":"), this.hls = e
                    }
                }, "./src/controller/base-stream-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {State: () => _, default: () => w});
                    var h = i("./src/polyfills/number.ts"), t = i("./src/task-loop.ts"),
                        d = i("./src/controller/fragment-tracker.ts"), n = i("./src/utils/buffer-helper.ts"),
                        a = i("./src/utils/logger.ts"), c = i("./src/events.ts"), r = i("./src/errors.ts"),
                        s = i("./src/types/transmuxer.ts"), o = i("./src/utils/mp4-tools.ts"),
                        l = i("./src/utils/discontinuities.ts"), u = i("./src/controller/fragment-finders.ts"),
                        p = i("./src/controller/level-helper.ts"), f = i("./src/loader/fragment-loader.ts"),
                        m = i("./src/crypt/decrypter.ts"), g = i("./src/utils/time-ranges.ts"),
                        y = i("./src/types/loader.ts");

                    function A(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function b(e, t) {
                        return (b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    var v, _ = {
                            STOPPED: "STOPPED",
                            IDLE: "IDLE",
                            KEY_LOADING: "KEY_LOADING",
                            FRAG_LOADING: "FRAG_LOADING",
                            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
                            WAITING_TRACK: "WAITING_TRACK",
                            PARSING: "PARSING",
                            PARSED: "PARSED",
                            ENDED: "ENDED",
                            ERROR: "ERROR",
                            WAITING_INIT_PTS: "WAITING_INIT_PTS",
                            WAITING_LEVEL: "WAITING_LEVEL"
                        },
                        w = (v = t.default, i = v, (t = S).prototype = Object.create(i.prototype), b(t.prototype.constructor = t, i), (t = S.prototype).doTick = function () {
                            this.onTickEnd()
                        }, t.onTickEnd = function () {
                        }, t.startLoad = function (e) {
                        }, t.stopLoad = function () {
                            this.fragmentLoader.abort(), this.keyLoader.abort();
                            var e = this.fragCurrent;
                            e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = _.STOPPED
                        }, t._streamEnded = function (e, t) {
                            if (t.live || e.nextStart || !e.end || !this.media) return !1;
                            var e = t.partList;
                            if (null != e && e.length) return e = e[e.length - 1], n.BufferHelper.isBuffered(this.media, e.start + e.duration / 2);
                            e = t.fragments[t.fragments.length - 1].type;
                            return this.fragmentTracker.isEndListAppended(e)
                        }, t.getLevelDetails = function () {
                            var e;
                            if (this.levels && null !== this.levelLastLoaded) return null == (e = this.levels[this.levelLastLoaded]) ? void 0 : e.details
                        }, t.onMediaAttached = function (e, t) {
                            t = this.media = this.mediaBuffer = t.media, this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener("seeking", this.onvseeking), t.addEventListener("ended", this.onvended), t = this.config;
                            this.levels && t.autoStartLoad && this.state === _.STOPPED && this.startLoad(t.startPosition)
                        }, t.onMediaDetaching = function () {
                            var e = this.media;
                            null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
                        }, t.onMediaSeeking = function () {
                            var e = this.config, t = this.fragCurrent, i = this.media, r = this.mediaBuffer,
                                s = this.state, a = i ? i.currentTime : 0,
                                r = n.BufferHelper.bufferInfo(r || i, a, e.maxBufferHole);
                            this.log("media seeking to " + ((0, h.isFiniteNumber)(a) ? a.toFixed(3) : a) + ", state: " + s), this.state === _.ENDED ? this.resetLoadingState() : t && (s = e.maxFragLookUpTolerance, e = t.start - s, s = t.start + t.duration + s, (!r.len || s < r.start || e > r.end) && (s = s < a, (a < e || s) && (s && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests()), this.resetLoadingState()))), i && (this.lastCurrentTime = a), this.loadedmetadata || r.len || (this.nextLoadPosition = this.startPosition = a), this.tickImmediate()
                        }, t.onMediaEnded = function () {
                            this.startPosition = this.lastCurrentTime = 0
                        }, t.onLevelSwitching = function (e, t) {
                            this.fragLoadError = 0
                        }, t.onHandlerDestroying = function () {
                            this.stopLoad(), v.prototype.onHandlerDestroying.call(this)
                        }, t.onHandlerDestroyed = function () {
                            this.state = _.STOPPED, this.hls.off(c.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, v.prototype.onHandlerDestroyed.call(this)
                        }, t.loadFragment = function (e, t, i) {
                            this._loadFragForPlayback(e, t, i)
                        }, t._loadFragForPlayback = function (i, e, t) {
                            var r = this;
                            this._doFragLoad(i, e, t, function (e) {
                                if (r.fragContextChanged(i)) return r.warn("Fragment " + i.sn + (e.part ? " p: " + e.part.index : "") + " of level " + i.level + " was dropped during download."), void r.fragmentTracker.removeFragment(i);
                                i.stats.chunkCount++, r._handleFragmentLoadProgress(e)
                            }).then(function (e) {
                                var t;
                                e && (r.fragLoadError = 0, t = r.state, r.fragContextChanged(i) ? t !== _.FRAG_LOADING && (r.fragCurrent || t !== _.PARSING) || (r.fragmentTracker.removeFragment(i), r.state = _.IDLE) : ("payload" in e && (r.log("Loaded fragment " + i.sn + " of level " + i.level), r.hls.trigger(c.Events.FRAG_LOADED, e)), r._handleFragmentLoadComplete(e)))
                            }).catch(function (e) {
                                r.state !== _.STOPPED && r.state !== _.ERROR && (r.warn(e), r.resetFragmentLoading(i))
                            })
                        }, t.flushMainBuffer = function (e, t, i) {
                            void 0 === i && (i = null), e - t && (e = {
                                startOffset: e,
                                endOffset: t,
                                type: i
                            }, this.fragLoadError = 0, this.hls.trigger(c.Events.BUFFER_FLUSHING, e))
                        }, t._loadInitSegment = function (a, e) {
                            var n = this;
                            this._doFragLoad(a, e).then(function (e) {
                                if (e && !n.fragContextChanged(a) && n.levels) return e;
                                throw new Error("init load aborted")
                            }).then(function (i) {
                                var r, s = n.hls, e = i.payload, t = a.decryptdata;
                                return e && 0 < e.byteLength && t && t.key && t.iv && "AES-128" === t.method ? (r = self.performance.now(), n.decrypter.decrypt(new Uint8Array(e), t.key.buffer, t.iv.buffer).then(function (e) {
                                    var t = self.performance.now();
                                    return s.trigger(c.Events.FRAG_DECRYPTED, {
                                        frag: a,
                                        payload: e,
                                        stats: {tstart: r, tdecrypt: t}
                                    }), i.payload = e, i
                                })) : i
                            }).then(function (e) {
                                var t = n.fragCurrent, i = n.hls, r = n.levels;
                                if (!r) throw new Error("init load aborted, missing levels");
                                r = r[a.level].details, console.assert(r, "Level details are defined when init segment is loaded"), r = a.stats;
                                n.state = _.IDLE, n.fragLoadError = 0, a.data = new Uint8Array(e.payload), r.parsing.start = r.buffering.start = self.performance.now(), r.parsing.end = r.buffering.end = self.performance.now(), e.frag === t && i.trigger(c.Events.FRAG_BUFFERED, {
                                    stats: r,
                                    frag: t,
                                    part: null,
                                    id: a.type
                                }), n.tick()
                            }).catch(function (e) {
                                n.state !== _.STOPPED && n.state !== _.ERROR && (n.warn(e), n.resetFragmentLoading(a))
                            })
                        }, t.fragContextChanged = function (e) {
                            var t = this.fragCurrent;
                            return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId
                        }, t.fragBufferedComplete = function (e, t) {
                            var i = this.mediaBuffer || this.media;
                            this.log("Buffered " + e.type + " sn: " + e.sn + (t ? " part: " + t.index : "") + " of " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + e.level + " (frag:[" + (e.startPTS || NaN).toFixed(3) + "-" + (e.endPTS || NaN).toFixed(3) + "] > buffer:" + (i ? g.default.toString(n.BufferHelper.getBuffered(i)) : "(detached)") + ")"), this.state = _.IDLE, i && (!this.loadedmetadata && e.type == y.PlaylistLevelType.MAIN && i.buffered.length && (null == (t = this.fragCurrent) ? void 0 : t.sn) === (null == (e = this.fragPrevious) ? void 0 : e.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
                        }, t.seekToStartPos = function () {
                        }, t._handleFragmentLoadComplete = function (e) {
                            var t, i, r = this.transmuxer;
                            r && (i = e.frag, t = e.part, e = !(e = e.partsLoaded) || 0 === e.length || e.some(function (e) {
                                return !e
                            }), i = new s.ChunkMetadata(i.level, i.sn, i.stats.chunkCount + 1, 0, t ? t.index : -1, !e), r.flush(i))
                        }, t._handleFragmentLoadProgress = function (e) {
                        }, t._doFragLoad = function (t, e, i, r) {
                            var s = this;
                            if (void 0 === i && (i = null), !this.levels) throw new Error("frag load aborted, missing levels");
                            var a = null;
                            if (!t.encrypted || null != (o = t.decryptdata) && o.key ? !t.encrypted && e.encryptedFragments.length && this.keyLoader.loadClear(t, e.encryptedFragments) : (this.log("Loading key for " + t.sn + " of [" + e.startSN + "-" + e.endSN + "], " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + t.level), this.state = _.KEY_LOADING, this.fragCurrent = t, a = this.keyLoader.load(t).then(function (e) {
                                if (!s.fragContextChanged(e.frag)) return s.hls.trigger(c.Events.KEY_LOADED, e), e
                            }), this.hls.trigger(c.Events.KEY_LOADING, {frag: t}), this.throwIfFragContextChanged("KEY_LOADING")), i = Math.max(t.start, i || 0), this.config.lowLatencyMode && e) {
                                var n = e.partList;
                                if (n && r) {
                                    i > t.end && e.fragmentHint && (t = e.fragmentHint);
                                    var o, l = this.getNextPart(n, t, i);
                                    if (-1 < l) return o = n[l], this.log("Loading part sn: " + t.sn + " p: " + o.index + " cc: " + t.cc + " of playlist [" + e.startSN + "-" + e.endSN + "] parts [0-" + l + "-" + (n.length - 1) + "] " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + t.level + ", target: " + parseFloat(i.toFixed(3))), this.nextLoadPosition = o.start + o.duration, this.state = _.FRAG_LOADING, this.hls.trigger(c.Events.FRAG_LOADING, {
                                        frag: t,
                                        part: n[l],
                                        targetBufferTime: i
                                    }), this.throwIfFragContextChanged("FRAG_LOADING parts"), a ? a.then(function (e) {
                                        return !e || s.fragContextChanged(e.frag) ? null : s.doFragPartsLoad(t, n, l, r)
                                    }).catch(function (e) {
                                        return s.handleFragLoadError(e)
                                    }) : this.doFragPartsLoad(t, n, l, r).catch(function (e) {
                                        return s.handleFragLoadError(e)
                                    });
                                    if (!t.url || this.loadedEndOfParts(n, i)) return Promise.resolve(null)
                                }
                            }
                            this.log("Loading fragment " + t.sn + " cc: " + t.cc + " " + (e ? "of [" + e.startSN + "-" + e.endSN + "] " : "") + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + t.level + ", target: " + parseFloat(i.toFixed(3))), (0, h.isFiniteNumber)(t.sn) && !this.bitrateTest && (this.nextLoadPosition = t.start + t.duration), this.state = _.FRAG_LOADING, this.hls.trigger(c.Events.FRAG_LOADING, {
                                frag: t,
                                targetBufferTime: i
                            }), this.throwIfFragContextChanged("FRAG_LOADING");
                            var d = this.config.progressive;
                            return d && a ? a.then(function (e) {
                                return !e || s.fragContextChanged(null == e ? void 0 : e.frag) ? null : s.fragmentLoader.load(t, r)
                            }).catch(function (e) {
                                return s.handleFragLoadError(e)
                            }) : Promise.all([this.fragmentLoader.load(t, d ? r : void 0), a]).then(function (e) {
                                e = e[0];
                                return !d && e && r && r(e), e
                            }).catch(function (e) {
                                return s.handleFragLoadError(e)
                            })
                        }, t.throwIfFragContextChanged = function (e) {
                            if (null === this.fragCurrent) throw new Error("frag load aborted, context changed in " + e)
                        }, t.doFragPartsLoad = function (o, l, t, d) {
                            var h = this;
                            return new Promise(function (a, e) {
                                var n = [];
                                !function i(r) {
                                    var s = l[r];
                                    h.fragmentLoader.loadPart(o, s, d).then(function (e) {
                                        var t = (n[s.index] = e).part,
                                            e = (h.hls.trigger(c.Events.FRAG_LOADED, e), l[r + 1]);
                                        if (!e || e.fragment !== o) return a({frag: o, part: t, partsLoaded: n});
                                        i(r + 1)
                                    }).catch(e)
                                }(t)
                            })
                        }, t.handleFragLoadError = function (e) {
                            var t;
                            return "data" in e ? (t = e.data, e.data && t.details === r.ErrorDetails.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(c.Events.ERROR, t)) : this.hls.trigger(c.Events.ERROR, {
                                type: r.ErrorTypes.OTHER_ERROR,
                                details: r.ErrorDetails.INTERNAL_EXCEPTION,
                                err: e,
                                fatal: !0
                            }), null
                        }, t._handleTransmuxerFlush = function (e) {
                            var t, i, r, s = this.getCurrentContext(e);
                            s && this.state === _.PARSING ? (t = s.frag, i = s.part, s = s.level, r = self.performance.now(), t.stats.parsing.end = r, i && (i.stats.parsing.end = r), this.updateLevelTiming(t, i, s, e.partial)) : this.fragCurrent || this.state === _.STOPPED || this.state === _.ERROR || (this.state = _.IDLE)
                        }, t.getCurrentContext = function (e) {
                            var t = this.levels, i = e.level, r = e.sn, e = e.part;
                            if (!t || !t[i]) return this.warn("Levels object was unset while buffering fragment " + r + " of level " + i + ". The current chunk will not be buffered."), null;
                            t = t[i], i = -1 < e ? (0, p.getPartWith)(t, r, e) : null, e = i ? i.fragment : (0, p.getFragmentWithSN)(t, r, this.fragCurrent);
                            return e ? {frag: e, part: i, level: t} : null
                        }, t.bufferFragmentData = function (e, t, i, r) {
                            var s, a, n;
                            e && this.state === _.PARSING && (n = e.data1, s = e.data2, (a = (a = n) && s ? (0, o.appendUint8Array)(n, s) : a) && a.length && (n = {
                                type: e.type,
                                frag: t,
                                part: i,
                                chunkMeta: r,
                                parent: t.type,
                                data: a
                            }, this.hls.trigger(c.Events.BUFFER_APPENDING, n), e.dropped && e.independent && !i && this.flushBufferGap(t)))
                        }, t.flushBufferGap = function (e) {
                            var t, i, r = this.media;
                            r && (n.BufferHelper.isBuffered(r, r.currentTime) ? (t = r.currentTime, r = n.BufferHelper.bufferInfo(r, t, 0), i = e.duration, i = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * i), r = Math.max(Math.min(e.start - i, r.end - i), t + i), e.start - r > i && this.flushMainBuffer(r, e.start)) : this.flushMainBuffer(0, e.start))
                        }, t.getFwdBufferInfo = function (e, t) {
                            var i = this.config, r = this.getLoadPosition();
                            if (!(0, h.isFiniteNumber)(r)) return null;
                            var s = n.BufferHelper.bufferInfo(e, r, i.maxBufferHole);
                            if (0 === s.len && void 0 !== s.nextStart) {
                                t = this.fragmentTracker.getBufferedFrag(r, t);
                                if (t && s.nextStart < t.end) return n.BufferHelper.bufferInfo(e, r, Math.max(s.nextStart, i.maxBufferHole))
                            }
                            return s
                        }, t.getMaxBufferLength = function (e) {
                            var t = this.config,
                                e = e ? Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : t.maxBufferLength;
                            return Math.min(e, t.maxMaxBufferLength)
                        }, t.reduceMaxBufferLength = function (e) {
                            var t = this.config, e = e || t.maxBufferLength;
                            return t.maxMaxBufferLength >= e && (t.maxMaxBufferLength /= 2, this.warn("Reduce max buffer length to " + t.maxMaxBufferLength + "s"), !0)
                        }, t.getNextFragment = function (e, t) {
                            var i = t.fragments, r = i.length;
                            if (!r) return null;
                            var s, a = this.config, n = i[0].start;
                            if (t.live) {
                                var o = a.initialLiveManifestSize;
                                if (r < o) return this.warn("Not enough fragments to start playback (have: " + r + ", need: " + o + ")"), null;
                                t.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (s = this.getInitialLiveFragment(t, i), this.startPosition = s ? this.hls.liveSyncPosition || s.start : e)
                            } else e <= n && (s = i[0]);
                            return s || (r = a.lowLatencyMode ? t.partEnd : t.fragmentEnd, s = this.getFragmentAtPosition(e, r, t)), this.mapToInitFragWhenRequired(s)
                        }, t.mapToInitFragWhenRequired = function (e) {
                            return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment
                        }, t.getNextPart = function (e, t, i) {
                            for (var r = -1, s = !1, a = !0, n = 0, o = e.length; n < o; n++) {
                                var l = e[n], a = a && !l.independent;
                                if (-1 < r && i < l.start) break;
                                var d = l.loaded;
                                d ? r = -1 : (s || l.independent || a) && l.fragment === t && (r = n), s = d
                            }
                            return r
                        }, t.loadedEndOfParts = function (e, t) {
                            e = e[e.length - 1];
                            return e && t > e.start && e.loaded
                        }, t.getInitialLiveFragment = function (e, t) {
                            var i, r = this.fragPrevious, s = null;
                            return r ? (e.hasProgramDateTime && (this.log("Live playlist, switching playlist, load frag with same PDT: " + r.programDateTime), s = (0, u.findFragmentByPDT)(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), s || ((i = r.sn + 1) >= e.startSN && i <= e.endSN && (i = t[i - e.startSN], r.cc === i.cc && this.log("Live playlist, switching playlist, load frag with next SN: " + (s = i).sn)), s || (s = (0, u.findFragWithCC)(t, r.cc)) && this.log("Live playlist, switching playlist, load frag with same CC: " + s.sn))) : null !== (i = this.hls.liveSyncPosition) && (s = this.getFragmentAtPosition(i, this.bitrateTest ? e.fragmentEnd : e.edge, e)), s
                        }, t.getFragmentAtPosition = function (e, t, i) {
                            var r = this.config, s = this.fragPrevious, a = i.fragments, n = i.endSN,
                                o = i.fragmentHint, l = r.maxFragLookUpTolerance,
                                r = !!(r.lowLatencyMode && i.partList && o);
                            return r && o && !this.bitrateTest && (a = a.concat(o), n = o.sn), (o = e < t ? (0, u.findFragmentByPTS)(s, a, e, t - l < e ? 0 : l) : a[a.length - 1]) && (t = o.sn - i.startSN, (s = this.fragmentTracker.getState(o) === d.FragmentState.OK ? o : s) && o.sn === s.sn && !r && s && o.level === s.level && (e = a[1 + t], o = o.sn < n && this.fragmentTracker.getState(e) !== d.FragmentState.OK ? (this.log("SN " + o.sn + " just loaded, load next one: " + e.sn), e) : null)), o
                        }, t.synchronizeToLiveEdge = function (e) {
                            var t, i, r, s, a = this.config, n = this.media;
                            n && (t = this.hls.liveSyncPosition, i = n.currentTime, s = e.fragments[0].start, r = e.edge, s = i >= s - a.maxFragLookUpTolerance && i <= r, null !== t && n.duration > t && (i < t || !s) && (a = void 0 !== a.liveMaxLatencyDuration ? a.liveMaxLatencyDuration : a.liveMaxLatencyDurationCount * e.targetduration, (!s && n.readyState < 4 || i < r - a) && (this.loadedmetadata || (this.nextLoadPosition = t), n.readyState && (this.warn("Playback: " + i.toFixed(3) + " is located too far from the end of live sliding playlist: " + r + ", reset currentTime to : " + t.toFixed(3)), n.currentTime = t))))
                        }, t.alignPlaylists = function (e, t) {
                            var i = this.levels, r = this.levelLastLoaded, s = this.fragPrevious,
                                i = null !== r ? i[r] : null, r = e.fragments.length;
                            if (!r) return this.warn("No fragments in live playlist"), 0;
                            var a = e.fragments[0].start, n = !t, o = e.alignedSliding && (0, h.isFiniteNumber)(a);
                            return n || !o && !a ? ((0, l.alignStream)(s, i, e), n = e.fragments[0].start, this.log("Live playlist sliding: " + n.toFixed(2) + " start-sn: " + (t ? t.startSN : "na") + "->" + e.startSN + " prev-sn: " + (s ? s.sn : "na") + " fragments: " + r), n) : a
                        }, t.waitForCdnTuneIn = function (e) {
                            return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
                        }, t.setStartPosition = function (e, t) {
                            var i, r = this.startPosition;
                            -1 !== (r = r < t ? -1 : r) && -1 !== this.lastCurrentTime || (i = e.startTimeOffset, (0, h.isFiniteNumber)(i) ? (r = t + i, i < 0 && (r += e.totalduration), r = Math.min(Math.max(t, r), t + e.totalduration), this.log("Start time offset " + i + " found in playlist, adjust startPosition to " + r), this.startPosition = r) : e.live ? r = this.hls.liveSyncPosition || t : this.startPosition = r = 0, this.lastCurrentTime = r), this.nextLoadPosition = r
                        }, t.getLoadPosition = function () {
                            var e = this.media, t = 0;
                            return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t
                        }, t.handleFragLoadAborted = function (e, t) {
                            this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn("Fragment " + e.sn + (t ? " part" + t.index : "") + " of level " + e.level + " was aborted"), this.resetFragmentLoading(e))
                        }, t.resetFragmentLoading = function (e) {
                            this.fragCurrent && (this.fragContextChanged(e) || this.state === _.FRAG_LOADING_WAITING_RETRY) || (this.state = _.IDLE)
                        }, t.onFragmentOrKeyLoadError = function (e, t) {
                            if (t.fatal) return this.stopLoad(), void (this.state = _.ERROR);
                            var i, r = this.config,
                                s = (!t.chunkMeta || (s = this.getCurrentContext(t.chunkMeta)) && (t.frag = s.frag, t.levelRetry = !0, this.fragLoadError = r.fragLoadingMaxRetry), t.frag);
                            s && s.type === e && (i = this.fragCurrent, console.assert(i && s.sn === i.sn && s.level === i.level && s.urlId === i.urlId, "Frag load error must match current frag to retry"), this.fragLoadError + 1 <= r.fragLoadingMaxRetry ? (this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), i = Math.min(Math.pow(2, this.fragLoadError) * r.fragLoadingRetryDelay, r.fragLoadingMaxRetryTimeout), this.warn("Fragment " + s.sn + " of " + e + " " + s.level + " failed to load, retrying in " + i + "ms"), this.retryDate = self.performance.now() + i, this.fragLoadError++, this.state = _.FRAG_LOADING_WAITING_RETRY) : t.levelRetry ? (e === y.PlaylistLevelType.AUDIO && (this.fragCurrent = null), this.fragLoadError = 0, this.state = _.IDLE) : (a.logger.error(t.details + " reaches max retry, redispatch as fatal ..."), t.fatal = !0, this.hls.stopLoad(), this.state = _.ERROR))
                        }, t.afterBufferFlushed = function (e, t, i) {
                            e && (e = n.BufferHelper.getBuffered(e), this.fragmentTracker.detectEvictedFragments(t, e, i), this.state === _.ENDED && this.resetLoadingState())
                        }, t.resetLoadingState = function () {
                            this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = _.IDLE
                        }, t.resetStartWhenNotLoaded = function (e) {
                            this.loadedmetadata || (this.startFragRequested = !1, null != (e = this.levels ? this.levels[e].details : null) && e.live ? (this.startPosition = -1, this.setStartPosition(e, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition)
                        }, t.updateLevelTiming = function (s, e, a, n) {
                            var o = this, l = a.details;
                            console.assert(!!l, "level.details must be defined"), Object.keys(s.elementaryStreams).reduce(function (e, t) {
                                var i = s.elementaryStreams[t];
                                if (i) {
                                    var r = i.endPTS - i.startPTS;
                                    if (r <= 0) return o.warn("Could not parse fragment " + s.sn + " " + t + " duration reliably (" + r + ")"), e || !1;
                                    r = n ? 0 : (0, p.updateFragPTSDTS)(l, s, i.startPTS, i.endPTS, i.startDTS, i.endDTS);
                                    return o.hls.trigger(c.Events.LEVEL_PTS_UPDATED, {
                                        details: l,
                                        level: a,
                                        drift: r,
                                        type: t,
                                        frag: s,
                                        start: i.startPTS,
                                        end: i.endPTS
                                    }), !0
                                }
                                return e
                            }, !1) || (this.warn("Found no media in fragment " + s.sn + " of level " + a.id + " resetting transmuxer to fallback to playlist timing"), this.resetTransmuxer()), this.state = _.PARSED, this.hls.trigger(c.Events.FRAG_PARSED, {
                                frag: s,
                                part: e
                            })
                        }, t.resetTransmuxer = function () {
                            this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
                        }, A((i = S).prototype, [{
                            key: "state", get: function () {
                                return this._state
                            }, set: function (e) {
                                var t = this._state;
                                t !== e && (this._state = e, this.log(t + "->" + e))
                            }
                        }]), Object.defineProperty(i, "prototype", {writable: !1}), S);

                    function S(e, t, i, r) {
                        var s;
                        return (s = v.call(this) || this).hls = void 0, s.fragPrevious = null, s.fragCurrent = null, s.fragmentTracker = void 0, s.transmuxer = null, s._state = _.STOPPED, s.media = null, s.mediaBuffer = null, s.config = void 0, s.bitrateTest = !1, s.lastCurrentTime = 0, s.nextLoadPosition = 0, s.startPosition = 0, s.loadedmetadata = !1, s.fragLoadError = 0, s.retryDate = 0, s.levels = null, s.fragmentLoader = void 0, s.keyLoader = void 0, s.levelLastLoaded = null, s.startFragRequested = !1, s.decrypter = void 0, s.initPTS = [], s.onvseeking = null, s.onvended = null, s.logPrefix = "", s.log = void 0, s.warn = void 0, s.logPrefix = r, s.log = a.logger.log.bind(a.logger, r + ":"), s.warn = a.logger.warn.bind(a.logger, r + ":"), s.hls = e, s.fragmentLoader = new f.default(e.config), s.keyLoader = i, s.fragmentTracker = t, s.config = e.config, s.decrypter = new m.default(e.config), e.on(c.Events.LEVEL_SWITCHING, s.onLevelSwitching, function (e) {
                            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return e
                        }(s)), s
                    }
                }, "./src/controller/buffer-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => a});
                    var d = i("./src/polyfills/number.ts"), g = i("./src/events.ts"), y = i("./src/utils/logger.ts"),
                        A = i("./src/errors.ts"), b = i("./src/utils/buffer-helper.ts"),
                        t = i("./src/utils/mediasource-helper.ts"), n = i("./src/loader/fragment.ts"),
                        r = i("./src/controller/buffer-operation-queue.ts"), s = (0, t.getMediaSource)(),
                        u = /([ha]vc.)(?:\.[^.,]+)+/, a = ((i = o.prototype).hasSourceTypes = function () {
                            return 0 < this.getSourceBufferTypes().length || 0 < Object.keys(this.pendingTracks).length
                        }, i.destroy = function () {
                            this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null
                        }, i.registerListeners = function () {
                            var e = this.hls;
                            e.on(g.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(g.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(g.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(g.Events.BUFFER_RESET, this.onBufferReset, this), e.on(g.Events.BUFFER_APPENDING, this.onBufferAppending, this), e.on(g.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.on(g.Events.BUFFER_EOS, this.onBufferEos, this), e.on(g.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(g.Events.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(g.Events.FRAG_PARSED, this.onFragParsed, this), e.on(g.Events.FRAG_CHANGED, this.onFragChanged, this)
                        }, i.unregisterListeners = function () {
                            var e = this.hls;
                            e.off(g.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(g.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(g.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(g.Events.BUFFER_RESET, this.onBufferReset, this), e.off(g.Events.BUFFER_APPENDING, this.onBufferAppending, this), e.off(g.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.off(g.Events.BUFFER_EOS, this.onBufferEos, this), e.off(g.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(g.Events.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(g.Events.FRAG_PARSED, this.onFragParsed, this), e.off(g.Events.FRAG_CHANGED, this.onFragChanged, this)
                        }, i._initSourceBuffer = function () {
                            this.sourceBuffer = {}, this.operationQueue = new r.default(this.sourceBuffer), this.listeners = {
                                audio: [],
                                video: [],
                                audiovideo: []
                            }, this.lastMpegAudioChunk = null
                        }, i.onManifestParsed = function (e, t) {
                            var i = 2;
                            (!t.audio || t.video) && t.altAudio || (i = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = i, this.details = null, y.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected")
                        }, i.onMediaAttaching = function (e, t) {
                            var i, t = this.media = t.media;
                            t && s && ((i = this.mediaSource = new s).addEventListener("sourceopen", this._onMediaSourceOpen), i.addEventListener("sourceended", this._onMediaSourceEnded), i.addEventListener("sourceclose", this._onMediaSourceClose), t.src = self.URL.createObjectURL(i), this._objectUrl = t.src)
                        }, i.onMediaDetaching = function () {
                            var e = this.media, t = this.mediaSource, i = this._objectUrl;
                            if (t) {
                                if (y.logger.log("[buffer-controller]: media source detaching"), "open" === t.readyState) try {
                                    t.endOfStream()
                                } catch (e) {
                                    y.logger.warn("[buffer-controller]: onMediaDetaching: " + e.message + " while calling endOfStream")
                                }
                                this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), e && (i && self.URL.revokeObjectURL(i), e.src === i ? (e.removeAttribute("src"), e.load()) : y.logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
                            }
                            this.hls.trigger(g.Events.MEDIA_DETACHED, void 0)
                        }, i.onBufferReset = function () {
                            var i = this;
                            this.getSourceBufferTypes().forEach(function (t) {
                                var e = i.sourceBuffer[t];
                                try {
                                    e && (i.removeBufferListeners(t), i.mediaSource && i.mediaSource.removeSourceBuffer(e), i.sourceBuffer[t] = void 0)
                                } catch (e) {
                                    y.logger.warn("[buffer-controller]: Failed to reset the " + t + " buffer", e)
                                }
                            }), this._initSourceBuffer()
                        }, i.onBufferCodecs = function (e, d) {
                            var h = this, c = this.getSourceBufferTypes().length;
                            Object.keys(d).forEach(function (e) {
                                var t, i, r, s, a, n, o, l;
                                c ? (t = h.tracks[e]) && "function" == typeof t.buffer.changeType && (i = (n = d[e]).id, r = n.codec, s = n.levelCodec, a = n.container, n = n.metadata, (o = (t.levelCodec || t.codec).replace(u, "$1")) !== (l = (s || r).replace(u, "$1")) && (h.appendChangeType(e, a + ";codecs=" + (s || r)), y.logger.log("[buffer-controller]: switching codec " + o + " to " + l), h.tracks[e] = {
                                    buffer: t.buffer,
                                    codec: r,
                                    container: a,
                                    levelCodec: s,
                                    metadata: n,
                                    id: i
                                })) : h.pendingTracks[e] = d[e]
                            }), c || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
                        }, i.appendChangeType = function (t, i) {
                            var r = this, s = this.operationQueue;
                            s.append({
                                execute: function () {
                                    var e = r.sourceBuffer[t];
                                    e && (y.logger.log("[buffer-controller]: changing " + t + " sourceBuffer type to " + i), e.changeType(i)), s.shiftAndExecuteNext(t)
                                }, onStart: function () {
                                }, onComplete: function () {
                                }, onError: function (e) {
                                    y.logger.warn("[buffer-controller]: Failed to change " + t + " SourceBuffer type", e)
                                }
                            }, t)
                        }, i.onBufferAppending = function (e, t) {
                            var s = this, i = this.hls, r = this.operationQueue, a = this.tracks, n = t.data, o = t.type,
                                l = t.frag, d = t.part, h = t.chunkMeta, c = h.buffering[o], t = self.performance.now(),
                                u = (c.start = t, l.stats.buffering), p = d ? d.stats.buffering : null,
                                t = (0 === u.start && (u.start = t), p && 0 === p.start && (p.start = t), a.audio), f = !1,
                                m = ("audio" === o && "audio/mpeg" === (null == t ? void 0 : t.container) && (f = !this.lastMpegAudioChunk || 1 === h.id || this.lastMpegAudioChunk.sn !== h.sn, this.lastMpegAudioChunk = h), l.start);
                            r.append({
                                execute: function () {
                                    var e, t;
                                    c.executeStart = self.performance.now(), f && (e = s.sourceBuffer[o]) && (t = m - e.timestampOffset, .1 <= Math.abs(t) && (y.logger.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + m + " (delta: " + t + ") sn: " + l.sn + ")"), e.timestampOffset = m)), s.appendExecutor(n, o)
                                }, onStart: function () {
                                }, onComplete: function () {
                                    var e, t = self.performance.now(),
                                        i = (c.executeEnd = c.end = t, 0 === u.first && (u.first = t), p && 0 === p.first && (p.first = t), s.sourceBuffer),
                                        r = {};
                                    for (e in i) r[e] = b.BufferHelper.getBuffered(i[e]);
                                    s.appendError = 0, s.hls.trigger(g.Events.BUFFER_APPENDED, {
                                        type: o,
                                        frag: l,
                                        part: d,
                                        chunkMeta: h,
                                        parent: l.type,
                                        timeRanges: r
                                    })
                                }, onError: function (e) {
                                    y.logger.error("[buffer-controller]: Error encountered while trying to append to the " + o + " SourceBuffer", e);
                                    var t = {
                                        type: A.ErrorTypes.MEDIA_ERROR,
                                        parent: l.type,
                                        details: A.ErrorDetails.BUFFER_APPEND_ERROR,
                                        err: e,
                                        fatal: !1
                                    };
                                    e.code === DOMException.QUOTA_EXCEEDED_ERR ? t.details = A.ErrorDetails.BUFFER_FULL_ERROR : (s.appendError++, t.details = A.ErrorDetails.BUFFER_APPEND_ERROR, s.appendError > i.config.appendErrorMaxRetry && (y.logger.error("[buffer-controller]: Failed " + i.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), t.fatal = !0, i.stopLoad())), i.trigger(g.Events.ERROR, t)
                                }
                            }, o)
                        }, i.onBufferFlushing = function (e, i) {
                            function t(t) {
                                return {
                                    execute: r.removeExecutor.bind(r, t, i.startOffset, i.endOffset),
                                    onStart: function () {
                                    },
                                    onComplete: function () {
                                        r.hls.trigger(g.Events.BUFFER_FLUSHED, {type: t})
                                    },
                                    onError: function (e) {
                                        y.logger.warn("[buffer-controller]: Failed to remove from " + t + " SourceBuffer", e)
                                    }
                                }
                            }

                            var r = this, s = this.operationQueue;
                            i.type ? s.append(t(i.type), i.type) : this.getSourceBufferTypes().forEach(function (e) {
                                s.append(t(e), e)
                            })
                        }, i.onFragParsed = function (e, t) {
                            var i = this, r = t.frag, s = t.part, t = [], a = (s || r).elementaryStreams;
                            a[n.ElementaryStreamTypes.AUDIOVIDEO] ? t.push("audiovideo") : (a[n.ElementaryStreamTypes.AUDIO] && t.push("audio"), a[n.ElementaryStreamTypes.VIDEO] && t.push("video")), 0 === t.length && y.logger.warn("Fragments must have at least one ElementaryStreamType set. type: " + r.type + " level: " + r.level + " sn: " + r.sn), this.blockBuffers(function () {
                                var e = self.performance.now(),
                                    e = (r.stats.buffering.end = e, s && (s.stats.buffering.end = e), (s || r).stats);
                                i.hls.trigger(g.Events.FRAG_BUFFERED, {frag: r, part: s, stats: e, id: r.type})
                            }, t)
                        }, i.onFragChanged = function (e, t) {
                            this.flushBackBuffer()
                        }, i.onBufferEos = function (e, r) {
                            var s = this;
                            this.getSourceBufferTypes().reduce(function (e, t) {
                                var i = s.sourceBuffer[t];
                                return !i || r.type && r.type !== t || (i.ending = !0, i.ended || (i.ended = !0, y.logger.log("[buffer-controller]: " + t + " sourceBuffer now EOS"))), e && !(i && !i.ended)
                            }, !0) && (y.logger.log("[buffer-controller]: Queueing mediaSource.endOfStream()"), this.blockBuffers(function () {
                                s.getSourceBufferTypes().forEach(function (e) {
                                    e = s.sourceBuffer[e];
                                    e && (e.ending = !1)
                                });
                                var e = s.mediaSource;
                                e && "open" === e.readyState ? (y.logger.log("[buffer-controller]: Calling mediaSource.endOfStream()"), e.endOfStream()) : e && y.logger.info("[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: " + e.readyState)
                            }))
                        }, i.onLevelUpdated = function (e, t) {
                            t = t.details;
                            t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
                        }, i.flushBackBuffer = function () {
                            var e, t, r, s, a, n = this.hls, o = this.details, i = this.media, l = this.sourceBuffer;
                            i && null !== o && (e = this.getSourceBufferTypes()).length && (t = o.live && null !== n.config.liveBackBufferLength ? n.config.liveBackBufferLength : n.config.backBufferLength, !(0, d.isFiniteNumber)(t) || t < 0 || (r = i.currentTime, s = o.levelTargetDuration, i = Math.max(t, s), a = Math.floor(r / s) * s - i, e.forEach(function (e) {
                                var t = l[e];
                                if (t) {
                                    var i = b.BufferHelper.getBuffered(t);
                                    if (0 < i.length && a > i.start(0)) {
                                        if (n.trigger(g.Events.BACK_BUFFER_REACHED, {bufferEnd: a}), o.live) n.trigger(g.Events.LIVE_BACK_BUFFER_REACHED, {bufferEnd: a}); else if (t.ended && i.end(i.length - 1) - r < 2 * s) return void y.logger.info("[buffer-controller]: Cannot flush " + e + " back buffer while SourceBuffer is in ended state");
                                        n.trigger(g.Events.BUFFER_FLUSHING, {startOffset: 0, endOffset: a, type: e})
                                    }
                                }
                            })))
                        }, i.updateMediaElementDuration = function () {
                            var e, t, i, r, s, a;
                            this.details && this.media && this.mediaSource && "open" === this.mediaSource.readyState && (e = this.details, t = this.hls, s = this.media, i = this.mediaSource, r = e.fragments[0].start + e.totalduration, s = s.duration, a = (0, d.isFiniteNumber)(i.duration) ? i.duration : 0, e.live && t.config.liveDurationInfinity ? (y.logger.log("[buffer-controller]: Media Source duration is set to Infinity"), i.duration = 1 / 0, this.updateSeekableRange(e)) : (a < r && s < r || !(0, d.isFiniteNumber)(s)) && (y.logger.log("[buffer-controller]: Updating Media Source duration to " + r.toFixed(3)), i.duration = r))
                        }, i.updateSeekableRange = function (e) {
                            var t = this.mediaSource, i = e.fragments;
                            i.length && e.live && null != t && t.setLiveSeekableRange && (i = Math.max(0, i[0].start), e = Math.max(i, i + e.totalduration), t.setLiveSeekableRange(i, e))
                        }, i.checkPendingTracks = function () {
                            var e = this.bufferCodecEventsExpected, t = this.operationQueue, i = this.pendingTracks,
                                r = Object.keys(i).length;
                            (r && !e || 2 === r) && (this.createSourceBuffers(i), this.pendingTracks = {}, 0 === (e = this.getSourceBufferTypes()).length ? this.hls.trigger(g.Events.ERROR, {
                                type: A.ErrorTypes.MEDIA_ERROR,
                                details: A.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                reason: "could not create source buffer for media codec(s)"
                            }) : e.forEach(function (e) {
                                t.executeNext(e)
                            }))
                        }, i.createSourceBuffers = function (e) {
                            var t = this.sourceBuffer, i = this.mediaSource;
                            if (!i) throw Error("createSourceBuffers called when mediaSource was null");
                            var r, s = 0;
                            for (r in e) if (!t[r]) {
                                var a = e[r];
                                if (!a) throw Error("source buffer exists for track " + r + ", however track does not");
                                var n = a.levelCodec || a.codec, o = a.container + ";codecs=" + n;
                                y.logger.log("[buffer-controller]: creating sourceBuffer(" + o + ")");
                                try {
                                    var l = t[r] = i.addSourceBuffer(o), d = r;
                                    this.addBufferListener(d, "updatestart", this._onSBUpdateStart), this.addBufferListener(d, "updateend", this._onSBUpdateEnd), this.addBufferListener(d, "error", this._onSBUpdateError), this.tracks[r] = {
                                        buffer: l,
                                        codec: n,
                                        container: a.container,
                                        levelCodec: a.levelCodec,
                                        metadata: a.metadata,
                                        id: a.id
                                    }, s++
                                } catch (e) {
                                    y.logger.error("[buffer-controller]: error while trying to add sourceBuffer: " + e.message), this.hls.trigger(g.Events.ERROR, {
                                        type: A.ErrorTypes.MEDIA_ERROR,
                                        details: A.ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                                        fatal: !1,
                                        error: e,
                                        mimeType: o
                                    })
                                }
                            }
                            s && this.hls.trigger(g.Events.BUFFER_CREATED, {tracks: this.tracks})
                        }, i._onSBUpdateStart = function (e) {
                            this.operationQueue.current(e).onStart()
                        }, i._onSBUpdateEnd = function (e) {
                            var t = this.operationQueue;
                            t.current(e).onComplete(), t.shiftAndExecuteNext(e)
                        }, i._onSBUpdateError = function (e, t) {
                            y.logger.error("[buffer-controller]: " + e + " SourceBuffer error", t), this.hls.trigger(g.Events.ERROR, {
                                type: A.ErrorTypes.MEDIA_ERROR,
                                details: A.ErrorDetails.BUFFER_APPENDING_ERROR,
                                fatal: !1
                            });
                            e = this.operationQueue.current(e);
                            e && e.onError(t)
                        }, i.removeExecutor = function (e, t, i) {
                            var r = this.media, s = this.mediaSource, a = this.operationQueue, n = this.sourceBuffer[e];
                            if (!r || !s || !n) return y.logger.warn("[buffer-controller]: Attempting to remove from the " + e + " SourceBuffer, but it does not exist"), void a.shiftAndExecuteNext(e);
                            r = (0, d.isFiniteNumber)(r.duration) ? r.duration : 1 / 0, s = (0, d.isFiniteNumber)(s.duration) ? s.duration : 1 / 0, t = Math.max(0, t), i = Math.min(i, r, s);
                            t < i && !n.ending ? (n.ended = !1, y.logger.log("[buffer-controller]: Removing [" + t + "," + i + "] from the " + e + " SourceBuffer"), console.assert(!n.updating, e + " sourceBuffer must not be updating"), n.remove(t, i)) : a.shiftAndExecuteNext(e)
                        }, i.appendExecutor = function (e, t) {
                            var i = this.operationQueue, r = this.sourceBuffer[t];
                            if (!r) return y.logger.warn("[buffer-controller]: Attempting to append to the " + t + " SourceBuffer, but it does not exist"), void i.shiftAndExecuteNext(t);
                            r.ended = !1, console.assert(!r.updating, t + " sourceBuffer must not be updating"), r.appendBuffer(e)
                        }, i.blockBuffers = function (e, t) {
                            var i = this;
                            if (!(t = void 0 === t ? this.getSourceBufferTypes() : t).length) return y.logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve().then(e);
                            var r = this.operationQueue, s = t.map(function (e) {
                                return r.appendBlocker(e)
                            });
                            Promise.all(s).then(function () {
                                e(), t.forEach(function (e) {
                                    var t = i.sourceBuffer[e];
                                    t && t.updating || r.shiftAndExecuteNext(e)
                                })
                            })
                        }, i.getSourceBufferTypes = function () {
                            return Object.keys(this.sourceBuffer)
                        }, i.addBufferListener = function (e, t, i) {
                            var r = this.sourceBuffer[e];
                            r && (i = i.bind(this, e), this.listeners[e].push({
                                event: t,
                                listener: i
                            }), r.addEventListener(t, i))
                        }, i.removeBufferListeners = function (e) {
                            var t = this.sourceBuffer[e];
                            t && this.listeners[e].forEach(function (e) {
                                t.removeEventListener(e.event, e.listener)
                            })
                        }, o);

                    function o(e) {
                        var r = this;
                        this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function () {
                            var e = r.hls, t = r.media, i = r.mediaSource;
                            y.logger.log("[buffer-controller]: Media source opened"), t && (r.updateMediaElementDuration(), e.trigger(g.Events.MEDIA_ATTACHED, {media: t})), i && i.removeEventListener("sourceopen", r._onMediaSourceOpen), r.checkPendingTracks()
                        }, this._onMediaSourceClose = function () {
                            y.logger.log("[buffer-controller]: Media source closed")
                        }, this._onMediaSourceEnded = function () {
                            y.logger.log("[buffer-controller]: Media source ended")
                        }, this.hls = e, this._initSourceBuffer(), this.registerListeners()
                    }
                }, "./src/controller/buffer-operation-queue.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var a = i("./src/utils/logger.ts"), r = ((t = s.prototype).append = function (e, t) {
                        var i = this.queues[t];
                        i.push(e), 1 === i.length && this.buffers[t] && this.executeNext(t)
                    }, t.insertAbort = function (e, t) {
                        this.queues[t].unshift(e), this.executeNext(t)
                    }, t.appendBlocker = function (e) {
                        var t, i = new Promise(function (e) {
                            t = e
                        }), r = {
                            execute: t, onStart: function () {
                            }, onComplete: function () {
                            }, onError: function () {
                            }
                        };
                        return this.append(r, e), i
                    }, t.executeNext = function (e) {
                        var t = this.buffers, i = this.queues, r = t[e], i = i[e];
                        if (i.length) {
                            var s = i[0];
                            try {
                                s.execute()
                            } catch (t) {
                                a.logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), s.onError(t), r && r.updating || (i.shift(), this.executeNext(e))
                            }
                        }
                    }, t.shiftAndExecuteNext = function (e) {
                        this.queues[e].shift(), this.executeNext(e)
                    }, t.current = function (e) {
                        return this.queues[e][0]
                    }, s);

                    function s(e) {
                        this.buffers = void 0, this.queues = {video: [], audio: [], audiovideo: []}, this.buffers = e
                    }
                }, "./src/controller/cap-level-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => n});
                    var r = i("./src/events.ts");

                    function s(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function a(e) {
                        this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
                    }

                    (t = a.prototype).setStreamController = function (e) {
                        this.streamController = e
                    }, t.destroy = function () {
                        this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
                    }, t.registerListeners = function () {
                        var e = this.hls;
                        e.on(r.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(r.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(r.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(r.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.on(r.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
                    }, t.unregisterListener = function () {
                        var e = this.hls;
                        e.off(r.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(r.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(r.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(r.Events.BUFFER_CODECS, this.onBufferCodecs, this), e.off(r.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
                    }, t.onFpsDropLevelCapping = function (e, t) {
                        a.isLevelAllowed(t.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(t.droppedLevel)
                    }, t.onMediaAttaching = function (e, t) {
                        this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null
                    }, t.onManifestParsed = function (e, t) {
                        var i = this.hls;
                        this.restrictedLevels = [], this.firstLevel = t.firstLevel, i.config.capLevelToPlayerSize && t.video && this.startCapping()
                    }, t.onBufferCodecs = function (e, t) {
                        this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
                    }, t.onMediaDetaching = function () {
                        this.stopCapping()
                    }, t.detectPlayerSize = function () {
                        var e, t;
                        this.media && 0 < this.mediaHeight && 0 < this.mediaWidth && ((e = this.hls.levels).length && ((t = this.hls).autoLevelCapping = this.getMaxLevel(e.length - 1), t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping))
                    }, t.getMaxLevel = function (i) {
                        var r = this, e = this.hls.levels;
                        if (!e.length) return -1;
                        e = e.filter(function (e, t) {
                            return a.isLevelAllowed(t, r.restrictedLevels) && t <= i
                        });
                        return this.clientRect = null, a.getMaxLevelByMediaSize(e, this.mediaWidth, this.mediaHeight)
                    }, t.startCapping = function () {
                        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
                    }, t.stopCapping = function () {
                        this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
                    }, t.getDimensions = function () {
                        if (this.clientRect) return this.clientRect;
                        var e, t = this.media, i = {width: 0, height: 0};
                        return t && (e = t.getBoundingClientRect(), i.width = e.width, i.height = e.height, i.width || i.height || (i.width = e.right - e.left || t.width || 0, i.height = e.bottom - e.top || t.height || 0)), this.clientRect = i
                    }, a.isLevelAllowed = function (e, t) {
                        return -1 === (t = void 0 === t ? [] : t).indexOf(e)
                    }, a.getMaxLevelByMediaSize = function (e, t, i) {
                        if (!e || !e.length) return -1;
                        for (var r, s = e.length - 1, a = 0; a < e.length; a += 1) {
                            var n = e[a];
                            if ((n.width >= t || n.height >= i) && (!(r = e[a + 1]) || n.width !== r.width || n.height !== r.height)) {
                                s = a;
                                break
                            }
                        }
                        return s
                    }, s((t = a).prototype, [{
                        key: "mediaWidth", get: function () {
                            return this.getDimensions().width * this.contentScaleFactor
                        }
                    }, {
                        key: "mediaHeight", get: function () {
                            return this.getDimensions().height * this.contentScaleFactor
                        }
                    }, {
                        key: "contentScaleFactor", get: function () {
                            var e = 1;
                            if (!this.hls.config.ignoreDevicePixelRatio) try {
                                e = self.devicePixelRatio
                            } catch (e) {
                            }
                            return e
                        }
                    }]), Object.defineProperty(t, "prototype", {writable: !1});
                    const n = a
                }, "./src/controller/cmcd-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => u});
                    var r = i("./src/events.ts"), n = i("./src/types/cmcd.ts"), s = i("./src/utils/buffer-helper.ts"),
                        o = i("./src/utils/logger.ts");

                    function a(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function l(e, t, i) {
                        t && a(e.prototype, t), i && a(e, i), Object.defineProperty(e, "prototype", {writable: !1})
                    }

                    function h(e, t) {
                        var i, r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (r) return (r = r.call(e)).next.bind(r);
                        if (Array.isArray(e) || (r = function (e) {
                            if (e) {
                                if ("string" == typeof e) return d(e, void 0);
                                var t = Object.prototype.toString.call(e).slice(8, -1);
                                return "Map" === (t = "Object" === t && e.constructor ? e.constructor.name : t) || "Set" === t ? Array.from(e) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? d(e, void 0) : void 0
                            }
                        }(e)) || t && e && "number" == typeof e.length) return r && (e = r), i = 0, function () {
                            return i >= e.length ? {done: !0} : {done: !1, value: e[i++]}
                        };
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }

                    function d(e, t) {
                        (null == t || t > e.length) && (t = e.length);
                        for (var i = 0, r = new Array(t); i < t; i++) r[i] = e[i];
                        return r
                    }

                    function c() {
                        return (c = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    (t = p.prototype).registerListeners = function () {
                        var e = this.hls;
                        e.on(r.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(r.Events.MEDIA_DETACHED, this.onMediaDetached, this), e.on(r.Events.BUFFER_CREATED, this.onBufferCreated, this)
                    }, t.unregisterListeners = function () {
                        var e = this.hls;
                        e.off(r.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(r.Events.MEDIA_DETACHED, this.onMediaDetached, this), e.off(r.Events.BUFFER_CREATED, this.onBufferCreated, this), this.onMediaDetached()
                    }, t.destroy = function () {
                        this.unregisterListeners(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null
                    }, t.onMediaAttached = function (e, t) {
                        this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
                    }, t.onMediaDetached = function () {
                        this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
                    }, t.onBufferCreated = function (e, t) {
                        var i;
                        this.audioBuffer = null == (i = t.tracks.audio) ? void 0 : i.buffer, this.videoBuffer = null == (i = t.tracks.video) ? void 0 : i.buffer
                    }, t.createData = function () {
                        var e;
                        return {
                            v: n.CMCDVersion,
                            sf: n.CMCDStreamingFormat.HLS,
                            sid: this.sid,
                            cid: this.cid,
                            pr: null == (e = this.media) ? void 0 : e.playbackRate,
                            mtp: this.hls.bandwidthEstimate / 1e3
                        }
                    }, t.apply = function (e, t) {
                        c(t = void 0 === t ? {} : t, this.createData());
                        var i = t.ot === n.CMCDObjectType.INIT || t.ot === n.CMCDObjectType.VIDEO || t.ot === n.CMCDObjectType.MUXED;
                        this.starved && i && (t.bs = !0, t.su = !0, this.starved = !1), null == t.su && (t.su = this.buffering), this.useHeaders ? (i = p.toHeaders(t), Object.keys(i).length && (e.headers || (e.headers = {}), c(e.headers, i))) : (i = p.toQuery(t)) && (e.url = p.appendQueryToUri(e.url, i))
                    }, t.getObjectType = function (e) {
                        var t = e.type;
                        return "subtitle" === t ? n.CMCDObjectType.TIMED_TEXT : "initSegment" === e.sn ? n.CMCDObjectType.INIT : "audio" === t ? n.CMCDObjectType.AUDIO : "main" === t ? this.hls.audioTracks.length ? n.CMCDObjectType.VIDEO : n.CMCDObjectType.MUXED : void 0
                    }, t.getTopBandwidth = function (e) {
                        for (var t = 0, i = this.hls, r = h(e === n.CMCDObjectType.AUDIO ? i.audioTracks : (e = -1 < (e = i.maxAutoLevel) ? e + 1 : i.levels.length, i.levels.slice(0, e))); !(s = r()).done;) {
                            var s = s.value;
                            s.bitrate > t && (t = s.bitrate)
                        }
                        return 0 < t ? t : NaN
                    }, t.getBufferLength = function (e) {
                        var t = this.hls.media, e = e === n.CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
                        return e && t ? 1e3 * s.BufferHelper.bufferInfo(e, t.currentTime, this.config.maxBufferHole).len : NaN
                    }, t.createPlaylistLoader = function () {
                        var e = this.config.pLoader, r = this.applyPlaylistData, t = e || this.config.loader;
                        return (e = i.prototype).destroy = function () {
                            this.loader.destroy()
                        }, e.abort = function () {
                            this.loader.abort()
                        }, e.load = function (e, t, i) {
                            r(e), this.loader.load(e, t, i)
                        }, l(i, [{
                            key: "stats", get: function () {
                                return this.loader.stats
                            }
                        }, {
                            key: "context", get: function () {
                                return this.loader.context
                            }
                        }]), i;

                        function i(e) {
                            this.loader = void 0, this.loader = new t(e)
                        }
                    }, t.createFragmentLoader = function () {
                        var e = this.config.fLoader, r = this.applyFragmentData, t = e || this.config.loader;
                        return (e = i.prototype).destroy = function () {
                            this.loader.destroy()
                        }, e.abort = function () {
                            this.loader.abort()
                        }, e.load = function (e, t, i) {
                            r(e), this.loader.load(e, t, i)
                        }, l(i, [{
                            key: "stats", get: function () {
                                return this.loader.stats
                            }
                        }, {
                            key: "context", get: function () {
                                return this.loader.context
                            }
                        }]), i;

                        function i(e) {
                            this.loader = void 0, this.loader = new t(e)
                        }
                    }, p.uuid = function () {
                        var e = URL.createObjectURL(new Blob), t = e.toString();
                        return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1)
                    }, p.serialize = function (e) {
                        for (var t = [], i = function (e) {
                            return Math.round(e)
                        }, r = function (e) {
                            return 100 * i(e / 100)
                        }, s = {
                            br: i, d: i, bl: r, dl: r, mtp: r, nor: function (e) {
                                return encodeURIComponent(e)
                            }, rtp: r, tb: i
                        }, a = h(Object.keys(e || {}).sort()); !(l = a()).done;) {
                            var n, o, l = l.value, d = e[l];
                            n = d, Number.isNaN(n) || null == n || "" === n || !1 === n || "v" === l && 1 === d || "pr" == l && 1 === d || (n = typeof (d = (n = s[l]) ? n(d) : d), o = void 0, o = "ot" === l || "sf" === l || "st" === l ? l + "=" + d : "boolean" == n ? l : "number" == n ? l + "=" + d : l + "=" + JSON.stringify(d), t.push(o))
                        }
                        return t.join(",")
                    }, p.toHeaders = function (e) {
                        for (var t = {}, i = ["Object", "Request", "Session", "Status"], r = [{}, {}, {}, {}], s = {
                            br: 0,
                            d: 0,
                            ot: 0,
                            tb: 0,
                            bl: 1,
                            dl: 1,
                            mtp: 1,
                            nor: 1,
                            nrr: 1,
                            su: 1,
                            cid: 2,
                            pr: 2,
                            sf: 2,
                            sid: 2,
                            st: 2,
                            v: 2,
                            bs: 3,
                            rtp: 3
                        }, a = 0, n = Object.keys(e); a < n.length; a++) {
                            var o = n[a];
                            r[null != s[o] ? s[o] : 1][o] = e[o]
                        }
                        for (var l = 0; l < r.length; l++) {
                            var d = p.serialize(r[l]);
                            d && (t["CMCD-" + i[l]] = d)
                        }
                        return t
                    }, p.toQuery = function (e) {
                        return "CMCD=" + encodeURIComponent(p.serialize(e))
                    }, p.appendQueryToUri = function (e, t) {
                        if (!t) return e;
                        var i = e.includes("?") ? "&" : "?";
                        return e + i + t
                    };
                    var u = p;

                    function p(e) {
                        var a = this,
                            e = (this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = function () {
                                a.initialized && (a.starved = !0), a.buffering = !0
                            }, this.onPlaying = function () {
                                a.initialized || (a.initialized = !0), a.buffering = !1
                            }, this.applyPlaylistData = function (e) {
                                try {
                                    a.apply(e, {ot: n.CMCDObjectType.MANIFEST, su: !a.initialized})
                                } catch (e) {
                                    o.logger.warn("Could not generate manifest CMCD data.", e)
                                }
                            }, this.applyFragmentData = function (e) {
                                try {
                                    var t = e.frag, i = a.hls.levels[t.level], r = a.getObjectType(t),
                                        s = {d: 1e3 * t.duration, ot: r};
                                    r !== n.CMCDObjectType.VIDEO && r !== n.CMCDObjectType.AUDIO && r != n.CMCDObjectType.MUXED || (s.br = i.bitrate / 1e3, s.tb = a.getTopBandwidth(r) / 1e3, s.bl = a.getBufferLength(r)), a.apply(e, s)
                                } catch (e) {
                                    o.logger.warn("Could not generate segment CMCD data.", e)
                                }
                            }, this.hls = e, this.config = e.config), t = e.cmcd;
                        null != t && (e.pLoader = this.createPlaylistLoader(), e.fLoader = this.createFragmentLoader(), this.sid = t.sessionId || p.uuid(), this.cid = t.contentId, this.useHeaders = !0 === t.useHeaders, this.registerListeners())
                    }
                }, "./src/controller/eme-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => S});
                    var r = i("./src/events.ts"), h = i("./src/errors.ts"), s = i("./src/utils/logger.ts"),
                        m = i("./src/utils/mediakeys-helper.ts"), c = i("./src/utils/keysystem-util.ts"),
                        g = i("./src/utils/numeric-encoding-utils.ts"), y = i("./src/loader/level-key.ts"),
                        A = i("./src/utils/hex.ts"), b = i("./src/utils/mp4-tools.ts"),
                        t = i("./node_modules/eventemitter3/index.js"), u = i.n(t);

                    function a(e) {
                        var i = "function" == typeof Map ? new Map : void 0;
                        return (a = function (e) {
                            if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e;
                            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                            if (void 0 !== i) {
                                if (i.has(e)) return i.get(e);
                                i.set(e, t)
                            }

                            function t() {
                                return n(e, arguments, l(this).constructor)
                            }

                            return t.prototype = Object.create(e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), o(t, e)
                        })(e)
                    }

                    function n(e, t, i) {
                        return (n = function () {
                            if ("undefined" == typeof Reflect || !Reflect.construct) return;
                            if (Reflect.construct.sham) return;
                            if ("function" == typeof Proxy) return 1;
                            try {
                                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
                                })), 1
                            } catch (e) {
                                return
                            }
                        }() ? Reflect.construct.bind() : function (e, t, i) {
                            var r = [null], t = (r.push.apply(r, t), new (Function.bind.apply(e, r)));
                            return i && o(t, i.prototype), t
                        }).apply(null, arguments)
                    }

                    function o(e, t) {
                        return (o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function l(e) {
                        return (l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {
                            return e.__proto__ || Object.getPrototypeOf(e)
                        })(e)
                    }

                    var d = "[eme]", t = ((i = p.prototype).destroy = function () {
                        this.unregisterListeners(), this.onMediaDetached(), this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null
                    }, i.registerListeners = function () {
                        this.hls.on(r.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(r.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(r.Events.MANIFEST_LOADED, this.onManifestLoaded, this)
                    }, i.unregisterListeners = function () {
                        this.hls.off(r.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(r.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(r.Events.MANIFEST_LOADED, this.onManifestLoaded, this)
                    }, i.getLicenseServerUrl = function (e) {
                        var t = this.config, i = t.drmSystems, t = t.widevineLicenseUrl, i = i[e];
                        if (i) return i.licenseUrl;
                        if (e === m.KeySystems.WIDEVINE && t) return t;
                        throw new Error('no license server URL configured for key-system "' + e + '"')
                    }, i.getServerCertificateUrl = function (e) {
                        var t = this.config.drmSystems[e];
                        if (t) return t.serverCertificateUrl;
                        this.log('No Server Certificate in config.drmSystems["' + e + '"]')
                    }, i.attemptKeySystemAccess = function (e) {
                        function t(e, t, i) {
                            return !!e && i.indexOf(e) === t
                        }

                        var n = this, i = this.hls.levels, o = i.map(function (e) {
                            return e.audioCodec
                        }).filter(t), l = i.map(function (e) {
                            return e.videoCodec
                        }).filter(t);
                        return o.length + l.length === 0 && l.push("avc1.42e01e"), new Promise(function (s, a) {
                            !function t(i) {
                                var r = i.shift();
                                n.getMediaKeysPromise(r, o, l).then(function (e) {
                                    return s({keySystem: r, mediaKeys: e})
                                }).catch(function (e) {
                                    i.length ? t(i) : a(e instanceof _ ? e : new _({
                                        type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: h.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                                        error: e,
                                        fatal: !0
                                    }, e.message))
                                })
                            }(e)
                        })
                    }, i.requestMediaKeySystemAccess = function (e, t) {
                        var i, r = this.config.requestMediaKeySystemAccessFunc;
                        return "function" != typeof r ? (i = "Configured requestMediaKeySystemAccess is not a function " + r, null === m.requestMediaKeySystemAccess && "http:" === self.location.protocol && (i = "navigator.requestMediaKeySystemAccess is not available over insecure protocol " + location.protocol), Promise.reject(new Error(i))) : r(e, t)
                    }, i.getMediaKeysPromise = function (r, e, t) {
                        var s, a = this,
                            e = (0, m.getSupportedMediaKeySystemConfigurations)(r, e, t, this.config.drmSystemOptions),
                            i = this.keySystemAccessPromises[r], t = null == i ? void 0 : i.keySystemAccess;
                        return t ? t.then(function () {
                            return i.mediaKeys
                        }) : (this.log('Requesting encrypted media "' + r + '" key-system access with config: ' + JSON.stringify(e)), t = this.requestMediaKeySystemAccess(r, e), s = this.keySystemAccessPromises[r] = {keySystemAccess: t}, t.catch(function (e) {
                            a.log('Failed to obtain access to key-system "' + r + '": ' + e)
                        }), t.then(function (e) {
                            a.log('Access for key-system "' + e.keySystem + '" obtained');
                            var i = a.fetchServerCertificate(r);
                            return a.log('Create media-keys for "' + r + '"'), s.mediaKeys = e.createMediaKeys().then(function (t) {
                                return a.log('Media-keys created for "' + r + '"'), i.then(function (e) {
                                    return e ? a.setMediaKeysServerCertificate(t, r, e) : t
                                })
                            }), s.mediaKeys.catch(function (e) {
                                a.error('Failed to create media-keys for "' + r + '"}: ' + e)
                            }), s.mediaKeys
                        }))
                    }, i.createMediaKeySessionContext = function (e) {
                        var t = e.decryptdata, i = e.keySystem, e = e.mediaKeys,
                            r = (console.assert(!!e, "mediaKeys is defined"), this.log('Creating key-system session "' + i + '" keyId: ' + A.default.hexDump(t.keyId || [])), e.createSession()),
                            t = {
                                decryptdata: t,
                                keySystem: i,
                                mediaKeys: e,
                                mediaKeysSession: r,
                                keyStatus: "status-pending"
                            };
                        return this.mediaKeySessions.push(t), t
                    }, i.renewKeySession = function (e) {
                        var t, i, r = e.decryptdata;
                        r.pssh ? (t = this.createMediaKeySessionContext(e), i = this.getKeyIdString(r), this.keyIdToKeySessionPromise[i] = this.generateRequestWithPreferredKeySession(t, "cenc", r.pssh, "expired")) : this.warn("Could not renew expired session. Missing pssh initData."), this.removeSession(e)
                    }, i.getKeyIdString = function (e) {
                        if (!e) throw new Error("Could not read keyId of undefined decryptdata");
                        if (null === e.keyId) throw new Error("keyId is null");
                        return A.default.hexDump(e.keyId)
                    }, i.updateKeySession = function (e, t) {
                        var i = e.mediaKeysSession;
                        return this.log('Updating key-session "' + i.sessionId + '" for keyID ' + A.default.hexDump((null == (e = e.decryptdata) ? void 0 : e.keyId) || []) + "\n      } (data length: " + (t && t.byteLength) + ")"), i.update(t)
                    }, i.selectKeySystemFormat = function (e) {
                        var t = Object.keys(e.levelkeys || {});
                        return this.keyFormatPromise || (this.log("Selecting key-system from fragment (sn: " + e.sn + " " + e.type + ": " + e.level + ") key formats " + t.join(", ")), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise
                    }, i.getKeyFormatPromise = function (s) {
                        var a = this;
                        return new Promise(function (i, r) {
                            var t = (0, m.getKeySystemsForConfig)(a.config),
                                e = s.map(m.keySystemFormatToKeySystemDomain).filter(function (e) {
                                    return !!e && -1 !== t.indexOf(e)
                                });
                            return a.getKeySystemSelectionPromise(e).then(function (e) {
                                var e = e.keySystem, t = (0, m.keySystemDomainToKeySystemFormat)(e);
                                t ? i(t) : r(new Error('Unable to find format for key-system "' + e + '"'))
                            }).catch(r)
                        })
                    }, i.loadKey = function (r) {
                        var s = this, a = r.keyInfo.decryptdata, e = this.getKeyIdString(a),
                            n = "(keyId: " + e + ' format: "' + a.keyFormat + '" method: ' + a.method + " uri: " + a.uri + ")",
                            t = (this.log("Starting session for key " + n), this.keyIdToKeySessionPromise[e]);
                        return t || (t = this.keyIdToKeySessionPromise[e] = this.getKeySystemForKeyPromise(a).then(function (e) {
                            var t = e.keySystem, i = e.mediaKeys;
                            return s.throwIfDestroyed(), s.log("Handle encrypted media sn: " + r.frag.sn + " " + r.frag.type + ": " + r.frag.level + " using key " + n), s.attemptSetMediaKeys(t, i).then(function () {
                                s.throwIfDestroyed();
                                var e = s.createMediaKeySessionContext({keySystem: t, mediaKeys: i, decryptdata: a});
                                return s.generateRequestWithPreferredKeySession(e, "cenc", a.pssh, "playlist-key")
                            })
                        })).catch(function (e) {
                            return s.handleError(e)
                        }), t
                    }, i.throwIfDestroyed = function (e) {
                        if (!this.hls) throw new Error("invalid state")
                    }, i.handleError = function (e) {
                        this.hls && (this.error(e.message), e instanceof _ ? this.hls.trigger(r.Events.ERROR, e.data) : this.hls.trigger(r.Events.ERROR, {
                            type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                            details: h.ErrorDetails.KEY_SYSTEM_NO_KEYS,
                            error: e,
                            fatal: !0
                        }))
                    }, i.getKeySystemForKeyPromise = function (e) {
                        var t = this.getKeyIdString(e), t = this.keyIdToKeySessionPromise[t];
                        return t || (e = (t = (0, m.keySystemFormatToKeySystemDomain)(e.keyFormat)) ? [t] : (0, m.getKeySystemsForConfig)(this.config), this.attemptKeySystemAccess(e))
                    }, i.getKeySystemSelectionPromise = function (e) {
                        if (0 === (e = e.length ? e : (0, m.getKeySystemsForConfig)(this.config)).length) throw new _({
                            type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                            details: h.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                            fatal: !0
                        }, "Missing key-system license configuration options " + JSON.stringify({drmSystems: this.config.drmSystems}));
                        return this.attemptKeySystemAccess(e)
                    }, i._onMediaEncrypted = function (e) {
                        var s, t, a = this, n = e.initDataType, o = e.initData;
                        if (this.debug('"' + e.type + '" event: init data type: "' + n + '"'), null !== o) {
                            if ("sinf" === n && this.config.drmSystems[m.KeySystems.FAIRPLAY]) {
                                var i = (0, b.bin2str)(new Uint8Array(o));
                                try {
                                    var r = (0, g.base64Decode)(JSON.parse(i).sinf),
                                        l = (0, b.parseSinf)(new Uint8Array(r));
                                    if (!l) return;
                                    s = l.subarray(8, 24), t = m.KeySystems.FAIRPLAY
                                } catch (e) {
                                    return void this.warn('Failed to parse sinf "encrypted" event message initData')
                                }
                            } else {
                                i = (0, b.parsePssh)(o);
                                if (null === i) return;
                                0 === i.version && i.systemId === m.KeySystemIds.WIDEVINE && i.data && (s = i.data.subarray(8, 24)), t = (0, m.keySystemIdToKeySystemDomain)(i.systemId)
                            }
                            if (t && s) {
                                for (var d = A.default.hexDump(s), h = this.keyIdToKeySessionPromise, c = this.mediaKeySessions, u = h[d], p = 0; p < c.length; p++) {
                                    var f = function (e) {
                                        var t = c[e], e = t.decryptdata;
                                        if (e.pssh || !e.keyId) return "continue";
                                        var i = A.default.hexDump(e.keyId);
                                        return d === i || -1 !== e.uri.replace(/-/g, "").indexOf(d) ? (u = h[i], delete h[i], e.pssh = new Uint8Array(o), e.keyId = s, u = h[d] = u.then(function () {
                                            return a.generateRequestWithPreferredKeySession(t, n, o, "encrypted-event-key-match")
                                        }), "break") : void 0
                                    }(p);
                                    if ("continue" !== f && "break" === f) break
                                }
                                (u = u || (h[d] = this.getKeySystemSelectionPromise([t]).then(function (e) {
                                    var t = e.keySystem, i = e.mediaKeys,
                                        r = (a.throwIfDestroyed(), new y.LevelKey("ISO-23001-7", d, null != (e = (0, m.keySystemDomainToKeySystemFormat)(t)) ? e : ""));
                                    return r.pssh = new Uint8Array(o), r.keyId = s, a.attemptSetMediaKeys(t, i).then(function () {
                                        a.throwIfDestroyed();
                                        var e = a.createMediaKeySessionContext({
                                            decryptdata: r,
                                            keySystem: t,
                                            mediaKeys: i
                                        });
                                        return a.generateRequestWithPreferredKeySession(e, n, o, "encrypted-event-no-match")
                                    })
                                }))).catch(function (e) {
                                    return a.handleError(e)
                                })
                            }
                        }
                    }, i._onWaitingForKey = function (e) {
                        this.log('"' + e.type + '" event')
                    }, i.attemptSetMediaKeys = function (e, t) {
                        var i = this, r = this.setMediaKeysQueue.slice(),
                            s = (this.log('Setting media-keys for "' + e + '"'), Promise.all(r).then(function () {
                                if (i.media) return i.media.setMediaKeys(t);
                                throw new Error("Attempted to set mediaKeys without media element attached")
                            }));
                        return this.setMediaKeysQueue.push(s), s.then(function () {
                            i.log('Media-keys set for "' + e + '"'), r.push(s), i.setMediaKeysQueue = i.setMediaKeysQueue.filter(function (e) {
                                return -1 === r.indexOf(e)
                            })
                        })
                    }, i.generateRequestWithPreferredKeySession = function (r, e, t, i) {
                        var s = this,
                            a = null == (a = this.config.drmSystems) || null == (a = a[r.keySystem]) ? void 0 : a.generateRequest;
                        if (a) try {
                            var n = a.call(this.hls, e, t, r);
                            if (!n) throw new Error("Invalid response from configured generateRequest filter");
                            e = n.initDataType, t = r.decryptdata.pssh = n.initData ? new Uint8Array(n.initData) : null
                        } catch (r) {
                            if (this.warn(r.message), null != (a = this.hls) && a.config.debug) throw r
                        }
                        if (null === t) return this.log('Skipping key-session request for "' + i + '" (no initData)'), Promise.resolve(r);
                        var o = this.getKeyIdString(r.decryptdata),
                            l = (this.log('Generating key-session request for "' + i + '": ' + o + " (init data type: " + e + " length: " + (t ? t.byteLength : null) + ")"), new (u())),
                            d = (r.mediaKeysSession.onmessage = function (e) {
                                var t, i = r.mediaKeysSession;
                                i ? (t = e.messageType, e = e.message, s.log('"' + t + '" message event for session "' + i.sessionId + '" message size: ' + e.byteLength), "license-request" === t || "license-renewal" === t ? s.renewLicense(r, e).catch(function (e) {
                                    s.handleError(e), l.emit("error", e)
                                }) : "license-release" === t ? r.keySystem === m.KeySystems.FAIRPLAY && (s.updateKeySession(r, (0, c.strToUtf8array)("acknowledged")), s.removeSession(r)) : s.warn('unhandled media key message type "' + t + '"')) : l.emit("error", new Error("invalid state"))
                            }, r.mediaKeysSession.onkeystatuseschange = function (e) {
                                var t;
                                r.mediaKeysSession ? (s.onKeyStatusChange(r), t = r.keyStatus, l.emit("keyStatus", t), "expired" === t && (s.warn(r.keySystem + " expired for key " + o), s.renewKeySession(r))) : l.emit("error", new Error("invalid state"))
                            }, new Promise(function (t, i) {
                                l.on("error", i), l.on("keyStatus", function (e) {
                                    e.startsWith("usable") ? t() : "output-restricted" === e ? i(new _({
                                        type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: h.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                                        fatal: !1
                                    }, "HDCP level output restricted")) : "internal-error" === e ? i(new _({
                                        type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: h.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                                        fatal: !0
                                    }, 'key status changed to "' + e + '"')) : "expired" === e ? i(new Error("key expired while generating request")) : s.warn('unhandled key status change "' + e + '"')
                                })
                            }));
                        return r.mediaKeysSession.generateRequest(e, t).then(function () {
                            var e;
                            s.log('Request generated for key-session "' + (null == (e = r.mediaKeysSession) ? void 0 : e.sessionId) + '" keyId: ' + o)
                        }).catch(function (e) {
                            throw new _({
                                type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                details: h.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                                error: e,
                                fatal: !1
                            }, "Error generating key-session request: " + e)
                        }).then(function () {
                            return d
                        }).catch(function (e) {
                            throw l.removeAllListeners(), s.removeSession(r), e
                        }).then(function () {
                            return l.removeAllListeners(), r
                        })
                    }, i.onKeyStatusChange = function (i) {
                        var r = this;
                        i.mediaKeysSession.keyStatuses.forEach(function (e, t) {
                            r.log('key status change "' + e + '" for keyStatuses keyId: ' + A.default.hexDump("buffer" in t ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(t)) + " session keyId: " + A.default.hexDump(new Uint8Array(i.decryptdata.keyId || [])) + " uri: " + i.decryptdata.uri), i.keyStatus = e
                        })
                    }, i.fetchServerCertificate = function (s) {
                        var a = this;
                        return new Promise(function (e, t) {
                            var i = a.getServerCertificateUrl(s);
                            if (!i) return e();
                            a.log('Fetching serverCertificate for "' + s + '"');
                            var r = new XMLHttpRequest;
                            r.open("GET", i, !0), r.responseType = "arraybuffer", r.onreadystatechange = function () {
                                r.readyState === XMLHttpRequest.DONE && (200 === r.status ? e(r.response) : t(new _({
                                    type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                    details: h.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                    fatal: !0,
                                    networkDetails: r
                                }, '"' + s + '" certificate request XHR failed (' + i + "). Status: " + r.status + " (" + r.statusText + ")")))
                            }, r.send()
                        })
                    }, i.setMediaKeysServerCertificate = function (r, s, a) {
                        var n = this;
                        return new Promise(function (t, i) {
                            r.setServerCertificate(a).then(function (e) {
                                n.log("setServerCertificate " + (e ? "success" : "not supported by CDM") + " (" + (null == a ? void 0 : a.byteLength) + ') on "' + s + '"'), t(r)
                            }).catch(function (e) {
                                i(new _({
                                    type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                    details: h.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                                    error: e,
                                    fatal: !0
                                }, e.message))
                            })
                        })
                    }, i.renewLicense = function (t, e) {
                        var i = this;
                        return this.requestLicense(t, new Uint8Array(e)).then(function (e) {
                            return i.updateKeySession(t, new Uint8Array(e)).catch(function (e) {
                                throw new _({
                                    type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                    details: h.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                                    error: e,
                                    fatal: !0
                                }, e.message)
                            })
                        })
                    }, i.setupLicenseXHR = function (t, i, r, s) {
                        var a = this, n = this.config.licenseXhrSetup;
                        return n ? Promise.resolve().then(function () {
                            if (r.decryptdata) return n.call(a.hls, t, i, r, s);
                            throw new Error("Key removed")
                        }).catch(function (e) {
                            if (r.decryptdata) return t.open("POST", i, !0), n.call(a.hls, t, i, r, s);
                            throw e
                        }).then(function (e) {
                            return t.readyState || t.open("POST", i, !0), {xhr: t, licenseChallenge: e || s}
                        }) : (t.open("POST", i, !0), Promise.resolve({xhr: t, licenseChallenge: s}))
                    }, i.requestLicense = function (n, o) {
                        var l = this;
                        return new Promise(function (i, r) {
                            var s = l.getLicenseServerUrl(n.keySystem),
                                a = (l.log("Sending license request to URL: " + s), new XMLHttpRequest);
                            a.responseType = "arraybuffer", a.onreadystatechange = function () {
                                if (!l.hls || !n.mediaKeysSession) return r(new Error("invalid state"));
                                if (4 === a.readyState) if (200 === a.status) {
                                    l._requestLicenseFailureCount = 0;
                                    var e = a.response,
                                        t = (l.log("License received " + (e instanceof ArrayBuffer ? e.byteLength : e)), l.config.licenseResponseCallback);
                                    if (t) try {
                                        e = t.call(l.hls, a, s, n)
                                    } catch (e) {
                                        l.error(e)
                                    }
                                    i(e)
                                } else l._requestLicenseFailureCount++, 3 < l._requestLicenseFailureCount || 400 <= a.status && a.status < 500 ? r(new _({
                                    type: h.ErrorTypes.KEY_SYSTEM_ERROR,
                                    details: h.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                    fatal: !0,
                                    networkDetails: a
                                }, "License Request XHR failed (" + s + "). Status: " + a.status + " (" + a.statusText + ")")) : (t = 3 - l._requestLicenseFailureCount + 1, l.warn("Retrying license request, " + t + " attempts left"), l.requestLicense(n, o).then(i, r))
                            }, n.licenseXhr && n.licenseXhr.readyState !== XMLHttpRequest.DONE && n.licenseXhr.abort(), n.licenseXhr = a, l.setupLicenseXHR(a, s, n, o).then(function (e) {
                                var t = e.xhr, e = e.licenseChallenge;
                                t.send(e)
                            })
                        })
                    }, i.onMediaAttached = function (e, t) {
                        this.config.emeEnabled && (t = t.media, (this.media = t).addEventListener("encrypted", this.onMediaEncrypted), t.addEventListener("waitingforkey", this.onWaitingForKey))
                    }, i.onMediaDetached = function () {
                        var t = this, i = this.media, e = this.mediaKeySessions,
                            r = (i && (i.removeEventListener("encrypted", this.onMediaEncrypted), i.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, y.LevelKey.clearKeyUriToKeyIdMap(), e.length);
                        p.CDMCleanupPromise = Promise.all(e.map(function (e) {
                            return t.removeSession(e)
                        }).concat(null == i ? void 0 : i.setMediaKeys(null).catch(function (e) {
                            t.log("Could not clear media keys: " + e + ". media.src: " + (null == i ? void 0 : i.src))
                        }))).then(function () {
                            r && (t.log("finished closing key sessions and clearing media keys"), e.length = 0)
                        }).catch(function (e) {
                            t.log("Could not close sessions and clear media keys: " + e + ". media.src: " + (null == i ? void 0 : i.src))
                        })
                    }, i.onManifestLoaded = function (e, t) {
                        var t = t.sessionKeys;
                        t && this.config.emeEnabled && !this.keyFormatPromise && (t = t.reduce(function (e, t) {
                            return -1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e
                        }, []), this.log("Selecting key-system from session-keys " + t.join(", ")), this.keyFormatPromise = this.getKeyFormatPromise(t))
                    }, i.removeSession = function (e) {
                        var t = this, i = e.mediaKeysSession, r = e.licenseXhr;
                        if (i) return this.log("Remove licenses and keys and close session " + i.sessionId), i.onmessage = null, i.onkeystatuseschange = null, r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0, -1 < (r = this.mediaKeySessions.indexOf(e)) && this.mediaKeySessions.splice(r, 1), i.remove().catch(function (e) {
                            t.log("Could not remove session: " + e)
                        }).then(function () {
                            return i.close()
                        }).catch(function (e) {
                            t.log("Could not close session: " + e)
                        })
                    }, p);

                    function p(e) {
                        this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = p.CDMCleanupPromise ? [p.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = s.logger.debug.bind(s.logger, d), this.log = s.logger.log.bind(s.logger, d), this.warn = s.logger.warn.bind(s.logger, d), this.error = s.logger.error.bind(s.logger, d), this.hls = e, this.config = e.config, this.registerListeners()
                    }

                    t.CDMCleanupPromise = void 0;
                    f = a(Error), i = f, (v = w).prototype = Object.create(i.prototype), o(v.prototype.constructor = v, i);
                    var f, v, _ = w;

                    function w(e, t) {
                        return (t = f.call(this, t) || this).data = void 0, (t.data = e).err = e.error, t
                    }

                    const S = t
                }, "./src/controller/fps-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => s});
                    var l = i("./src/events.ts"), d = i("./src/utils/logger.ts");

                    function r(e) {
                        this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners()
                    }

                    (t = r.prototype).setStreamController = function (e) {
                        this.streamController = e
                    }, t.registerListeners = function () {
                        this.hls.on(l.Events.MEDIA_ATTACHING, this.onMediaAttaching, this)
                    }, t.unregisterListeners = function () {
                        this.hls.off(l.Events.MEDIA_ATTACHING, this.onMediaAttaching)
                    }, t.destroy = function () {
                        this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
                    }, t.onMediaAttaching = function (e, t) {
                        var i = this.hls.config;
                        i.capLevelOnFPSDrop && (t = t.media instanceof self.HTMLVideoElement ? t.media : null, (this.media = t) && "function" == typeof t.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod))
                    }, t.checkFPS = function (e, t, i) {
                        var r, s, a, n, o = performance.now();
                        t && (this.lastTime && (n = o - this.lastTime, r = i - this.lastDroppedFrames, s = t - this.lastDecodedFrames, n = 1e3 * r / n, (a = this.hls).trigger(l.Events.FPS_DROP, {
                            currentDropped: r,
                            currentDecoded: s,
                            totalDroppedFrames: i
                        }), 0 < n && r > a.config.fpsDroppedMonitoringThreshold * s && (n = a.currentLevel, d.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + n), 0 < n && (-1 === a.autoLevelCapping || a.autoLevelCapping >= n) && (a.trigger(l.Events.FPS_DROP_LEVEL_CAPPING, {
                            level: --n,
                            droppedLevel: a.currentLevel
                        }), a.autoLevelCapping = n, this.streamController.nextLevelSwitch()))), this.lastTime = o, this.lastDroppedFrames = i, this.lastDecodedFrames = t)
                    }, t.checkFPSInterval = function () {
                        var e, t = this.media;
                        t && (this.isVideoPlaybackQualityAvailable ? (e = t.getVideoPlaybackQuality(), this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames)) : this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount))
                    };
                    const s = r
                }, "./src/controller/fragment-finders.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        findFragWithCC: () => function (e, t) {
                            return n.default.search(e, function (e) {
                                return e.cc < t ? 1 : e.cc > t ? -1 : 0
                            })
                        }, findFragmentByPDT: () => function (e, t, i) {
                            if (null === t || !Array.isArray(e) || !e.length || !(0, a.isFiniteNumber)(t)) return null;
                            if (t < (e[0].programDateTime || 0)) return null;
                            if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;
                            i = i || 0;
                            for (var r = 0; r < e.length; ++r) {
                                var s = e[r];
                                if (l(t, i, s)) return s
                            }
                            return null
                        }, findFragmentByPTS: () => function (e, t, i, r) {
                            void 0 === i && (i = 0), void 0 === r && (r = 0);
                            var s = null;
                            if (e ? s = t[e.sn - t[0].sn + 1] || null : 0 === i && 0 === t[0].start && (s = t[0]), s && 0 === o(i, r, s)) return s;
                            t = n.default.search(t, o.bind(null, i, r));
                            return !t || t === e && s ? s : t
                        }, fragmentWithinToleranceTest: () => o, pdtWithinToleranceTest: () => l
                    });
                    var a = i("./src/polyfills/number.ts"), n = i("./src/utils/binary-search.ts");

                    function o(e, t, i) {
                        if (void 0 === t && (t = 0), i.start <= (e = void 0 === e ? 0 : e) && i.start + i.duration > e) return 0;
                        t = Math.min(t, i.duration + (i.deltaPTS || 0));
                        return i.start + i.duration - t <= e ? 1 : i.start - t > e && i.start ? -1 : 0
                    }

                    function l(e, t, i) {
                        t = 1e3 * Math.min(t, i.duration + (i.deltaPTS || 0));
                        return (i.endProgramDateTime || 0) - t > e
                    }
                }, "./src/controller/fragment-tracker.ts": (e, t, i) => {
                    i.r(t), i.d(t, {FragmentState: () => r, FragmentTracker: () => a});
                    var r, s = i("./src/events.ts"), d = i("./src/types/loader.ts"),
                        a = ((t = r = r || {}).NOT_LOADED = "NOT_LOADED", t.APPENDING = "APPENDING", t.PARTIAL = "PARTIAL", t.OK = "OK", (i = n.prototype)._registerListeners = function () {
                            var e = this.hls;
                            e.on(s.Events.BUFFER_APPENDED, this.onBufferAppended, this), e.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.on(s.Events.FRAG_LOADED, this.onFragLoaded, this)
                        }, i._unregisterListeners = function () {
                            var e = this.hls;
                            e.off(s.Events.BUFFER_APPENDED, this.onBufferAppended, this), e.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), e.off(s.Events.FRAG_LOADED, this.onFragLoaded, this)
                        }, i.destroy = function () {
                            this._unregisterListeners(), this.fragments = this.endListFragments = this.timeRanges = this.activeFragment = this.activeParts = null
                        }, i.getAppendedFrag = function (e, t) {
                            if (t === d.PlaylistLevelType.MAIN) {
                                var i = this.activeFragment, r = this.activeParts;
                                if (!i) return null;
                                if (r) for (var s = r.length; s--;) {
                                    var a = r[s], n = a ? a.end : i.appendedPTS;
                                    if (a.start <= e && void 0 !== n && e <= n) return 9 < s && (this.activeParts = r.slice(s - 9)), a
                                } else if (i.start <= e && void 0 !== i.appendedPTS && e <= i.appendedPTS) return i
                            }
                            return this.getBufferedFrag(e, t)
                        }, i.getBufferedFrag = function (e, t) {
                            for (var i = this.fragments, r = Object.keys(i), s = r.length; s--;) {
                                var a = i[r[s]];
                                if ((null == a ? void 0 : a.body.type) === t && a.buffered) {
                                    a = a.body;
                                    if (a.start <= e && e <= a.end) return a
                                }
                            }
                            return null
                        }, i.detectEvictedFragments = function (i, r, s) {
                            var a = this;
                            this.timeRanges && (this.timeRanges[i] = r), Object.keys(this.fragments).forEach(function (e) {
                                var t = a.fragments[e];
                                t && (t.buffered || t.loaded ? (e = t.range[i]) && e.time.some(function (e) {
                                    e = !a.isTimeBuffered(e.startPTS, e.endPTS, r);
                                    return e && a.removeFragment(t.body), e
                                }) : t.body.type === s && a.removeFragment(t.body))
                            })
                        }, i.detectPartialFragments = function (e) {
                            var r, s = this, a = this.timeRanges, n = e.frag, o = e.part;
                            a && "initSegment" !== n.sn && (e = h(n), (r = this.fragments[e]) && (Object.keys(a).forEach(function (e) {
                                var t, i = n.elementaryStreams[e];
                                i && (t = a[e], i = null !== o || !0 === i.partial, r.range[e] = s.getBufferedTimes(n, o, i, t))
                            }), r.loaded = null, Object.keys(r.range).length ? (r.buffered = !0, r.body.endList && (this.endListFragments[r.body.type] = r)) : this.removeFragment(r.body)))
                        }, i.fragBuffered = function (e) {
                            e = h(e), e = this.fragments[e];
                            e && (e.loaded = null, e.buffered = !0)
                        }, i.getBufferedTimes = function (e, t, i, r) {
                            for (var s = {
                                time: [],
                                partial: i
                            }, a = (t || e).start, n = (t || e).end, o = e.minEndPTS || n, l = e.maxStartPTS || a, d = 0; d < r.length; d++) {
                                var h = r.start(d) - this.bufferPadding, c = r.end(d) + this.bufferPadding;
                                if (h <= l && o <= c) {
                                    s.time.push({startPTS: Math.max(a, r.start(d)), endPTS: Math.min(n, r.end(d))});
                                    break
                                }
                                if (a < c && h < n) s.partial = !0, s.time.push({
                                    startPTS: Math.max(a, r.start(d)),
                                    endPTS: Math.min(n, r.end(d))
                                }); else if (n <= h) break
                            }
                            return s
                        }, i.getPartialFragment = function (t) {
                            var i, r, s = null, a = 0, n = this.bufferPadding, o = this.fragments;
                            return Object.keys(o).forEach(function (e) {
                                e = o[e];
                                e && l(e) && (i = e.body.start - n, r = e.body.end + n, i <= t && t <= r && (i = Math.min(t - i, r - t), a <= i && (s = e.body, a = i)))
                            }), s
                        }, i.isEndListAppended = function (e) {
                            e = this.endListFragments[e];
                            return void 0 !== e && (e.buffered || l(e))
                        }, i.getState = function (e) {
                            e = h(e), e = this.fragments[e];
                            return e ? e.buffered ? l(e) ? r.PARTIAL : r.OK : r.APPENDING : r.NOT_LOADED
                        }, i.isTimeBuffered = function (e, t, i) {
                            for (var r, s, a = 0; a < i.length; a++) {
                                if (r = i.start(a) - this.bufferPadding, s = i.end(a) + this.bufferPadding, r <= e && t <= s) return !0;
                                if (t <= r) return !1
                            }
                            return !1
                        }, i.onFragLoaded = function (e, t) {
                            var i = t.frag, r = t.part;
                            "initSegment" === i.sn || i.bitrateTest || r || (r = h(i), this.fragments[r] = {
                                body: i,
                                loaded: t,
                                buffered: !1,
                                range: Object.create(null)
                            })
                        }, i.onBufferAppended = function (e, t) {
                            var a = this, n = t.frag, o = t.part, l = t.timeRanges;
                            n.type === d.PlaylistLevelType.MAIN && (this.activeFragment !== n && ((this.activeFragment = n).appendedPTS = void 0), o ? ((t = this.activeParts) || (this.activeParts = t = []), t.push(o)) : this.activeParts = null), this.timeRanges = l, Object.keys(l).forEach(function (e) {
                                var t = l[e];
                                if (a.detectEvictedFragments(e, t), !o && n.type === d.PlaylistLevelType.MAIN) {
                                    var i = n.elementaryStreams[e];
                                    if (i) for (var r = 0; r < t.length; r++) {
                                        var s = t.end(r);
                                        s <= i.endPTS && s > i.startPTS ? n.appendedPTS = Math.max(s, n.appendedPTS || 0) : n.appendedPTS = i.endPTS
                                    }
                                }
                            })
                        }, i.onFragBuffered = function (e, t) {
                            this.detectPartialFragments(t)
                        }, i.hasFragment = function (e) {
                            e = h(e);
                            return !!this.fragments[e]
                        }, i.removeFragmentsInRange = function (t, i, r) {
                            var s = this;
                            Object.keys(this.fragments).forEach(function (e) {
                                var e = s.fragments[e];
                                e && e.buffered && ((e = e.body).type === r && e.start < i && e.end > t && s.removeFragment(e))
                            })
                        }, i.removeFragment = function (e) {
                            var t = h(e);
                            e.stats.loaded = 0, e.clearElementaryStreamInfo(), e.appendedPTS = void 0, delete this.fragments[t], e.endList && delete this.endListFragments[e.type]
                        }, i.removeAllFragments = function () {
                            this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activeFragment = null, this.activeParts = null
                        }, n);

                    function n(e) {
                        this.activeFragment = null, this.activeParts = null, this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hls = e, this._registerListeners()
                    }

                    function l(e) {
                        var t;
                        return e.buffered && ((null == (t = e.range.video) ? void 0 : t.partial) || (null == (t = e.range.audio) ? void 0 : t.partial))
                    }

                    function h(e) {
                        return e.type + "_" + e.level + "_" + e.urlId + "_" + e.sn
                    }
                }, "./src/controller/gap-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        MAX_START_GAP_JUMP: () => f,
                        SKIP_BUFFER_HOLE_STEP_SECONDS: () => m,
                        SKIP_BUFFER_RANGE_START: () => g,
                        STALL_MINIMUM_DURATION_MS: () => p,
                        default: () => r
                    });
                    var d = i("./src/utils/buffer-helper.ts"), h = i("./src/errors.ts"), c = i("./src/events.ts"),
                        u = i("./src/utils/logger.ts"), p = 250, f = 2, m = .1, g = .05,
                        r = ((t = s.prototype).destroy = function () {
                            this.media = null, this.hls = this.fragmentTracker = null
                        }, t.poll = function (e, t) {
                            var i = this.config, r = this.media, s = this.stalled;
                            if (null !== r) {
                                var a = r.currentTime, n = r.seeking, o = this.seeking && !n, l = !this.seeking && n;
                                if (this.seeking = n, a === e) {
                                    if ((l || o) && (this.stalled = null), !(r.paused && !n || r.ended || 0 === r.playbackRate) && d.BufferHelper.getBuffered(r).length) {
                                        e = d.BufferHelper.bufferInfo(r, a, 0), l = 0 < e.len, o = e.nextStart || 0;
                                        if (l || o) {
                                            if (n) {
                                                l = e.len > f, t = !o || t && t.start <= a || f < o - a && !this.fragmentTracker.getPartialFragment(a);
                                                if (l || t) return;
                                                this.moved = !1
                                            }
                                            if (!this.moved && null !== this.stalled) {
                                                l = Math.max(o, e.start || 0) - a, t = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null, o = null != t && null != (o = t.details) && o.live ? 2 * t.details.targetduration : f;
                                                if (0 < l && l <= o) return void this._trySkipBufferHole(null)
                                            }
                                            t = self.performance.now();
                                            null !== s ? (l = t - s, !n && p <= l && (this._reportStall(e), !this.media) || (o = d.BufferHelper.bufferInfo(r, a, i.maxBufferHole), this._tryFixBufferStall(o, l))) : this.stalled = t
                                        }
                                    }
                                } else this.moved = !0, null !== s && (this.stallReported && (n = self.performance.now() - s, u.logger.warn("playback not stuck anymore @" + a + ", after " + Math.round(n) + "ms"), this.stallReported = !1), this.stalled = null, this.nudgeRetry = 0)
                            }
                        }, t._tryFixBufferStall = function (e, t) {
                            var i = this.config, r = this.fragmentTracker, s = this.media;
                            null !== s && (s = s.currentTime, (!(r = r.getPartialFragment(s)) || !this._trySkipBufferHole(r) && this.media) && e.len > i.maxBufferHole && t > 1e3 * i.highBufferWatchdogPeriod && (u.logger.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer()))
                        }, t._reportStall = function (e) {
                            var t = this.hls, i = this.media;
                            !this.stallReported && i && (this.stallReported = !0, u.logger.warn("Playback stalling at @" + i.currentTime + " due to low buffer (" + JSON.stringify(e) + ")"), t.trigger(c.Events.ERROR, {
                                type: h.ErrorTypes.MEDIA_ERROR,
                                details: h.ErrorDetails.BUFFER_STALLED_ERROR,
                                fatal: !1,
                                buffer: e.len
                            }))
                        }, t._trySkipBufferHole = function (e) {
                            var t = this.config, i = this.hls, r = this.media;
                            if (null === r) return 0;
                            for (var s = r.currentTime, a = 0, n = d.BufferHelper.getBuffered(r), o = 0; o < n.length; o++) {
                                var l = n.start(o);
                                if (s + t.maxBufferHole >= a && s < l) return l = Math.max(l + g, r.currentTime + m), u.logger.warn("skipping hole, adjusting currentTime from " + s + " to " + l), this.moved = !0, this.stalled = null, r.currentTime = l, e && i.trigger(c.Events.ERROR, {
                                    type: h.ErrorTypes.MEDIA_ERROR,
                                    details: h.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                                    fatal: !1,
                                    reason: "fragment loaded with buffer holes, seeking from " + s + " to " + l,
                                    frag: e
                                }), l;
                                a = n.end(o)
                            }
                            return 0
                        }, t._tryNudgeBuffer = function () {
                            var e, t = this.config, i = this.hls, r = this.media, s = this.nudgeRetry;
                            null !== r && (e = r.currentTime, this.nudgeRetry++, s < t.nudgeMaxRetry ? (s = e + (s + 1) * t.nudgeOffset, u.logger.warn("Nudging 'currentTime' from " + e + " to " + s), r.currentTime = s, i.trigger(c.Events.ERROR, {
                                type: h.ErrorTypes.MEDIA_ERROR,
                                details: h.ErrorDetails.BUFFER_NUDGE_ON_STALL,
                                fatal: !1
                            })) : (u.logger.error("Playhead still not moving while enough data buffered @" + e + " after " + t.nudgeMaxRetry + " nudges"), i.trigger(c.Events.ERROR, {
                                type: h.ErrorTypes.MEDIA_ERROR,
                                details: h.ErrorDetails.BUFFER_STALLED_ERROR,
                                fatal: !0
                            })))
                        }, s);

                    function s(e, t, i, r) {
                        this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = i, this.hls = r
                    }
                }, "./src/controller/id3-track-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => a});
                    var n = i("./src/polyfills/number.ts"), r = i("./src/events.ts"),
                        l = i("./src/utils/texttrack-utils.ts"), m = i("./src/demux/id3.ts"),
                        v = i("./src/loader/date-range.ts"), _ = i("./src/types/demuxer.ts");

                    function w() {
                        return self.WebKitDataCue || self.VTTCue || self.TextTrackCue
                    }

                    var S = function () {
                        var e = w();
                        try {
                            new e(0, Number.POSITIVE_INFINITY, "")
                        } catch (e) {
                            return Number.MAX_VALUE
                        }
                        return Number.POSITIVE_INFINITY
                    }();

                    function E(e, t) {
                        return e.getTime() / 1e3 - t
                    }

                    function s(e) {
                        this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners()
                    }

                    (t = s.prototype).destroy = function () {
                        this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
                    }, t._registerListeners = function () {
                        var e = this.hls;
                        e.on(r.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(r.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(r.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(r.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(r.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(r.Events.LEVEL_UPDATED, this.onLevelUpdated, this)
                    }, t._unregisterListeners = function () {
                        var e = this.hls;
                        e.off(r.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(r.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(r.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(r.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(r.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(r.Events.LEVEL_UPDATED, this.onLevelUpdated, this)
                    }, t.onMediaAttached = function (e, t) {
                        this.media = t.media
                    }, t.onMediaDetaching = function () {
                        this.id3Track && ((0, l.clearCurrentCues)(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
                    }, t.onManifestLoading = function () {
                        this.dateRangeCuesAppended = {}
                    }, t.createTrack = function (e) {
                        e = this.getID3Track(e.textTracks);
                        return e.mode = "hidden", e
                    }, t.getID3Track = function (e) {
                        if (this.media) {
                            for (var t = 0; t < e.length; t++) {
                                var i = e[t];
                                if ("metadata" === i.kind && "id3" === i.label) return (0, l.sendAddTrackEvent)(i, this.media), i
                            }
                            return this.media.addTextTrack("metadata", "id3")
                        }
                    }, t.onFragParsingMetadata = function (e, t) {
                        if (this.media) {
                            var i = this.hls.config, r = i.enableEmsgMetadataCues, s = i.enableID3MetadataCues;
                            if (r || s) {
                                var a = t.samples;
                                this.id3Track || (this.id3Track = this.createTrack(this.media));
                                for (var n = w(), o = 0; o < a.length; o++) {
                                    var l = a[o].type;
                                    if ((l !== _.MetadataSchema.emsg || r) && s) {
                                        var d = m.getID3Frames(a[o].data);
                                        if (d) {
                                            var h = a[o].pts, c = h + a[o].duration;
                                            (c = S < c ? S : c) - h <= 0 && (c = h + .25);
                                            for (var u = 0; u < d.length; u++) {
                                                var p, f = d[u];
                                                m.isTimeStampFrame(f) || (this.updateId3CueEnds(h), (p = new n(h, c, "")).value = f, l && (p.type = l), this.id3Track.addCue(p))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, t.updateId3CueEnds = function (e) {
                        var t, i = null == (t = this.id3Track) ? void 0 : t.cues;
                        if (i) for (var r = i.length; r--;) {
                            var s = i[r];
                            s.startTime < e && s.endTime === S && (s.endTime = e)
                        }
                    }, t.onBufferFlushing = function (e, t) {
                        var i, r, s = t.startOffset, a = t.endOffset, t = t.type, n = this.id3Track, o = this.hls;
                        o && (o = o.config, i = o.enableEmsgMetadataCues, r = o.enableID3MetadataCues, n && (i || r) && (0, l.removeCuesInRange)(n, s, a, "audio" === t ? function (e) {
                            return e.type === _.MetadataSchema.audioId3 && r
                        } : "video" === t ? function (e) {
                            return e.type === _.MetadataSchema.emsg && i
                        } : function (e) {
                            return e.type === _.MetadataSchema.audioId3 && r || e.type === _.MetadataSchema.emsg && i
                        }))
                    }, t.onLevelUpdated = function (e, t) {
                        var f = this, t = t.details;
                        if (this.media && t.hasProgramDateTime && this.hls.config.enableDateRangeMetadataCues) {
                            var m = this.dateRangeCuesAppended, i = this.id3Track, g = t.dateRanges, y = Object.keys(g);
                            if (i) for (var r = Object.keys(m).filter(function (e) {
                                return !y.includes(e)
                            }), s = r.length; s--;) !function (e) {
                                var t = r[e];
                                Object.keys(m[t].cues).forEach(function (e) {
                                    i.removeCue(m[t].cues[e])
                                }), delete m[t]
                            }(s);
                            t = t.fragments[t.fragments.length - 1];
                            if (0 !== y.length && (0, n.isFiniteNumber)(null == t ? void 0 : t.programDateTime)) {
                                this.id3Track || (this.id3Track = this.createTrack(this.media));
                                for (var A = t.programDateTime / 1e3 - t.start, b = w(), a = 0; a < y.length; a++) !function (e) {
                                    var e = y[e], r = g[e], t = m[e], i = (null == t ? void 0 : t.cues) || {},
                                        s = (null == t ? void 0 : t.durationKnown) || !1, a = E(r.startDate, A), n = S,
                                        o = r.endDate;
                                    o ? (n = E(o, A), s = !0) : r.endOnNext && !s && (o = y.reduce(function (e, t) {
                                        var i = g[t];
                                        return i.class === r.class && i.id !== t && i.startDate > r.startDate && e.push(i), e
                                    }, []).sort(function (e, t) {
                                        return e.startDate.getTime() - t.startDate.getTime()
                                    })[0]) && (n = E(o.startDate, A), s = !0);
                                    for (var l, d = Object.keys(r.attr), h = 0; h < d.length; h++) {
                                        var c, u, p = d[h];
                                        p !== v.DateRangeAttribute.ID && p !== v.DateRangeAttribute.CLASS && p !== v.DateRangeAttribute.START_DATE && p !== v.DateRangeAttribute.DURATION && p !== v.DateRangeAttribute.END_DATE && p !== v.DateRangeAttribute.END_ON_NEXT && ((u = i[p]) ? s && !t.durationKnown && (u.endTime = n) : (c = r.attr[p], u = new b(a, n, ""), p !== v.DateRangeAttribute.SCTE35_OUT && p !== v.DateRangeAttribute.SCTE35_IN || (l = c, c = Uint8Array.from(l.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer), u.value = {
                                            key: p,
                                            data: c
                                        }, u.type = _.MetadataSchema.dateRange, f.id3Track.addCue(u), i[p] = u))
                                    }
                                    m[e] = {cues: i, dateRange: r, durationKnown: s}
                                }(a)
                            }
                        }
                    };
                    const a = s
                }, "./src/controller/latency-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => o});
                    var r = i("./src/errors.ts"), s = i("./src/events.ts"), a = i("./src/utils/logger.ts");

                    function n(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    (t = l.prototype).destroy = function () {
                        this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
                    }, t.registerListeners = function () {
                        this.hls.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(s.Events.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(s.Events.ERROR, this.onError, this)
                    }, t.unregisterListeners = function () {
                        this.hls.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(s.Events.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(s.Events.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(s.Events.ERROR, this.onError)
                    }, t.onMediaAttached = function (e, t) {
                        this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
                    }, t.onMediaDetaching = function () {
                        this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
                    }, t.onManifestLoading = function () {
                        this.levelDetails = null, this._latency = null, this.stallCount = 0
                    }, t.onLevelUpdated = function (e, t) {
                        t = t.details;
                        (this.levelDetails = t).advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
                    }, t.onError = function (e, t) {
                        t.details === r.ErrorDetails.BUFFER_STALLED_ERROR && (this.stallCount++, a.logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
                    }, t.timeupdate = function () {
                        var e, t, i, r = this.media, s = this.levelDetails;
                        r && s && (this.currentTime = r.currentTime, null !== (t = this.computeLatency()) && (this._latency = t, i = (e = this.config).lowLatencyMode, e = e.maxLiveSyncPlaybackRate, i && 1 !== e && null !== (i = this.targetLatency) && (i = (t = t - i) < Math.min(this.maxLatency, i + s.targetduration), s.live && i && .05 < t && 1 < this.forwardBufferLength ? (s = Math.min(2, Math.max(1, e)), i = Math.round(2 / (1 + Math.exp(-.75 * t - this.edgeStalled)) * 20) / 20, r.playbackRate = Math.min(s, Math.max(1, i))) : 1 !== r.playbackRate && 0 !== r.playbackRate && (r.playbackRate = 1))))
                    }, t.estimateLiveEdge = function () {
                        var e = this.levelDetails;
                        return null === e ? null : e.edge + e.age
                    }, t.computeLatency = function () {
                        var e = this.estimateLiveEdge();
                        return null === e ? null : e - this.currentTime
                    }, n((t = l).prototype, [{
                        key: "latency", get: function () {
                            return this._latency || 0
                        }
                    }, {
                        key: "maxLatency", get: function () {
                            var e = this.config, t = this.levelDetails;
                            return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
                        }
                    }, {
                        key: "targetLatency", get: function () {
                            var e = this.levelDetails;
                            if (null === e) return null;
                            var t = e.holdBack, i = e.partHoldBack, e = e.targetduration, r = this.config,
                                s = r.liveSyncDuration, a = r.liveSyncDurationCount, r = r.lowLatencyMode,
                                n = this.hls.userConfig, r = r && i || t;
                            return (r = n.liveSyncDuration || n.liveSyncDurationCount || 0 === r ? void 0 !== s ? s : a * e : r) + Math.min(+this.stallCount, e)
                        }
                    }, {
                        key: "liveSyncPosition", get: function () {
                            var e = this.estimateLiveEdge(), t = this.targetLatency, i = this.levelDetails;
                            if (null === e || null === t || null === i) return null;
                            var r = i.edge, e = e - t - this.edgeStalled, t = r - i.totalduration,
                                r = r - (this.config.lowLatencyMode && i.partTarget || i.targetduration);
                            return Math.min(Math.max(t, e), r)
                        }
                    }, {
                        key: "drift", get: function () {
                            var e = this.levelDetails;
                            return null === e ? 1 : e.drift
                        }
                    }, {
                        key: "edgeStalled", get: function () {
                            var e = this.levelDetails;
                            if (null === e) return 0;
                            var t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);
                            return Math.max(e.age - t, 0)
                        }
                    }, {
                        key: "forwardBufferLength", get: function () {
                            var e = this.media, t = this.levelDetails;
                            if (!e || !t) return 0;
                            var i = e.buffered.length;
                            return (i ? e.buffered.end(i - 1) : t.edge) - this.currentTime
                        }
                    }]), Object.defineProperty(t, "prototype", {writable: !1});
                    var o = l;

                    function l(e) {
                        var t = this;
                        this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function () {
                            return t.timeupdate()
                        }, this.hls = e, this.config = e.config, this.registerListeners()
                    }
                }, "./src/controller/level-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => n});
                    var p = i("./src/types/level.ts"), f = i("./src/events.ts"), m = i("./src/errors.ts"),
                        g = i("./src/utils/codecs.ts"), y = i("./src/controller/level-helper.ts"),
                        t = i("./src/controller/base-playlist-controller.ts"), d = i("./src/types/loader.ts");

                    function s() {
                        return (s = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    function r(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function a(e, t) {
                        return (a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    var h, A = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
                        n = (h = t.default, i = h, (t = o).prototype = Object.create(i.prototype), a(t.prototype.constructor = t, i), (t = o.prototype)._registerListeners = function () {
                            var e = this.hls;
                            e.on(f.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(f.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(f.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(f.Events.FRAG_LOADED, this.onFragLoaded, this), e.on(f.Events.ERROR, this.onError, this)
                        }, t._unregisterListeners = function () {
                            var e = this.hls;
                            e.off(f.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(f.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(f.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(f.Events.FRAG_LOADED, this.onFragLoaded, this), e.off(f.Events.ERROR, this.onError, this)
                        }, t.destroy = function () {
                            this._unregisterListeners(), this.manualLevelIndex = -1, this._levels.length = 0, h.prototype.destroy.call(this)
                        }, t.startLoad = function () {
                            this._levels.forEach(function (e) {
                                e.loadError = 0
                            }), h.prototype.startLoad.call(this)
                        }, t.onManifestLoaded = function (e, t) {
                            var i, r, s = [], a = [], n = [], o = {}, l = !1, d = !1, h = !1;
                            if (t.levels.forEach(function (e) {
                                var t = e.attrs,
                                    i = (l = l || !(!e.width || !e.height), d = d || !!e.videoCodec, h = h || !!e.audioCodec, A && e.audioCodec && -1 !== e.audioCodec.indexOf("mp4a.40.34") && (e.audioCodec = void 0), e.bitrate + "-" + e.attrs.RESOLUTION + "-" + e.attrs.CODECS);
                                (r = o[i]) ? r.url.push(e.url) : (r = new p.Level(e), o[i] = r, s.push(r)), t && (t.AUDIO && (0, y.addGroupId)(r, "audio", t.AUDIO), t.SUBTITLES && (0, y.addGroupId)(r, "text", t.SUBTITLES))
                            }), s = (s = (l || d) && h ? s.filter(function (e) {
                                var t = e.videoCodec, i = e.width, e = e.height;
                                return !!t || !(!i || !e)
                            }) : s).filter(function (e) {
                                var t = e.audioCodec, e = e.videoCodec;
                                return (!t || (0, g.isCodecSupportedInMp4)(t, "audio")) && (!e || (0, g.isCodecSupportedInMp4)(e, "video"))
                            }), t.audioTracks && (a = t.audioTracks.filter(function (e) {
                                return !e.audioCodec || (0, g.isCodecSupportedInMp4)(e.audioCodec, "audio")
                            }), (0, y.assignTrackIdsByGroup)(a)), t.subtitles && (n = t.subtitles, (0, y.assignTrackIdsByGroup)(n)), 0 < s.length) {
                                i = s[0].bitrate, s.sort(function (e, t) {
                                    return e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"] ? (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : e.bitrate !== t.bitrate ? e.bitrate - t.bitrate : e.attrs.SCORE !== t.attrs.SCORE ? e.attrs.decimalFloatingPoint("SCORE") - t.attrs.decimalFloatingPoint("SCORE") : l && e.height !== t.height ? e.height - t.height : 0
                                }), this._levels = s;
                                for (var c = 0; c < s.length; c++) if (s[c].bitrate === i) {
                                    this._firstLevel = c, this.log("manifest loaded, " + s.length + " level(s) found, first bitrate: " + i);
                                    break
                                }
                                var u = h && !d, n = {
                                    levels: s,
                                    audioTracks: a,
                                    subtitleTracks: n,
                                    sessionData: t.sessionData,
                                    sessionKeys: t.sessionKeys,
                                    firstLevel: this._firstLevel,
                                    stats: t.stats,
                                    audio: h,
                                    video: d,
                                    altAudio: !u && a.some(function (e) {
                                        return !!e.url
                                    })
                                };
                                this.hls.trigger(f.Events.MANIFEST_PARSED, n), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
                            } else this.hls.trigger(f.Events.ERROR, {
                                type: m.ErrorTypes.MEDIA_ERROR,
                                details: m.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                url: t.url,
                                reason: "no level with compatible codecs found in manifest"
                            })
                        }, t.onError = function (e, t) {
                            if (h.prototype.onError.call(this, e, t), !t.fatal) {
                                var i = t.context, r = this._levels[this.currentLevelIndex];
                                if (i && (i.type === d.PlaylistContextType.AUDIO_TRACK && r.audioGroupIds && i.groupId === r.audioGroupIds[r.urlId] || i.type === d.PlaylistContextType.SUBTITLE_TRACK && r.textGroupIds && i.groupId === r.textGroupIds[r.urlId])) this.redundantFailover(this.currentLevelIndex); else {
                                    var s, a, n = !1, o = !0;
                                    switch (t.details) {
                                        case m.ErrorDetails.FRAG_LOAD_ERROR:
                                        case m.ErrorDetails.FRAG_LOAD_TIMEOUT:
                                        case m.ErrorDetails.KEY_LOAD_ERROR:
                                        case m.ErrorDetails.KEY_LOAD_TIMEOUT:
                                            t.frag && (a = t.frag.type === d.PlaylistLevelType.MAIN ? t.frag.level : this.currentLevelIndex, (l = this._levels[a]) ? (l.fragmentError++, l.fragmentError > this.hls.config.fragLoadingMaxRetry && (s = a)) : s = a);
                                            break;
                                        case m.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
                                            var l = r.attrs["HDCP-LEVEL"];
                                            l && (this.hls.maxHdcpLevel = p.HdcpLevels[p.HdcpLevels.indexOf(l) - 1], this.warn('Restricting playback to HDCP-LEVEL of "' + this.hls.maxHdcpLevel + '" or lower'));
                                        case m.ErrorDetails.FRAG_PARSING_ERROR:
                                        case m.ErrorDetails.KEY_SYSTEM_NO_SESSION:
                                            s = (null == (a = t.frag) ? void 0 : a.type) === d.PlaylistLevelType.MAIN ? t.frag.level : this.currentLevelIndex, t.levelRetry = !1;
                                            break;
                                        case m.ErrorDetails.LEVEL_LOAD_ERROR:
                                        case m.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                                            i && (i.deliveryDirectives && (o = !1), s = i.level), n = !0;
                                            break;
                                        case m.ErrorDetails.REMUX_ALLOC_ERROR:
                                            s = null != (l = t.level) ? l : this.currentLevelIndex, n = !0
                                    }
                                    void 0 !== s && this.recoverLevel(t, s, n, o)
                                }
                            }
                        }, t.recoverLevel = function (e, t, i, r) {
                            var s = e.details, a = this._levels[t];
                            if (a.loadError++, i) {
                                if (!this.retryLoadingOrFail(e)) return void (this.currentLevelIndex = -1);
                                e.levelRetry = !0
                            }
                            if (r) {
                                i = a.url.length;
                                if (1 < i && a.loadError < i) e.levelRetry = !0, this.redundantFailover(t); else if (-1 === this.manualLevelIndex) {
                                    for (var n = -1, o = this._levels, l = o.length; l--;) {
                                        var d = (l + this.currentLevelIndex) % o.length;
                                        if (d !== this.currentLevelIndex && 0 === o[d].loadError) {
                                            n = d;
                                            break
                                        }
                                    }
                                    -1 < n && this.currentLevelIndex !== n ? (this.warn(s + ": switch to " + n), e.levelRetry = !0, this.hls.nextAutoLevel = n) : !1 === e.levelRetry && (e.fatal = !0)
                                }
                            }
                        }, t.redundantFailover = function (e) {
                            var t, i = this._levels[e], r = i.url.length;
                            1 < r && (t = (i.urlId + 1) % r, this.warn("Switching to redundant URL-id " + t), this._levels.forEach(function (e) {
                                e.urlId = t
                            }), this.level = e)
                        }, t.onFragLoaded = function (e, t) {
                            var t = t.frag;
                            void 0 !== t && t.type === d.PlaylistLevelType.MAIN && void 0 !== (t = this._levels[t.level]) && (t.fragmentError = 0, t.loadError = 0)
                        }, t.onLevelLoaded = function (e, t) {
                            var i, r = t.level, s = t.details, a = this._levels[r];
                            if (!a) return this.warn("Invalid level index " + r), void (null != (i = t.deliveryDirectives) && i.skip && (s.deltaUpdateFailed = !0));
                            r === this.currentLevelIndex ? (0 === a.fragmentError && (a.loadError = 0, this.retryCount = 0), this.playlistLoaded(r, t, a.details)) : null != (i = t.deliveryDirectives) && i.skip && (s.deltaUpdateFailed = !0)
                        }, t.onAudioTrackSwitched = function (e, t) {
                            var i = this.hls.levels[this.currentLevelIndex];
                            if (i && i.audioGroupIds) {
                                for (var r = -1, s = this.hls.audioTracks[t.id].groupId, a = 0; a < i.audioGroupIds.length; a++) if (i.audioGroupIds[a] === s) {
                                    r = a;
                                    break
                                }
                                r !== i.urlId && (i.urlId = r, this.startLoad())
                            }
                        }, t.loadPlaylist = function (e) {
                            h.prototype.loadPlaylist.call(this);
                            var t = this.currentLevelIndex, i = this._levels[t];
                            if (this.canLoad && i && 0 < i.url.length) {
                                var r = i.urlId, i = i.url[r];
                                if (e) try {
                                    i = e.addDirectives(i)
                                } catch (e) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
                                }
                                this.log("Attempt loading level index " + t + (void 0 !== (null == e ? void 0 : e.msn) ? " at sn " + e.msn + " part " + e.part : "") + " with URL-id " + r + " " + i), this.clearTimer(), this.hls.trigger(f.Events.LEVEL_LOADING, {
                                    url: i,
                                    level: t,
                                    id: r,
                                    deliveryDirectives: e || null
                                })
                            }
                        }, t.removeLevel = function (i, r) {
                            function s(e, t) {
                                return t !== r
                            }

                            var e = this._levels.filter(function (e, t) {
                                return t !== i || 1 < e.url.length && void 0 !== r && (e.url = e.url.filter(s), e.audioGroupIds && (e.audioGroupIds = e.audioGroupIds.filter(s)), e.textGroupIds && (e.textGroupIds = e.textGroupIds.filter(s)), !(e.urlId = 0))
                            }).map(function (e, t) {
                                var i = e.details;
                                return null != i && i.fragments && i.fragments.forEach(function (e) {
                                    e.level = t
                                }), e
                            });
                            this._levels = e, this.hls.trigger(f.Events.LEVELS_UPDATED, {levels: e})
                        }, r((i = o).prototype, [{
                            key: "levels", get: function () {
                                return 0 === this._levels.length ? null : this._levels
                            }
                        }, {
                            key: "level", get: function () {
                                return this.currentLevelIndex
                            }, set: function (e) {
                                var t = this._levels;
                                if (0 !== t.length && (this.currentLevelIndex !== e || null == (i = t[e]) || !i.details)) {
                                    if (e < 0 || e >= t.length) {
                                        var i = e < 0;
                                        if (this.hls.trigger(f.Events.ERROR, {
                                            type: m.ErrorTypes.OTHER_ERROR,
                                            details: m.ErrorDetails.LEVEL_SWITCH_ERROR,
                                            level: e,
                                            fatal: i,
                                            reason: "invalid level idx"
                                        }), i) return;
                                        e = Math.min(e, t.length - 1)
                                    }
                                    this.clearTimer();
                                    var i = this.currentLevelIndex, r = t[i], t = t[e],
                                        i = (this.log("switching to level " + e + " from " + i), s({}, t, {
                                            level: this.currentLevelIndex = e,
                                            maxBitrate: t.maxBitrate,
                                            uri: t.uri,
                                            urlId: t.urlId
                                        })),
                                        e = (delete i._urlId, this.hls.trigger(f.Events.LEVEL_SWITCHING, i), t.details);
                                    e && !e.live || (i = this.switchParams(t.uri, null == r ? void 0 : r.details), this.loadPlaylist(i))
                                }
                            }
                        }, {
                            key: "manualLevel", get: function () {
                                return this.manualLevelIndex
                            }, set: function (e) {
                                this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e)
                            }
                        }, {
                            key: "firstLevel", get: function () {
                                return this._firstLevel
                            }, set: function (e) {
                                this._firstLevel = e
                            }
                        }, {
                            key: "startLevel", get: function () {
                                var e;
                                return void 0 === this._startLevel ? void 0 !== (e = this.hls.config.startLevel) ? e : this._firstLevel : this._startLevel
                            }, set: function (e) {
                                this._startLevel = e
                            }
                        }, {
                            key: "nextLoadLevel", get: function () {
                                return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
                            }, set: function (e) {
                                this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
                            }
                        }]), Object.defineProperty(i, "prototype", {writable: !1}), o);

                    function o(e) {
                        return (e = h.call(this, e, "[level-controller]") || this)._levels = [], e._firstLevel = -1, e._startLevel = void 0, e.currentLevelIndex = -1, e.manualLevelIndex = -1, e.onParsedComplete = void 0, e._registerListeners(), e
                    }
                }, "./src/controller/level-helper.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        addGroupId: () => function (e, t, i) {
                            switch (t) {
                                case"audio":
                                    e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds.push(i);
                                    break;
                                case"text":
                                    e.textGroupIds || (e.textGroupIds = []), e.textGroupIds.push(i)
                            }
                        },
                        addSliding: () => r,
                        adjustSliding: () => w,
                        assignTrackIdsByGroup: () => function (e) {
                            var i = {};
                            e.forEach(function (e) {
                                var t = e.groupId || "";
                                e.id = i[t] = i[t] || 0, i[t]++
                            })
                        },
                        computeReloadInterval: () => function (e, t) {
                            void 0 === t && (t = 1 / 0);
                            var i = 1e3 * e.targetduration;
                            e.updated ? (e = e.fragments).length && t < 4 * i && ((t = 1e3 * e[e.length - 1].duration) < i && (i = t)) : i /= 2;
                            return Math.round(i)
                        },
                        getFragmentWithSN: () => function (e, t, i) {
                            if (!e || !e.details) return null;
                            var r, e = e.details;
                            return (r = e.fragments[t - e.startSN]) || ((r = e.fragmentHint) && r.sn === t ? r : t < e.startSN && i && i.sn === t ? i : null)
                        },
                        getPartWith: () => function (e, t, i) {
                            if (!e || !e.details) return null;
                            var r = e.details.partList;
                            if (r) for (var s = r.length; s--;) {
                                var a = r[s];
                                if (a.index === i && a.fragment.sn === t) return a
                            }
                            return null
                        },
                        mapFragmentIntersection: () => _,
                        mapPartIntersection: () => v,
                        mergeDetails: () => function (e, i) {
                            for (var r = null, t = e.fragments, s = t.length - 1; 0 <= s; s--) {
                                var a = t[s].initSegment;
                                if (a) {
                                    r = a;
                                    break
                                }
                            }
                            e.fragmentHint && delete e.fragmentHint.endPTS;
                            var n, o, l, d = 0;
                            if (_(e, i, function (e, t) {
                                e.relurl && (d = e.cc - t.cc), (0, m.isFiniteNumber)(e.startPTS) && (0, m.isFiniteNumber)(e.endPTS) && (t.start = t.startPTS = e.startPTS, t.startDTS = e.startDTS, t.appendedPTS = e.appendedPTS, t.maxStartPTS = e.maxStartPTS, t.endPTS = e.endPTS, t.endDTS = e.endDTS, t.minEndPTS = e.minEndPTS, t.duration = e.endPTS - e.startPTS, t.duration && (n = t), i.PTSKnown = i.alignedSliding = !0), t.elementaryStreams = e.elementaryStreams, t.loader = e.loader, t.stats = e.stats, t.urlId = e.urlId, e.initSegment && (t.initSegment = e.initSegment, r = e.initSegment)
                            }), r && (i.fragmentHint ? i.fragments.concat(i.fragmentHint) : i.fragments).forEach(function (e) {
                                var t;
                                e.initSegment && e.initSegment.relurl !== (null == (t = r) ? void 0 : t.relurl) || (e.initSegment = r)
                            }), i.skippedSegments) if (i.deltaUpdateFailed = i.fragments.some(function (e) {
                                return !e
                            }), i.deltaUpdateFailed) {
                                g.logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                                for (var h = i.skippedSegments; h--;) i.fragments.shift();
                                i.startSN = i.fragments[0].sn, i.startCC = i.fragments[0].cc
                            } else i.canSkipDateRanges && (i.dateRanges = (p = e.dateRanges, o = i.dateRanges, f = i.recentlyRemovedDateranges, l = A({}, p), f && f.forEach(function (e) {
                                delete l[e]
                            }), Object.keys(o).forEach(function (e) {
                                var t = new y.DateRange(o[e].attr, l[e]);
                                t.isValid ? l[e] = t : g.logger.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(o[e].attr) + '"')
                            }), l));
                            var c = i.fragments;
                            if (d) {
                                g.logger.warn("discontinuity sliding from playlist, take drift into account");
                                for (var u = 0; u < c.length; u++) c[u].cc += d
                            }
                            i.skippedSegments && (i.startCC = i.fragments[0].cc), v(e.partList, i.partList, function (e, t) {
                                t.elementaryStreams = e.elementaryStreams, t.stats = e.stats
                            }), n ? b(i, n, n.startPTS, n.endPTS, n.startDTS, n.endDTS) : w(e, i), c.length && (i.totalduration = i.edge - c[0].start), i.driftStartTime = e.driftStartTime, i.driftStart = e.driftStart;
                            var p = i.advancedDateTime;
                            {
                                var f;
                                i.advanced && p ? (f = i.edge, i.driftStart || (i.driftStartTime = p, i.driftStart = f), i.driftEndTime = p, i.driftEnd = f) : (i.driftEndTime = e.driftEndTime, i.driftEnd = e.driftEnd, i.advancedDateTime = e.advancedDateTime)
                            }
                        },
                        updateFragPTSDTS: () => b,
                        updatePTS: () => function (e, t, i) {
                            p(e[t], e[i])
                        }
                    });
                    var m = i("./src/polyfills/number.ts"), g = i("./src/utils/logger.ts"),
                        y = i("./src/loader/date-range.ts");

                    function A() {
                        return (A = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    function p(e, t) {
                        var i, r = t.startPTS;
                        (0, m.isFiniteNumber)(r) ? (i = 0, (r = t.sn > e.sn ? (i = r - e.start, e) : (i = e.start - r, t)).duration !== i && (r.duration = i)) : t.sn > e.sn ? e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration : t.start = Math.max(e.start - t.duration, 0)
                    }

                    function b(e, t, i, r, s, a) {
                        r - i <= 0 && (g.logger.warn("Fragment should have a positive duration", t), r = i + t.duration, a = s + t.duration);
                        var n = i, o = r, l = t.startPTS, d = t.endPTS,
                            h = ((0, m.isFiniteNumber)(l) && (h = Math.abs(l - i), (0, m.isFiniteNumber)(t.deltaPTS) ? t.deltaPTS = Math.max(h, t.deltaPTS) : t.deltaPTS = h, n = Math.max(i, l), i = Math.min(i, l), s = Math.min(s, t.startDTS), o = Math.min(r, d), r = Math.max(r, d), a = Math.max(a, t.endDTS)), t.duration = r - i, i - t.start);
                        t.start = t.startPTS = i, t.maxStartPTS = n, t.startDTS = s, t.endPTS = r, t.minEndPTS = o, t.endDTS = a;
                        var c, l = t.sn;
                        if (!e || l < e.startSN || l > e.endSN) return 0;
                        var d = l - e.startSN, u = e.fragments;
                        for (u[d] = t, c = d; 0 < c; c--) p(u[c], u[c - 1]);
                        for (c = d; c < u.length - 1; c++) p(u[c], u[c + 1]);
                        return e.fragmentHint && p(u[u.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, h
                    }

                    function v(e, t, i) {
                        if (e && t) for (var r = 0, s = 0, a = e.length; s <= a; s++) {
                            var n = e[s], o = t[s + r];
                            n && o && n.index === o.index && n.fragment.sn === o.fragment.sn ? i(n, o) : r--
                        }
                    }

                    function _(e, t, i) {
                        for (var r = t.skippedSegments, s = Math.max(e.startSN, t.startSN) - t.startSN, a = (e.fragmentHint ? 1 : 0) + (r ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN, n = t.startSN - e.startSN, o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, d = s; d <= a; d++) {
                            var h = l[n + d], c = o[d];
                            r && !c && d < r && (c = t.fragments[d] = h), h && c && i(h, c)
                        }
                    }

                    function w(e, t) {
                        var i = t.startSN + t.skippedSegments - e.startSN, e = e.fragments;
                        i < 0 || i >= e.length || r(t, e[i].start)
                    }

                    function r(e, t) {
                        if (t) {
                            for (var i = e.fragments, r = e.skippedSegments; r < i.length; r++) i[r].start += t;
                            e.fragmentHint && (e.fragmentHint.start += t)
                        }
                    }
                }, "./src/controller/stream-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => f});
                    var g = i("./src/polyfills/number.ts"), y = i("./src/controller/base-stream-controller.ts"),
                        a = i("./src/is-supported.ts"), A = i("./src/events.ts"), s = i("./src/utils/buffer-helper.ts"),
                        n = i("./src/controller/fragment-tracker.ts"), c = i("./src/types/loader.ts"),
                        b = i("./src/loader/fragment.ts"), u = i("./src/demux/transmuxer-interface.ts"),
                        p = i("./src/types/transmuxer.ts"), r = i("./src/controller/gap-controller.ts"),
                        o = i("./src/errors.ts");

                    function l(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function d(e, t) {
                        return (d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    h = y.default, t = h, (i = m).prototype = Object.create(t.prototype), d(i.prototype.constructor = i, t), (i = m.prototype)._registerListeners = function () {
                        var e = this.hls;
                        e.on(A.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(A.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(A.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(A.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(A.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(A.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(A.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(A.Events.ERROR, this.onError, this), e.on(A.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(A.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(A.Events.BUFFER_CREATED, this.onBufferCreated, this), e.on(A.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(A.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(A.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, i._unregisterListeners = function () {
                        var e = this.hls;
                        e.off(A.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(A.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(A.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(A.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(A.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(A.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(A.Events.ERROR, this.onError, this), e.off(A.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(A.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(A.Events.BUFFER_CREATED, this.onBufferCreated, this), e.off(A.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(A.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(A.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, i.onHandlerDestroying = function () {
                        this._unregisterListeners(), this.onMediaDetaching()
                    }, i.startLoad = function (e) {
                        var t, i, r;
                        this.levels ? (t = this.lastCurrentTime, i = this.hls, this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, this.startFragRequested || (-1 === (r = i.startLevel) && (i.config.testBandwidth && 1 < this.levels.length ? this.bitrateTest = !(r = 0) : r = i.nextAutoLevel), this.level = i.nextLoadLevel = r, this.loadedmetadata = !1), 0 < t && -1 === e && (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)), e = t), this.state = y.State.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()) : (this._forceStartLoad = !0, this.state = y.State.STOPPED)
                    }, i.stopLoad = function () {
                        this._forceStartLoad = !1, h.prototype.stopLoad.call(this)
                    }, i.doTick = function () {
                        switch (this.state) {
                            case y.State.IDLE:
                                this.doTickIdle();
                                break;
                            case y.State.WAITING_LEVEL:
                                var e = this.levels, t = this.level,
                                    t = null == e || null == (e = e[t]) ? void 0 : e.details;
                                if (!t || t.live && this.levelLastLoaded !== this.level) break;
                                if (this.waitForCdnTuneIn(t)) break;
                                this.state = y.State.IDLE;
                                break;
                            case y.State.FRAG_LOADING_WAITING_RETRY:
                                e = self.performance.now(), t = this.retryDate;
                                (!t || t <= e || null != (t = this.media) && t.seeking) && (this.log("retryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.level), this.state = y.State.IDLE)
                        }
                        this.onTickEnd()
                    }, i.onTickEnd = function () {
                        h.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged()
                    }, i.doTickIdle = function () {
                        var e = this.hls, t = this.levelLastLoaded, i = this.levels, r = this.media, s = e.config,
                            a = e.nextLoadLevel;
                        if (null !== t && (r || !this.startFragRequested && s.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && i && i[a]) {
                            t = i[a], r = this.getMainFwdBufferInfo();
                            if (null !== r) {
                                s = this.getLevelDetails();
                                if (s && this._streamEnded(r, s)) return i = {}, this.altAudio && (i.type = "video"), this.hls.trigger(A.Events.BUFFER_EOS, i), void (this.state = y.State.ENDED);
                                this.level = e.nextLoadLevel = a;
                                s = t.details;
                                if (!s || this.state === y.State.WAITING_LEVEL || s.live && this.levelLastLoaded !== a) return this.level = a, void (this.state = y.State.WAITING_LEVEL);
                                r.len >= this.getMaxBufferLength(t.maxBitrate) || (this.backtrackFragment && this.backtrackFragment.start > r.end && (this.backtrackFragment = null), i = this.backtrackFragment ? this.backtrackFragment.start : r.end, e = this.getNextFragment(i, s), this.couldBacktrack && !this.fragPrevious && e && "initSegment" !== e.sn && this.fragmentTracker.getState(e) !== n.FragmentState.OK ? (t = (null != (a = this.backtrackFragment) ? a : e).sn - s.startSN, (a = s.fragments[t - 1]) && e.cc === a.cc && this.fragmentTracker.removeFragment(e = a)) : this.backtrackFragment && r.len && (this.backtrackFragment = null), e && this.fragmentTracker.getState(e) === n.FragmentState.OK && this.nextLoadPosition > i && ((a = ((t = this.audioOnly && !this.altAudio ? b.ElementaryStreamTypes.AUDIO : b.ElementaryStreamTypes.VIDEO) === b.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media) && this.afterBufferFlushed(a, t, c.PlaylistLevelType.MAIN), e = this.getNextFragment(this.nextLoadPosition, s)), e && (!e.initSegment || e.initSegment.data || this.bitrateTest || (e = e.initSegment), this.loadFragment(e, s, i)))
                            }
                        }
                    }, i.loadFragment = function (e, t, i) {
                        var r = this.fragmentTracker.getState(e);
                        this.fragCurrent = e, r === n.FragmentState.NOT_LOADED ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log("Fragment " + e.sn + " of level " + e.level + " is being downloaded to test bitrate and will not be buffered"), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, h.prototype.loadFragment.call(this, e, t, i)) : r === n.FragmentState.APPENDING ? this.reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e) : 0 === (null == (t = this.media) ? void 0 : t.buffered.length) && this.fragmentTracker.removeAllFragments()
                    }, i.getAppendedFrag = function (e) {
                        e = this.fragmentTracker.getAppendedFrag(e, c.PlaylistLevelType.MAIN);
                        return e && "fragment" in e ? e.fragment : e
                    }, i.getBufferedFrag = function (e) {
                        return this.fragmentTracker.getBufferedFrag(e, c.PlaylistLevelType.MAIN)
                    }, i.followingBufferedFrag = function (e) {
                        return e ? this.getBufferedFrag(e.end + .5) : null
                    }, i.immediateLevelSwitch = function () {
                        this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
                    }, i.nextLevelSwitch = function () {
                        var e, t = this.levels, i = this.media;
                        null != i && i.readyState && ((e = this.getAppendedFrag(i.currentTime)) && 1 < e.start && this.flushMainBuffer(0, e.start - 1), e = !i.paused && t ? (e = t[this.hls.nextLoadLevel], (t = this.fragLastKbps) && this.fragCurrent ? this.fragCurrent.duration * e.maxBitrate / (1e3 * t) + 1 : 0) : 0, (t = this.getBufferedFrag(i.currentTime + e)) && (i = this.followingBufferedFrag(t)) && (this.abortCurrentFrag(), e = i.maxStartPTS || i.start, i = i.duration, t = Math.max(t.end, e + Math.min(Math.max(i - this.config.maxFragLookUpTolerance, .5 * i), .75 * i)), this.flushMainBuffer(t, Number.POSITIVE_INFINITY)))
                    }, i.abortCurrentFrag = function () {
                        var e = this.fragCurrent;
                        switch (this.fragCurrent = null, this.backtrackFragment = null, e && e.abortRequests(), this.state) {
                            case y.State.KEY_LOADING:
                            case y.State.FRAG_LOADING:
                            case y.State.FRAG_LOADING_WAITING_RETRY:
                            case y.State.PARSING:
                            case y.State.PARSED:
                                this.state = y.State.IDLE
                        }
                        this.nextLoadPosition = this.getLoadPosition()
                    }, i.flushMainBuffer = function (e, t) {
                        h.prototype.flushMainBuffer.call(this, e, t, this.altAudio ? "video" : null)
                    }, i.onMediaAttached = function (e, t) {
                        h.prototype.onMediaAttached.call(this, e, t);
                        e = t.media;
                        this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), e.addEventListener("playing", this.onvplaying), e.addEventListener("seeked", this.onvseeked), this.gapController = new r.default(this.config, e, this.fragmentTracker, this.hls)
                    }, i.onMediaDetaching = function () {
                        var e = this.media;
                        e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), h.prototype.onMediaDetaching.call(this)
                    }, i.onMediaPlaying = function () {
                        this.tick()
                    }, i.onMediaSeeked = function () {
                        var e = this.media, e = e ? e.currentTime : null;
                        (0, g.isFiniteNumber)(e) && this.log("Media seeked to " + e.toFixed(3)), this.tick()
                    }, i.onManifestLoading = function () {
                        this.log("Trigger BUFFER_RESET"), this.hls.trigger(A.Events.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null, this.backtrackFragment = null
                    }, i.onManifestParsed = function (e, t) {
                        var i, r = !1, s = !1;
                        t.levels.forEach(function (e) {
                            (i = e.audioCodec) && (-1 !== i.indexOf("mp4a.40.2") && (r = !0), -1 !== i.indexOf("mp4a.40.5") && (s = !0))
                        }), this.audioCodecSwitch = r && s && !(0, a.changeTypeSupported)(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1
                    }, i.onLevelLoading = function (e, t) {
                        var i = this.levels;
                        i && this.state === y.State.IDLE && (!(i = i[t.level]).details || i.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(i.details)) && (this.state = y.State.WAITING_LEVEL)
                    }, i.onLevelLoaded = function (e, t) {
                        var i = this.levels, r = t.level, s = t.details, a = s.totalduration;
                        if (i) {
                            this.log("Level " + r + " loaded [" + s.startSN + "," + s.endSN + "], cc [" + s.startCC + ", " + s.endCC + "] duration:" + a);
                            a = this.fragCurrent, t = (!a || this.state !== y.State.FRAG_LOADING && this.state !== y.State.FRAG_LOADING_WAITING_RETRY || a.level !== t.level && a.loader && (this.state = y.State.IDLE, this.backtrackFragment = null, a.abortRequests()), i[r]), a = 0;
                            if (s.live || null != (i = t.details) && i.live) {
                                if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed) return;
                                a = this.alignPlaylists(s, t.details)
                            }
                            if (t.details = s, this.levelLastLoaded = r, this.hls.trigger(A.Events.LEVEL_UPDATED, {
                                details: s,
                                level: r
                            }), this.state === y.State.WAITING_LEVEL) {
                                if (this.waitForCdnTuneIn(s)) return;
                                this.state = y.State.IDLE
                            }
                            this.startFragRequested ? s.live && this.synchronizeToLiveEdge(s) : this.setStartPosition(s, a), this.tick()
                        } else this.warn("Levels were reset while loading level " + r)
                    }, i._handleFragmentLoadProgress = function (e) {
                        var t, i, r, s, a, n, o, l = e.frag, d = e.part, e = e.payload, h = this.levels;
                        h ? (t = (h = h[l.level]).details) ? (i = h.videoCodec, r = t.PTSKnown || !t.live, s = null == (s = l.initSegment) ? void 0 : s.data, h = this._getAudioCodec(h), a = this.transmuxer = this.transmuxer || new u.default(this.hls, c.PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), n = d ? d.index : -1, n = new p.ChunkMetadata(l.level, l.sn, l.stats.chunkCount, e.byteLength, n, -1 !== n), o = this.initPTS[l.cc], a.push(e, s, h, i, l, d, t.totalduration, r, n, o)) : this.warn("Dropping fragment " + l.sn + " of level " + l.level + " after level details were reset") : this.warn("Levels were reset while fragment load was in progress. Fragment " + l.sn + " of level " + l.level + " will not be buffered")
                    }, i.onAudioTrackSwitching = function (e, t) {
                        var i = this.altAudio, r = !!t.url, t = t.id;
                        r || (this.mediaBuffer !== this.media ? (this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media, (r = this.fragCurrent) && (this.log("Switching to main audio track, cancel main fragment load"), r.abortRequests()), this.resetTransmuxer(), this.resetLoadingState()) : this.audioOnly && this.resetTransmuxer(), r = this.hls, i && r.trigger(A.Events.BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: Number.POSITIVE_INFINITY,
                            type: "audio"
                        }), r.trigger(A.Events.AUDIO_TRACK_SWITCHED, {id: t}))
                    }, i.onAudioTrackSwitched = function (e, t) {
                        var i, t = t.id, t = !!this.hls.audioTracks[t].url;
                        t && (i = this.videoBuffer) && this.mediaBuffer !== i && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = i), this.altAudio = t, this.tick()
                    }, i.onBufferCreated = function (e, t) {
                        var i, r = t.tracks, s = !1;
                        for (i in r) {
                            var a, n, o = r[i];
                            "main" === o.id ? (n = o, "video" === (a = i) && (o = r[i]) && (this.videoBuffer = o.buffer)) : s = !0
                        }
                        s && n ? (this.log("Alternate track found, use " + a + ".buffered to schedule main fragment loading"), this.mediaBuffer = n.buffer) : this.mediaBuffer = this.media
                    }, i.onFragBuffered = function (e, t) {
                        var i = t.frag, t = t.part;
                        if (!i || i.type === c.PlaylistLevelType.MAIN) {
                            if (this.fragContextChanged(i)) return this.warn("Fragment " + i.sn + (t ? " p: " + t.index : "") + " of level " + i.level + " finished buffering, but was aborted. state: " + this.state), void (this.state === y.State.PARSED && (this.state = y.State.IDLE));
                            var r = (t || i).stats;
                            this.fragLastKbps = Math.round(8 * r.total / (r.buffering.end - r.loading.first)), "initSegment" !== i.sn && (this.fragPrevious = i), this.fragBufferedComplete(i, t)
                        }
                    }, i.onError = function (e, t) {
                        if (t.type !== o.ErrorTypes.KEY_SYSTEM_ERROR) switch (t.details) {
                            case o.ErrorDetails.FRAG_LOAD_ERROR:
                            case o.ErrorDetails.FRAG_LOAD_TIMEOUT:
                            case o.ErrorDetails.FRAG_PARSING_ERROR:
                            case o.ErrorDetails.KEY_LOAD_ERROR:
                            case o.ErrorDetails.KEY_LOAD_TIMEOUT:
                                this.onFragmentOrKeyLoadError(c.PlaylistLevelType.MAIN, t);
                                break;
                            case o.ErrorDetails.LEVEL_LOAD_ERROR:
                            case o.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                                this.state !== y.State.ERROR && (t.fatal ? (this.warn("" + t.details), this.state = y.State.ERROR) : t.levelRetry || this.state !== y.State.WAITING_LEVEL || (this.state = y.State.IDLE));
                                break;
                            case o.ErrorDetails.BUFFER_FULL_ERROR:
                                var i, r;
                                "main" !== t.parent || this.state !== y.State.PARSING && this.state !== y.State.PARSED || (i = !0, (i = (r = this.getFwdBufferInfo(this.media, c.PlaylistLevelType.MAIN)) && .5 < r.len ? !this.reduceMaxBufferLength(r.len) : i) && (this.warn("buffer full error also media.currentTime is not buffered, flush main"), this.immediateLevelSwitch()), this.resetLoadingState())
                        } else this.onFragmentOrKeyLoadError(c.PlaylistLevelType.MAIN, t)
                    }, i.checkBuffer = function () {
                        var e, t = this.media, i = this.gapController;
                        t && i && t.readyState && (!this.loadedmetadata && s.BufferHelper.getBuffered(t).length || (e = this.state !== y.State.IDLE ? this.fragCurrent : null, i.poll(this.lastCurrentTime, e)), this.lastCurrentTime = t.currentTime)
                    }, i.onFragLoadEmergencyAborted = function () {
                        this.state = y.State.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
                    }, i.onBufferFlushed = function (e, t) {
                        var i, t = t.type;
                        (t !== b.ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) && (i = (t === b.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media, this.afterBufferFlushed(i, t, c.PlaylistLevelType.MAIN))
                    }, i.onLevelsUpdated = function (e, t) {
                        this.levels = t.levels
                    }, i.swapAudioCodec = function () {
                        this.audioCodecSwap = !this.audioCodecSwap
                    }, i.seekToStartPos = function () {
                        var e, t, i, r = this.media;
                        r && (e = r.currentTime, 0 <= (t = this.startPosition) && e < t && (r.seeking ? this.log("could not seek to " + t + ", already seeking at " + e) : (0 < (i = ((i = s.BufferHelper.getBuffered(r)).length ? i.start(0) : 0) - t) && (i < this.config.maxBufferHole || i < this.config.maxFragLookUpTolerance) && (this.log("adjusting start position by " + i + " to match buffer start"), this.startPosition = t += i), this.log("seek to target start position " + t + " from current time " + e), r.currentTime = t)))
                    }, i._getAudioCodec = function (e) {
                        e = this.config.defaultAudioCodec || e.audioCodec;
                        return this.audioCodecSwap && e && (this.log("Swapping audio codec"), e = -1 !== e.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), e
                    }, i._loadBitrateTestFrag = function (r, e) {
                        var s = this;
                        r.bitrateTest = !0, this._doFragLoad(r, e).then(function (e) {
                            var t, i = s.hls;
                            e && !s.fragContextChanged(r) && (s.fragLoadError = 0, s.state = y.State.IDLE, s.startFragRequested = !1, s.bitrateTest = !1, (t = r.stats).parsing.start = t.parsing.end = t.buffering.start = t.buffering.end = self.performance.now(), i.trigger(A.Events.FRAG_LOADED, e), r.bitrateTest = !1)
                        })
                    }, i._handleTransmuxComplete = function (e) {
                        var t = "main", i = this.hls, r = e.remuxResult, e = e.chunkMeta, s = this.getCurrentContext(e);
                        if (!s) return this.warn("The loading context changed while buffering fragment " + e.sn + " of level " + e.level + ". This chunk will not be buffered."), void this.resetStartWhenNotLoaded(e.level);
                        var a = s.frag, n = s.part, s = s.level, o = r.video, l = r.text, d = r.id3, h = r.initSegment,
                            c = s.details, u = this.altAudio ? void 0 : r.audio;
                        if (!this.fragContextChanged(a)) {
                            if (this.state = y.State.PARSING, h && (h.tracks && (this._bufferInitSegment(s, h.tracks, a, e), i.trigger(A.Events.FRAG_PARSING_INIT_SEGMENT, {
                                frag: a,
                                id: t,
                                tracks: h.tracks
                            })), s = h.initPTS, h = h.timescale, (0, g.isFiniteNumber)(s) && (this.initPTS[a.cc] = s, i.trigger(A.Events.INIT_PTS_FOUND, {
                                frag: a,
                                id: t,
                                initPTS: s,
                                timescale: h
                            }))), o && !1 !== r.independent) {
                                if (c) {
                                    var s = o.startPTS, h = o.endPTS, p = o.startDTS, f = o.endDTS;
                                    if (n) n.elementaryStreams[o.type] = {
                                        startPTS: s,
                                        endPTS: h,
                                        startDTS: p,
                                        endDTS: f
                                    }; else if (o.firstKeyFrame && o.independent && 1 === e.id && (this.couldBacktrack = !0), o.dropped && o.independent) {
                                        var m = this.getMainFwdBufferInfo();
                                        if ((m ? m.end : this.getLoadPosition()) + this.config.maxBufferHole < (o.firstKeyFramePTS || s) - this.config.maxBufferHole) return void this.backtrack(a);
                                        a.setElementaryStreamInfo(o.type, a.start, h, a.start, f, !0)
                                    }
                                    a.setElementaryStreamInfo(o.type, s, h, p, f), this.backtrackFragment && (this.backtrackFragment = a), this.bufferFragmentData(o, a, n, e)
                                }
                            } else if (!1 === r.independent) return void this.backtrack(a);
                            u && (m = u.startPTS, s = u.endPTS, h = u.startDTS, p = u.endDTS, n && (n.elementaryStreams[b.ElementaryStreamTypes.AUDIO] = {
                                startPTS: m,
                                endPTS: s,
                                startDTS: h,
                                endDTS: p
                            }), a.setElementaryStreamInfo(b.ElementaryStreamTypes.AUDIO, m, s, h, p), this.bufferFragmentData(u, a, n, e)), c && null != d && null != (f = d.samples) && f.length && (o = {
                                id: t,
                                frag: a,
                                details: c,
                                samples: d.samples
                            }, i.trigger(A.Events.FRAG_PARSING_METADATA, o)), c && l && (r = {
                                id: t,
                                frag: a,
                                details: c,
                                samples: l.samples
                            }, i.trigger(A.Events.FRAG_PARSING_USERDATA, r))
                        }
                    }, i._bufferInitSegment = function (e, i, r, s) {
                        var t, a, n, o, l, d = this;
                        this.state === y.State.PARSING && (this.audioOnly = !!i.audio && !i.video, this.altAudio && !this.audioOnly && delete i.audio, t = i.audio, a = i.video, n = i.audiovideo, t && (o = e.audioCodec, l = navigator.userAgent.toLowerCase(), this.audioCodecSwitch && (o = o && (-1 !== o.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== t.metadata.channelCount && -1 === l.indexOf("firefox") && (o = "mp4a.40.5")), -1 !== l.indexOf("android") && "audio/mpeg" !== t.container && this.log("Android: force audio codec to " + (o = "mp4a.40.2")), e.audioCodec && e.audioCodec !== o && this.log('Swapping manifest audio codec "' + e.audioCodec + '" for "' + o + '"'), t.levelCodec = o, t.id = "main", this.log("Init audio buffer, container:" + t.container + ", codecs[selected/level/parsed]=[" + (o || "") + "/" + (e.audioCodec || "") + "/" + t.codec + "]")), a && (a.levelCodec = e.videoCodec, a.id = "main", this.log("Init video buffer, container:" + a.container + ", codecs[level/parsed]=[" + (e.videoCodec || "") + "/" + a.codec + "]")), n && this.log("Init audiovideo buffer, container:" + n.container + ", codecs[level/parsed]=[" + (e.attrs.CODECS || "") + "/" + n.codec + "]"), this.hls.trigger(A.Events.BUFFER_CODECS, i), Object.keys(i).forEach(function (e) {
                            var t = i[e].initSegment;
                            null != t && t.byteLength && d.hls.trigger(A.Events.BUFFER_APPENDING, {
                                type: e,
                                data: t,
                                frag: r,
                                part: null,
                                chunkMeta: s,
                                parent: r.type
                            })
                        }), this.tick())
                    }, i.getMainFwdBufferInfo = function () {
                        return this.getFwdBufferInfo(this.mediaBuffer || this.media, c.PlaylistLevelType.MAIN)
                    }, i.backtrack = function (e) {
                        this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = y.State.IDLE
                    }, i.checkFragmentChanged = function () {
                        var e, t = this.media, i = null;
                        t && 1 < t.readyState && !1 === t.seeking && (e = t.currentTime, s.BufferHelper.isBuffered(t, e) ? i = this.getAppendedFrag(e) : s.BufferHelper.isBuffered(t, e + .1) && (i = this.getAppendedFrag(e + .1)), i && (this.backtrackFragment = null, t = this.fragPlaying, e = i.level, t && i.sn === t.sn && t.level === e && i.urlId === t.urlId || (this.fragPlaying = i, this.hls.trigger(A.Events.FRAG_CHANGED, {frag: i}), t && t.level === e || this.hls.trigger(A.Events.LEVEL_SWITCHED, {level: e}))))
                    }, l((t = m).prototype, [{
                        key: "nextLevel", get: function () {
                            var e = this.nextBufferedFrag;
                            return e ? e.level : -1
                        }
                    }, {
                        key: "currentFrag", get: function () {
                            var e = this.media;
                            return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
                        }
                    }, {
                        key: "currentProgramDateTime", get: function () {
                            var e = this.media;
                            if (e) {
                                var e = e.currentTime, t = this.currentFrag;
                                if (t && (0, g.isFiniteNumber)(e) && (0, g.isFiniteNumber)(t.programDateTime)) return e = t.programDateTime + 1e3 * (e - t.start), new Date(e)
                            }
                            return null
                        }
                    }, {
                        key: "currentLevel", get: function () {
                            var e = this.currentFrag;
                            return e ? e.level : -1
                        }
                    }, {
                        key: "nextBufferedFrag", get: function () {
                            var e = this.currentFrag;
                            return e ? this.followingBufferedFrag(e) : null
                        }
                    }, {
                        key: "forceStartLoad", get: function () {
                            return this._forceStartLoad
                        }
                    }]), Object.defineProperty(t, "prototype", {writable: !1});
                    var h, f = m;

                    function m(e, t, i) {
                        return (e = h.call(this, e, t, i, "[stream-controller]") || this).audioCodecSwap = !1, e.gapController = null, e.level = -1, e._forceStartLoad = !1, e.altAudio = !1, e.audioOnly = !1, e.fragPlaying = null, e.onvplaying = null, e.onvseeked = null, e.fragLastKbps = 0, e.couldBacktrack = !1, e.backtrackFragment = null, e.audioCodecSwitch = !1, e.videoBuffer = null, e._registerListeners(), e
                    }
                }, "./src/controller/subtitle-stream-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {SubtitleStreamController: () => m});
                    var n = i("./src/events.ts"), l = i("./src/utils/buffer-helper.ts"),
                        d = i("./src/controller/fragment-finders.ts"), o = i("./src/utils/discontinuities.ts"),
                        h = i("./src/controller/level-helper.ts"), c = i("./src/controller/fragment-tracker.ts"),
                        u = i("./src/controller/base-stream-controller.ts"), p = i("./src/types/loader.ts"),
                        r = i("./src/types/level.ts");

                    function s(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function a(e, t) {
                        return (a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    f = u.default, t = f, (i = y).prototype = Object.create(t.prototype), a(i.prototype.constructor = i, t), (i = y.prototype).onHandlerDestroying = function () {
                        this._unregisterListeners(), this.mainDetails = null
                    }, i._registerListeners = function () {
                        var e = this.hls;
                        e.on(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(n.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.on(n.Events.ERROR, this.onError, this), e.on(n.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(n.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(n.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(n.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(n.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(n.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, i._unregisterListeners = function () {
                        var e = this.hls;
                        e.off(n.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(n.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(n.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(n.Events.LEVEL_LOADED, this.onLevelLoaded, this), e.off(n.Events.ERROR, this.onError, this), e.off(n.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(n.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(n.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(n.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(n.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(n.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, i.startLoad = function (e) {
                        this.stopLoad(), this.state = u.State.IDLE, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                    }, i.onManifestLoading = function () {
                        this.mainDetails = null, this.fragmentTracker.removeAllFragments()
                    }, i.onLevelLoaded = function (e, t) {
                        this.mainDetails = t.details
                    }, i.onSubtitleFragProcessed = function (e, t) {
                        var i = t.frag, t = t.success;
                        if (this.fragPrevious = i, this.state = u.State.IDLE, t) {
                            var r = this.tracksBuffered[this.currentTrackId];
                            if (r) {
                                for (var s, a = i.start, n = 0; n < r.length; n++) if (a >= r[n].start && a <= r[n].end) {
                                    s = r[n];
                                    break
                                }
                                t = i.start + i.duration;
                                s ? s.end = t : r.push(s = {start: a, end: t}), this.fragmentTracker.fragBuffered(i)
                            }
                        }
                    }, i.onBufferFlushing = function (e, t) {
                        var i, r, s, a = t.startOffset, n = t.endOffset;
                        0 === a && n !== Number.POSITIVE_INFINITY && (i = this.currentTrackId, (r = this.levels).length && r[i] && r[i].details && ((s = n - r[i].details.targetduration) <= 0 || (t.endOffsetSubtitles = Math.max(0, s), this.tracksBuffered.forEach(function (e) {
                            for (var t = 0; t < e.length;) if (e[t].end <= s) e.shift(); else {
                                if (!(e[t].start < s)) break;
                                e[t].start = s, t++
                            }
                        }), this.fragmentTracker.removeFragmentsInRange(a, s, p.PlaylistLevelType.SUBTITLE))))
                    }, i.onFragBuffered = function (e, t) {
                        this.loadedmetadata || t.frag.type !== p.PlaylistLevelType.MAIN || null != (t = this.media) && t.buffered.length && (this.loadedmetadata = !0)
                    }, i.onError = function (e, t) {
                        t = t.frag;
                        t && t.type === p.PlaylistLevelType.SUBTITLE && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state = u.State.IDLE)
                    }, i.onSubtitleTracksUpdated = function (e, t) {
                        var i = this, t = t.subtitleTracks;
                        this.tracksBuffered = [], this.levels = t.map(function (e) {
                            return new r.Level(e)
                        }), this.fragmentTracker.removeAllFragments(), this.fragPrevious = null, this.levels.forEach(function (e) {
                            i.tracksBuffered[e.id] = []
                        }), this.mediaBuffer = null
                    }, i.onSubtitleTrackSwitch = function (e, t) {
                        this.currentTrackId = t.id, this.levels.length && -1 !== this.currentTrackId ? (null != (t = this.levels[this.currentTrackId]) && t.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, t && this.setInterval(500)) : this.clearInterval()
                    }, i.onSubtitleTrackLoaded = function (e, t) {
                        var i = t.details, t = t.id, r = this.currentTrackId, s = this.levels;
                        if (s.length) {
                            var a = s[r];
                            if (!(t >= s.length || t !== r) && a) {
                                this.mediaBuffer = this.mediaBufferTimeRanges;
                                s = 0;
                                if (i.live || null != (r = a.details) && r.live) {
                                    r = this.mainDetails;
                                    if (i.deltaUpdateFailed || !r) return;
                                    var n = r.fragments[0];
                                    a.details ? 0 === (s = this.alignPlaylists(i, a.details)) && n && (s = n.start, (0, h.addSliding)(i, s)) : i.hasProgramDateTime && r.hasProgramDateTime ? ((0, o.alignMediaPlaylistByPDT)(i, r), s = i.fragments[0].start) : n && (s = n.start, (0, h.addSliding)(i, s))
                                }
                                a.details = i, this.levelLastLoaded = t, this.startFragRequested || !this.mainDetails && i.live || this.setStartPosition(a.details, s), this.tick(), !i.live || this.fragCurrent || !this.media || this.state !== u.State.IDLE || (0, d.findFragmentByPTS)(null, i.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), a.details = void 0)
                            }
                        }
                    }, i._handleFragmentLoadComplete = function (e) {
                        var i, t = this, r = e.frag, e = e.payload, s = r.decryptdata, a = this.hls;
                        !this.fragContextChanged(r) && e && 0 < e.byteLength && s && s.key && s.iv && "AES-128" === s.method && (i = performance.now(), this.decrypter.decrypt(new Uint8Array(e), s.key.buffer, s.iv.buffer).then(function (e) {
                            var t = performance.now();
                            a.trigger(n.Events.FRAG_DECRYPTED, {frag: r, payload: e, stats: {tstart: i, tdecrypt: t}})
                        }).catch(function (e) {
                            t.warn(e.name + ": " + e.message), t.state = u.State.IDLE
                        }))
                    }, i.doTick = function () {
                        var e, t, i, r, s, a, n, o;
                        this.media ? this.state === u.State.IDLE && (o = this.currentTrackId, (e = this.levels).length && e[o] && e[o].details && (o = (e = e[o].details).targetduration, t = this.config, r = this.getLoadPosition(), i = (r = l.BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], r - o, t.maxBufferHole)).end, r = r.len, s = this.getFwdBufferInfo(this.media, p.PlaylistLevelType.MAIN), r > this.getMaxBufferLength(null == s ? void 0 : s.len) + o || (console.assert(e, "Subtitle track details are defined on idle subtitle stream controller tick"), s = (r = e.fragments).length, o = e.edge, a = null, n = this.fragPrevious, i < o ? (o = t.maxFragLookUpTolerance, !(a = (0, d.findFragmentByPTS)(n, r, Math.max(r[0].start, i), o)) && n && n.start < r[0].start && (a = r[0])) : a = r[s - 1], a && (a = this.mapToInitFragWhenRequired(a), this.fragmentTracker.getState(a) === c.FragmentState.NOT_LOADED && this.loadFragment(a, e, i))))) : this.state = u.State.IDLE
                    }, i.getMaxBufferLength = function (e) {
                        var t = f.prototype.getMaxBufferLength.call(this);
                        return e ? Math.max(t, e) : t
                    }, i.loadFragment = function (e, t, i) {
                        "initSegment" === (this.fragCurrent = e).sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, f.prototype.loadFragment.call(this, e, t, i))
                    }, s((t = y).prototype, [{
                        key: "mediaBufferTimeRanges", get: function () {
                            return new g(this.tracksBuffered[this.currentTrackId] || [])
                        }
                    }]), Object.defineProperty(t, "prototype", {writable: !1});
                    var f, m = y, g = function (r) {
                        this.buffered = void 0;

                        function t(e, t, i) {
                            if ((t >>>= 0) > i - 1) throw new DOMException("Failed to execute '" + e + "' on 'TimeRanges': The index provided (" + t + ") is greater than the maximum bound (" + i + ")");
                            return r[t][e]
                        }

                        this.buffered = {
                            get length() {
                                return r.length
                            }, end: function (e) {
                                return t("end", e, r.length)
                            }, start: function (e) {
                                return t("start", e, r.length)
                            }
                        }
                    };

                    function y(e, t, i) {
                        return (e = f.call(this, e, t, i, "[subtitle-stream-controller]") || this).levels = [], e.currentTrackId = -1, e.tracksBuffered = [], e.mainDetails = null, e._registerListeners(), e
                    }
                }, "./src/controller/subtitle-track-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => c});
                    var s, l = i("./src/events.ts"), r = i("./src/utils/texttrack-utils.ts"),
                        t = i("./src/controller/base-playlist-controller.ts"), a = i("./src/types/loader.ts");

                    function n(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function o(e, t) {
                        return (o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function d(e) {
                        var t;
                        return (t = s.call(this, e, "[subtitle-track-controller]") || this).media = null, t.tracks = [], t.groupId = null, t.tracksInGroup = [], t.trackId = -1, t.selectDefaultTrack = !0, t.queuedDefaultTrack = -1, t.trackChangeListener = function () {
                            return t.onTextTracksChanged()
                        }, t.asyncPollTrackChange = function () {
                            return t.pollTrackChange(0)
                        }, t.useTextTrackPolling = !1, t.subtitlePollingInterval = -1, t._subtitleDisplay = !0, t.registerListeners(), t
                    }

                    function h(e) {
                        for (var t = [], i = 0; i < e.length; i++) {
                            var r = e[i];
                            "subtitles" === r.kind && r.label && t.push(e[i])
                        }
                        return t
                    }

                    s = t.default, i = s, (t = d).prototype = Object.create(i.prototype), o(t.prototype.constructor = t, i), (t = d.prototype).destroy = function () {
                        this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, s.prototype.destroy.call(this)
                    }, t.registerListeners = function () {
                        var e = this.hls;
                        e.on(l.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(l.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(l.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(l.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.on(l.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(l.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(l.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(l.Events.ERROR, this.onError, this)
                    }, t.unregisterListeners = function () {
                        var e = this.hls;
                        e.off(l.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(l.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(l.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(l.Events.MANIFEST_PARSED, this.onManifestParsed, this), e.off(l.Events.LEVEL_LOADING, this.onLevelLoading, this), e.off(l.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(l.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(l.Events.ERROR, this.onError, this)
                    }, t.onMediaAttached = function (e, t) {
                        this.media = t.media, this.media && (-1 < this.queuedDefaultTrack && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
                    }, t.pollTrackChange = function (e) {
                        self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e)
                    }, t.onMediaDetaching = function () {
                        this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), -1 < this.trackId && (this.queuedDefaultTrack = this.trackId), h(this.media.textTracks).forEach(function (e) {
                            (0, r.clearCurrentCues)(e)
                        }), this.subtitleTrack = -1, this.media = null)
                    }, t.onManifestLoading = function () {
                        this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0
                    }, t.onManifestParsed = function (e, t) {
                        this.tracks = t.subtitleTracks
                    }, t.onSubtitleTrackLoaded = function (e, t) {
                        var i, r = t.id, s = t.details, a = this.trackId, a = this.tracksInGroup[a];
                        a ? (i = a.details, a.details = t.details, this.log("subtitle track " + r + " loaded [" + s.startSN + "-" + s.endSN + "]"), r === this.trackId && (this.retryCount = 0, this.playlistLoaded(r, t, i))) : this.warn("Invalid subtitle track id " + r)
                    }, t.onLevelLoading = function (e, t) {
                        this.switchLevel(t.level)
                    }, t.onLevelSwitching = function (e, t) {
                        this.switchLevel(t.level)
                    }, t.switchLevel = function (e) {
                        var t, i, r, s, e = this.hls.levels[e];
                        null != e && e.textGroupIds && (t = e.textGroupIds[e.urlId], this.groupId !== t && (e = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0, i = this.tracks.filter(function (e) {
                            return !t || e.groupId === t
                        }), this.tracksInGroup = i, r = this.findTrackId(null == e ? void 0 : e.name) || this.findTrackId(), this.groupId = t, s = {subtitleTracks: i}, this.log("Updating subtitle tracks, " + i.length + ' track(s) found in "' + t + '" group-id'), this.hls.trigger(l.Events.SUBTITLE_TRACKS_UPDATED, s), -1 !== r && this.setSubtitleTrack(r, e)))
                    }, t.findTrackId = function (e) {
                        for (var t = this.tracksInGroup, i = 0; i < t.length; i++) {
                            var r = t[i];
                            if ((!this.selectDefaultTrack || r.default) && (!e || e === r.name)) return r.id
                        }
                        return -1
                    }, t.onError = function (e, t) {
                        s.prototype.onError.call(this, e, t), !t.fatal && t.context && t.context.type === a.PlaylistContextType.SUBTITLE_TRACK && t.context.id === this.trackId && t.context.groupId === this.groupId && this.retryLoadingOrFail(t)
                    }, t.loadPlaylist = function (e) {
                        s.prototype.loadPlaylist.call(this);
                        var t = this.tracksInGroup[this.trackId];
                        if (this.shouldLoadTrack(t)) {
                            var i = t.id, r = t.groupId, t = t.url;
                            if (e) try {
                                t = e.addDirectives(t)
                            } catch (e) {
                                this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
                            }
                            this.log("Loading subtitle playlist for id " + i), this.hls.trigger(l.Events.SUBTITLE_TRACK_LOADING, {
                                url: t,
                                id: i,
                                groupId: r,
                                deliveryDirectives: e || null
                            })
                        }
                    }, t.toggleTrackModes = function (e) {
                        var t, i = this, r = this.media, s = this.trackId;
                        r && (t = (r = h(r.textTracks)).filter(function (e) {
                            return e.groupId === i.groupId
                        }), -1 === e ? [].slice.call(r).forEach(function (e) {
                            e.mode = "disabled"
                        }) : (r = t[s]) && (r.mode = "disabled"), (s = t[e]) && (s.mode = this.subtitleDisplay ? "showing" : "hidden"))
                    }, t.setSubtitleTrack = function (e, t) {
                        var i, r, s, a, n, o = this.tracksInGroup;
                        this.media ? (this.trackId !== e && this.toggleTrackModes(e), this.trackId === e && (-1 === e || null != (i = o[e]) && i.details) || e < -1 || e >= o.length || (this.clearTimer(), i = o[e], this.log("Switching to subtitle track " + e), this.trackId = e, i ? (o = i.id, r = i.groupId, s = i.name, a = i.type, n = i.url, this.hls.trigger(l.Events.SUBTITLE_TRACK_SWITCH, {
                            id: o,
                            groupId: void 0 === r ? "" : r,
                            name: s,
                            type: a,
                            url: n
                        }), o = this.switchParams(i.url, null == t ? void 0 : t.details), this.loadPlaylist(o)) : this.hls.trigger(l.Events.SUBTITLE_TRACK_SWITCH, {id: e}))) : this.queuedDefaultTrack = e
                    }, t.onTextTracksChanged = function () {
                        if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), this.media && this.hls.config.renderTextTracksNatively) {
                            for (var e = -1, t = h(this.media.textTracks), i = 0; i < t.length; i++) if ("hidden" === t[i].mode) e = i; else if ("showing" === t[i].mode) {
                                e = i;
                                break
                            }
                            this.subtitleTrack !== e && (this.subtitleTrack = e)
                        }
                    }, n((i = d).prototype, [{
                        key: "subtitleDisplay", get: function () {
                            return this._subtitleDisplay
                        }, set: function (e) {
                            this._subtitleDisplay = e, -1 < this.trackId && this.toggleTrackModes(this.trackId)
                        }
                    }, {
                        key: "subtitleTracks", get: function () {
                            return this.tracksInGroup
                        }
                    }, {
                        key: "subtitleTrack", get: function () {
                            return this.trackId
                        }, set: function (e) {
                            this.selectDefaultTrack = !1;
                            var t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                            this.setSubtitleTrack(e, t)
                        }
                    }]), Object.defineProperty(i, "prototype", {writable: !1});
                    const c = d
                }, "./src/controller/timeline-controller.ts": (e, t, i) => {
                    i.r(t), i.d(t, {TimelineController: () => r});
                    var n = i("./src/polyfills/number.ts"), u = i("./src/events.ts"),
                        a = i("./src/utils/cea-608-parser.ts"), o = i("./src/utils/output-filter.ts"),
                        l = i("./src/utils/webvtt-parser.ts"), d = i("./src/utils/texttrack-utils.ts"),
                        h = i("./src/utils/imsc1-ttml-parser.ts"), c = i("./src/utils/mp4-tools.ts"),
                        p = i("./src/types/loader.ts"), f = i("./src/utils/logger.ts"),
                        r = ((t = s.prototype).destroy = function () {
                            var e = this.hls;
                            e.off(u.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(u.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(u.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(u.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(u.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(u.Events.FRAG_LOADING, this.onFragLoading, this), e.off(u.Events.FRAG_LOADED, this.onFragLoaded, this), e.off(u.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(u.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(u.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(u.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(u.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
                        }, t.addCues = function (e, t, i, r, s) {
                            for (var a, n, o, l = !1, d = s.length; d--;) {
                                var h = s[d], c = (a = h[0], c = h[1], n = t, Math.min(c, i) - Math.max(a, n));
                                if (0 <= c && (h[0] = Math.min(h[0], t), h[1] = Math.max(h[1], i), l = !0, .5 < c / (i - t))) return
                            }
                            l || s.push([t, i]), this.config.renderTextTracksNatively ? (o = this.captionsTracks[e], this.Cues.newCue(o, t, i, r)) : (o = this.Cues.newCue(null, t, i, r), this.hls.trigger(u.Events.CUES_PARSED, {
                                type: "captions",
                                cues: o,
                                track: e
                            }))
                        }, t.onInitPtsFound = function (e, t) {
                            var i = this, r = t.frag, s = t.id, a = t.initPTS, t = t.timescale,
                                n = this.unparsedVttFrags;
                            "main" === s && (this.initPTS[r.cc] = a, this.timescale[r.cc] = t), n.length && (this.unparsedVttFrags = [], n.forEach(function (e) {
                                i.onFragLoaded(u.Events.FRAG_LOADED, e)
                            }))
                        }, t.getExistingTrack = function (e) {
                            var t = this.media;
                            if (t) for (var i = 0; i < t.textTracks.length; i++) {
                                var r = t.textTracks[i];
                                if (r[e]) return r
                            }
                            return null
                        }, t.createCaptionsTrack = function (e) {
                            this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
                        }, t.createNativeTrack = function (e) {
                            var t, i, r, s, a;
                            this.captionsTracks[e] || (s = this.captionsProperties, t = this.captionsTracks, i = this.media, r = (s = s[e]).label, s = s.languageCode, (a = this.getExistingTrack(e)) ? (t[e] = a, (0, d.clearCurrentCues)(t[e]), (0, d.sendAddTrackEvent)(t[e], i)) : (a = this.createTextTrack("captions", r, s)) && (a[e] = !0, t[e] = a))
                        }, t.createNonNativeTrack = function (e) {
                            var t;
                            this.nonNativeCaptionsTracks[e] || (t = this.captionsProperties[e]) && (t = {
                                _id: e,
                                label: t.label,
                                kind: "captions",
                                default: !!t.media && !!t.media.default,
                                closedCaptions: t.media
                            }, this.nonNativeCaptionsTracks[e] = t, this.hls.trigger(u.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {tracks: [t]}))
                        }, t.createTextTrack = function (e, t, i) {
                            var r = this.media;
                            if (r) return r.addTextTrack(e, t, i)
                        }, t.onMediaAttaching = function (e, t) {
                            this.media = t.media, this._cleanTracks()
                        }, t.onMediaDetaching = function () {
                            var t = this.captionsTracks;
                            Object.keys(t).forEach(function (e) {
                                (0, d.clearCurrentCues)(t[e]), delete t[e]
                            }), this.nonNativeCaptionsTracks = {}
                        }, t.onManifestLoading = function () {
                            this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                                ccOffset: 0,
                                presentationOffset: 0,
                                0: {start: 0, prevCC: -1, new: !0}
                            }, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.timescale = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
                        }, t._cleanTracks = function () {
                            var e = this.media;
                            if (e) {
                                var t = e.textTracks;
                                if (t) for (var i = 0; i < t.length; i++) (0, d.clearCurrentCues)(t[i])
                            }
                        }, t.onSubtitleTracksUpdated = function (e, t) {
                            var o, l = this, t = (this.textTracks = [], t.subtitleTracks || []),
                                i = t.some(function (e) {
                                    return e.textCodec === h.IMSC1_CODEC
                                });
                            (this.config.enableWebVTT || i && this.config.enableIMSC1) && (i = this.tracks && t && this.tracks.length === t.length, this.tracks = t || [], this.config.renderTextTracksNatively ? (o = this.media ? this.media.textTracks : [], this.tracks.forEach(function (e, t) {
                                var i, r, s;
                                if (t < o.length) {
                                    for (var a = null, n = 0; n < o.length; n++) if (r = o[n], s = e, r && r.label === s.name && !r.textTrack1 && !r.textTrack2) {
                                        a = o[n];
                                        break
                                    }
                                    a && (i = a)
                                }
                                i ? (0, d.clearCurrentCues)(i) : (t = l._captionsOrSubtitlesFromCharacteristics(e), (i = l.createTextTrack(t, e.name, e.lang)) && (i.mode = "disabled")), i && (i.groupId = e.groupId, l.textTracks.push(i))
                            })) : !i && this.tracks && this.tracks.length && (t = this.tracks.map(function (e) {
                                return {label: e.name, kind: e.type.toLowerCase(), default: e.default, subtitleTrack: e}
                            }), this.hls.trigger(u.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {tracks: t})))
                        }, t._captionsOrSubtitlesFromCharacteristics = function (e) {
                            if (null != (t = e.attrs) && t.CHARACTERISTICS) {
                                var t = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS),
                                    e = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS);
                                if (t && e) return "captions"
                            }
                            return "subtitles"
                        }, t.onManifestLoaded = function (e, t) {
                            var i = this;
                            this.config.enableCEA708Captions && t.captions && t.captions.forEach(function (e) {
                                var t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId);
                                t && (t = "textTrack" + t[1], (t = i.captionsProperties[t]) && (t.label = e.name, e.lang && (t.languageCode = e.lang), t.media = e))
                            })
                        }, t.closedCaptionsForLevel = function (e) {
                            e = this.hls.levels[e.level];
                            return null == e ? void 0 : e.attrs["CLOSED-CAPTIONS"]
                        }, t.onFragLoading = function (e, t) {
                            var i, r = this.cea608Parser1, s = this.cea608Parser2, a = this.lastSn,
                                n = this.lastPartIndex;
                            this.enabled && r && s && t.frag.type === p.PlaylistLevelType.MAIN && (i = t.frag.sn, t = null != (t = null == t || null == (t = t.part) ? void 0 : t.index) ? t : -1, i === a + 1 || i === a && t === n + 1 || (r.reset(), s.reset()), this.lastSn = i, this.lastPartIndex = t)
                        }, t.onFragLoaded = function (e, t) {
                            var i = t.frag, r = t.payload, s = this.initPTS, a = this.unparsedVttFrags;
                            if (i.type === p.PlaylistLevelType.SUBTITLE) if (r.byteLength) {
                                if (!(0, n.isFiniteNumber)(s[i.cc])) return a.push(t), void (s.length && this.hls.trigger(u.Events.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: i,
                                    error: new Error("Missing initial subtitle PTS")
                                }));
                                var a = i.decryptdata, s = "stats" in t;
                                null != a && a.encrypted && !s || (t = this.tracks[i.level], (a = this.vttCCs)[i.cc] || (a[i.cc] = {
                                    start: i.start,
                                    prevCC: this.prevCC,
                                    new: !0
                                }, this.prevCC = i.cc), t && t.textCodec === h.IMSC1_CODEC ? this._parseIMSC1(i, r) : this._parseVTTs(i, r, a))
                            } else this.hls.trigger(u.Events.SUBTITLE_FRAG_PROCESSED, {
                                success: !1,
                                frag: i,
                                error: new Error("Empty subtitle payload")
                            })
                        }, t._parseIMSC1 = function (t, e) {
                            var i = this, r = this.hls;
                            (0, h.parseIMSC1)(e, this.initPTS[t.cc], this.timescale[t.cc], function (e) {
                                i._appendCues(e, t.level), r.trigger(u.Events.SUBTITLE_FRAG_PROCESSED, {
                                    success: !0,
                                    frag: t
                                })
                            }, function (e) {
                                f.logger.log("Failed to parse IMSC1: " + e), r.trigger(u.Events.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: t,
                                    error: e
                                })
                            })
                        }, t._parseVTTs = function (t, i, e) {
                            var r = this, s = this.hls,
                                a = null != (a = t.initSegment) && a.data ? (0, c.appendUint8Array)(t.initSegment.data, new Uint8Array(i)) : i;
                            (0, l.parseWebVTT)(a, this.initPTS[t.cc], this.timescale[t.cc], e, t.cc, t.start, function (e) {
                                r._appendCues(e, t.level), s.trigger(u.Events.SUBTITLE_FRAG_PROCESSED, {
                                    success: !0,
                                    frag: t
                                })
                            }, function (e) {
                                r._fallbackToIMSC1(t, i), f.logger.log("Failed to parse VTT cue: " + e), s.trigger(u.Events.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: t,
                                    error: e
                                })
                            })
                        }, t._fallbackToIMSC1 = function (e, t) {
                            var i = this, r = this.tracks[e.level];
                            r.textCodec || (0, h.parseIMSC1)(t, this.initPTS[e.cc], this.timescale[e.cc], function () {
                                r.textCodec = h.IMSC1_CODEC, i._parseIMSC1(e, t)
                            }, function () {
                                r.textCodec = "wvtt"
                            })
                        }, t._appendCues = function (e, t) {
                            var i, r, s = this.hls;
                            this.config.renderTextTracksNatively ? (i = this.textTracks[t]) && "disabled" !== i.mode && e.forEach(function (e) {
                                return (0, d.addCueToTrack)(i, e)
                            }) : (r = this.tracks[t]) && (r = r.default ? "default" : "subtitles" + t, s.trigger(u.Events.CUES_PARSED, {
                                type: "subtitles",
                                cues: e,
                                track: r
                            }))
                        }, t.onFragDecrypted = function (e, t) {
                            var i = t.frag;
                            i.type === p.PlaylistLevelType.SUBTITLE && ((0, n.isFiniteNumber)(this.initPTS[i.cc]) ? this.onFragLoaded(u.Events.FRAG_LOADED, t) : this.unparsedVttFrags.push(t))
                        }, t.onSubtitleTracksCleared = function () {
                            this.tracks = [], this.captionsTracks = {}
                        }, t.onFragParsingUserdata = function (e, t) {
                            var i = this.cea608Parser1, r = this.cea608Parser2;
                            if (this.enabled && i && r) {
                                var s = t.frag, a = t.samples;
                                if (s.type !== p.PlaylistLevelType.MAIN || "NONE" !== this.closedCaptionsForLevel(s)) for (var n = 0; n < a.length; n++) {
                                    var o = a[n].bytes;
                                    o && (o = this.extractCea608Data(o), i.addData(a[n].pts, o[0]), r.addData(a[n].pts, o[1]))
                                }
                            }
                        }, t.onBufferFlushing = function (e, t) {
                            var i, r, s = t.startOffset, a = t.endOffset, n = t.endOffsetSubtitles, t = t.type,
                                o = this.media;
                            !o || o.currentTime < a || (t && "video" !== t || (i = this.captionsTracks, Object.keys(i).forEach(function (e) {
                                return (0, d.removeCuesInRange)(i[e], s, a)
                            })), this.config.renderTextTracksNatively && 0 === s && void 0 !== n && (r = this.textTracks, Object.keys(r).forEach(function (e) {
                                return (0, d.removeCuesInRange)(r[e], s, n)
                            })))
                        }, t.extractCea608Data = function (e) {
                            for (var t = [[], []], i = 31 & e[0], r = 2, s = 0; s < i; s++) {
                                var a = e[r++], n = 127 & e[r++], o = 127 & e[r++];
                                0 == n && 0 == o || 0 == (4 & a) || (0 != (a = 3 & a) && 1 != a || (t[a].push(n), t[a].push(o)))
                            }
                            return t
                        }, s);

                    function s(e) {
                        var t, i, r, s;
                        this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.timescale = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                            ccOffset: 0,
                            presentationOffset: 0,
                            0: {start: 0, prevCC: -1, new: !0}
                        }, this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
                            textTrack1: {
                                label: this.config.captionsTextTrack1Label,
                                languageCode: this.config.captionsTextTrack1LanguageCode
                            },
                            textTrack2: {
                                label: this.config.captionsTextTrack2Label,
                                languageCode: this.config.captionsTextTrack2LanguageCode
                            },
                            textTrack3: {
                                label: this.config.captionsTextTrack3Label,
                                languageCode: this.config.captionsTextTrack3LanguageCode
                            },
                            textTrack4: {
                                label: this.config.captionsTextTrack4Label,
                                languageCode: this.config.captionsTextTrack4LanguageCode
                            }
                        }, this.config.enableCEA708Captions && (t = new o.default(this, "textTrack1"), i = new o.default(this, "textTrack2"), r = new o.default(this, "textTrack3"), s = new o.default(this, "textTrack4"), this.cea608Parser1 = new a.default(1, t, i), this.cea608Parser2 = new a.default(3, r, s)), e.on(u.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(u.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(u.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(u.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(u.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(u.Events.FRAG_LOADING, this.onFragLoading, this), e.on(u.Events.FRAG_LOADED, this.onFragLoaded, this), e.on(u.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(u.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(u.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(u.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(u.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
                    }
                }, "./src/crypt/aes-crypto.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    s.prototype.decrypt = function (e, t) {
                        return this.subtle.decrypt({name: "AES-CBC", iv: this.aesIV}, t, e)
                    };
                    var r = s;

                    function s(e, t) {
                        this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t
                    }
                }, "./src/crypt/aes-decryptor.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        default: () => s, removePadding: () => function (e) {
                            var t = e.byteLength, i = t && new DataView(e.buffer).getUint8(t - 1);
                            return i ? (0, r.sliceUint8)(e, 0, t - i) : e
                        }
                    });
                    var r = i("./src/utils/typed-array.ts");
                    (t = a.prototype).uint8ArrayToUint32Array_ = function (e) {
                        for (var t = new DataView(e), i = new Uint32Array(4), r = 0; r < 4; r++) i[r] = t.getUint32(4 * r);
                        return i
                    }, t.initTable = function () {
                        for (var e = this.sBox, t = this.invSBox, i = this.subMix, r = i[0], s = i[1], a = i[2], n = i[3], i = this.invSubMix, o = i[0], l = i[1], d = i[2], h = i[3], c = new Uint32Array(256), u = 0, p = 0, f = 0, f = 0; f < 256; f++) c[f] = f < 128 ? f << 1 : f << 1 ^ 283;
                        for (f = 0; f < 256; f++) {
                            var m = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4,
                                g = (e[u] = m = m >>> 8 ^ 255 & m ^ 99, c[t[m] = u]), y = c[g], A = c[y],
                                b = 257 * c[m] ^ 16843008 * m;
                            r[u] = b << 24 | b >>> 8, s[u] = b << 16 | b >>> 16, a[u] = b << 8 | b >>> 24, n[u] = b, o[m] = (b = 16843009 * A ^ 65537 * y ^ 257 * g ^ 16843008 * u) << 24 | b >>> 8, l[m] = b << 16 | b >>> 16, d[m] = b << 8 | b >>> 24, h[m] = b, u ? (u = g ^ c[c[c[A ^ g]]], p ^= c[c[p]]) : u = p = 1
                        }
                    }, t.expandKey = function (e) {
                        for (var t = this.uint8ArrayToUint32Array_(e), i = !0, r = 0; r < t.length && i;) i = t[r] === this.key[r], r++;
                        if (!i) {
                            this.key = t;
                            var s = this.keySize = t.length;
                            if (4 !== s && 6 !== s && 8 !== s) throw new Error("Invalid aes key size=" + s);
                            for (var a, n, o, l = this.ksRows = 4 * (s + 6 + 1), d = this.keySchedule = new Uint32Array(l), h = this.invKeySchedule = new Uint32Array(l), c = this.sBox, u = this.rcon, e = this.invSubMix, p = e[0], f = e[1], m = e[2], g = e[3], y = 0; y < l; y++) y < s ? n = d[y] = t[y] : (o = n, y % s == 0 ? (o = c[(o = o << 8 | o >>> 24) >>> 24] << 24 | c[o >>> 16 & 255] << 16 | c[o >>> 8 & 255] << 8 | c[255 & o], o ^= u[y / s | 0] << 24) : 6 < s && y % s == 4 && (o = c[o >>> 24] << 24 | c[o >>> 16 & 255] << 16 | c[o >>> 8 & 255] << 8 | c[255 & o]), d[y] = n = (d[y - s] ^ o) >>> 0);
                            for (a = 0; a < l; a++) y = l - a, o = 3 & a ? d[y] : d[y - 4], h[a] = a < 4 || y <= 4 ? o : p[c[o >>> 24]] ^ f[c[o >>> 16 & 255]] ^ m[c[o >>> 8 & 255]] ^ g[c[255 & o]], h[a] = h[a] >>> 0
                        }
                    }, t.networkToHostOrderSwap = function (e) {
                        return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
                    }, t.decrypt = function (e, t, i) {
                        for (var r, s, a, n, o, l, d, h, c, u, p, f, m, g, y = this.keySize + 6, A = this.invKeySchedule, b = this.invSBox, v = this.invSubMix, _ = v[0], w = v[1], S = v[2], E = v[3], v = this.uint8ArrayToUint32Array_(i), T = v[0], k = v[1], x = v[2], C = v[3], L = new Int32Array(e), D = new Int32Array(L.length), I = this.networkToHostOrderSwap; t < L.length;) {
                            for (c = I(L[t]), u = I(L[t + 1]), p = I(L[t + 2]), f = I(L[t + 3]), o = c ^ A[0], l = f ^ A[1], d = p ^ A[2], h = u ^ A[3], m = 4, g = 1; g < y; g++) r = _[o >>> 24] ^ w[l >> 16 & 255] ^ S[d >> 8 & 255] ^ E[255 & h] ^ A[m], s = _[l >>> 24] ^ w[d >> 16 & 255] ^ S[h >> 8 & 255] ^ E[255 & o] ^ A[m + 1], a = _[d >>> 24] ^ w[h >> 16 & 255] ^ S[o >> 8 & 255] ^ E[255 & l] ^ A[m + 2], n = _[h >>> 24] ^ w[o >> 16 & 255] ^ S[l >> 8 & 255] ^ E[255 & d] ^ A[m + 3], o = r, l = s, d = a, h = n, m += 4;
                            r = b[o >>> 24] << 24 ^ b[l >> 16 & 255] << 16 ^ b[d >> 8 & 255] << 8 ^ b[255 & h] ^ A[m], s = b[l >>> 24] << 24 ^ b[d >> 16 & 255] << 16 ^ b[h >> 8 & 255] << 8 ^ b[255 & o] ^ A[m + 1], a = b[d >>> 24] << 24 ^ b[h >> 16 & 255] << 16 ^ b[o >> 8 & 255] << 8 ^ b[255 & l] ^ A[m + 2], n = b[h >>> 24] << 24 ^ b[o >> 16 & 255] << 16 ^ b[l >> 8 & 255] << 8 ^ b[255 & d] ^ A[m + 3], D[t] = I(r ^ T), D[t + 1] = I(n ^ k), D[t + 2] = I(a ^ x), D[t + 3] = I(s ^ C), T = c, k = u, x = p, C = f, t += 4
                        }
                        return D.buffer
                    };
                    var s = a;

                    function a() {
                        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
                    }
                }, "./src/crypt/decrypter.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var n = i("./src/crypt/aes-crypto.ts"), o = i("./src/crypt/fast-aes-key.ts"),
                        l = i("./src/crypt/aes-decryptor.ts"), d = i("./src/utils/logger.ts"),
                        h = i("./src/utils/mp4-tools.ts"), c = i("./src/utils/typed-array.ts"),
                        r = ((t = s.prototype).destroy = function () {
                            this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
                        }, t.isSync = function () {
                            return this.useSoftware
                        }, t.flush = function () {
                            var e = this.currentResult, t = this.remainderData;
                            if (!e || t) return d.logger.error("[softwareDecrypt] " + (t ? "overflow bytes: " + t.byteLength : "no result")), this.reset(), null;
                            t = new Uint8Array(e);
                            return this.reset(), this.removePKCS7Padding ? (0, l.removePadding)(t) : t
                        }, t.reset = function () {
                            this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
                        }, t.decrypt = function (r, s, a) {
                            var n = this;
                            return this.useSoftware ? new Promise(function (e, t) {
                                n.softwareDecrypt(new Uint8Array(r), s, a);
                                var i = n.flush();
                                i ? e(i.buffer) : t(new Error("[softwareDecrypt] Failed to decrypt data"))
                            }) : this.webCryptoDecrypt(new Uint8Array(r), s, a)
                        }, t.softwareDecrypt = function (e, t, i) {
                            var r = this.currentIV, s = this.currentResult, a = this.remainderData,
                                a = (this.logOnce("JS AES decrypt"), a && (e = (0, h.appendUint8Array)(a, e), this.remainderData = null), this.getValidChunk(e));
                            if (!a.length) return null;
                            r && (i = r);
                            e = this.softwareDecrypter, (e = e || (this.softwareDecrypter = new l.default)).expandKey(t), r = s;
                            return this.currentResult = e.decrypt(a.buffer, 0, i), this.currentIV = (0, c.sliceUint8)(a, -16).buffer, r || null
                        }, t.webCryptoDecrypt = function (t, i, r) {
                            var s = this, a = this.subtle;
                            return this.key === i && this.fastAesKey || (this.key = i, this.fastAesKey = new o.default(a, i)), this.fastAesKey.expandKey().then(function (e) {
                                return a ? (s.logOnce("WebCrypto AES decrypt"), new n.default(a, new Uint8Array(r)).decrypt(t.buffer, e)) : Promise.reject(new Error("web crypto not initialized"))
                            }).catch(function (e) {
                                return d.logger.warn("[decrypter]: WebCrypto Error, disable WebCrypto API, " + e.name + ": " + e.message), s.onWebCryptoError(t, i, r)
                            })
                        }, t.onWebCryptoError = function (e, t, i) {
                            this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, i);
                            e = this.flush();
                            if (e) return e.buffer;
                            throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
                        }, t.getValidChunk = function (e) {
                            var t = e, i = e.length - e.length % 16;
                            return i !== e.length && (t = (0, c.sliceUint8)(e, 0, i), this.remainderData = (0, c.sliceUint8)(e, i)), t
                        }, t.logOnce = function (e) {
                            this.logEnabled && (d.logger.log("[decrypter]: " + e), this.logEnabled = !1)
                        }, s);

                    function s(e, t) {
                        t = (void 0 === t ? {} : t).removePKCS7Padding, t = void 0 === t || t;
                        if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t) try {
                            var i = self.crypto;
                            i && (this.subtle = i.subtle || i.webkitSubtle)
                        } catch (e) {
                        }
                        null === this.subtle && (this.useSoftware = !0)
                    }
                }, "./src/crypt/fast-aes-key.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    s.prototype.expandKey = function () {
                        return this.subtle.importKey("raw", this.key, {name: "AES-CBC"}, !1, ["encrypt", "decrypt"])
                    };
                    var r = s;

                    function s(e, t) {
                        this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t
                    }
                }, "./src/demux/aacdemuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => d});
                    var s, t = i("./src/demux/base-audio-demuxer.ts"), r = i("./src/demux/adts.ts"),
                        a = i("./src/utils/logger.ts"), n = i("./src/demux/id3.ts");

                    function o(e, t) {
                        return (o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function l(e, t) {
                        var i;
                        return (i = s.call(this) || this).observer = void 0, i.config = void 0, i.observer = e, i.config = t, i
                    }

                    s = t.default, i = s, (t = l).prototype = Object.create(i.prototype), o(t.prototype.constructor = t, i), (t = l.prototype).resetInitSegment = function (e, t, i, r) {
                        s.prototype.resetInitSegment.call(this, e, t, i, r), this._audioTrack = {
                            container: "audio/adts",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "aac",
                            samples: [],
                            manifestCodec: t,
                            duration: r,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }, l.probe = function (e) {
                        if (!e) return !1;
                        for (var t = (n.getID3Data(e, 0) || []).length, i = e.length; t < i; t++) if (r.probe(e, t)) return a.logger.log("ADTS sync word found !"), !0;
                        return !1
                    }, t.canParse = function (e, t) {
                        return r.canParse(e, t)
                    }, t.appendFrame = function (e, t, i) {
                        r.initTrackConfig(e, this.observer, t, i, e.manifestCodec);
                        e = r.appendFrame(e, t, i, this.basePTS, this.frameIndex);
                        if (e && 0 === e.missing) return e
                    };
                    const d = l
                }, "./src/demux/adts.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        appendFrame: () => function (e, t, i, r, s) {
                            var a, r = r + s * d(e.samplerate), s = h(t, i);
                            {
                                var n, o;
                                if (s) return n = s.frameLength, s = s.headerLength, n = s + n, (o = Math.max(0, i + n - t.length)) ? (a = new Uint8Array(n - s)).set(t.subarray(i + s, t.length), 0) : a = t.subarray(i + s, i + n), s = {
                                    unit: a,
                                    pts: r
                                }, o || e.samples.push(s), {sample: s, length: n, missing: o}
                            }
                            e = t.length - i;
                            return (a = new Uint8Array(e)).set(t.subarray(i, t.length), 0), {
                                sample: {unit: a, pts: r},
                                length: e,
                                missing: -1
                            }
                        },
                        canGetFrameLength: () => o,
                        canParse: () => function (e, t) {
                            return o(e, t) && r(e, t) && n(e, t) <= e.length - t
                        },
                        getAudioConfig: () => a,
                        getFrameDuration: () => d,
                        getFullFrameLength: () => n,
                        getHeaderLength: () => s,
                        initTrackConfig: () => function (e, t, i, r, s) {
                            e.samplerate || (t = a(t, i, r, s)) && (e.config = t.config, e.samplerate = t.samplerate, e.channelCount = t.channelCount, e.codec = t.codec, e.manifestCodec = t.manifestCodec, c.logger.log("parsed codec:" + e.codec + ", rate:" + t.samplerate + ", channels:" + t.channelCount))
                        },
                        isHeader: () => l,
                        isHeaderPattern: () => r,
                        parseFrameHeader: () => h,
                        probe: () => function (e, t) {
                            if (l(e, t)) {
                                var i = s(e, t);
                                if (t + i >= e.length) return !1;
                                var r = n(e, t);
                                if (r <= i) return !1;
                                i = t + r;
                                return i === e.length || l(e, i)
                            }
                            return !1
                        }
                    });
                    var c = i("./src/utils/logger.ts"), u = i("./src/errors.ts"), p = i("./src/events.ts");

                    function a(e, t, i, r) {
                        var s, a, n = navigator.userAgent.toLowerCase(), o = r,
                            l = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350],
                            d = 1 + ((192 & t[i + 2]) >>> 6), h = (60 & t[i + 2]) >>> 2;
                        if (!(l.length - 1 < h)) return s = (1 & t[i + 2]) << 2, s |= (192 & t[i + 3]) >>> 6, c.logger.log("manifest codec:" + r + ", ADTS type:" + d + ", samplingIndex:" + h), t = /firefox/i.test(n) ? 6 <= h ? (d = 5, a = new Array(4), h - 3) : (d = 2, a = new Array(2), h) : -1 !== n.indexOf("android") ? (d = 2, a = new Array(2), h) : (d = 5, a = new Array(4), r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && 6 <= h ? h - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") && (6 <= h && 1 == s || /vivaldi/i.test(n)) || !r && 1 == s) && (d = 2, a = new Array(2)), h)), a[0] = d << 3, a[0] |= (14 & h) >> 1, a[1] |= (1 & h) << 7, a[1] |= s << 3, 5 === d && (a[1] |= (14 & t) >> 1, a[2] = (1 & t) << 7, a[2] |= 8, a[3] = 0), {
                            config: a,
                            samplerate: l[h],
                            channelCount: s,
                            codec: "mp4a.40." + d,
                            manifestCodec: o
                        };
                        e.trigger(p.Events.ERROR, {
                            type: u.ErrorTypes.MEDIA_ERROR,
                            details: u.ErrorDetails.FRAG_PARSING_ERROR,
                            fatal: !0,
                            reason: "invalid ADTS sampling index:" + h
                        })
                    }

                    function r(e, t) {
                        return 255 === e[t] && 240 == (246 & e[t + 1])
                    }

                    function s(e, t) {
                        return 1 & e[t + 1] ? 7 : 9
                    }

                    function n(e, t) {
                        return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
                    }

                    function o(e, t) {
                        return t + 5 < e.length
                    }

                    function l(e, t) {
                        return t + 1 < e.length && r(e, t)
                    }

                    function d(e) {
                        return 9216e4 / e
                    }

                    function h(e, t) {
                        var i = s(e, t);
                        if (t + i <= e.length) {
                            e = n(e, t) - i;
                            if (0 < e) return {headerLength: i, frameLength: e}
                        }
                    }
                }, "./src/demux/base-audio-demuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => s, initPTSFn: () => g});
                    var h = i("./src/polyfills/number.ts"), c = i("./src/demux/id3.ts"),
                        u = i("./src/types/demuxer.ts"), p = i("./src/demux/dummy-demuxed-track.ts"),
                        f = i("./src/utils/mp4-tools.ts"), m = i("./src/utils/typed-array.ts");
                    (t = r.prototype).resetInitSegment = function (e, t, i, r) {
                        this._id3Track = {
                            type: "id3",
                            id: 3,
                            pid: -1,
                            inputTimeScale: 9e4,
                            sequenceNumber: 0,
                            samples: [],
                            dropped: 0
                        }
                    }, t.resetTimeStamp = function (e) {
                        this.initPTS = e, this.resetContiguity()
                    }, t.resetContiguity = function () {
                        this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
                    }, t.canParse = function (e, t) {
                        return !1
                    }, t.appendFrame = function (e, t, i) {
                    }, t.demux = function (e, t) {
                        this.cachedData && (e = (0, f.appendUint8Array)(this.cachedData, e), this.cachedData = null);
                        var i, r, s = c.getID3Data(e, 0), a = s ? s.length : 0, n = this._audioTrack,
                            o = this._id3Track, l = s ? c.getTimeStamp(s) : void 0, d = e.length;
                        for ((null === this.basePTS || 0 === this.frameIndex && (0, h.isFiniteNumber)(l)) && (this.basePTS = g(l, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), s && 0 < s.length && o.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: s,
                            type: u.MetadataSchema.audioId3,
                            duration: Number.POSITIVE_INFINITY
                        }); a < d;) this.canParse(e, a) ? (r = this.appendFrame(n, e, a)) ? (this.frameIndex++, this.lastPTS = r.sample.pts, i = a += r.length) : a = d : c.canParse(e, a) ? (s = c.getID3Data(e, a), o.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: s,
                            type: u.MetadataSchema.audioId3,
                            duration: Number.POSITIVE_INFINITY
                        }), i = a += s.length) : a++, a === d && i !== d && (r = (0, m.sliceUint8)(e, i), this.cachedData ? this.cachedData = (0, f.appendUint8Array)(this.cachedData, r) : this.cachedData = r);
                        return {
                            audioTrack: n,
                            videoTrack: (0, p.dummyTrack)(),
                            id3Track: o,
                            textTrack: (0, p.dummyTrack)()
                        }
                    }, t.demuxSampleAes = function (e, t, i) {
                        return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"))
                    }, t.flush = function (e) {
                        var t = this.cachedData;
                        return t && (this.cachedData = null, this.demux(t, 0)), {
                            audioTrack: this._audioTrack,
                            videoTrack: (0, p.dummyTrack)(),
                            id3Track: this._id3Track,
                            textTrack: (0, p.dummyTrack)()
                        }
                    }, t.destroy = function () {
                    };
                    var g = function (e, t, i) {
                        return (0, h.isFiniteNumber)(e) ? 90 * e : 9e4 * t + (i || 0)
                    };

                    function r() {
                        this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
                    }

                    const s = r
                }, "./src/demux/chunk-cache.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    (i = s.prototype).push = function (e) {
                        this.chunks.push(e), this.dataLength += e.length
                    }, i.flush = function () {
                        var e = this.chunks, a = this.dataLength;
                        return e.length ? (e = 1 === e.length ? e[0] : function (e) {
                            for (var t = new Uint8Array(a), i = 0, r = 0; r < e.length; r++) {
                                var s = e[r];
                                t.set(s, i), i += s.length
                            }
                            return t
                        }(e), this.reset(), e) : new Uint8Array(0)
                    }, i.reset = function () {
                        this.chunks.length = 0, this.dataLength = 0
                    };
                    var r = s;

                    function s() {
                        this.chunks = [], this.dataLength = 0
                    }
                }, "./src/demux/dummy-demuxed-track.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        dummyTrack: () => function (e, t) {
                            return {
                                type: e = void 0 === e ? "" : e,
                                id: -1,
                                pid: -1,
                                inputTimeScale: t = void 0 === t ? 9e4 : t,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            }
                        }
                    })
                }, "./src/demux/exp-golomb.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => s});
                    var r = i("./src/utils/logger.ts");
                    (t = a.prototype).loadWord = function () {
                        var e = this.data, t = this.bytesAvailable, i = e.byteLength - t, r = new Uint8Array(4),
                            t = Math.min(4, t);
                        if (0 === t) throw new Error("no bytes available");
                        r.set(e.subarray(i, i + t)), this.word = new DataView(r.buffer).getUint32(0), this.bitsAvailable = 8 * t, this.bytesAvailable -= t
                    }, t.skipBits = function (e) {
                        var t;
                        e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e || (e = (e -= this.bitsAvailable) - ((t = e >> 3) << 3), this.bytesAvailable -= t, this.loadWord()), this.word <<= e, this.bitsAvailable -= e
                    }, t.readBits = function (e) {
                        var t = Math.min(this.bitsAvailable, e), i = this.word >>> 32 - t;
                        if (32 < e && r.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, 0 < this.bitsAvailable) this.word <<= t; else {
                            if (!(0 < this.bytesAvailable)) throw new Error("no bits available");
                            this.loadWord()
                        }
                        return 0 < (t = e - t) && this.bitsAvailable ? i << t | this.readBits(t) : i
                    }, t.skipLZ = function () {
                        for (var e = 0; e < this.bitsAvailable; ++e) if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;
                        return this.loadWord(), e + this.skipLZ()
                    }, t.skipUEG = function () {
                        this.skipBits(1 + this.skipLZ())
                    }, t.skipEG = function () {
                        this.skipBits(1 + this.skipLZ())
                    }, t.readUEG = function () {
                        var e = this.skipLZ();
                        return this.readBits(e + 1) - 1
                    }, t.readEG = function () {
                        var e = this.readUEG();
                        return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
                    }, t.readBoolean = function () {
                        return 1 === this.readBits(1)
                    }, t.readUByte = function () {
                        return this.readBits(8)
                    }, t.readUShort = function () {
                        return this.readBits(16)
                    }, t.readUInt = function () {
                        return this.readBits(32)
                    }, t.skipScalingList = function (e) {
                        for (var t = 8, i = 8, r = 0; r < e; r++) t = 0 === (i = 0 !== i ? (t + this.readEG() + 256) % 256 : i) ? t : i
                    }, t.readSPS = function () {
                        var e, t, i, r = 0, s = 0, a = 0, n = 0, o = this.readUByte.bind(this),
                            l = this.readBits.bind(this), d = this.readUEG.bind(this), h = this.readBoolean.bind(this),
                            c = this.skipBits.bind(this), u = this.skipEG.bind(this), p = this.skipUEG.bind(this),
                            f = this.skipScalingList.bind(this), m = (o(), o());
                        if (l(5), c(3), o(), p(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) {
                            m = d();
                            if (3 === m && c(1), p(), p(), c(1), h()) for (t = 3 !== m ? 8 : 12, i = 0; i < t; i++) h() && f(i < 6 ? 16 : 64)
                        }
                        p();
                        m = d();
                        if (0 === m) d(); else if (1 === m) for (c(1), u(), u(), e = d(), i = 0; i < e; i++) u();
                        p(), c(1);
                        var m = d(), p = d(), l = l(1),
                            g = (0 === l && c(1), c(1), h() && (r = d(), s = d(), a = d(), n = d()), [1, 1]);
                        if (h() && h()) switch (o()) {
                            case 1:
                                g = [1, 1];
                                break;
                            case 2:
                                g = [12, 11];
                                break;
                            case 3:
                                g = [10, 11];
                                break;
                            case 4:
                                g = [16, 11];
                                break;
                            case 5:
                                g = [40, 33];
                                break;
                            case 6:
                                g = [24, 11];
                                break;
                            case 7:
                                g = [20, 11];
                                break;
                            case 8:
                                g = [32, 11];
                                break;
                            case 9:
                                g = [80, 33];
                                break;
                            case 10:
                                g = [18, 11];
                                break;
                            case 11:
                                g = [15, 11];
                                break;
                            case 12:
                                g = [64, 33];
                                break;
                            case 13:
                                g = [160, 99];
                                break;
                            case 14:
                                g = [4, 3];
                                break;
                            case 15:
                                g = [3, 2];
                                break;
                            case 16:
                                g = [2, 1];
                                break;
                            case 255:
                                g = [o() << 8 | o(), o() << 8 | o()]
                        }
                        return {
                            width: Math.ceil(16 * (m + 1) - 2 * r - 2 * s),
                            height: (2 - l) * (p + 1) * 16 - (l ? 2 : 4) * (a + n),
                            pixelRatio: g
                        }
                    }, t.readSliceType = function () {
                        return this.readUByte(), this.readUEG(), this.readUEG()
                    };
                    const s = a;

                    function a(e) {
                        this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
                    }
                }, "./src/demux/id3.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        canParse: () => s,
                        decodeFrame: () => p,
                        getID3Data: () => r,
                        getID3Frames: () => u,
                        getTimeStamp: () => a,
                        isFooter: () => l,
                        isHeader: () => o,
                        isTimeStampFrame: () => n,
                        testables: () => b,
                        utf8ArrayToStr: () => A
                    });
                    var h, o = function (e, t) {
                        return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
                    }, l = function (e, t) {
                        return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
                    }, r = function (e, t) {
                        for (var i = t, r = 0; o(e, t);) r = (r += 10) + d(e, t + 6), l(e, t + 10) && (r += 10), t += r;
                        if (0 < r) return e.subarray(i, i + r)
                    }, d = function (e, t) {
                        var i = 0, i = (127 & e[t]) << 21;
                        return (i = (i |= (127 & e[t + 1]) << 14) | (127 & e[t + 2]) << 7) | 127 & e[t + 3]
                    }, s = function (e, t) {
                        return o(e, t) && d(e, t + 6) + 10 <= e.length - t
                    }, a = function (e) {
                        for (var t = u(e), i = 0; i < t.length; i++) {
                            var r = t[i];
                            if (n(r)) return y(r)
                        }
                    }, n = function (e) {
                        return e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info
                    }, c = function (e) {
                        var t = String.fromCharCode(e[0], e[1], e[2], e[3]), i = d(e, 4);
                        return {type: t, size: i, data: e.subarray(10, 10 + i)}
                    }, u = function (e) {
                        for (var t = 0, i = []; o(e, t);) {
                            for (var r = d(e, t + 6), s = (t += 10) + r; t + 8 < s;) {
                                var a = c(e.subarray(t)), n = p(a);
                                n && i.push(n), t += a.size + 10
                            }
                            l(e, t) && (t += 10)
                        }
                        return i
                    }, p = function (e) {
                        return ("PRIV" === e.type ? f : "W" === e.type[0] ? g : m)(e)
                    }, f = function (e) {
                        var t, i;
                        if (!(e.size < 2)) return t = A(e.data, !0), i = new Uint8Array(e.data.subarray(t.length + 1)), {
                            key: e.type,
                            info: t,
                            data: i.buffer
                        }
                    }, m = function (e) {
                        if (!(e.size < 2)) {
                            var t;
                            if ("TXXX" === e.type) return t = 1, t += (i = A(e.data.subarray(1), !0)).length + 1, t = A(e.data.subarray(t)), {
                                key: e.type,
                                info: i,
                                data: t
                            };
                            var i = A(e.data.subarray(1));
                            return {key: e.type, data: i}
                        }
                    }, g = function (e) {
                        if ("WXXX" === e.type) {
                            if (e.size < 2) return;
                            var t = 1, i = A(e.data.subarray(1), !0), t = (t += i.length + 1, A(e.data.subarray(t)));
                            return {key: e.type, info: i, data: t}
                        }
                        i = A(e.data);
                        return {key: e.type, data: i}
                    }, y = function (e) {
                        var t;
                        if (8 === e.data.byteLength) return t = 1 & (e = new Uint8Array(e.data))[3], e = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7], e /= 45, t && (e += 47721858.84), Math.round(e)
                    }, A = function (e, t) {
                        void 0 === t && (t = !1);
                        var i, r;
                        h = h || void 0 === self.TextDecoder ? h : new self.TextDecoder("utf-8");
                        if (h) return i = h.decode(e), t ? -1 !== (r = i.indexOf("\0")) ? i.substring(0, r) : i : i.replace(/\0/g, "");
                        for (var s, a, n, o = e.length, l = "", d = 0; d < o;) {
                            if (0 === (s = e[d++]) && t) return l;
                            if (0 !== s && 3 !== s) switch (s >> 4) {
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                    l += String.fromCharCode(s);
                                    break;
                                case 12:
                                case 13:
                                    a = e[d++], l += String.fromCharCode((31 & s) << 6 | 63 & a);
                                    break;
                                case 14:
                                    a = e[d++], n = e[d++], l += String.fromCharCode((15 & s) << 12 | (63 & a) << 6 | (63 & n) << 0)
                            }
                        }
                        return l
                    }, b = {decodeTextFrame: m}
                }, "./src/demux/mp3demuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => d});
                    var s, t = i("./src/demux/base-audio-demuxer.ts"), r = i("./src/demux/id3.ts"),
                        a = i("./src/utils/logger.ts"), n = i("./src/demux/mpegaudio.ts");

                    function o(e, t) {
                        return (o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function l() {
                        return s.apply(this, arguments) || this
                    }

                    s = t.default, i = s, (t = l).prototype = Object.create(i.prototype), o(t.prototype.constructor = t, i), (t = l.prototype).resetInitSegment = function (e, t, i, r) {
                        s.prototype.resetInitSegment.call(this, e, t, i, r), this._audioTrack = {
                            container: "audio/mpeg",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "mp3",
                            samples: [],
                            manifestCodec: t,
                            duration: r,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }, l.probe = function (e) {
                        if (!e) return !1;
                        for (var t = (r.getID3Data(e, 0) || []).length, i = e.length; t < i; t++) if (n.probe(e, t)) return a.logger.log("MPEG Audio sync word found !"), !0;
                        return !1
                    }, t.canParse = function (e, t) {
                        return n.canParse(e, t)
                    }, t.appendFrame = function (e, t, i) {
                        if (null !== this.basePTS) return n.appendFrame(e, t, i, this.basePTS, this.frameIndex)
                    };
                    const d = l
                }, "./src/demux/mp4demuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var a = i("./src/polyfills/number.ts"), n = i("./src/types/demuxer.ts"),
                        h = i("./src/utils/mp4-tools.ts"), c = i("./src/demux/dummy-demuxed-track.ts"),
                        o = /\/emsg[-/]ID3/i;
                    (t = s.prototype).resetTimeStamp = function () {
                    }, t.resetInitSegment = function (e, t, i, r) {
                        var s, a, n, o = this.videoTrack = (0, c.dummyTrack)("video", 1),
                            l = this.audioTrack = (0, c.dummyTrack)("audio", 1),
                            d = this.txtTrack = (0, c.dummyTrack)("text", 1);
                        this.id3Track = (0, c.dummyTrack)("id3", 1), this.timeOffset = 0, e && e.byteLength && ((e = (0, h.parseInitSegment)(e)).video && (s = (n = e.video).id, a = n.timescale, n = n.codec, o.id = s, o.timescale = d.timescale = a, o.codec = n), e.audio && (a = (s = e.audio).id, n = s.timescale, e = s.codec, l.id = a, l.timescale = n, l.codec = e), d.id = h.RemuxerTrackIdConfig.text, o.sampleDuration = 0, o.duration = l.duration = r)
                    }, t.resetContiguity = function () {
                    }, s.probe = function (e) {
                        return e = 16384 < e.length ? e.subarray(0, 16384) : e, 0 < (0, h.findBox)(e, ["moof"]).length
                    }, t.demux = function (e, t) {
                        this.timeOffset = t;
                        var i = e, r = this.videoTrack, s = this.txtTrack,
                            e = (this.config.progressive ? (this.remainderData && (i = (0, h.appendUint8Array)(this.remainderData, e)), e = (0, h.segmentValidRange)(i), this.remainderData = e.remainder, r.samples = e.valid || new Uint8Array) : r.samples = i, this.extractID3Track(r, t));
                        return s.samples = (0, h.parseSamples)(t, r), {
                            videoTrack: r,
                            audioTrack: this.audioTrack,
                            id3Track: e,
                            textTrack: this.txtTrack
                        }
                    }, t.flush = function () {
                        var e = this.timeOffset, t = this.videoTrack, i = this.txtTrack,
                            r = (t.samples = this.remainderData || new Uint8Array, this.remainderData = null, this.extractID3Track(t, this.timeOffset));
                        return i.samples = (0, h.parseSamples)(e, t), {
                            videoTrack: t,
                            audioTrack: (0, c.dummyTrack)(),
                            id3Track: r,
                            textTrack: (0, c.dummyTrack)()
                        }
                    }, t.extractID3Track = function (e, r) {
                        var s = this.id3Track;
                        return e.samples.length && (e = (0, h.findBox)(e.samples, ["emsg"])) && e.forEach(function (e) {
                            var t, i, e = (0, h.parseEmsg)(e);
                            o.test(e.schemeIdUri) && (t = (0, a.isFiniteNumber)(e.presentationTime) ? e.presentationTime / e.timeScale : r + e.presentationTimeDelta / e.timeScale, (i = 4294967295 === e.eventDuration ? Number.POSITIVE_INFINITY : e.eventDuration / e.timeScale) <= .001 && (i = Number.POSITIVE_INFINITY), e = e.payload, s.samples.push({
                                data: e,
                                len: e.byteLength,
                                dts: t,
                                pts: t,
                                type: n.MetadataSchema.emsg,
                                duration: i
                            }))
                        }), s
                    }, t.demuxSampleAes = function (e, t, i) {
                        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                    }, t.destroy = function () {
                    };
                    const r = s;

                    function s(e, t) {
                        this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t
                    }
                }, "./src/demux/mpegaudio.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        appendFrame: () => function (e, t, i, r, s) {
                            if (!(i + 24 > t.length)) {
                                var a = n(t, i);
                                if (a && i + a.frameLength <= t.length) return r = r + s * (9e4 * a.samplesPerFrame / a.sampleRate), s = {
                                    unit: t.subarray(i, i + a.frameLength),
                                    pts: r,
                                    dts: r
                                }, e.config = [], e.channelCount = a.channelCount, e.samplerate = a.sampleRate, e.samples.push(s), {
                                    sample: s,
                                    length: a.frameLength,
                                    missing: 0
                                }
                            }
                        },
                        canParse: () => function (e, t) {
                            return s(e, t) && 4 <= e.length - t
                        },
                        isHeader: () => a,
                        isHeaderPattern: () => s,
                        parseHeader: () => n,
                        probe: () => function (e, t) {
                            {
                                var i, r;
                                if (t + 1 < e.length && s(e, t)) return r = n(e, t), i = 4, null != r && r.frameLength && (i = r.frameLength), (r = t + i) === e.length || a(e, r)
                            }
                            return !1
                        }
                    });
                    var c = null,
                        u = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
                        p = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
                        f = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], m = [0, 1, 1, 4];

                    function n(e, t) {
                        var i, r, s, a, n, o = e[t + 1] >> 3 & 3, l = e[t + 1] >> 1 & 3, d = e[t + 2] >> 4 & 15,
                            h = e[t + 2] >> 2 & 3;
                        if (1 != o && 0 != d && 15 != d && 3 != h) return n = e[t + 2] >> 1 & 1, i = e[t + 3] >> 6, d = 1e3 * u[14 * (3 == o ? 3 - l : 3 == l ? 3 : 4) + d - 1], h = p[3 * (3 == o ? 0 : 2 == o ? 1 : 2) + h], r = 3 == i ? 1 : 2, a = 8 * (o = f[o][l]) * (s = m[l]), o = Math.floor(o * d / h + n) * s, null === c && (n = (navigator.userAgent || "").match(/Chrome\/(\d+)/i), c = n ? parseInt(n[1]) : 0), c && c <= 87 && 2 == l && 224e3 <= d && 0 == i && (e[t + 3] = 128 | e[t + 3]), {
                            sampleRate: h,
                            channelCount: r,
                            frameLength: o,
                            samplesPerFrame: a
                        }
                    }

                    function s(e, t) {
                        return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
                    }

                    function a(e, t) {
                        return t + 1 < e.length && s(e, t)
                    }
                }, "./src/demux/sample-aes.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => s});
                    var r = i("./src/crypt/decrypter.ts"), l = i("./src/utils/mp4-tools.ts");
                    (t = a.prototype).decryptBuffer = function (e) {
                        return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
                    }, t.decryptAacSample = function (t, i, r) {
                        var e, s = this, a = t[i].unit;
                        a.length <= 16 || (e = (e = a.subarray(16, a.length - a.length % 16)).buffer.slice(e.byteOffset, e.byteOffset + e.length), this.decryptBuffer(e).then(function (e) {
                            e = new Uint8Array(e);
                            a.set(e, 16), s.decrypter.isSync() || s.decryptAacSamples(t, i + 1, r)
                        }))
                    }, t.decryptAacSamples = function (e, t, i) {
                        for (; ; t++) {
                            if (t >= e.length) return void i();
                            if (!(e[t].unit.length < 32 || (this.decryptAacSample(e, t, i), this.decrypter.isSync()))) return
                        }
                    }, t.getAvcEncryptedData = function (e) {
                        for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, i = new Int8Array(t), r = 0, s = 32; s < e.length - 16; s += 160, r += 16) i.set(e.subarray(s, s + 16), r);
                        return i
                    }, t.getAvcDecryptedUnit = function (e, t) {
                        for (var i = new Uint8Array(t), r = 0, s = 32; s < e.length - 16; s += 160, r += 16) e.set(i.subarray(r, r + 16), s);
                        return e
                    }, t.decryptAvcSample = function (t, i, r, s, a) {
                        var n = this, o = (0, l.discardEPB)(a.data), e = this.getAvcEncryptedData(o);
                        this.decryptBuffer(e.buffer).then(function (e) {
                            a.data = n.getAvcDecryptedUnit(o, e), n.decrypter.isSync() || n.decryptAvcSamples(t, i, r + 1, s)
                        })
                    }, t.decryptAvcSamples = function (e, t, i, r) {
                        if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
                        for (; ; t++, i = 0) {
                            if (t >= e.length) return void r();
                            for (var s = e[t].units; !(i >= s.length); i++) {
                                var a = s[i];
                                if (!(a.data.length <= 48 || 1 !== a.type && 5 !== a.type || (this.decryptAvcSample(e, t, i, r, a), this.decrypter.isSync()))) return
                            }
                        }
                    };
                    const s = a;

                    function a(e, t, i) {
                        this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new r.default(t, {removePKCS7Padding: !1})
                    }
                }, "./src/demux/transmuxer-interface.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var l = i("./src/demux/webworkify-webpack.js"), d = i("./src/events.ts"),
                        w = i("./src/demux/transmuxer.ts"), S = i("./src/utils/logger.ts"), h = i("./src/errors.ts"),
                        t = i("./src/utils/mediasource-helper.ts"), c = i("./node_modules/eventemitter3/index.js"),
                        u = (0, t.getMediaSource)() || {
                            isTypeSupported: function () {
                                return !1
                            }
                        }, r = ((i = s.prototype).destroy = function () {
                            var e = this.worker,
                                e = (e ? (e.removeEventListener("message", this.onwmsg), e.terminate(), this.worker = null, this.onwmsg = void 0) : (e = this.transmuxer) && (e.destroy(), this.transmuxer = null), this.observer);
                            e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
                        }, i.push = function (e, t, i, r, s, a, n, o, l, d) {
                            var h = this, c = (l.transmuxing.start = self.performance.now(), this.transmuxer),
                                u = this.worker, p = (a || s).start, f = s.decryptdata, m = this.frag,
                                g = !(m && s.cc === m.cc), y = !(m && l.level === m.level), A = m ? l.sn - m.sn : -1,
                                b = this.part ? l.part - this.part.index : -1,
                                v = 0 == A && 1 < l.id && l.id === (null == m ? void 0 : m.stats.chunkCount),
                                v = !y && (1 == A || 0 == A && (1 == b || v && b <= 0)), _ = self.performance.now(),
                                _ = ((y || A || 0 === s.stats.parsing.start) && (s.stats.parsing.start = _), !a || !b && v || (a.stats.parsing.start = _), !(m && (null == (A = s.initSegment) ? void 0 : A.url) === (null == (b = m.initSegment) ? void 0 : b.url))),
                                A = new w.TransmuxState(g, v, o, y, p, _);
                            v && !g && !_ || (S.logger.log("[transmuxer-interface, " + s.type + "]: Starting new transmux session for sn: " + l.sn + " p: " + l.part + " level: " + l.level + " id: " + l.id + "\n        discontinuity: " + g + "\n        trackSwitch: " + y + "\n        contiguous: " + v + "\n        accurateTimeOffset: " + o + "\n        timeOffset: " + p + "\n        initSegmentChange: " + _), m = new w.TransmuxConfig(i, r, t, n, d), this.configureTransmuxer(m)), this.frag = s, this.part = a, u ? u.postMessage({
                                cmd: "demux",
                                data: e,
                                decryptdata: f,
                                chunkMeta: l,
                                state: A
                            }, e instanceof ArrayBuffer ? [e] : []) : c && (b = c.push(e, f, l, A), (0, w.isPromise)(b) ? (c.async = !0, b.then(function (e) {
                                h.handleTransmuxComplete(e)
                            }).catch(function (e) {
                                h.transmuxerError(e, l, "transmuxer-interface push error")
                            })) : (c.async = !1, this.handleTransmuxComplete(b)))
                        }, i.flush = function (t) {
                            var i = this, e = (t.transmuxing.start = self.performance.now(), this.transmuxer),
                                r = this.worker;
                            r ? r.postMessage({
                                cmd: "flush",
                                chunkMeta: t
                            }) : e && (r = e.flush(t), (0, w.isPromise)(r) || e.async ? (r = (0, w.isPromise)(r) ? r : Promise.resolve(r)).then(function (e) {
                                i.handleFlushResult(e, t)
                            }).catch(function (e) {
                                i.transmuxerError(e, t, "transmuxer-interface flush error")
                            }) : this.handleFlushResult(r, t))
                        }, i.transmuxerError = function (e, t, i) {
                            this.hls && this.hls.trigger(d.Events.ERROR, {
                                type: h.ErrorTypes.MEDIA_ERROR,
                                details: h.ErrorDetails.FRAG_PARSING_ERROR,
                                chunkMeta: t,
                                fatal: !1,
                                error: e,
                                err: e,
                                reason: i
                            })
                        }, i.handleFlushResult = function (e, t) {
                            var i = this;
                            e.forEach(function (e) {
                                i.handleTransmuxComplete(e)
                            }), this.onFlush(t)
                        }, i.onWorkerMessage = function (e) {
                            var t = e.data, i = this.hls;
                            switch (t.event) {
                                case"init":
                                    self.URL.revokeObjectURL(this.worker.objectURL);
                                    break;
                                case"transmuxComplete":
                                    this.handleTransmuxComplete(t.data);
                                    break;
                                case"flush":
                                    this.onFlush(t.data);
                                    break;
                                case"workerLog":
                                    S.logger[t.data.logType] && S.logger[t.data.logType](t.data.message);
                                    break;
                                default:
                                    t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, i.trigger(t.event, t.data)
                            }
                        }, i.configureTransmuxer = function (e) {
                            var t = this.worker, i = this.transmuxer;
                            t ? t.postMessage({cmd: "configure", config: e}) : i && i.configure(e)
                        }, i.handleTransmuxComplete = function (e) {
                            e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e)
                        }, s);

                    function s(e, t, i, r) {
                        function s(e, t) {
                            (t = t || {}).frag = n.frag, t.id = n.id, n.hls.trigger(e, t)
                        }

                        var a, n = this,
                            o = (this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, e.config),
                            i = (this.hls = e, this.id = t, this.useWorker = !!o.enableWorker, this.onTransmuxComplete = i, this.onFlush = r, this.observer = new c.EventEmitter, this.observer.on(d.Events.FRAG_DECRYPTED, s), this.observer.on(d.Events.ERROR, s), {
                                mp4: u.isTypeSupported("video/mp4"),
                                mpeg: u.isTypeSupported("audio/mpeg"),
                                mp3: u.isTypeSupported('audio/mp4; codecs="mp3"')
                            }), r = navigator.vendor;
                        if (this.useWorker && "undefined" != typeof Worker) {
                            S.logger.log("demuxing in webworker");
                            try {
                                a = this.worker = (0, l.default)("./src/demux/transmuxer-worker.ts"), this.onwmsg = this.onWorkerMessage.bind(this), a.addEventListener("message", this.onwmsg), a.onerror = function (e) {
                                    n.useWorker = !1, S.logger.warn("Exception in webworker, fallback to inline"), n.hls.trigger(d.Events.ERROR, {
                                        type: h.ErrorTypes.OTHER_ERROR,
                                        details: h.ErrorDetails.INTERNAL_EXCEPTION,
                                        fatal: !1,
                                        event: "demuxerWorker",
                                        error: new Error(e.message + "  (" + e.filename + ":" + e.lineno + ")")
                                    })
                                }, a.postMessage({
                                    cmd: "init",
                                    typeSupported: i,
                                    vendor: r,
                                    id: t,
                                    config: JSON.stringify(o)
                                })
                            } catch (e) {
                                S.logger.warn("Error in worker:", e), S.logger.error("Error while initializing DemuxerWorker, fallback to inline"), a && self.URL.revokeObjectURL(a.objectURL), this.transmuxer = new w.default(this.observer, i, o, r, t), this.worker = null
                            }
                        } else this.transmuxer = new w.default(this.observer, i, o, r, t)
                    }
                }, "./src/demux/transmuxer-worker.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        default: () => function (a) {
                            function n(e, t) {
                                a.postMessage({event: e, data: t})
                            }

                            var o = new r.EventEmitter;
                            o.on(d.Events.FRAG_DECRYPTED, n), o.on(d.Events.ERROR, n), a.addEventListener("message", function (e) {
                                var t = e.data;
                                switch (t.cmd) {
                                    case"init":
                                        var i, r = JSON.parse(t.config);
                                        for (i in a.transmuxer = new l.default(o, t.typeSupported, r, t.vendor, t.id), (0, h.enableLogs)(r.debug, t.id), h.logger) !function (t) {
                                            h.logger[t] = function (e) {
                                                n("workerLog", {logType: t, message: e})
                                            }
                                        }(i);
                                        n("init", null);
                                        break;
                                    case"configure":
                                        a.transmuxer.configure(t.config);
                                        break;
                                    case"demux":
                                        r = a.transmuxer.push(t.data, t.decryptdata, t.chunkMeta, t.state);
                                        (0, l.isPromise)(r) ? (a.transmuxer.async = !0, r.then(function (e) {
                                            u(a, e)
                                        }).catch(function (e) {
                                            n(d.Events.ERROR, {
                                                type: c.ErrorTypes.MEDIA_ERROR,
                                                details: c.ErrorDetails.FRAG_PARSING_ERROR,
                                                chunkMeta: t.chunkMeta,
                                                fatal: !1,
                                                error: e,
                                                err: e,
                                                reason: "transmuxer-worker push error"
                                            })
                                        })) : (a.transmuxer.async = !1, u(a, r));
                                        break;
                                    case"flush":
                                        var s = t.chunkMeta, r = a.transmuxer.flush(s);
                                        (0, l.isPromise)(r) || a.transmuxer.async ? (r = (0, l.isPromise)(r) ? r : Promise.resolve(r)).then(function (e) {
                                            p(a, e, s)
                                        }).catch(function (e) {
                                            n(d.Events.ERROR, {
                                                type: c.ErrorTypes.MEDIA_ERROR,
                                                details: c.ErrorDetails.FRAG_PARSING_ERROR,
                                                chunkMeta: t.chunkMeta,
                                                fatal: !1,
                                                error: e,
                                                err: e,
                                                reason: "transmuxer-worker flush error"
                                            })
                                        }) : p(a, r, s)
                                }
                            })
                        }
                    });
                    var l = i("./src/demux/transmuxer.ts"), d = i("./src/events.ts"), h = i("./src/utils/logger.ts"),
                        r = i("./node_modules/eventemitter3/index.js"), c = i("./src/errors.ts");

                    function u(e, t) {
                        if (!((i = t.remuxResult).audio || i.video || i.text || i.id3 || i.initSegment)) return !1;
                        var i = [], r = t.remuxResult, s = r.audio, r = r.video;
                        return s && a(i, s), r && a(i, r), e.postMessage({event: "transmuxComplete", data: t}, i), !0
                    }

                    function a(e, t) {
                        t.data1 && e.push(t.data1.buffer), t.data2 && e.push(t.data2.buffer)
                    }

                    function p(i, e, t) {
                        e.reduce(function (e, t) {
                            return u(i, t) || e
                        }, !1) || i.postMessage({event: "transmuxComplete", data: e[0]}), i.postMessage({
                            event: "flush",
                            data: t
                        })
                    }
                }, "./src/demux/transmuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        TransmuxConfig: () => g,
                        TransmuxState: () => y,
                        default: () => d,
                        isPromise: () => c
                    });
                    var A, o = i("./src/events.ts"), l = i("./src/errors.ts"), r = i("./src/crypt/decrypter.ts"),
                        t = i("./src/demux/aacdemuxer.ts"), u = i("./src/demux/mp4demuxer.ts"),
                        s = i("./src/demux/tsdemuxer.ts"), a = i("./src/demux/mp3demuxer.ts"),
                        n = i("./src/remux/mp4-remuxer.ts"), p = i("./src/remux/passthrough-remuxer.ts"),
                        f = i("./src/utils/logger.ts");
                    try {
                        A = self.performance.now.bind(self.performance)
                    } catch (e) {
                        f.logger.debug("Unable to use Performance API on this environment"), A = self.Date.now
                    }
                    var m = [{demux: u.default, remux: p.default}, {
                            demux: s.default,
                            remux: n.default
                        }, {demux: t.default, remux: n.default}, {demux: a.default, remux: n.default}],
                        d = ((i = h.prototype).configure = function (e) {
                            this.transmuxConfig = e, this.decrypter && this.decrypter.reset()
                        }, i.push = function (e, t, i, r) {
                            var s = this, a = i.transmuxing, e = (a.executeStart = A(), new Uint8Array(e)),
                                n = this.currentTransmuxState, o = this.transmuxConfig,
                                r = (r && (this.currentTransmuxState = r), r || n), n = r.contiguous,
                                l = r.discontinuity, d = r.trackSwitch, h = r.accurateTimeOffset, c = r.timeOffset,
                                r = r.initSegmentChange, u = o.audioCodec, p = o.videoCodec, f = o.defaultInitPts,
                                m = o.duration, o = o.initSegmentData,
                                g = (g = null, g = 0 < e.byteLength && null != t && null != t.key && null !== t.iv && null != t.method ? t : g);
                            if (g && "AES-128" === g.method) {
                                var y = this.getDecrypter();
                                if (!y.isSync()) return this.decryptionPromise = y.webCryptoDecrypt(e, g.key.buffer, g.iv.buffer).then(function (e) {
                                    e = s.push(e, null, i);
                                    return s.decryptionPromise = null, e
                                }), this.decryptionPromise;
                                y = y.softwareDecrypt(e, g.key.buffer, g.iv.buffer);
                                if (!y) return a.executeEnd = A(), b(i);
                                e = new Uint8Array(y)
                            }
                            y = this.needsProbing(l, d), y && this.configureTransmuxer(e), (l || d || r || y) && this.resetInitSegment(o, u, p, m, t), (l || r || y) && this.resetInitialTimestamp(f), n || this.resetContiguity(), d = this.transmux(e, g, c, h, i), o = this.currentTransmuxState;
                            return o.contiguous = !0, o.discontinuity = !1, o.trackSwitch = !1, a.executeEnd = A(), d
                        }, i.flush = function (t) {
                            var i = this, e = t.transmuxing, r = (e.executeStart = A(), this.decrypter),
                                s = this.currentTransmuxState, a = this.decryptionPromise;
                            if (a) return a.then(function () {
                                return i.flush(t)
                            });
                            var n = [], a = s.timeOffset,
                                r = (!r || (s = r.flush()) && n.push(this.push(s, null, t)), this.demuxer),
                                s = this.remuxer;
                            if (!r || !s) return this.observer.emit(o.Events.ERROR, o.Events.ERROR, {
                                type: l.ErrorTypes.MEDIA_ERROR,
                                details: l.ErrorDetails.FRAG_PARSING_ERROR,
                                fatal: !0,
                                reason: "no demux matching with content found"
                            }), e.executeEnd = A(), [b(t)];
                            s = r.flush(a);
                            return c(s) ? s.then(function (e) {
                                return i.flushRemux(n, e, t), n
                            }) : (this.flushRemux(n, s, t), n)
                        }, i.flushRemux = function (e, t, i) {
                            var r = t.audioTrack, s = t.videoTrack, a = t.id3Track, t = t.textTrack,
                                n = this.currentTransmuxState, o = n.accurateTimeOffset, n = n.timeOffset,
                                r = (f.logger.log("[transmuxer.ts]: Flushed fragment " + i.sn + (-1 < i.part ? " p: " + i.part : "") + " of level " + i.level), this.remuxer.remux(r, s, a, t, n, o, !0, this.id));
                            e.push({remuxResult: r, chunkMeta: i}), i.transmuxing.executeEnd = A()
                        }, i.resetInitialTimestamp = function (e) {
                            var t = this.demuxer, i = this.remuxer;
                            t && i && (t.resetTimeStamp(e), i.resetTimeStamp(e))
                        }, i.resetContiguity = function () {
                            var e = this.demuxer, t = this.remuxer;
                            e && t && (e.resetContiguity(), t.resetNextTimestamp())
                        }, i.resetInitSegment = function (e, t, i, r, s) {
                            var a = this.demuxer, n = this.remuxer;
                            a && n && (a.resetInitSegment(e, t, i, r), n.resetInitSegment(e, t, i, s))
                        }, i.destroy = function () {
                            this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
                        }, i.transmux = function (e, t, i, r, s) {
                            return t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, i, r, s) : this.transmuxUnencrypted(e, i, r, s)
                        }, i.transmuxUnencrypted = function (e, t, i, r) {
                            var e = this.demuxer.demux(e, t, !1, !this.config.progressive), s = e.audioTrack,
                                a = e.videoTrack, n = e.id3Track, e = e.textTrack;
                            return {remuxResult: this.remuxer.remux(s, a, n, e, t, i, !1, this.id), chunkMeta: r}
                        }, i.transmuxSampleAes = function (e, t, i, r, s) {
                            var a = this;
                            return this.demuxer.demuxSampleAes(e, t, i).then(function (e) {
                                return {
                                    remuxResult: a.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, i, r, !1, a.id),
                                    chunkMeta: s
                                }
                            })
                        }, i.configureTransmuxer = function (e) {
                            for (var t, i = this.config, r = this.observer, s = this.typeSupported, a = this.vendor, n = 0, o = m.length; n < o; n++) if (m[n].demux.probe(e)) {
                                t = m[n];
                                break
                            }
                            t || (f.logger.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough"), t = {
                                demux: u.default,
                                remux: p.default
                            });
                            var l = this.demuxer, d = this.remuxer, h = t.remux, c = t.demux;
                            d && d instanceof h || (this.remuxer = new h(r, i, s, a)), l && l instanceof c || (this.demuxer = new c(r, i, s), this.probe = c.probe)
                        }, i.needsProbing = function (e, t) {
                            return !this.demuxer || !this.remuxer || e || t
                        }, i.getDecrypter = function () {
                            return this.decrypter || (this.decrypter = new r.default(this.config))
                        }, h), b = function (e) {
                            return {remuxResult: {}, chunkMeta: e}
                        };

                    function h(e, t, i, r, s) {
                        this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = i, this.vendor = r, this.id = s
                    }

                    function c(e) {
                        return "then" in e && e.then instanceof Function
                    }

                    var g = function (e, t, i, r, s) {
                        this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = i, this.duration = r, this.defaultInitPts = s
                    }, y = function (e, t, i, r, s, a) {
                        this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = i, this.trackSwitch = r, this.timeOffset = s, this.initSegmentChange = a
                    }
                }, "./src/demux/tsdemuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => n});
                    var f = i("./src/demux/adts.ts"), l = i("./src/demux/mpegaudio.ts"),
                        p = i("./src/demux/exp-golomb.ts"), r = i("./src/demux/sample-aes.ts"),
                        C = i("./src/events.ts"), L = i("./src/utils/mp4-tools.ts"), D = i("./src/utils/logger.ts"),
                        I = i("./src/errors.ts"), s = i("./src/types/demuxer.ts");

                    function a() {
                        return (a = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    function R(e, t, i) {
                        this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e, this.config = t, this.typeSupported = i
                    }

                    function m(e, t, i, r) {
                        return {key: e, frame: !1, pts: t, dts: i, units: [], debug: r, length: 0}
                    }

                    function P(e) {
                        var t, i, r, s, a = 0, n = e.data;
                        if (!e || 0 === e.size) return null;
                        for (; n[0].length < 19 && 1 < n.length;) {
                            var o = new Uint8Array(n[0].length + n[1].length);
                            o.set(n[0]), o.set(n[1], n[0].length), n[0] = o, n.splice(1, 1)
                        }
                        if (1 !== ((t = n[0])[0] << 16) + (t[1] << 8) + t[2]) return null;
                        if ((i = (t[4] << 8) + t[5]) && i > e.size - 6) return null;
                        var l = t[7],
                            d = (192 & l && (r = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, 64 & l ? 54e5 < r - (s = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2) && (D.logger.warn(Math.round((r - s) / 9e4) + "s delta between PTS and DTS, align them"), r = s) : s = r), (l = t[8]) + 9);
                        if (e.size <= d) return null;
                        e.size -= d;
                        for (var h = new Uint8Array(e.size), c = 0, u = n.length; c < u; c++) {
                            var p = (t = n[c]).byteLength;
                            if (d) {
                                if (p < d) {
                                    d -= p;
                                    continue
                                }
                                t = t.subarray(d), p -= d, d = 0
                            }
                            h.set(t, a), a += p
                        }
                        return i && (i -= l + 3), {data: h, pts: r, dts: s, len: i}
                    }

                    function g(e, t) {
                        if (e.units.length && e.frame) {
                            if (void 0 === e.pts) {
                                var i = t.samples, r = i.length;
                                if (!r) return t.dropped++;
                                i = i[r - 1];
                                e.pts = i.pts, e.dts = i.dts
                            }
                            t.samples.push(e)
                        }
                        e.debug.length && D.logger.log(e.pts + "/" + e.dts + ":" + e.debug)
                    }

                    R.probe = function (e) {
                        e = R.syncOffset(e);
                        return 0 < e && D.logger.warn("MPEG2-TS detected but first sync word found @ offset " + e), -1 !== e
                    }, R.syncOffset = function (e) {
                        for (var t = Math.min(940, e.length - 376) + 1, i = 0; i < t;) {
                            if (71 === e[i] && 71 === e[i + 188]) return i;
                            i++
                        }
                        return -1
                    }, R.createTrack = function (e, t) {
                        return {
                            container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
                            type: e,
                            id: L.RemuxerTrackIdConfig[e],
                            pid: -1,
                            inputTimeScale: 9e4,
                            sequenceNumber: 0,
                            samples: [],
                            dropped: 0,
                            duration: "audio" === e ? t : void 0
                        }
                    }, (t = R.prototype).resetInitSegment = function (e, t, i, r) {
                        this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = R.createTrack("video"), this._audioTrack = R.createTrack("audio", r), this._id3Track = R.createTrack("id3"), this._txtTrack = R.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = i, this._duration = r
                    }, t.resetTimeStamp = function () {
                    }, t.resetContiguity = function () {
                        var e = this._audioTrack, t = this._avcTrack, i = this._id3Track;
                        e && (e.pesData = null), t && (t.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null
                    }, t.demux = function (e, t, i, r) {
                        void 0 === r && (r = !1), (i = void 0 === i ? !1 : i) || (this.sampleAes = null);
                        var s, a = this._avcTrack, n = this._audioTrack, o = this._id3Track, l = this._txtTrack,
                            d = a.pid, h = a.pesData, c = n.pid, u = o.pid, p = n.pesData, f = o.pesData, m = null,
                            g = this.pmtParsed, y = this._pmtId, A = e.length;
                        if (this.remainderData && (A = (e = (0, L.appendUint8Array)(this.remainderData, e)).length, this.remainderData = null), A < 188 && !r) return this.remainderData = e, {
                            audioTrack: n,
                            videoTrack: a,
                            id3Track: o,
                            textTrack: l
                        };
                        var b = Math.max(0, R.syncOffset(e));
                        (A -= (A - b) % 188) < e.byteLength && !r && (this.remainderData = new Uint8Array(e.buffer, A, e.buffer.byteLength - A));
                        for (var v, _ = 0, w = b; w < A; w += 188) if (71 === e[w]) {
                            var S = !!(64 & e[w + 1]), E = ((31 & e[w + 1]) << 8) + e[w + 2], T = void 0;
                            if (1 < (48 & e[w + 3]) >> 4) {
                                if ((T = w + 5 + e[w + 4]) === w + 188) continue
                            } else T = w + 4;
                            switch (E) {
                                case d:
                                    S && (h && (s = P(h)) && this.parseAVCPES(a, l, s, !1), h = {
                                        data: [],
                                        size: 0
                                    }), h && (h.data.push(e.subarray(T, w + 188)), h.size += w + 188 - T);
                                    break;
                                case c:
                                    if (S) {
                                        if (p && (s = P(p))) switch (n.segmentCodec) {
                                            case"aac":
                                                this.parseAACPES(n, s);
                                                break;
                                            case"mp3":
                                                this.parseMPEGPES(n, s)
                                        }
                                        p = {data: [], size: 0}
                                    }
                                    p && (p.data.push(e.subarray(T, w + 188)), p.size += w + 188 - T);
                                    break;
                                case u:
                                    S && (f && (s = P(f)) && this.parseID3PES(o, s), f = {
                                        data: [],
                                        size: 0
                                    }), f && (f.data.push(e.subarray(T, w + 188)), f.size += w + 188 - T);
                                    break;
                                case 0:
                                    S && (T += e[T] + 1), y = this._pmtId = (31 & (k = e)[(v = T) + 10]) << 8 | k[v + 11];
                                    break;
                                case y:
                                    S && (T += e[T] + 1);
                                    var k = function (e, t, i, r) {
                                        var s = {audio: -1, avc: -1, id3: -1, segmentCodec: "aac"},
                                            a = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
                                        for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < a;) {
                                            var n = (31 & e[t + 1]) << 8 | e[t + 2];
                                            switch (e[t]) {
                                                case 207:
                                                    if (!r) {
                                                        D.logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                                                        break
                                                    }
                                                case 15:
                                                    -1 === s.audio && (s.audio = n);
                                                    break;
                                                case 21:
                                                    -1 === s.id3 && (s.id3 = n);
                                                    break;
                                                case 219:
                                                    if (!r) {
                                                        D.logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                                                        break
                                                    }
                                                case 27:
                                                    -1 === s.avc && (s.avc = n);
                                                    break;
                                                case 3:
                                                case 4:
                                                    !0 !== i.mpeg && !0 !== i.mp3 ? D.logger.log("MPEG audio found, not supported in this browser") : -1 === s.audio && (s.audio = n, s.segmentCodec = "mp3");
                                                    break;
                                                case 36:
                                                    D.logger.warn("Unsupported HEVC stream type found")
                                            }
                                            t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
                                        }
                                        return s
                                    }(e, T, this.typeSupported, i);
                                    0 < (d = k.avc) && (a.pid = d), 0 < (c = k.audio) && (n.pid = c, n.segmentCodec = k.segmentCodec), 0 < (u = k.id3) && (o.pid = u), null === m || g || (D.logger.log("unknown PID '" + m + "' in TS found"), m = null, w = b - 188), g = this.pmtParsed = !0;
                                    break;
                                case 17:
                                case 8191:
                                    break;
                                default:
                                    m = E
                            }
                        } else _++;
                        0 < _ && this.observer.emit(C.Events.ERROR, C.Events.ERROR, {
                            type: I.ErrorTypes.MEDIA_ERROR,
                            details: I.ErrorDetails.FRAG_PARSING_ERROR,
                            fatal: !1,
                            reason: "Found " + _ + " TS packet/s that do not start with 0x47"
                        }), a.pesData = h, n.pesData = p, o.pesData = f;
                        var x = {audioTrack: n, videoTrack: a, id3Track: o, textTrack: l};
                        return r && this.extractRemainingSamples(x), x
                    }, t.flush = function () {
                        var e = this.remainderData;
                        return this.remainderData = null, e = e ? this.demux(e, -1, !1, !0) : {
                            videoTrack: this._avcTrack,
                            audioTrack: this._audioTrack,
                            id3Track: this._id3Track,
                            textTrack: this._txtTrack
                        }, this.extractRemainingSamples(e), this.sampleAes ? this.decrypt(e, this.sampleAes) : e
                    }, t.extractRemainingSamples = function (e) {
                        var t, i = e.audioTrack, r = e.videoTrack, s = e.id3Track, e = e.textTrack, a = r.pesData,
                            n = i.pesData, o = s.pesData;
                        if (a && (t = P(a)) ? (this.parseAVCPES(r, e, t, !0), r.pesData = null) : r.pesData = a, n && (t = P(n))) {
                            switch (i.segmentCodec) {
                                case"aac":
                                    this.parseAACPES(i, t);
                                    break;
                                case"mp3":
                                    this.parseMPEGPES(i, t)
                            }
                            i.pesData = null
                        } else null != n && n.size && D.logger.log("last AAC PES packet truncated,might overlap between fragments"), i.pesData = n;
                        o && (t = P(o)) ? (this.parseID3PES(s, t), s.pesData = null) : s.pesData = o
                    }, t.demuxSampleAes = function (e, t, i) {
                        e = this.demux(e, i, !0, !this.config.progressive), i = this.sampleAes = new r.default(this.observer, this.config, t);
                        return this.decrypt(e, i)
                    }, t.decrypt = function (r, s) {
                        return new Promise(function (e) {
                            var t = r.audioTrack, i = r.videoTrack;
                            t.samples && "aac" === t.segmentCodec ? s.decryptAacSamples(t.samples, 0, function () {
                                i.samples ? s.decryptAvcSamples(i.samples, 0, 0, function () {
                                    e(r)
                                }) : e(r)
                            }) : i.samples && s.decryptAvcSamples(i.samples, 0, 0, function () {
                                e(r)
                            })
                        })
                    }, t.destroy = function () {
                        this._duration = 0
                    }, t.parseAVCPES = function (n, o, l, e) {
                        var d, h = this, t = this.parseAVCNALu(n, l.data), c = this.avcSample, u = !1;
                        l.data = null, c && t.length && !n.audFound && (g(c, n), c = this.avcSample = m(!1, l.pts, l.dts, "")), t.forEach(function (e) {
                            switch (e.type) {
                                case 1:
                                    d = !0, (c = c || (h.avcSample = m(!0, l.pts, l.dts, ""))).frame = !0;
                                    var t = e.data;
                                    u && 4 < t.length && (2 !== (t = new p.default(t).readSliceType()) && 4 !== t && 7 !== t && 9 !== t || (c.key = !0));
                                    break;
                                case 5:
                                    d = !0, (c = c || (h.avcSample = m(!0, l.pts, l.dts, ""))).key = !0, c.frame = !0;
                                    break;
                                case 6:
                                    d = !0, (0, L.parseSEIMessageFromNALu)(e.data, 1, l.pts, o.samples);
                                    break;
                                case 7:
                                    if (u = d = !0, !n.sps) {
                                        t = new p.default(e.data).readSPS();
                                        n.width = t.width, n.height = t.height, n.pixelRatio = t.pixelRatio, n.sps = [e.data], n.duration = h._duration;
                                        for (var i = e.data.subarray(1, 4), r = "avc1.", s = 0; s < 3; s++) {
                                            var a = i[s].toString(16);
                                            r += a = a.length < 2 ? "0" + a : a
                                        }
                                        n.codec = r
                                    }
                                    break;
                                case 8:
                                    d = !0, n.pps || (n.pps = [e.data]);
                                    break;
                                case 9:
                                    d = !1, n.audFound = !0, c && g(c, n), c = h.avcSample = m(!1, l.pts, l.dts, "");
                                    break;
                                case 12:
                                    d = !0;
                                    break;
                                default:
                                    d = !1, c && (c.debug += "unknown NAL " + e.type + " ")
                            }
                            c && d && c.units.push(e)
                        }), e && c && (g(c, n), this.avcSample = null)
                    }, t.getLastNalUnit = function (e) {
                        var t, i = this.avcSample;
                        return t = null != (e = i = i && 0 !== i.units.length ? i : e[e.length - 1]) && e.units ? (e = i.units)[e.length - 1] : t
                    }, t.parseAVCNALu = function (e, t) {
                        var i, r, s, a, n, o, l = t.byteLength, d = e.naluState || 0, h = d, c = [], u = 0, p = -1,
                            f = 0;
                        for (-1 === d && (f = 31 & t[p = 0], d = 0, u = 1); u < l;) i = t[u++], d = d ? 1 !== d ? i ? 1 === i ? (0 <= p ? (s = {
                            data: t.subarray(p, u - d - 1),
                            type: f
                        }, c.push(s)) : (s = this.getLastNalUnit(e.samples)) && (h && u <= 4 - h && s.state && (s.data = s.data.subarray(0, s.data.byteLength - h)), 0 < (r = u - d - 1)) && ((a = new Uint8Array(s.data.byteLength + r)).set(s.data, 0), a.set(t.subarray(0, r), s.data.byteLength), s.data = a, s.state = 0), u < l ? (f = 31 & t[p = u], 0) : -1) : 0 : 3 : i ? 0 : 2 : i ? 0 : 1;
                        return 0 <= p && 0 <= d && (n = {
                            data: t.subarray(p, l),
                            type: f,
                            state: d
                        }, c.push(n)), 0 === c.length && (n = this.getLastNalUnit(e.samples)) && ((o = new Uint8Array(n.data.byteLength + t.byteLength)).set(n.data, 0), o.set(t, n.data.byteLength), n.data = o), e.naluState = d, c
                    }, t.parseAACPES = function (e, t) {
                        var i, r, s, a, n, o = 0, l = this.aacOverFlow, d = t.data;
                        for (l && (this.aacOverFlow = null, h = l.missing, a = l.sample.unit.byteLength, -1 === h ? ((n = new Uint8Array(a + d.byteLength)).set(l.sample.unit, 0), n.set(d, a), d = n) : (n = a - h, l.sample.unit.set(d.subarray(0, h), n), e.samples.push(l.sample), o = l.missing)), i = o, r = d.length; i < r - 1 && !f.isHeader(d, i); i++) ;
                        if (i === o || (a = i < r - 1 ? (s = "AAC PES did not start with ADTS header,offset:" + i, !1) : (s = "no ADTS header found in AAC PES", !0), D.logger.warn("parsing error:" + s), this.observer.emit(C.Events.ERROR, C.Events.ERROR, {
                            type: I.ErrorTypes.MEDIA_ERROR,
                            details: I.ErrorDetails.FRAG_PARSING_ERROR,
                            fatal: a,
                            reason: s
                        }), !a)) {
                            if (f.initTrackConfig(e, this.observer, d, i, this.audioCodec), void 0 !== t.pts) c = t.pts; else {
                                if (!l) return void D.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
                                var h = f.getFrameDuration(e.samplerate), c = l.sample.pts + h
                            }
                            for (var u, p = 0; i < r;) {
                                if (i += (u = f.appendFrame(e, d, i, c, p)).length, u.missing) {
                                    this.aacOverFlow = u;
                                    break
                                }
                                for (p++; i < r - 1 && !f.isHeader(d, i); i++) ;
                            }
                        }
                    }, t.parseMPEGPES = function (e, t) {
                        var i = t.data, r = i.length, s = 0, a = 0, n = t.pts;
                        if (void 0 !== n) for (; a < r;) if (l.isHeader(i, a)) {
                            var o = l.appendFrame(e, i, a, n, s);
                            if (!o) break;
                            a += o.length, s++
                        } else a++; else D.logger.warn("[tsdemuxer]: MPEG PES unknown PTS")
                    }, t.parseID3PES = function (e, t) {
                        void 0 !== t.pts ? (t = a({}, t, {
                            type: this._avcTrack ? s.MetadataSchema.emsg : s.MetadataSchema.audioId3,
                            duration: Number.POSITIVE_INFINITY
                        }), e.samples.push(t)) : D.logger.warn("[tsdemuxer]: ID3 PES unknown PTS")
                    };
                    const n = R
                }, "./src/demux/webworkify-webpack.js": (e, t, u) => {
                    u.r(t), u.d(t, {
                        default: () => function (c, e) {
                            e = e || {};
                            var i = {main: u.m}, r = e.all ? {main: Object.keys(i.main)} : function (e) {
                                    for (var t = {main: [c]}, i = {main: []}, r = {main: {}}; function (i) {
                                        return Object.keys(i).reduce(function (e, t) {
                                            return e || 0 < i[t].length
                                        }, !1)
                                    }(t);) for (var s = Object.keys(t), a = 0; a < s.length; a++) {
                                        var n = s[a], o = t[n].pop();
                                        if (r[n] = r[n] || {}, !r[n][o] && e[n][o]) {
                                            r[n][o] = !0, i[n] = i[n] || [], i[n].push(o);
                                            for (var l = function (e, t, i) {
                                                var r = {}, s = (r[i] = [], t.toString().replace(/^"[^"]+"/, "function")),
                                                    t = s.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/) || s.match(/^\(\w+,\s*\w+,\s*(\w+)\)\s?\=\s?\>/);
                                                if (!t) return r;
                                                for (var a, t = t[1], n = new RegExp("(\\\\n|\\W)" + m(t) + f, "g"); a = n.exec(s);) "dll-reference" !== a[3] && r[i].push(a[3]);
                                                for (n = new RegExp("\\(" + m(t) + '\\("(dll-reference\\s(' + p + '))"\\)\\)' + f, "g"); a = n.exec(s);) e[a[2]] || (r[i].push(a[1]), e[a[2]] = u(a[1]).m), r[a[2]] = r[a[2]] || [], r[a[2]].push(a[4]);
                                                for (var o, l = Object.keys(r), d = 0; d < l.length; d++) for (var h = 0; h < r[l[d]].length; h++) o = r[l[d]][h], isNaN(+o) || (r[l[d]][h] = +r[l[d]][h]);
                                                return r
                                            }(e, e[n][o], n), d = Object.keys(l), h = 0; h < d.length; h++) t[d[h]] = t[d[h]] || [], t[d[h]] = t[d[h]].concat(l[d[h]])
                                        }
                                    }
                                    return i
                                }(i), s = "", e = (Object.keys(r).filter(function (e) {
                                    return "main" !== e
                                }).forEach(function (e) {
                                    for (var t = 0; r[e][t];) t++;
                                    r[e].push(t), i[e][t] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", s = s + "var " + e + " = (" + a(r, i, t, modules) + ")();\n"
                                }), s = s + "new ((" + a(r, i, c, "main") + ")())(self);", new window.Blob([s], {type: "text/javascript"})),
                                e = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(e),
                                t = new window.Worker(e);
                            return t.objectURL = e, t
                        }
                    });
                    var s = function () {
                            function r(e) {
                                var t = s[e];
                                return void 0 !== t || (t = s[e] = {exports: {}}, i[e].call(t.exports, t, t.exports, r)), t.exports
                            }

                            var i = ENTRY_MODULE, s = {}, e = (r.m = i, r.n = function (e) {
                                var t = e && e.__esModule ? function () {
                                    return e.default
                                } : function () {
                                    return e
                                };
                                return r.d(t, {a: t}), t
                            }, r.d = function (e, t) {
                                for (var i in t) r.o(t, i) && !r.o(e, i) && Object.defineProperty(e, i, {
                                    enumerable: !0,
                                    get: t[i]
                                })
                            }, r.o = function (e, t) {
                                return Object.prototype.hasOwnProperty.call(e, t)
                            }, r.r = function (e) {
                                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
                            }, r(ENTRY_MODULE));
                            return e.default || e
                        }.toString().split("ENTRY_MODULE"), p = "[\\.|\\-|\\+|\\w|/|@]+",
                        f = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)";

                    function m(e) {
                        return (e + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
                    }

                    function a(e, t, i, r) {
                        e = e[r].map(function (e) {
                            return '"' + e + '": ' + t[r][e].toString().replace(/^"[^"]+"/, "function")
                        }).join(",");
                        return s[0] + "{" + e + "}" + s[1] + '"' + i + '"' + s[2]
                    }
                }, "./src/errors.ts": (e, t, i) => {
                    var r, s;
                    i.r(t), i.d(t, {
                        ErrorDetails: () => s,
                        ErrorTypes: () => r
                    }), (i = r = r || {}).NETWORK_ERROR = "networkError", i.MEDIA_ERROR = "mediaError", i.KEY_SYSTEM_ERROR = "keySystemError", i.MUX_ERROR = "muxError", i.OTHER_ERROR = "otherError", (t = s = s || {}).KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", t.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", t.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", t.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", t.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", t.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", t.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", t.MANIFEST_LOAD_ERROR = "manifestLoadError", t.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", t.MANIFEST_PARSING_ERROR = "manifestParsingError", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", t.LEVEL_EMPTY_ERROR = "levelEmptyError", t.LEVEL_LOAD_ERROR = "levelLoadError", t.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", t.LEVEL_SWITCH_ERROR = "levelSwitchError", t.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", t.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", t.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", t.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", t.FRAG_LOAD_ERROR = "fragLoadError", t.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", t.FRAG_DECRYPT_ERROR = "fragDecryptError", t.FRAG_PARSING_ERROR = "fragParsingError", t.REMUX_ALLOC_ERROR = "remuxAllocError", t.KEY_LOAD_ERROR = "keyLoadError", t.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", t.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", t.BUFFER_APPEND_ERROR = "bufferAppendError", t.BUFFER_APPENDING_ERROR = "bufferAppendingError", t.BUFFER_STALLED_ERROR = "bufferStalledError", t.BUFFER_FULL_ERROR = "bufferFullError", t.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", t.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", t.INTERNAL_EXCEPTION = "internalException", t.INTERNAL_ABORTED = "aborted", t.UNKNOWN = "unknown"
                }, "./src/events.ts": (e, t, i) => {
                    var r;
                    i.r(t), i.d(t, {Events: () => r}), (i = r = r || {}).MEDIA_ATTACHING = "hlsMediaAttaching", i.MEDIA_ATTACHED = "hlsMediaAttached", i.MEDIA_DETACHING = "hlsMediaDetaching", i.MEDIA_DETACHED = "hlsMediaDetached", i.BUFFER_RESET = "hlsBufferReset", i.BUFFER_CODECS = "hlsBufferCodecs", i.BUFFER_CREATED = "hlsBufferCreated", i.BUFFER_APPENDING = "hlsBufferAppending", i.BUFFER_APPENDED = "hlsBufferAppended", i.BUFFER_EOS = "hlsBufferEos", i.BUFFER_FLUSHING = "hlsBufferFlushing", i.BUFFER_FLUSHED = "hlsBufferFlushed", i.MANIFEST_LOADING = "hlsManifestLoading", i.MANIFEST_LOADED = "hlsManifestLoaded", i.MANIFEST_PARSED = "hlsManifestParsed", i.LEVEL_SWITCHING = "hlsLevelSwitching", i.LEVEL_SWITCHED = "hlsLevelSwitched", i.LEVEL_LOADING = "hlsLevelLoading", i.LEVEL_LOADED = "hlsLevelLoaded", i.LEVEL_UPDATED = "hlsLevelUpdated", i.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", i.LEVELS_UPDATED = "hlsLevelsUpdated", i.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", i.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", i.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", i.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", i.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", i.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", i.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", i.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", i.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", i.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", i.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", i.CUES_PARSED = "hlsCuesParsed", i.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", i.INIT_PTS_FOUND = "hlsInitPtsFound", i.FRAG_LOADING = "hlsFragLoading", i.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", i.FRAG_LOADED = "hlsFragLoaded", i.FRAG_DECRYPTED = "hlsFragDecrypted", i.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", i.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", i.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", i.FRAG_PARSED = "hlsFragParsed", i.FRAG_BUFFERED = "hlsFragBuffered", i.FRAG_CHANGED = "hlsFragChanged", i.FPS_DROP = "hlsFpsDrop", i.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", i.ERROR = "hlsError", i.DESTROYING = "hlsDestroying", i.KEY_LOADING = "hlsKeyLoading", i.KEY_LOADED = "hlsKeyLoaded", i.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", i.BACK_BUFFER_REACHED = "hlsBackBufferReached"
                }, "./src/hls.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => d});
                    var s = i("./node_modules/url-toolkit/src/url-toolkit.js"),
                        c = i("./src/loader/playlist-loader.ts"), u = i("./src/controller/id3-track-controller.ts"),
                        p = i("./src/controller/latency-controller.ts"), f = i("./src/controller/level-controller.ts"),
                        m = i("./src/controller/fragment-tracker.ts"), g = i("./src/loader/key-loader.ts"),
                        y = i("./src/controller/stream-controller.ts"), r = i("./src/is-supported.ts"),
                        A = i("./src/utils/logger.ts"), b = i("./src/config.ts"),
                        v = i("./node_modules/eventemitter3/index.js"), a = i("./src/events.ts"),
                        n = i("./src/errors.ts"), o = i("./src/types/level.ts");

                    function l(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    _.isSupported = function () {
                        return (0, r.isSupported)()
                    }, (t = _.prototype).createController = function (e, t) {
                        return e ? (e = new e(this), t && t.push(e), e) : null
                    }, t.on = function (e, t, i) {
                        this._emitter.on(e, t, i = void 0 === i ? this : i)
                    }, t.once = function (e, t, i) {
                        this._emitter.once(e, t, i = void 0 === i ? this : i)
                    }, t.removeAllListeners = function (e) {
                        this._emitter.removeAllListeners(e)
                    }, t.off = function (e, t, i, r) {
                        this._emitter.off(e, t, i = void 0 === i ? this : i, r)
                    }, t.listeners = function (e) {
                        return this._emitter.listeners(e)
                    }, t.emit = function (e, t, i) {
                        return this._emitter.emit(e, t, i)
                    }, t.trigger = function (e, t) {
                        if (this.config.debug) return this.emit(e, e, t);
                        try {
                            return this.emit(e, e, t)
                        } catch (t) {
                            A.logger.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), this.trigger(a.Events.ERROR, {
                                type: n.ErrorTypes.OTHER_ERROR,
                                details: n.ErrorDetails.INTERNAL_EXCEPTION,
                                fatal: !1,
                                event: e,
                                error: t
                            })
                        }
                        return !1
                    }, t.listenerCount = function (e) {
                        return this._emitter.listenerCount(e)
                    }, t.destroy = function () {
                        A.logger.log("destroy"), this.trigger(a.Events.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(function (e) {
                            return e.destroy()
                        }), this.networkControllers.length = 0, this.coreComponents.forEach(function (e) {
                            return e.destroy()
                        }), this.coreComponents.length = 0
                    }, t.attachMedia = function (e) {
                        A.logger.log("attachMedia"), this._media = e, this.trigger(a.Events.MEDIA_ATTACHING, {media: e})
                    }, t.detachMedia = function () {
                        A.logger.log("detachMedia"), this.trigger(a.Events.MEDIA_DETACHING, void 0), this._media = null
                    }, t.loadSource = function (e) {
                        this.stopLoad();
                        var t = this.media, i = this.url,
                            r = this.url = s.buildAbsoluteURL(self.location.href, e, {alwaysNormalize: !0});
                        A.logger.log("loadSource:" + r), t && i && i !== r && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(t)), this.trigger(a.Events.MANIFEST_LOADING, {url: e})
                    }, t.startLoad = function (t) {
                        void 0 === t && (t = -1), A.logger.log("startLoad(" + t + ")"), this.networkControllers.forEach(function (e) {
                            e.startLoad(t)
                        })
                    }, t.stopLoad = function () {
                        A.logger.log("stopLoad"), this.networkControllers.forEach(function (e) {
                            e.stopLoad()
                        })
                    }, t.swapAudioCodec = function () {
                        A.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec()
                    }, t.recoverMediaError = function () {
                        A.logger.log("recoverMediaError");
                        var e = this._media;
                        this.detachMedia(), e && this.attachMedia(e)
                    }, t.removeLevel = function (e, t) {
                        this.levelController.removeLevel(e, t = void 0 === t ? 0 : t)
                    }, t = [{
                        key: "version", get: function () {
                            return "1.3.2"
                        }
                    }, {
                        key: "Events", get: function () {
                            return a.Events
                        }
                    }, {
                        key: "ErrorTypes", get: function () {
                            return n.ErrorTypes
                        }
                    }, {
                        key: "ErrorDetails", get: function () {
                            return n.ErrorDetails
                        }
                    }, {
                        key: "DefaultConfig", get: function () {
                            return _.defaultConfig || b.hlsDefaultConfig
                        }, set: function (e) {
                            _.defaultConfig = e
                        }
                    }], l((i = _).prototype, [{
                        key: "levels", get: function () {
                            return this.levelController.levels || []
                        }
                    }, {
                        key: "currentLevel", get: function () {
                            return this.streamController.currentLevel
                        }, set: function (e) {
                            A.logger.log("set currentLevel:" + e), this.loadLevel = e, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch()
                        }
                    }, {
                        key: "nextLevel", get: function () {
                            return this.streamController.nextLevel
                        }, set: function (e) {
                            A.logger.log("set nextLevel:" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
                        }
                    }, {
                        key: "loadLevel", get: function () {
                            return this.levelController.level
                        }, set: function (e) {
                            A.logger.log("set loadLevel:" + e), this.levelController.manualLevel = e
                        }
                    }, {
                        key: "nextLoadLevel", get: function () {
                            return this.levelController.nextLoadLevel
                        }, set: function (e) {
                            this.levelController.nextLoadLevel = e
                        }
                    }, {
                        key: "firstLevel", get: function () {
                            return Math.max(this.levelController.firstLevel, this.minAutoLevel)
                        }, set: function (e) {
                            A.logger.log("set firstLevel:" + e), this.levelController.firstLevel = e
                        }
                    }, {
                        key: "startLevel", get: function () {
                            return this.levelController.startLevel
                        }, set: function (e) {
                            A.logger.log("set startLevel:" + e), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e
                        }
                    }, {
                        key: "capLevelToPlayerSize", get: function () {
                            return this.config.capLevelToPlayerSize
                        }, set: function (e) {
                            e = !!e;
                            e !== this.config.capLevelToPlayerSize && (e ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = e)
                        }
                    }, {
                        key: "autoLevelCapping", get: function () {
                            return this._autoLevelCapping
                        }, set: function (e) {
                            this._autoLevelCapping !== e && (A.logger.log("set autoLevelCapping:" + e), this._autoLevelCapping = e)
                        }
                    }, {
                        key: "bandwidthEstimate", get: function () {
                            var e = this.abrController.bwEstimator;
                            return e ? e.getEstimate() : NaN
                        }
                    }, {
                        key: "maxHdcpLevel", get: function () {
                            return this._maxHdcpLevel
                        }, set: function (e) {
                            -1 < o.HdcpLevels.indexOf(e) && (this._maxHdcpLevel = e)
                        }
                    }, {
                        key: "autoLevelEnabled", get: function () {
                            return -1 === this.levelController.manualLevel
                        }
                    }, {
                        key: "manualLevel", get: function () {
                            return this.levelController.manualLevel
                        }
                    }, {
                        key: "minAutoLevel", get: function () {
                            var e = this.levels, t = this.config.minAutoBitrate;
                            if (!e) return 0;
                            for (var i = e.length, r = 0; r < i; r++) if (e[r].maxBitrate >= t) return r;
                            return 0
                        }
                    }, {
                        key: "maxAutoLevel", get: function () {
                            var e = this.levels, t = this.autoLevelCapping, i = this.maxHdcpLevel,
                                t = -1 === t && e && e.length ? e.length - 1 : t;
                            if (i) for (var r = t; r--;) {
                                var s = e[r].attrs["HDCP-LEVEL"];
                                if (s && s <= i) return r
                            }
                            return t
                        }
                    }, {
                        key: "nextAutoLevel", get: function () {
                            return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
                        }, set: function (e) {
                            this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
                        }
                    }, {
                        key: "playingDate", get: function () {
                            return this.streamController.currentProgramDateTime
                        }
                    }, {
                        key: "mainForwardBufferInfo", get: function () {
                            return this.streamController.getMainFwdBufferInfo()
                        }
                    }, {
                        key: "audioTracks", get: function () {
                            var e = this.audioTrackController;
                            return e ? e.audioTracks : []
                        }
                    }, {
                        key: "audioTrack", get: function () {
                            var e = this.audioTrackController;
                            return e ? e.audioTrack : -1
                        }, set: function (e) {
                            var t = this.audioTrackController;
                            t && (t.audioTrack = e)
                        }
                    }, {
                        key: "subtitleTracks", get: function () {
                            var e = this.subtitleTrackController;
                            return e ? e.subtitleTracks : []
                        }
                    }, {
                        key: "subtitleTrack", get: function () {
                            var e = this.subtitleTrackController;
                            return e ? e.subtitleTrack : -1
                        }, set: function (e) {
                            var t = this.subtitleTrackController;
                            t && (t.subtitleTrack = e)
                        }
                    }, {
                        key: "media", get: function () {
                            return this._media
                        }
                    }, {
                        key: "subtitleDisplay", get: function () {
                            var e = this.subtitleTrackController;
                            return !!e && e.subtitleDisplay
                        }, set: function (e) {
                            var t = this.subtitleTrackController;
                            t && (t.subtitleDisplay = e)
                        }
                    }, {
                        key: "lowLatencyMode", get: function () {
                            return this.config.lowLatencyMode
                        }, set: function (e) {
                            this.config.lowLatencyMode = e
                        }
                    }, {
                        key: "liveSyncPosition", get: function () {
                            return this.latencyController.liveSyncPosition
                        }
                    }, {
                        key: "latency", get: function () {
                            return this.latencyController.latency
                        }
                    }, {
                        key: "maxLatency", get: function () {
                            return this.latencyController.maxLatency
                        }
                    }, {
                        key: "targetLatency", get: function () {
                            return this.latencyController.targetLatency
                        }
                    }, {
                        key: "drift", get: function () {
                            return this.latencyController.drift
                        }
                    }, {
                        key: "forceStartLoad", get: function () {
                            return this.streamController.forceStartLoad
                        }
                    }]), l(i, t), Object.defineProperty(i, "prototype", {writable: !1});
                    var d = _;

                    function _(e) {
                        void 0 === e && (e = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new v.EventEmitter, this._autoLevelCapping = void 0, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null;
                        var t = this.config = (0, b.mergeConfig)(_.DefaultConfig, e),
                            e = (this.userConfig = e, (0, A.enableLogs)(t.debug, "Hls instance"), this._autoLevelCapping = -1, t.progressive && (0, b.enableStreamingMode)(t), t.abrController),
                            i = t.bufferController, r = t.capLevelController, s = t.fpsController,
                            e = this.abrController = new e(this), i = this.bufferController = new i(this),
                            r = this.capLevelController = new r(this), s = new s(this), a = new c.default(this),
                            n = new u.default(this), o = this.levelController = new f.default(this),
                            l = new m.FragmentTracker(this), d = new g.default(this.config),
                            h = this.streamController = new y.default(this, l, d),
                            a = (r.setStreamController(h), s.setStreamController(h), [a, o, h]),
                            o = (this.networkControllers = a, [e, i, r, s, n, l]),
                            h = (this.audioTrackController = this.createController(t.audioTrackController, a), t.audioStreamController),
                            e = (h && a.push(new h(this, l, d)), this.subtitleTrackController = this.createController(t.subtitleTrackController, a), t.subtitleStreamController);
                        e && a.push(new e(this, l, d)), this.createController(t.timelineController, o), d.emeController = this.emeController = this.createController(t.emeController, o), this.cmcdController = this.createController(t.cmcdController, o), this.latencyController = this.createController(p.default, o), this.coreComponents = o
                    }

                    d.defaultConfig = void 0
                }, "./src/is-supported.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        changeTypeSupported: () => function () {
                            var e = s();
                            return "function" == typeof (null == e || null == (e = e.prototype) ? void 0 : e.changeType)
                        }, isSupported: () => function () {
                            var e = (0, r.getMediaSource)();
                            if (!e) return !1;
                            var t = s(),
                                e = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
                                t = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
                            return !!e && !!t
                        }
                    });
                    var r = i("./src/utils/mediasource-helper.ts");

                    function s() {
                        return self.SourceBuffer || self.WebKitSourceBuffer
                    }
                }, "./src/loader/date-range.ts": (e, t, i) => {
                    i.r(t), i.d(t, {DateRange: () => d, DateRangeAttribute: () => s});
                    var s, a = i("./src/polyfills/number.ts"), n = i("./src/utils/attr-list.ts"),
                        o = i("./src/utils/logger.ts");

                    function l() {
                        return (l = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    function r(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    (t = s = s || {}).ID = "ID", t.CLASS = "CLASS", t.START_DATE = "START-DATE", t.DURATION = "DURATION", t.END_DATE = "END-DATE", t.END_ON_NEXT = "END-ON-NEXT", t.PLANNED_DURATION = "PLANNED-DURATION", t.SCTE35_OUT = "SCTE35-OUT", t.SCTE35_IN = "SCTE35-IN";
                    r((i = h).prototype, [{
                        key: "id", get: function () {
                            return this.attr.ID
                        }
                    }, {
                        key: "class", get: function () {
                            return this.attr.CLASS
                        }
                    }, {
                        key: "startDate", get: function () {
                            return this._startDate
                        }
                    }, {
                        key: "endDate", get: function () {
                            if (this._endDate) return this._endDate;
                            var e = this.duration;
                            return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null
                        }
                    }, {
                        key: "duration", get: function () {
                            if (s.DURATION in this.attr) {
                                var e = this.attr.decimalFloatingPoint(s.DURATION);
                                if ((0, a.isFiniteNumber)(e)) return e
                            } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                            return null
                        }
                    }, {
                        key: "plannedDuration", get: function () {
                            return s.PLANNED_DURATION in this.attr ? this.attr.decimalFloatingPoint(s.PLANNED_DURATION) : null
                        }
                    }, {
                        key: "endOnNext", get: function () {
                            return this.attr.bool(s.END_ON_NEXT)
                        }
                    }, {
                        key: "isValid", get: function () {
                            return !!this.id && !this._badValueForSameId && (0, a.isFiniteNumber)(this.startDate.getTime()) && (null === this.duration || 0 <= this.duration) && (!this.endOnNext || !!this.class)
                        }
                    }]), Object.defineProperty(i, "prototype", {writable: !1});
                    var d = h;

                    function h(e, t) {
                        if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) {
                            var i, r = t.attr;
                            for (i in r) if (Object.prototype.hasOwnProperty.call(e, i) && e[i] !== r[i]) {
                                o.logger.warn('DATERANGE tag attribute: "' + i + '" does not match for tags with ID: "' + e.ID + '"'), this._badValueForSameId = i;
                                break
                            }
                            e = l(new n.AttrList({}), r, e)
                        }
                        this.attr = e, this._startDate = new Date(e[s.START_DATE]), s.END_DATE in this.attr && (t = new Date(this.attr[s.END_DATE]), (0, a.isFiniteNumber)(t.getTime()) && (this._endDate = t))
                    }
                }, "./src/loader/fragment-loader.ts": (e, t, i) => {
                    i.r(t), i.d(t, {LoadError: () => m, default: () => l});
                    var n = i("./src/polyfills/number.ts"), u = i("./src/errors.ts");

                    function r(e) {
                        var i = "function" == typeof Map ? new Map : void 0;
                        return (r = function (e) {
                            if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e;
                            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                            if (void 0 !== i) {
                                if (i.has(e)) return i.get(e);
                                i.set(e, t)
                            }

                            function t() {
                                return s(e, arguments, o(this).constructor)
                            }

                            return t.prototype = Object.create(e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), a(t, e)
                        })(e)
                    }

                    function s(e, t, i) {
                        return (s = function () {
                            if ("undefined" == typeof Reflect || !Reflect.construct) return;
                            if (Reflect.construct.sham) return;
                            if ("function" == typeof Proxy) return 1;
                            try {
                                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
                                })), 1
                            } catch (e) {
                                return
                            }
                        }() ? Reflect.construct.bind() : function (e, t, i) {
                            var r = [null], t = (r.push.apply(r, t), new (Function.bind.apply(e, r)));
                            return i && a(t, i.prototype), t
                        }).apply(null, arguments)
                    }

                    function a(e, t) {
                        return (a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function o(e) {
                        return (o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {
                            return e.__proto__ || Object.getPrototypeOf(e)
                        })(e)
                    }

                    var p = Math.pow(2, 17), l = ((t = d.prototype).destroy = function () {
                        this.loader && (this.loader.destroy(), this.loader = null)
                    }, t.abort = function () {
                        this.loader && this.loader.abort()
                    }, t.load = function (n, o) {
                        var l = this, e = n.url;
                        if (!e) return Promise.reject(new m({
                            type: u.ErrorTypes.NETWORK_ERROR,
                            details: u.ErrorDetails.FRAG_LOAD_ERROR,
                            fatal: !1,
                            frag: n,
                            networkDetails: null
                        }, "Fragment does not have a " + (e ? "part list" : "url")));
                        this.abort();
                        var i = this.config, d = i.fLoader, h = i.loader;
                        return new Promise(function (s, r) {
                            l.loader && l.loader.destroy();
                            var a = l.loader = n.loader = new (d || h)(i), e = f(n), t = {
                                timeout: i.fragLoadingTimeOut,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: i.fragLoadingMaxRetryTimeout,
                                highWaterMark: "initSegment" === n.sn ? 1 / 0 : p
                            };
                            n.stats = a.stats, a.load(e, t, {
                                onSuccess: function (e, t, i, r) {
                                    l.resetLoader(n, a);
                                    e = e.data;
                                    i.resetIV && n.decryptdata && (n.decryptdata.iv = new Uint8Array(e.slice(0, 16)), e = e.slice(16)), s({
                                        frag: n,
                                        part: null,
                                        payload: e,
                                        networkDetails: r
                                    })
                                }, onError: function (e, t, i) {
                                    l.resetLoader(n, a), r(new m({
                                        type: u.ErrorTypes.NETWORK_ERROR,
                                        details: u.ErrorDetails.FRAG_LOAD_ERROR,
                                        fatal: !1,
                                        frag: n,
                                        response: e,
                                        networkDetails: i
                                    }))
                                }, onAbort: function (e, t, i) {
                                    l.resetLoader(n, a), r(new m({
                                        type: u.ErrorTypes.NETWORK_ERROR,
                                        details: u.ErrorDetails.INTERNAL_ABORTED,
                                        fatal: !1,
                                        frag: n,
                                        networkDetails: i
                                    }))
                                }, onTimeout: function (e, t, i) {
                                    l.resetLoader(n, a), r(new m({
                                        type: u.ErrorTypes.NETWORK_ERROR,
                                        details: u.ErrorDetails.FRAG_LOAD_TIMEOUT,
                                        fatal: !1,
                                        frag: n,
                                        networkDetails: i
                                    }))
                                }, onProgress: function (e, t, i, r) {
                                    o && o({frag: n, part: null, payload: i, networkDetails: r})
                                }
                            })
                        })
                    }, t.loadPart = function (n, o, l) {
                        var d = this, i = (this.abort(), this.config), h = i.fLoader, c = i.loader;
                        return new Promise(function (s, r) {
                            d.loader && d.loader.destroy();
                            var a = d.loader = n.loader = new (h || c)(i), e = f(n, o), t = {
                                timeout: i.fragLoadingTimeOut,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: i.fragLoadingMaxRetryTimeout,
                                highWaterMark: p
                            };
                            o.stats = a.stats, a.load(e, t, {
                                onSuccess: function (e, t, i, r) {
                                    d.resetLoader(n, a), d.updateStatsFromPart(n, o);
                                    e = {frag: n, part: o, payload: e.data, networkDetails: r};
                                    l(e), s(e)
                                }, onError: function (e, t, i) {
                                    d.resetLoader(n, a), r(new m({
                                        type: u.ErrorTypes.NETWORK_ERROR,
                                        details: u.ErrorDetails.FRAG_LOAD_ERROR,
                                        fatal: !1,
                                        frag: n,
                                        part: o,
                                        response: e,
                                        networkDetails: i
                                    }))
                                }, onAbort: function (e, t, i) {
                                    n.stats.aborted = o.stats.aborted, d.resetLoader(n, a), r(new m({
                                        type: u.ErrorTypes.NETWORK_ERROR,
                                        details: u.ErrorDetails.INTERNAL_ABORTED,
                                        fatal: !1,
                                        frag: n,
                                        part: o,
                                        networkDetails: i
                                    }))
                                }, onTimeout: function (e, t, i) {
                                    d.resetLoader(n, a), r(new m({
                                        type: u.ErrorTypes.NETWORK_ERROR,
                                        details: u.ErrorDetails.FRAG_LOAD_TIMEOUT,
                                        fatal: !1,
                                        frag: n,
                                        part: o,
                                        networkDetails: i
                                    }))
                                }
                            })
                        })
                    }, t.updateStatsFromPart = function (e, t) {
                        var i = e.stats, r = t.stats, s = r.total,
                            e = (i.loaded += r.loaded, s ? (s = ((e = Math.round(e.duration / t.duration)) - (t = Math.min(Math.round(i.loaded / s), e))) * Math.round(i.loaded / t), i.total = i.loaded + s) : i.total = Math.max(i.loaded, i.total), i.loading),
                            t = r.loading;
                        e.start ? e.first += t.first - t.start : (e.start = t.start, e.first = t.first), e.end = t.end
                    }, t.resetLoader = function (e, t) {
                        e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy()
                    }, d);

                    function d(e) {
                        this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e
                    }

                    function f(e, t) {
                        var i, r, s = (t = void 0 === t ? null : t) || e, t = {
                            frag: e,
                            part: t,
                            responseType: "arraybuffer",
                            url: s.url,
                            headers: {},
                            rangeStart: 0,
                            rangeEnd: 0
                        }, a = s.byteRangeStartOffset, s = s.byteRangeEndOffset;
                        return (0, n.isFiniteNumber)(a) && (0, n.isFiniteNumber)(s) && (i = a, r = s, "initSegment" === e.sn && "AES-128" === (null == (e = e.decryptdata) ? void 0 : e.method) && ((e = s - a) % 16 && (r = s + (16 - e % 16)), 0 !== a && (t.resetIV = !0, i = a - 16)), t.rangeStart = i, t.rangeEnd = r), t
                    }

                    h = r(Error), i = h, (t = c).prototype = Object.create(i.prototype), a(t.prototype.constructor = t, i);
                    var h, m = c;

                    function c(e) {
                        for (var t, i = arguments.length, r = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) r[s - 1] = arguments[s];
                        return (t = h.call.apply(h, [this].concat(r)) || this).data = void 0, t.data = e, t
                    }
                }, "./src/loader/fragment.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        BaseSegment: () => p,
                        ElementaryStreamTypes: () => r,
                        Fragment: () => f,
                        Part: () => m
                    });
                    var r, s = i("./src/polyfills/number.ts"), a = i("./node_modules/url-toolkit/src/url-toolkit.js"),
                        n = i("./src/loader/load-stats.ts");

                    function o(e, t) {
                        e.prototype = Object.create(t.prototype), l(e.prototype.constructor = e, t)
                    }

                    function l(e, t) {
                        return (l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function d(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    function h(e, t, i) {
                        t && d(e.prototype, t), i && d(e, i), Object.defineProperty(e, "prototype", {writable: !1})
                    }

                    (t = r = r || {}).AUDIO = "audio", t.VIDEO = "video", t.AUDIOVIDEO = "audiovideo";
                    A.prototype.setByteRange = function (e, t) {
                        var e = e.split("@", 2), i = [];
                        1 === e.length ? i[0] = t ? t.byteRangeEndOffset : 0 : i[0] = parseInt(e[1]), i[1] = parseInt(e[0]) + i[0], this._byteRange = i
                    }, h(A, [{
                        key: "byteRange", get: function () {
                            return this._byteRange || []
                        }
                    }, {
                        key: "byteRangeStartOffset", get: function () {
                            return this.byteRange[0]
                        }
                    }, {
                        key: "byteRangeEndOffset", get: function () {
                            return this.byteRange[1]
                        }
                    }, {
                        key: "url", get: function () {
                            return !this._url && this.baseurl && this.relurl && (this._url = (0, a.buildAbsoluteURL)(this.baseurl, this.relurl, {alwaysNormalize: !0})), this._url || ""
                        }, set: function (e) {
                            this._url = e
                        }
                    }]);
                    var c, u, p = A, f = (o(y, u = p), (i = y.prototype).setKeyFormat = function (e) {
                        this.levelkeys && (e = this.levelkeys[e]) && !this._decryptdata && (this._decryptdata = e.getDecryptData(this.sn))
                    }, i.abortRequests = function () {
                        var e;
                        null != (e = this.loader) && e.abort(), null != (e = this.keyLoader) && e.abort()
                    }, i.setElementaryStreamInfo = function (e, t, i, r, s, a) {
                        void 0 === a && (a = !1);
                        var n = this.elementaryStreams, o = n[e];
                        o ? (o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, i), o.startDTS = Math.min(o.startDTS, r), o.endDTS = Math.max(o.endDTS, s)) : n[e] = {
                            startPTS: t,
                            endPTS: i,
                            startDTS: r,
                            endDTS: s,
                            partial: a
                        }
                    }, i.clearElementaryStreamInfo = function () {
                        var e = this.elementaryStreams;
                        e[r.AUDIO] = null, e[r.VIDEO] = null, e[r.AUDIOVIDEO] = null
                    }, h(y, [{
                        key: "decryptdata", get: function () {
                            if (!this.levelkeys && !this._decryptdata) return null;
                            if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
                                var e = this.levelkeys.identity;
                                if (e) this._decryptdata = e.getDecryptData(this.sn); else {
                                    e = Object.keys(this.levelkeys);
                                    if (1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn)
                                }
                            }
                            return this._decryptdata
                        }
                    }, {
                        key: "end", get: function () {
                            return this.start + this.duration
                        }
                    }, {
                        key: "endProgramDateTime", get: function () {
                            if (null === this.programDateTime) return null;
                            if (!(0, s.isFiniteNumber)(this.programDateTime)) return null;
                            var e = (0, s.isFiniteNumber)(this.duration) ? this.duration : 0;
                            return this.programDateTime + 1e3 * e
                        }
                    }, {
                        key: "encrypted", get: function () {
                            if (null != (e = this._decryptdata) && e.encrypted) return !0;
                            if (this.levelkeys) {
                                var e = Object.keys(this.levelkeys), t = e.length;
                                if (1 < t || 1 === t && this.levelkeys[e[0]].encrypted) return !0
                            }
                            return !1
                        }
                    }]), y), m = (o(g, c = p), h(g, [{
                        key: "start", get: function () {
                            return this.fragment.start + this.fragOffset
                        }
                    }, {
                        key: "end", get: function () {
                            return this.start + this.duration
                        }
                    }, {
                        key: "loaded", get: function () {
                            var e = this.elementaryStreams;
                            return !!(e.audio || e.video || e.audiovideo)
                        }
                    }]), g);

                    function g(e, t, i, r, s) {
                        (i = c.call(this, i) || this).fragOffset = 0, i.duration = 0, i.gap = !1, i.independent = !1, i.relurl = void 0, i.fragment = void 0, i.index = void 0, i.stats = new n.LoadStats, i.duration = e.decimalFloatingPoint("DURATION"), i.gap = e.bool("GAP"), i.independent = e.bool("INDEPENDENT"), i.relurl = e.enumeratedString("URI"), i.fragment = t, i.index = r;
                        t = e.enumeratedString("BYTERANGE");
                        return t && i.setByteRange(t, s), s && (i.fragOffset = s.fragOffset + s.duration), i
                    }

                    function y(e, t) {
                        return (t = u.call(this, t) || this)._decryptdata = null, t.rawProgramDateTime = null, t.programDateTime = null, t.tagList = [], t.duration = 0, t.sn = 0, t.levelkeys = void 0, t.type = void 0, t.loader = null, t.keyLoader = null, t.level = -1, t.cc = 0, t.startPTS = void 0, t.endPTS = void 0, t.appendedPTS = void 0, t.startDTS = void 0, t.endDTS = void 0, t.start = 0, t.deltaPTS = void 0, t.maxStartPTS = void 0, t.minEndPTS = void 0, t.stats = new n.LoadStats, t.urlId = 0, t.data = void 0, t.bitrateTest = !1, t.title = null, t.initSegment = null, t.endList = void 0, t.type = e, t
                    }

                    function A(e) {
                        var t;
                        this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = ((t = {})[r.AUDIO] = null, t[r.VIDEO] = null, t[r.AUDIOVIDEO] = null, t), this.baseurl = e
                    }
                }, "./src/loader/key-loader.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var d = i("./src/errors.ts"), s = i("./src/loader/fragment-loader.ts"),
                        r = ((t = a.prototype).abort = function () {
                            for (var e in this.keyUriToKeyInfo) {
                                e = this.keyUriToKeyInfo[e].loader;
                                e && e.abort()
                            }
                        }, t.detach = function () {
                            for (var e in this.keyUriToKeyInfo) {
                                var t = this.keyUriToKeyInfo[e];
                                (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e]
                            }
                        }, t.destroy = function () {
                            for (var e in this.detach(), this.keyUriToKeyInfo) {
                                e = this.keyUriToKeyInfo[e].loader;
                                e && e.destroy()
                            }
                            this.keyUriToKeyInfo = {}
                        }, t.createKeyLoadError = function (e, t, i, r) {
                            return void 0 === t && (t = d.ErrorDetails.KEY_LOAD_ERROR), new s.LoadError({
                                type: d.ErrorTypes.NETWORK_ERROR,
                                details: t,
                                fatal: !1,
                                frag: e,
                                networkDetails: i
                            })
                        }, t.loadClear = function (e, i) {
                            var r = this;
                            if (this.emeController && this.config.emeEnabled) for (var s = e.sn, a = e.cc, t = 0; t < i.length && "break" !== function (e) {
                                var t = i[e];
                                if (a <= t.cc && ("initSegment" === s || s < t.sn)) return r.emeController.selectKeySystemFormat(t).then(function (e) {
                                    t.setKeyFormat(e)
                                }), "break"
                            }(t); t++) ;
                        }, t.load = function (t) {
                            var i = this;
                            return !t.decryptdata && t.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(t).then(function (e) {
                                return i.loadInternal(t, e)
                            }) : this.loadInternal(t)
                        }, t.loadInternal = function (e, t) {
                            t && e.setKeyFormat(t);
                            var i = e.decryptdata;
                            if (!i) return Promise.reject(this.createKeyLoadError(e, d.ErrorDetails.KEY_LOAD_ERROR, null, t ? "Expected frag.decryptdata to be defined after setting format " + t : "Missing decryption data on fragment in onKeyLoading"));
                            t = i.uri;
                            if (!t) return Promise.reject(this.createKeyLoadError(e, d.ErrorDetails.KEY_LOAD_ERROR, null, 'Invalid key URI: "' + t + '"'));
                            var r, s = this.keyUriToKeyInfo[t];
                            if (null != (r = s) && r.decryptdata.key) return i.key = s.decryptdata.key, Promise.resolve({
                                frag: e,
                                keyInfo: s
                            });
                            if (null != (r = s) && r.keyLoadPromise) switch (null == (r = s.mediaKeySessionContext) ? void 0 : r.keyStatus) {
                                case void 0:
                                case"status-pending":
                                case"usable":
                                case"usable-in-future":
                                    return s.keyLoadPromise
                            }
                            switch (s = this.keyUriToKeyInfo[t] = {
                                decryptdata: i,
                                keyLoadPromise: null,
                                loader: null,
                                mediaKeySessionContext: null
                            }, i.method) {
                                case"ISO-23001-7":
                                case"SAMPLE-AES":
                                case"SAMPLE-AES-CENC":
                                case"SAMPLE-AES-CTR":
                                    return "identity" === i.keyFormat ? this.loadKeyHTTP(s, e) : this.loadKeyEME(s, e);
                                case"AES-128":
                                    return this.loadKeyHTTP(s, e);
                                default:
                                    return Promise.reject(this.createKeyLoadError(e, d.ErrorDetails.KEY_LOAD_ERROR, null, 'Key supplied with unsupported METHOD: "' + i.method + '"'))
                            }
                        }, t.loadKeyEME = function (t, e) {
                            var i = {frag: e, keyInfo: t};
                            if (this.emeController && this.config.emeEnabled) {
                                e = this.emeController.loadKey(i);
                                if (e) return (t.keyLoadPromise = e.then(function (e) {
                                    return t.mediaKeySessionContext = e, i
                                })).catch(function (e) {
                                    throw t.keyLoadPromise = null, e
                                })
                            }
                            return Promise.resolve(i)
                        }, t.loadKeyHTTP = function (i, r) {
                            var l = this, s = this.config, a = new s.loader(s);
                            return r.keyLoader = i.loader = a, i.keyLoadPromise = new Promise(function (n, o) {
                                var e = {keyInfo: i, frag: r, responseType: "arraybuffer", url: i.decryptdata.uri},
                                    t = {
                                        timeout: s.fragLoadingTimeOut,
                                        maxRetry: 0,
                                        retryDelay: s.fragLoadingRetryDelay,
                                        maxRetryDelay: s.fragLoadingMaxRetryTimeout,
                                        highWaterMark: 0
                                    };
                                a.load(e, t, {
                                    onSuccess: function (e, t, i, r) {
                                        var s = i.frag, a = i.keyInfo, i = i.url;
                                        if (!s.decryptdata || a !== l.keyUriToKeyInfo[i]) return o(l.createKeyLoadError(s, d.ErrorDetails.KEY_LOAD_ERROR, r, "after key load, decryptdata unset or changed"));
                                        a.decryptdata.key = s.decryptdata.key = new Uint8Array(e.data), s.keyLoader = null, a.loader = null, n({
                                            frag: s,
                                            keyInfo: a
                                        })
                                    }, onError: function (e, t, i) {
                                        l.resetLoader(t), o(l.createKeyLoadError(r, d.ErrorDetails.KEY_LOAD_ERROR, i))
                                    }, onTimeout: function (e, t, i) {
                                        l.resetLoader(t), o(l.createKeyLoadError(r, d.ErrorDetails.KEY_LOAD_TIMEOUT, i))
                                    }, onAbort: function (e, t, i) {
                                        l.resetLoader(t), o(l.createKeyLoadError(r, d.ErrorDetails.INTERNAL_ABORTED, i))
                                    }
                                })
                            })
                        }, t.resetLoader = function (e) {
                            var t = e.frag, i = e.keyInfo, e = e.url, r = i.loader;
                            t.keyLoader === r && (t.keyLoader = null, i.loader = null), delete this.keyUriToKeyInfo[e], r && r.destroy()
                        }, a);

                    function a(e) {
                        this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e
                    }
                }, "./src/loader/level-details.ts": (e, t, i) => {
                    i.r(t), i.d(t, {LevelDetails: () => a});
                    var r = i("./src/polyfills/number.ts");

                    function s(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    n.prototype.reloaded = function (e) {
                        if (!e) return this.advanced = !0, void (this.updated = !0);
                        var t = this.lastPartSn - e.lastPartSn, i = this.lastPartIndex - e.lastPartIndex;
                        this.updated = this.endSN !== e.endSN || !!i || !!t, this.advanced = this.endSN > e.endSN || 0 < t || 0 == t && 0 < i, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay
                    }, s((t = n).prototype, [{
                        key: "hasProgramDateTime", get: function () {
                            return !!this.fragments.length && (0, r.isFiniteNumber)(this.fragments[this.fragments.length - 1].programDateTime)
                        }
                    }, {
                        key: "levelTargetDuration", get: function () {
                            return this.averagetargetduration || this.targetduration || 10
                        }
                    }, {
                        key: "drift", get: function () {
                            var e = this.driftEndTime - this.driftStartTime;
                            return 0 < e ? 1e3 * (this.driftEnd - this.driftStart) / e : 1
                        }
                    }, {
                        key: "edge", get: function () {
                            return this.partEnd || this.fragmentEnd
                        }
                    }, {
                        key: "partEnd", get: function () {
                            var e;
                            return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
                        }
                    }, {
                        key: "fragmentEnd", get: function () {
                            var e;
                            return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0
                        }
                    }, {
                        key: "age", get: function () {
                            return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
                        }
                    }, {
                        key: "lastPartIndex", get: function () {
                            var e;
                            return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1
                        }
                    }, {
                        key: "lastPartSn", get: function () {
                            var e;
                            return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
                        }
                    }]), Object.defineProperty(t, "prototype", {writable: !1});
                    var a = n;

                    function n(e) {
                        this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e
                    }
                }, "./src/loader/level-key.ts": (e, t, i) => {
                    i.r(t), i.d(t, {LevelKey: () => r});
                    var a = i("./src/utils/keysystem-util.ts"), n = i("./src/utils/mediakeys-helper.ts"),
                        o = i("./src/utils/mp4-tools.ts"), l = i("./src/utils/logger.ts"),
                        d = i("./src/utils/numeric-encoding-utils.ts"), h = {},
                        r = (c.clearKeyUriToKeyIdMap = function () {
                            h = {}
                        }, (t = c.prototype).isSupported = function () {
                            if (this.method) {
                                if ("AES-128" === this.method || "NONE" === this.method) return !0;
                                switch (this.keyFormat) {
                                    case"identity":
                                        return "SAMPLE-AES" === this.method;
                                    case n.KeySystemFormats.FAIRPLAY:
                                    case n.KeySystemFormats.WIDEVINE:
                                    case n.KeySystemFormats.PLAYREADY:
                                    case n.KeySystemFormats.CLEARKEY:
                                        return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
                                }
                            }
                            return !1
                        }, t.getDecryptData = function (e) {
                            if (!this.encrypted || !this.uri) return null;
                            if ("AES-128" === this.method && this.uri && !this.iv) return "number" != typeof e && ("AES-128" !== this.method || this.iv || l.logger.warn('missing IV for initialization segment with method="' + this.method + '" - compliance issue'), e = 0), e = function (e) {
                                for (var t = new Uint8Array(16), i = 12; i < 16; i++) t[i] = e >> 8 * (15 - i) & 255;
                                return t
                            }(e), new c(this.method, this.uri, "identity", this.keyFormatVersions, e);
                            var t, i = (0, a.convertDataUriToArrayBytes)(this.uri);
                            if (i) switch (this.keyFormat) {
                                case n.KeySystemFormats.WIDEVINE:
                                    22 <= (this.pssh = i).length && (this.keyId = i.subarray(i.length - 22, i.length - 6));
                                    break;
                                case n.KeySystemFormats.PLAYREADY:
                                    var r = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]),
                                        r = (this.pssh = (0, o.mp4pssh)(r, null, i), new Uint16Array(i.buffer, i.byteOffset, i.byteLength / 2)),
                                        r = String.fromCharCode.apply(null, Array.from(r)),
                                        r = r.substring(r.indexOf("<"), r.length),
                                        r = (new DOMParser).parseFromString(r, "text/xml").getElementsByTagName("KID")[0];
                                    !r || (r = r.childNodes[0] ? r.childNodes[0].nodeValue : r.getAttribute("VALUE")) && (r = (0, d.base64Decode)(r).subarray(0, 16), (0, a.changeEndianness)(r), this.keyId = r);
                                    break;
                                default:
                                    var s, r = i.subarray(0, 16);
                                    16 !== r.length && ((s = new Uint8Array(16)).set(r, 16 - r.length), r = s), this.keyId = r
                            }
                            return this.keyId && 16 === this.keyId.byteLength || ((e = h[this.uri]) || (t = Object.keys(h).length % Number.MAX_SAFE_INTEGER, e = new Uint8Array(16), new DataView(e.buffer, 12, 4).setUint32(0, t), h[this.uri] = e), this.keyId = e), this
                        }, c);

                    function c(e, t, i, r, s) {
                        void 0 === r && (r = [1]), void 0 === s && (s = null), this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = i, this.keyFormatVersions = r, this.iv = s, this.encrypted = !!e && "NONE" !== e, this.isCommonEncryption = this.encrypted && "AES-128" !== e
                    }
                }, "./src/loader/load-stats.ts": (e, t, i) => {
                    i.r(t), i.d(t, {LoadStats: () => r});
                    var r = function () {
                        this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
                            start: 0,
                            first: 0,
                            end: 0
                        }, this.parsing = {start: 0, end: 0}, this.buffering = {start: 0, first: 0, end: 0}
                    }
                }, "./src/loader/m3u8-parser.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => d});
                    var F = i("./src/polyfills/number.ts"), r = i("./node_modules/url-toolkit/src/url-toolkit.js"),
                        M = i("./src/loader/date-range.ts"), O = i("./src/loader/fragment.ts"),
                        N = i("./src/loader/level-details.ts"), o = i("./src/loader/level-key.ts"),
                        j = i("./src/utils/attr-list.ts"), z = i("./src/utils/logger.ts"),
                        c = i("./src/utils/codecs.ts");

                    function G() {
                        return (G = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    var u = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+|#EXT-X-SESSION-KEY:([^\n\r]*)[\r\n]+/g,
                        l = /#EXT-X-MEDIA:(.*)/g,
                        H = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
                        W = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")),
                        d = (p.findGroup = function (e, t) {
                            for (var i = 0; i < e.length; i++) {
                                var r = e[i];
                                if (r.id === t) return r
                            }
                        }, p.convertAVC1ToAVCOTI = function (e) {
                            var t, i = e.split(".");
                            return 2 < i.length ? (t = i.shift() + ".", (t += parseInt(i.shift()).toString(16)) + ("000" + parseInt(i.shift()).toString(16)).slice(-4)) : e
                        }, p.resolve = function (e, t) {
                            return (0, r.buildAbsoluteURL)(t, e, {alwaysNormalize: !0})
                        }, p.parseMasterPlaylist = function (e, t) {
                            var i, r, s, a, n = [], o = [], l = {}, d = [], h = !1;
                            for (u.lastIndex = 0; null != (i = u.exec(e));) i[1] ? (a = {
                                attrs: r = new j.AttrList(i[1]),
                                bitrate: r.decimalInteger("AVERAGE-BANDWIDTH") || r.decimalInteger("BANDWIDTH"),
                                name: r.NAME,
                                url: p.resolve(i[2], t)
                            }, (s = r.decimalResolution("RESOLUTION")) && (a.width = s.width, a.height = s.height), function (r, s) {
                                ["video", "audio", "text"].forEach(function (t) {
                                    var e, i = r.filter(function (e) {
                                        return (0, c.isCodecType)(e, t)
                                    });
                                    i.length && (e = i.filter(function (e) {
                                        return 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)
                                    }), s[t + "Codec"] = (0 < e.length ? e : i)[0], r = r.filter(function (e) {
                                        return -1 === i.indexOf(e)
                                    }))
                                }), s.unknownCodecs = r
                            }((r.CODECS || "").split(/[ ,]+/).filter(function (e) {
                                return e
                            }), a), a.videoCodec && -1 !== a.videoCodec.indexOf("avc1") && (a.videoCodec = p.convertAVC1ToAVCOTI(a.videoCodec)), null != (s = a.unknownCodecs) && s.length || o.push(a), n.push(a)) : i[3] ? (r = new j.AttrList(i[3]))["DATA-ID"] && (h = !0, l[r["DATA-ID"]] = r) : i[4] && ((a = V(s = i[4], t)).encrypted && a.isSupported() ? d.push(a) : z.logger.warn('[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "' + s + '"'));
                            return {
                                levels: 0 < o.length && o.length < n.length ? o : n,
                                sessionData: h ? l : null,
                                sessionKeys: d.length ? d : null
                            }
                        }, p.parseMasterPlaylistMedia = function (e, t, i, r) {
                            void 0 === r && (r = []);
                            var s = [], a = 0;
                            for (l.lastIndex = 0; null !== (o = l.exec(e));) {
                                var n, o = new j.AttrList(o[1]);
                                o.TYPE === i && (o = {
                                    attrs: o,
                                    bitrate: 0,
                                    id: a++,
                                    groupId: o["GROUP-ID"],
                                    instreamId: o["INSTREAM-ID"],
                                    name: o.NAME || o.LANGUAGE || "",
                                    type: i,
                                    default: o.bool("DEFAULT"),
                                    autoselect: o.bool("AUTOSELECT"),
                                    forced: o.bool("FORCED"),
                                    lang: o.LANGUAGE,
                                    url: o.URI ? p.resolve(o.URI, t) : ""
                                }, r.length && (h(o, n = p.findGroup(r, o.groupId) || r[0], "audioCodec"), h(o, n, "textCodec")), s.push(o))
                            }
                            return s
                        }, p.parseLevelPlaylist = function (e, t, i, r, s) {
                            var a, n, o, l = new N.LevelDetails(t), d = l.fragments, h = null, c = 0, u = 0, p = 0,
                                f = 0, m = null, g = new O.Fragment(r, t), y = -1, A = !1;
                            for (H.lastIndex = 0, l.m3u8 = e; null !== (a = H.exec(e));) {
                                A && (A = !1, (g = new O.Fragment(r, t)).start = p, g.sn = c, g.cc = f, g.level = i, h && (g.initSegment = h, g.rawProgramDateTime = h.rawProgramDateTime, h.rawProgramDateTime = null));
                                var b = a[1];
                                if (b) {
                                    g.duration = parseFloat(b);
                                    var v = (" " + a[2]).slice(1);
                                    g.title = v || null, g.tagList.push(v ? ["INF", b, v] : ["INF", b])
                                } else if (a[3]) (0, F.isFiniteNumber)(g.duration) && (g.start = p, o && (g.levelkeys = o, v = l.encryptedFragments, !g.levelkeys || !Object.keys(g.levelkeys).some(function (e) {
                                    return g.levelkeys[e].isCommonEncryption
                                }) || v.length && v[v.length - 1].levelkeys === o || v.push(g)), g.sn = c, g.level = i, g.cc = f, g.urlId = s, d.push(g), g.relurl = (" " + a[3]).slice(1), K(g, m), p += (m = g).duration, c++, A = !(u = 0)); else if (a[4]) {
                                    b = (" " + a[4]).slice(1);
                                    m ? g.setByteRange(b, m) : g.setByteRange(b)
                                } else if (a[5]) g.rawProgramDateTime = (" " + a[5]).slice(1), g.tagList.push(["PROGRAM-DATE-TIME", g.rawProgramDateTime]), -1 === y && (y = d.length); else if (a = a[0].match(W)) {
                                    for (n = 1; n < a.length && void 0 === a[n]; n++) ;
                                    var _ = (" " + a[n]).slice(1), w = (" " + a[n + 1]).slice(1),
                                        S = a[n + 2] ? (" " + a[n + 2]).slice(1) : "";
                                    switch (_) {
                                        case"PLAYLIST-TYPE":
                                            l.type = w.toUpperCase();
                                            break;
                                        case"MEDIA-SEQUENCE":
                                            c = l.startSN = parseInt(w);
                                            break;
                                        case"SKIP":
                                            var E = new j.AttrList(w), T = E.decimalInteger("SKIPPED-SEGMENTS");
                                            if ((0, F.isFiniteNumber)(T)) {
                                                for (var k = l.skippedSegments = T; k--;) d.unshift(null);
                                                c += T
                                            }
                                            T = E.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                                            T && (l.recentlyRemovedDateranges = T.split("\t"));
                                            break;
                                        case"TARGETDURATION":
                                            l.targetduration = parseFloat(w);
                                            break;
                                        case"VERSION":
                                            l.version = parseInt(w);
                                            break;
                                        case"EXTM3U":
                                            break;
                                        case"ENDLIST":
                                            l.live = !1;
                                            break;
                                        case"#":
                                            (w || S) && g.tagList.push(S ? [w, S] : [w]);
                                            break;
                                        case"DISCONTINUITY":
                                            f++, g.tagList.push(["DIS"]);
                                            break;
                                        case"GAP":
                                            g.tagList.push([_]);
                                            break;
                                        case"BITRATE":
                                            g.tagList.push([_, w]);
                                            break;
                                        case"DATERANGE":
                                            E = new j.AttrList(w), T = new M.DateRange(E, l.dateRanges[E.ID]);
                                            T.isValid || l.skippedSegments ? l.dateRanges[T.id] = T : z.logger.warn('Ignoring invalid DATERANGE tag: "' + w + '"'), g.tagList.push(["EXT-X-DATERANGE", w]);
                                            break;
                                        case"DISCONTINUITY-SEQUENCE":
                                            f = parseInt(w);
                                            break;
                                        case"KEY":
                                            var x = V(w, t);
                                            if (x.isSupported()) {
                                                if ("NONE" === x.method) {
                                                    o = void 0;
                                                    break
                                                }
                                                (o = (o = o || {})[x.keyFormat] ? G({}, o) : o)[x.keyFormat] = x
                                            } else z.logger.warn('[Keys] Ignoring invalid EXT-X-KEY tag: "' + w + '"');
                                            break;
                                        case"START":
                                            x = new j.AttrList(w).decimalFloatingPoint("TIME-OFFSET");
                                            (0, F.isFiniteNumber)(x) && (l.startTimeOffset = x);
                                            break;
                                        case"MAP":
                                            var C = new j.AttrList(w);
                                            g.duration ? ($(L = new O.Fragment(r, t), C, i, o), (g.initSegment = h = L).rawProgramDateTime && !g.rawProgramDateTime && (g.rawProgramDateTime = h.rawProgramDateTime)) : ($(g, C, i, o), h = g, A = !0);
                                            break;
                                        case"SERVER-CONTROL":
                                            var L = new j.AttrList(w);
                                            l.canBlockReload = L.bool("CAN-BLOCK-RELOAD"), l.canSkipUntil = L.optionalFloat("CAN-SKIP-UNTIL", 0), l.canSkipDateRanges = 0 < l.canSkipUntil && L.bool("CAN-SKIP-DATERANGES"), l.partHoldBack = L.optionalFloat("PART-HOLD-BACK", 0), l.holdBack = L.optionalFloat("HOLD-BACK", 0);
                                            break;
                                        case"PART-INF":
                                            C = new j.AttrList(w);
                                            l.partTarget = C.decimalFloatingPoint("PART-TARGET");
                                            break;
                                        case"PART":
                                            var D = (D = l.partList) || (l.partList = []),
                                                I = 0 < u ? D[D.length - 1] : void 0, R = u++,
                                                R = new O.Part(new j.AttrList(w), g, t, R, I);
                                            D.push(R), g.duration += R.duration;
                                            break;
                                        case"PRELOAD-HINT":
                                            I = new j.AttrList(w);
                                            l.preloadHint = I;
                                            break;
                                        case"RENDITION-REPORT":
                                            D = new j.AttrList(w);
                                            l.renditionReports = l.renditionReports || [], l.renditionReports.push(D);
                                            break;
                                        default:
                                            z.logger.warn("line parsed but not handled: " + a)
                                    }
                                } else z.logger.warn("No matches on slow regex match for level playlist!")
                            }
                            m && !m.relurl ? (d.pop(), p -= m.duration, l.partList && (l.fragmentHint = m)) : l.partList && (K(g, m), g.cc = f, l.fragmentHint = g);
                            var P = d.length, B = d[0], U = d[P - 1];
                            return 0 < (p += l.skippedSegments * l.targetduration) && P && U ? (l.averagetargetduration = p / P, P = U.sn, l.endSN = "initSegment" !== P ? P : 0, l.live || (U.endList = !0), B && (l.startCC = B.cc)) : (l.endSN = 0, l.startCC = 0), l.fragmentHint && (p += l.fragmentHint.duration), l.totalduration = p, l.endCC = f, 0 < y && function (e, t) {
                                for (var i = e[t], r = t; r--;) {
                                    var s = e[r];
                                    if (!s) return;
                                    s.programDateTime = i.programDateTime - 1e3 * s.duration, i = s
                                }
                            }(d, y), l
                        }, p);

                    function p() {
                    }

                    function V(e, t) {
                        var e = new j.AttrList(e), i = null != (i = e.enumeratedString("METHOD")) ? i : "", r = e.URI,
                            s = e.hexadecimalInteger("IV"), a = e.enumeratedString("KEYFORMATVERSIONS"),
                            n = null != (n = e.enumeratedString("KEYFORMAT")) ? n : "identity",
                            e = (r && e.IV && !s && z.logger.error("Invalid IV: " + e.IV), r ? d.resolve(r, t) : ""),
                            r = (a || "1").split("/").map(Number).filter(Number.isFinite);
                        return new o.LevelKey(i, e, n, r, s)
                    }

                    function h(e, t, i) {
                        t = t[i];
                        t && (e[i] = t)
                    }

                    function K(e, t) {
                        e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), (0, F.isFiniteNumber)(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null)
                    }

                    function $(e, t, i, r) {
                        e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = i, e.sn = "initSegment", r && (e.levelkeys = r), e.initSegment = null
                    }
                }, "./src/loader/playlist-loader.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => s});
                    var h = i("./src/polyfills/number.ts"), u = i("./src/events.ts"), c = i("./src/errors.ts"),
                        p = i("./src/utils/logger.ts"), f = i("./src/loader/m3u8-parser.ts"),
                        m = i("./src/types/loader.ts"), g = i("./src/utils/attr-list.ts");

                    function y(e, t) {
                        e = e.url;
                        return e = void 0 !== e && 0 !== e.indexOf("data:") ? e : t.url
                    }

                    function r(e) {
                        this.hls = void 0, this.loaders = Object.create(null), this.hls = e, this.registerListeners()
                    }

                    (t = r.prototype).startLoad = function (e) {
                    }, t.stopLoad = function () {
                        this.destroyInternalLoaders()
                    }, t.registerListeners = function () {
                        var e = this.hls;
                        e.on(u.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.on(u.Events.LEVEL_LOADING, this.onLevelLoading, this), e.on(u.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(u.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                    }, t.unregisterListeners = function () {
                        var e = this.hls;
                        e.off(u.Events.MANIFEST_LOADING, this.onManifestLoading, this), e.off(u.Events.LEVEL_LOADING, this.onLevelLoading, this), e.off(u.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(u.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                    }, t.createInternalLoader = function (e) {
                        var t = this.hls.config, i = t.pLoader, r = t.loader, i = new (i || r)(t);
                        return e.loader = i, this.loaders[e.type] = i
                    }, t.getInternalLoader = function (e) {
                        return this.loaders[e.type]
                    }, t.resetInternalLoader = function (e) {
                        this.loaders[e] && delete this.loaders[e]
                    }, t.destroyInternalLoaders = function () {
                        for (var e in this.loaders) {
                            var t = this.loaders[e];
                            t && t.destroy(), this.resetInternalLoader(e)
                        }
                    }, t.destroy = function () {
                        this.unregisterListeners(), this.destroyInternalLoaders()
                    }, t.onManifestLoading = function (e, t) {
                        t = t.url;
                        this.load({
                            id: null,
                            groupId: null,
                            level: 0,
                            responseType: "text",
                            type: m.PlaylistContextType.MANIFEST,
                            url: t,
                            deliveryDirectives: null
                        })
                    }, t.onLevelLoading = function (e, t) {
                        var i = t.id, r = t.level, s = t.url, t = t.deliveryDirectives;
                        this.load({
                            id: i,
                            groupId: null,
                            level: r,
                            responseType: "text",
                            type: m.PlaylistContextType.LEVEL,
                            url: s,
                            deliveryDirectives: t
                        })
                    }, t.onAudioTrackLoading = function (e, t) {
                        var i = t.id, r = t.groupId, s = t.url, t = t.deliveryDirectives;
                        this.load({
                            id: i,
                            groupId: r,
                            level: null,
                            responseType: "text",
                            type: m.PlaylistContextType.AUDIO_TRACK,
                            url: s,
                            deliveryDirectives: t
                        })
                    }, t.onSubtitleTrackLoading = function (e, t) {
                        var i = t.id, r = t.groupId, s = t.url, t = t.deliveryDirectives;
                        this.load({
                            id: i,
                            groupId: r,
                            level: null,
                            responseType: "text",
                            type: m.PlaylistContextType.SUBTITLE_TRACK,
                            url: s,
                            deliveryDirectives: t
                        })
                    }, t.load = function (e) {
                        var t, i, r, s, a = this.hls.config;
                        if (o = this.getInternalLoader(e)) {
                            var n = o.context;
                            if (n && n.url === e.url) return void p.logger.trace("[playlist-loader]: playlist request ongoing");
                            p.logger.log("[playlist-loader]: aborting previous loader for type: " + e.type), o.abort()
                        }
                        switch (e.type) {
                            case m.PlaylistContextType.MANIFEST:
                                t = a.manifestLoadingMaxRetry, i = a.manifestLoadingTimeOut, r = a.manifestLoadingRetryDelay, s = a.manifestLoadingMaxRetryTimeout;
                                break;
                            case m.PlaylistContextType.LEVEL:
                            case m.PlaylistContextType.AUDIO_TRACK:
                            case m.PlaylistContextType.SUBTITLE_TRACK:
                                t = 0, i = a.levelLoadingTimeOut;
                                break;
                            default:
                                t = a.levelLoadingMaxRetry, i = a.levelLoadingTimeOut, r = a.levelLoadingRetryDelay, s = a.levelLoadingMaxRetryTimeout
                        }
                        var o = this.createInternalLoader(e),
                            n = (null != (n = e.deliveryDirectives) && n.part && (e.type === m.PlaylistContextType.LEVEL && null !== e.level ? l = this.hls.levels[e.level].details : e.type === m.PlaylistContextType.AUDIO_TRACK && null !== e.id ? l = this.hls.audioTracks[e.id].details : e.type === m.PlaylistContextType.SUBTITLE_TRACK && null !== e.id && (l = this.hls.subtitleTracks[e.id].details), l) && (n = l.partTarget, l = l.targetduration, n && l && (i = Math.min(1e3 * Math.max(3 * n, .8 * l), i))), {
                                timeout: i,
                                maxRetry: t,
                                retryDelay: r,
                                maxRetryDelay: s,
                                highWaterMark: 0
                            }), l = {
                                onSuccess: this.loadsuccess.bind(this),
                                onError: this.loaderror.bind(this),
                                onTimeout: this.loadtimeout.bind(this)
                            };
                        o.load(e, n, l)
                    }, t.loadsuccess = function (e, t, i, r) {
                        void 0 === r && (r = null), this.resetInternalLoader(i.type);
                        var s = e.data;
                        0 === s.indexOf("#EXTM3U") ? (t.parsing.start = performance.now(), 0 < s.indexOf("#EXTINF:") || 0 < s.indexOf("#EXT-X-TARGETDURATION:") ? this.handleTrackOrLevelPlaylist(e, t, i, r) : this.handleMasterPlaylist(e, t, i, r)) : this.handleManifestParsingError(e, i, "no EXTM3U delimiter", r)
                    }, t.loaderror = function (e, t, i) {
                        this.handleNetworkError(t, i = void 0 === i ? null : i, !1, e)
                    }, t.loadtimeout = function (e, t, i) {
                        this.handleNetworkError(t, i = void 0 === i ? null : i, !0)
                    }, t.handleMasterPlaylist = function (e, t, i, r) {
                        var s, a, n = this.hls, o = e.data, l = y(e, i), d = f.default.parseMasterPlaylist(o, l),
                            h = d.levels, c = d.sessionData, d = d.sessionKeys;
                        h.length ? (s = h.map(function (e) {
                            return {id: e.attrs.AUDIO, audioCodec: e.audioCodec}
                        }), a = h.map(function (e) {
                            return {id: e.attrs.SUBTITLES, textCodec: e.textCodec}
                        }), s = f.default.parseMasterPlaylistMedia(o, l, "AUDIO", s), a = f.default.parseMasterPlaylistMedia(o, l, "SUBTITLES", a), o = f.default.parseMasterPlaylistMedia(o, l, "CLOSED-CAPTIONS"), s.length && !s.some(function (e) {
                            return !e.url
                        }) && h[0].audioCodec && !h[0].attrs.AUDIO && (p.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), s.unshift({
                            type: "main",
                            name: "main",
                            default: !1,
                            autoselect: !1,
                            forced: !1,
                            id: -1,
                            attrs: new g.AttrList({}),
                            bitrate: 0,
                            url: ""
                        })), n.trigger(u.Events.MANIFEST_LOADED, {
                            levels: h,
                            audioTracks: s,
                            subtitles: a,
                            captions: o,
                            url: l,
                            stats: t,
                            networkDetails: r,
                            sessionData: c,
                            sessionKeys: d
                        })) : this.handleManifestParsingError(e, i, "no level found in manifest", r)
                    }, t.handleTrackOrLevelPlaylist = function (e, t, i, r) {
                        var s = this.hls, a = i.id, n = i.level, o = i.type, l = y(e, i),
                            a = (0, h.isFiniteNumber)(a) ? a : 0, n = (0, h.isFiniteNumber)(n) ? n : a,
                            d = function () {
                                switch (i.type) {
                                    case m.PlaylistContextType.AUDIO_TRACK:
                                        return m.PlaylistLevelType.AUDIO;
                                    case m.PlaylistContextType.SUBTITLE_TRACK:
                                        return m.PlaylistLevelType.SUBTITLE;
                                    default:
                                        return m.PlaylistLevelType.MAIN
                                }
                            }(), n = f.default.parseLevelPlaylist(e.data, l, n, d, a);
                        n.fragments.length ? (o === m.PlaylistContextType.MANIFEST && (d = {
                            attrs: new g.AttrList({}),
                            bitrate: 0,
                            details: n,
                            name: "",
                            url: l
                        }, s.trigger(u.Events.MANIFEST_LOADED, {
                            levels: [d],
                            audioTracks: [],
                            url: l,
                            stats: t,
                            networkDetails: r,
                            sessionData: null,
                            sessionKeys: null
                        })), t.parsing.end = performance.now(), i.levelDetails = n, this.handlePlaylistLoaded(e, t, i, r)) : s.trigger(u.Events.ERROR, {
                            type: c.ErrorTypes.NETWORK_ERROR,
                            details: c.ErrorDetails.LEVEL_EMPTY_ERROR,
                            fatal: !1,
                            url: l,
                            reason: "no fragments found in level",
                            level: "number" == typeof i.level ? i.level : void 0
                        })
                    }, t.handleManifestParsingError = function (e, t, i, r) {
                        this.hls.trigger(u.Events.ERROR, {
                            type: c.ErrorTypes.NETWORK_ERROR,
                            details: c.ErrorDetails.MANIFEST_PARSING_ERROR,
                            fatal: t.type === m.PlaylistContextType.MANIFEST,
                            url: e.url,
                            reason: i,
                            response: e,
                            context: t,
                            networkDetails: r
                        })
                    }, t.handleNetworkError = function (e, t, i, r) {
                        p.logger.warn("[playlist-loader]: A network " + ((i = void 0 === i ? !1 : i) ? "timeout" : "error") + " occurred while loading " + e.type + " level: " + e.level + " id: " + e.id + ' group-id: "' + e.groupId + '"');
                        var s = c.ErrorDetails.UNKNOWN, a = !1, n = this.getInternalLoader(e);
                        switch (e.type) {
                            case m.PlaylistContextType.MANIFEST:
                                s = i ? c.ErrorDetails.MANIFEST_LOAD_TIMEOUT : c.ErrorDetails.MANIFEST_LOAD_ERROR, a = !0;
                                break;
                            case m.PlaylistContextType.LEVEL:
                                s = i ? c.ErrorDetails.LEVEL_LOAD_TIMEOUT : c.ErrorDetails.LEVEL_LOAD_ERROR, a = !1;
                                break;
                            case m.PlaylistContextType.AUDIO_TRACK:
                                s = i ? c.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : c.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, a = !1;
                                break;
                            case m.PlaylistContextType.SUBTITLE_TRACK:
                                s = i ? c.ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : c.ErrorDetails.SUBTITLE_LOAD_ERROR, a = !1
                        }
                        n && this.resetInternalLoader(e.type);
                        n = {
                            type: c.ErrorTypes.NETWORK_ERROR,
                            details: s,
                            fatal: a,
                            url: e.url,
                            loader: n,
                            context: e,
                            networkDetails: t
                        };
                        r && (n.response = r), this.hls.trigger(u.Events.ERROR, n)
                    }, t.handlePlaylistLoaded = function (e, t, i, r) {
                        var s = i.type, a = i.level, n = i.id, o = i.groupId, l = i.loader, d = i.levelDetails,
                            h = i.deliveryDirectives;
                        if (null != d && d.targetduration) {
                            if (l) switch (d.live && (l.getCacheAge && (d.ageHeader = l.getCacheAge() || 0), l.getCacheAge && !isNaN(d.ageHeader) || (d.ageHeader = 0)), s) {
                                case m.PlaylistContextType.MANIFEST:
                                case m.PlaylistContextType.LEVEL:
                                    this.hls.trigger(u.Events.LEVEL_LOADED, {
                                        details: d,
                                        level: a || 0,
                                        id: n || 0,
                                        stats: t,
                                        networkDetails: r,
                                        deliveryDirectives: h
                                    });
                                    break;
                                case m.PlaylistContextType.AUDIO_TRACK:
                                    this.hls.trigger(u.Events.AUDIO_TRACK_LOADED, {
                                        details: d,
                                        id: n || 0,
                                        groupId: o || "",
                                        stats: t,
                                        networkDetails: r,
                                        deliveryDirectives: h
                                    });
                                    break;
                                case m.PlaylistContextType.SUBTITLE_TRACK:
                                    this.hls.trigger(u.Events.SUBTITLE_TRACK_LOADED, {
                                        details: d,
                                        id: n || 0,
                                        groupId: o || "",
                                        stats: t,
                                        networkDetails: r,
                                        deliveryDirectives: h
                                    })
                            }
                        } else this.handleManifestParsingError(e, i, "invalid target duration", r)
                    };
                    const s = r
                }, "./src/polyfills/number.ts": (e, t, i) => {
                    i.r(t), i.d(t, {MAX_SAFE_INTEGER: () => s, isFiniteNumber: () => r});
                    var r = Number.isFinite || function (e) {
                        return "number" == typeof e && isFinite(e)
                    }, s = Number.MAX_SAFE_INTEGER || 9007199254740991
                }, "./src/remux/aac-helper.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    s.getSilentFrame = function (e, t) {
                        return "mp4a.40.2" === e ? 1 === t ? new Uint8Array([0, 200, 0, 128, 35, 128]) : 2 === t ? new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]) : 3 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]) : 4 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]) : 5 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]) : 6 === t ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) : void 0 : 1 === t ? new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) : 2 === t || 3 === t ? new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) : void 0
                    };
                    const r = s;

                    function s() {
                    }
                }, "./src/remux/mp4-generator.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var a = Math.pow(2, 32) - 1, i = (c.init = function () {
                        for (var e in c.types = {
                            avc1: [],
                            avcC: [],
                            btrt: [],
                            dinf: [],
                            dref: [],
                            esds: [],
                            ftyp: [],
                            hdlr: [],
                            mdat: [],
                            mdhd: [],
                            mdia: [],
                            mfhd: [],
                            minf: [],
                            moof: [],
                            moov: [],
                            mp4a: [],
                            ".mp3": [],
                            mvex: [],
                            mvhd: [],
                            pasp: [],
                            sdtp: [],
                            stbl: [],
                            stco: [],
                            stsc: [],
                            stsd: [],
                            stsz: [],
                            stts: [],
                            tfdt: [],
                            tfhd: [],
                            traf: [],
                            trak: [],
                            trun: [],
                            trex: [],
                            tkhd: [],
                            vmhd: [],
                            smhd: []
                        }) c.types.hasOwnProperty(e) && (c.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
                        var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                            i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]),
                            t = (c.HDLR_TYPES = {
                                video: t,
                                audio: i
                            }, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1])),
                            i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),
                            i = (c.STTS = c.STSC = c.STCO = i, c.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), c.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), c.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), c.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), new Uint8Array([105, 115, 111, 109])),
                            r = new Uint8Array([97, 118, 99, 49]), s = new Uint8Array([0, 0, 0, 1]);
                        c.FTYP = c.box(c.types.ftyp, i, s, i, r), c.DINF = c.box(c.types.dinf, c.box(c.types.dref, t))
                    }, c.box = function (e) {
                        for (var t = 8, i = arguments.length, r = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) r[s - 1] = arguments[s];
                        for (var a = r.length, n = a; a--;) t += r[a].byteLength;
                        var o = new Uint8Array(t);
                        for (o[0] = t >> 24 & 255, o[1] = t >> 16 & 255, o[2] = t >> 8 & 255, o[3] = 255 & t, o.set(e, 4), a = 0, t = 8; a < n; a++) o.set(r[a], t), t += r[a].byteLength;
                        return o
                    }, c.hdlr = function (e) {
                        return c.box(c.types.hdlr, c.HDLR_TYPES[e])
                    }, c.mdat = function (e) {
                        return c.box(c.types.mdat, e)
                    }, c.mdhd = function (e, t) {
                        t *= e;
                        var i = Math.floor(t / (1 + a)), t = Math.floor(t % (1 + a));
                        return c.box(c.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 85, 196, 0, 0]))
                    }, c.mdia = function (e) {
                        return c.box(c.types.mdia, c.mdhd(e.timescale, e.duration), c.hdlr(e.type), c.minf(e))
                    }, c.mfhd = function (e) {
                        return c.box(c.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]))
                    }, c.minf = function (e) {
                        return "audio" === e.type ? c.box(c.types.minf, c.box(c.types.smhd, c.SMHD), c.DINF, c.stbl(e)) : c.box(c.types.minf, c.box(c.types.vmhd, c.VMHD), c.DINF, c.stbl(e))
                    }, c.moof = function (e, t, i) {
                        return c.box(c.types.moof, c.mfhd(e), c.traf(i, t))
                    }, c.moov = function (e) {
                        for (var t = e.length, i = []; t--;) i[t] = c.trak(e[t]);
                        return c.box.apply(null, [c.types.moov, c.mvhd(e[0].timescale, e[0].duration)].concat(i).concat(c.mvex(e)))
                    }, c.mvex = function (e) {
                        for (var t = e.length, i = []; t--;) i[t] = c.trex(e[t]);
                        return c.box.apply(null, [c.types.mvex].concat(i))
                    }, c.mvhd = function (e, t) {
                        t *= e;
                        var i = Math.floor(t / (1 + a)), t = Math.floor(t % (1 + a)),
                            e = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                        return c.box(c.types.mvhd, e)
                    }, c.sdtp = function (e) {
                        for (var t, i = e.samples || [], r = new Uint8Array(4 + i.length), s = 0; s < i.length; s++) t = i[s].flags, r[s + 4] = t.dependsOn << 4 | t.isDependedOn << 2 | t.hasRedundancy;
                        return c.box(c.types.sdtp, r)
                    }, c.stbl = function (e) {
                        return c.box(c.types.stbl, c.stsd(e), c.box(c.types.stts, c.STTS), c.box(c.types.stsc, c.STSC), c.box(c.types.stsz, c.STSZ), c.box(c.types.stco, c.STCO))
                    }, c.avc1 = function (e) {
                        for (var t, i, r = [], s = [], a = 0; a < e.sps.length; a++) i = (t = e.sps[a]).byteLength, r.push(i >>> 8 & 255), r.push(255 & i), r = r.concat(Array.prototype.slice.call(t));
                        for (a = 0; a < e.pps.length; a++) i = (t = e.pps[a]).byteLength, s.push(i >>> 8 & 255), s.push(255 & i), s = s.concat(Array.prototype.slice.call(t));
                        var n = c.box(c.types.avcC, new Uint8Array([1, r[3], r[4], r[5], 255, 224 | e.sps.length].concat(r).concat([e.pps.length]).concat(s))),
                            o = e.width, l = e.height, d = e.pixelRatio[0], h = e.pixelRatio[1];
                        return c.box(c.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), n, c.box(c.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), c.box(c.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])))
                    }, c.esds = function (e) {
                        var t = e.config.length;
                        return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
                    }, c.mp4a = function (e) {
                        var t = e.samplerate;
                        return c.box(c.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]), c.box(c.types.esds, c.esds(e)))
                    }, c.mp3 = function (e) {
                        var t = e.samplerate;
                        return c.box(c.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]))
                    }, c.stsd = function (e) {
                        return "audio" === e.type ? "mp3" === e.segmentCodec && "mp3" === e.codec ? c.box(c.types.stsd, c.STSD, c.mp3(e)) : c.box(c.types.stsd, c.STSD, c.mp4a(e)) : c.box(c.types.stsd, c.STSD, c.avc1(e))
                    }, c.tkhd = function (e) {
                        var t = e.id, i = e.duration * e.timescale, r = e.width, e = e.height,
                            s = Math.floor(i / (1 + a)), i = Math.floor(i % (1 + a));
                        return c.box(c.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, e >> 8 & 255, 255 & e, 0, 0]))
                    }, c.traf = function (e, t) {
                        var i = c.sdtp(e), r = e.id, s = Math.floor(t / (1 + a)), t = Math.floor(t % (1 + a));
                        return c.box(c.types.traf, c.box(c.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), c.box(c.types.tfdt, new Uint8Array([1, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t])), c.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
                    }, c.trak = function (e) {
                        return e.duration = e.duration || 4294967295, c.box(c.types.trak, c.tkhd(e), c.mdia(e))
                    }, c.trex = function (e) {
                        e = e.id;
                        return c.box(c.types.trex, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
                    }, c.trun = function (e, t) {
                        var i, r, s, a, n, o = e.samples || [], l = o.length, d = 12 + 16 * l, h = new Uint8Array(d);
                        for (h.set(["video" === e.type ? 1 : 0, 0, 15, 1, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, (t += 8 + d) >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), i = 0; i < l; i++) r = (n = o[i]).duration, s = n.size, a = n.flags, n = n.cts, h.set([r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, a.isLeading << 2 | a.dependsOn, a.isDependedOn << 6 | a.hasRedundancy << 4 | a.paddingValue << 1 | a.isNonSync, 61440 & a.degradPrio, 15 & a.degradPrio, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n], 12 + 16 * i);
                        return c.box(c.types.trun, h)
                    }, c.initSegment = function (e) {
                        c.types || c.init();
                        var e = c.moov(e), t = new Uint8Array(c.FTYP.byteLength + e.byteLength);
                        return t.set(c.FTYP), t.set(e, c.FTYP.byteLength), t
                    }, c);

                    function c() {
                    }

                    i.types = void 0, i.HDLR_TYPES = void 0, i.STTS = void 0, i.STSC = void 0, i.STCO = void 0, i.STSZ = void 0, i.VMHD = void 0, i.SMHD = void 0, i.STSD = void 0, i.FTYP = void 0, i.DINF = void 0;
                    const r = i
                }, "./src/remux/mp4-remuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        default: () => r,
                        flushTextTrackMetadataCueSamples: () => S,
                        flushTextTrackUserdataCueSamples: () => E,
                        normalizePts: () => ne
                    });
                    var u = i("./src/polyfills/number.ts"), M = i("./src/remux/aac-helper.ts"),
                        X = i("./src/remux/mp4-generator.ts"), Z = i("./src/events.ts"), ee = i("./src/errors.ts"),
                        te = i("./src/utils/logger.ts"), w = i("./src/types/loader.ts"),
                        ie = i("./src/utils/timescale-conversion.ts");

                    function re() {
                        return (re = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    var se = null, ae = null, r = ((t = s.prototype).destroy = function () {
                    }, t.resetTimeStamp = function (e) {
                        te.logger.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e
                    }, t.resetNextTimestamp = function () {
                        te.logger.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
                    }, t.resetInitSegment = function () {
                        te.logger.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
                    }, t.getVideoStartPts = function (e) {
                        var r = !1, e = e.reduce(function (e, t) {
                            var i = t.pts - e;
                            return i < -4294967296 ? (r = !0, ne(e, t.pts)) : 0 < i ? e : t.pts
                        }, e[0].pts);
                        return r && te.logger.debug("PTS rollover detected"), e
                    }, t.remux = function (e, t, i, r, s, a, n, o) {
                        var l, d, h, c, u, p, f, m = s, g = s, y = -1 < e.pid, A = -1 < t.pid, b = t.samples.length,
                            v = 0 < e.samples.length, _ = n && 0 < b || 1 < b;
                        return (y && !v || A && !_) && !this.ISGenerated && !n || (this.ISGenerated || (h = this.generateIS(e, t, s)), y = this.isVideoContiguous, n = -1, _ && (n = function (e) {
                            for (var t = 0; t < e.length; t++) if (e[t].key) return t;
                            return -1
                        }(t.samples), !y && this.config.forceKeyFrameOnDiscontinuity) && (p = !0, 0 < n ? (te.logger.warn("[mp4-remuxer]: Dropped " + n + " out of " + b + " video samples due to a missing keyframe"), f = this.getVideoStartPts(t.samples), t.samples = t.samples.slice(n), t.dropped += n, f = g += (t.samples[0].pts - f) / t.inputTimeScale) : -1 === n && (te.logger.warn("[mp4-remuxer]: No keyframe found out of " + b + " video samples"), p = !1)), this.ISGenerated && (v && _ && (b = this.getVideoStartPts(t.samples), b = (ne(e.samples[0].pts, b) - b) / t.inputTimeScale, m += Math.max(0, b), g += Math.max(0, -b)), v ? (e.samplerate || (te.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), h = this.generateIS(e, t, s)), d = this.remuxAudio(e, m, this.isAudioContiguous, a, A || _ || o === w.PlaylistLevelType.AUDIO ? g : void 0), _ && (b = d ? d.endPTS - d.startPTS : 0, t.inputTimeScale || (te.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), h = this.generateIS(e, t, s)), l = this.remuxVideo(t, g, y, b))) : _ && (l = this.remuxVideo(t, g, y, 0)), l && (l.firstKeyFrame = n, l.independent = -1 !== n, l.firstKeyFramePTS = f))), this.ISGenerated && (i.samples.length && (u = S(i, s, this._initPTS, this._initDTS)), r.samples.length && (c = E(r, s, this._initPTS))), {
                            audio: d,
                            video: l,
                            initSegment: h,
                            independent: p,
                            text: c,
                            id3: u
                        }
                    }, t.generateIS = function (e, t, i) {
                        var r, s, a, n = e.samples, o = t.samples, l = this.typeSupported, d = {},
                            h = !(0, u.isFiniteNumber)(this._initPTS), c = "audio/mp4";
                        if (h && (a = s = 1 / 0), e.config && n.length && (e.timescale = e.samplerate, "mp3" === e.segmentCodec && (l.mpeg ? (c = "audio/mpeg", e.codec = "") : l.mp3 && (e.codec = "mp3")), d.audio = {
                            id: "audio",
                            container: c,
                            codec: e.codec,
                            initSegment: "mp3" === e.segmentCodec && l.mpeg ? new Uint8Array(0) : X.default.initSegment([e]),
                            metadata: {channelCount: e.channelCount}
                        }, h && (r = e.inputTimeScale, a = s = n[0].pts - Math.round(r * i))), t.sps && t.pps && o.length && (t.timescale = t.inputTimeScale, d.video = {
                            id: "main",
                            container: "video/mp4",
                            codec: t.codec,
                            initSegment: X.default.initSegment([t]),
                            metadata: {width: t.width, height: t.height}
                        }, h) && (r = t.inputTimeScale, c = this.getVideoStartPts(o), l = Math.round(r * i), s = Math.min(s, ne(o[0].dts, c) - l), a = Math.min(a, c - l)), Object.keys(d).length) return this.ISGenerated = !0, h && (this._initPTS = a, this._initDTS = s), {
                            tracks: d,
                            initPTS: a,
                            timescale: r
                        }
                    }, t.remuxVideo = function (e, t, i, r) {
                        var s = e.inputTimeScale, a = e.samples, n = [], o = a.length, l = this._initPTS,
                            d = this.nextAvcDts, h = 8, c = this.videoSampleDuration, u = Number.POSITIVE_INFINITY,
                            p = Number.NEGATIVE_INFINITY, f = !1;
                        i && null !== d || (d = t * s - (a[0].pts - ne(a[0].dts, a[0].pts)));
                        for (var m = 0; m < o; m++) {
                            var g = a[m];
                            g.pts = ne(g.pts - l, d), g.dts = ne(g.dts - l, d), g.dts < a[0 < m ? m - 1 : m].dts && (f = !0)
                        }
                        f && a.sort(function (e, t) {
                            var i = e.dts - t.dts, e = e.pts - t.pts;
                            return i || e
                        }), y = a[0].dts;
                        var y, t = a[a.length - 1].dts - y,
                            A = t ? Math.round(t / (o - 1)) : c || e.inputTimeScale / 30;
                        i && (i = (t = y - d) < -1, ((T = A < t) || i) && (T ? te.logger.warn("AVC: " + (0, ie.toMsFromMpegTsClock)(t, !0) + " ms (" + t + "dts) hole between fragments detected, filling it") : te.logger.warn("AVC: " + (0, ie.toMsFromMpegTsClock)(-t, !0) + " ms (" + t + "dts) overlapping between fragments detected"), !i || d > a[0].pts) && (y = d, T = a[0].pts - t, a[0].dts = y, a[0].pts = T, te.logger.log("Video: First PTS/DTS adjusted: " + (0, ie.toMsFromMpegTsClock)(T, !0) + "/" + (0, ie.toMsFromMpegTsClock)(y, !0) + ", delta: " + (0, ie.toMsFromMpegTsClock)(t, !0) + " ms"))), y = Math.max(0, y);
                        for (var b = 0, F = 0, v = 0; v < o; v++) {
                            for (var _ = a[v], M = _.units, O = M.length, w = 0, S = 0; S < O; S++) w += M[S].data.length;
                            F += w, b += O, _.length = w, _.dts = Math.max(_.dts, y), u = Math.min(_.pts, u), p = Math.max(_.pts, p)
                        }
                        var E, i = a[o - 1].dts, T = F + 4 * b + 8;
                        try {
                            E = new Uint8Array(T)
                        } catch (e) {
                            return void this.observer.emit(Z.Events.ERROR, Z.Events.ERROR, {
                                type: ee.ErrorTypes.MUX_ERROR,
                                details: ee.ErrorDetails.REMUX_ALLOC_ERROR,
                                fatal: !1,
                                bytes: T,
                                reason: "fail allocating video mdat " + T
                            })
                        }
                        var N = new DataView(E.buffer);
                        N.setUint32(0, T), E.set(X.default.types.mdat, 4);
                        for (var j = !1, z = Number.POSITIVE_INFINITY, G = Number.POSITIVE_INFINITY, k = Number.NEGATIVE_INFINITY, H = Number.NEGATIVE_INFINITY, x = 0; x < o; x++) {
                            for (var C = a[x], W = C.units, V = 0, L = 0, K = W.length; L < K; L++) {
                                var D = W[L], $ = D.data, D = D.data.byteLength;
                                N.setUint32(h, D), h += 4, E.set($, h), h += D, V += 4 + D
                            }
                            var I, R = void 0,
                                P = (x < o - 1 ? (c = a[x + 1].dts - C.dts, R = a[x + 1].pts - C.pts) : (P = this.config, I = 0 < x ? C.dts - a[x - 1].dts : A, R = 0 < x ? C.pts - a[x - 1].pts : A, P.stretchShortVideoTrack && null !== this.nextAudioPts && Math.floor(P.maxBufferHole * s) < (P = (r ? u + r * s : this.nextAudioPts) - C.pts) ? ((c = P - I) < 0 ? c = I : j = !0, te.logger.log("[mp4-remuxer]: It is approximately " + P / 90 + " ms to the next segment; using duration " + c / 90 + " ms for the last video frame.")) : c = I), Math.round(C.pts - C.dts)),
                                z = Math.min(z, c), k = Math.max(k, c), G = Math.min(G, R), H = Math.max(H, R);
                            n.push(new oe(C.key, c, V, P))
                        }
                        if (n.length) if (se) se < 70 && ((t = n[0].flags).dependsOn = 2, t.isNonSync = 0); else if (ae && H - G < k - z && A / k < .025 && 0 === n[0].cts) {
                            te.logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                            for (var B = y, U = 0, q = n.length; U < q; U++) {
                                var Y, J = B + n[U].duration, Q = B + n[U].cts;
                                U < q - 1 ? (Y = J + n[U + 1].cts, n[U].duration = Y - Q) : n[U].duration = U ? n[U - 1].duration : A, n[U].cts = 0, B = J
                            }
                        }
                        console.assert(null !== c, "mp4SampleDuration must be computed"), this.nextAvcDts = d = i + (c = j || !c ? A : c), this.videoSampleDuration = c, this.isVideoContiguous = !0;
                        T = {
                            data1: X.default.moof(e.sequenceNumber++, y, re({}, e, {samples: n})),
                            data2: E,
                            startPTS: u / s,
                            endPTS: (p + c) / s,
                            startDTS: y / s,
                            endDTS: d / s,
                            type: "video",
                            hasAudio: !1,
                            hasVideo: !0,
                            nb: n.length,
                            dropped: e.dropped
                        };
                        return e.samples = [], e.dropped = 0, console.assert(E.length, "MDAT length must not be zero"), T
                    }, t.remuxAudio = function (e, t, i, r, s) {
                        var a = e.inputTimeScale, n = a / (e.samplerate || a),
                            o = "aac" === e.segmentCodec ? 1024 : 1152, l = o * n, d = this._initPTS,
                            h = "mp3" === e.segmentCodec && this.typeSupported.mpeg, c = [], u = void 0 !== s,
                            p = e.samples, f = h ? 0 : 8, m = this.nextAudioPts || -1, g = t * a;
                        if (this.isAudioContiguous = i = i || p.length && 0 < m && (r && Math.abs(g - m) < 9e3 || Math.abs(ne(p[0].pts - d, g) - m) < 20 * l), p.forEach(function (e) {
                            e.pts = ne(e.pts - d, g)
                        }), !i || m < 0) {
                            if (!(p = p.filter(function (e) {
                                return 0 <= e.pts
                            })).length) return;
                            m = 0 === s ? 0 : r && !u ? Math.max(0, g) : p[0].pts
                        }
                        if ("aac" === e.segmentCodec) for (var y = this.config.maxAudioFramesDrift, A = 0, b = m; A < p.length; A++) {
                            var v = p[A], _ = v.pts, w = _ - b, S = Math.abs(1e3 * w / a);
                            if (w <= -y * l && u) 0 === A && (te.logger.warn("Audio frame @ " + (_ / a).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * w / a) + " ms."), this.nextAudioPts = m = b = _); else if (y * l <= w && S < 1e4 && u) {
                                var E = Math.round(w / l);
                                (b = _ - E * l) < 0 && (E--, b += l), 0 === A && (this.nextAudioPts = m = b), te.logger.warn("[mp4-remuxer]: Injecting " + E + " audio frame @ " + (b / a).toFixed(3) + "s due to " + Math.round(1e3 * w / a) + " ms gap.");
                                for (var T = 0; T < E; T++) {
                                    var k = Math.max(b, 0),
                                        x = M.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                                    x || (te.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), x = v.unit.subarray()), p.splice(A, 0, {
                                        unit: x,
                                        pts: k
                                    }), b += l, A++
                                }
                            }
                            v.pts = b, b += l
                        }
                        for (var C, L = null, D = null, I = 0, R = p.length; R--;) I += p[R].unit.byteLength;
                        for (var P = 0, F = p.length; P < F; P++) {
                            var B = p[P], U = B.unit, B = B.pts;
                            if (null !== D) c[P - 1].duration = Math.round((B - D) / n); else {
                                if (L = B = i && "aac" === e.segmentCodec ? m : B, !(0 < I)) return;
                                I += f;
                                try {
                                    C = new Uint8Array(I)
                                } catch (e) {
                                    return void this.observer.emit(Z.Events.ERROR, Z.Events.ERROR, {
                                        type: ee.ErrorTypes.MUX_ERROR,
                                        details: ee.ErrorDetails.REMUX_ALLOC_ERROR,
                                        fatal: !1,
                                        bytes: I,
                                        reason: "fail allocating audio mdat " + I
                                    })
                                }
                                h || (new DataView(C.buffer).setUint32(0, I), C.set(X.default.types.mdat, 4))
                            }
                            C.set(U, f);
                            U = U.byteLength;
                            f += U, c.push(new oe(!0, o, U, 0)), D = B
                        }
                        t = c.length;
                        if (t) return s = c[c.length - 1], this.nextAudioPts = m = D + n * s.duration, r = {
                            data1: h ? new Uint8Array(0) : X.default.moof(e.sequenceNumber++, L / n, re({}, e, {samples: c})),
                            data2: C,
                            startPTS: r = L / a,
                            endPTS: s = m / a,
                            startDTS: r,
                            endDTS: s,
                            type: "audio",
                            hasAudio: !0,
                            hasVideo: !(e.samples = []),
                            nb: t
                        }, this.isAudioContiguous = !0, console.assert(C.length, "MDAT length must not be zero"), r
                    }, t.remuxEmptyAudio = function (e, t, i, r) {
                        var s = e.inputTimeScale, a = s / (e.samplerate || s), n = this.nextAudioPts,
                            o = (null !== n ? n : r.startDTS * s) + this._initDTS, n = r.endDTS * s + this._initDTS,
                            l = 1024 * a, d = Math.ceil((n - o) / l),
                            h = M.default.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                        if (te.logger.warn("[mp4-remuxer]: remux empty Audio"), h) {
                            for (var c = [], u = 0; u < d; u++) {
                                var p = o + u * l;
                                c.push({unit: h, pts: p, dts: p})
                            }
                            return e.samples = c, this.remuxAudio(e, t, i, !1)
                        }
                        te.logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec")
                    }, s);

                    function s(e, t, i, r) {
                        this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = e, this.config = t, this.typeSupported = i, this.ISGenerated = !1, null === se && (e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i), se = e ? parseInt(e[1]) : 0), null === ae && (t = navigator.userAgent.match(/Safari\/(\d+)/i), ae = t ? parseInt(t[1]) : 0)
                    }

                    function ne(e, t) {
                        var i;
                        if (null === t) return e;
                        for (i = t < e ? -8589934592 : 8589934592; 4294967296 < Math.abs(e - t);) e += i;
                        return e
                    }

                    function S(e, t, i, r) {
                        var s = e.samples.length;
                        if (s) {
                            for (var a = e.inputTimeScale, n = 0; n < s; n++) {
                                var o = e.samples[n];
                                o.pts = ne(o.pts - i, t * a) / a, o.dts = ne(o.dts - r, t * a) / a
                            }
                            var l = e.samples;
                            return e.samples = [], {samples: l}
                        }
                    }

                    function E(e, t, i) {
                        var r = e.samples.length;
                        if (r) {
                            for (var s = e.inputTimeScale, a = 0; a < r; a++) {
                                var n = e.samples[a];
                                n.pts = ne(n.pts - i, t * s) / s
                            }
                            e.samples.sort(function (e, t) {
                                return e.pts - t.pts
                            });
                            var o = e.samples;
                            return e.samples = [], {samples: o}
                        }
                    }

                    var oe = function (e, t, i, r) {
                        this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = i, this.cts = r, this.flags = new a(e)
                    }, a = function (e) {
                        this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e ? 2 : 1, this.isNonSync = e ? 0 : 1
                    }
                }, "./src/remux/passthrough-remuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var u = i("./src/polyfills/number.ts"), p = i("./src/remux/mp4-remuxer.ts"),
                        f = i("./src/utils/mp4-tools.ts"), a = i("./src/loader/fragment.ts"),
                        m = i("./src/utils/logger.ts");

                    function n(e, t) {
                        e = null == e ? void 0 : e.codec;
                        return e && 4 < e.length ? e : "hvc1" === e || "hev1" === e ? "hvc1.1.c.L120.90" : "av01" === e ? "av01.0.04M.08" : "avc1" === e || t === a.ElementaryStreamTypes.VIDEO ? "avc1.42e01e" : "mp4a.40.5"
                    }

                    (t = s.prototype).destroy = function () {
                    }, t.resetTimeStamp = function (e) {
                        this.initPTS = e, this.lastEndTime = null
                    }, t.resetNextTimestamp = function () {
                        this.lastEndTime = null
                    }, t.resetInitSegment = function (e, t, i, r) {
                        this.audioCodec = t, this.videoCodec = i, this.generateInitSegment((0, f.patchEncyptionData)(e, r)), this.emitInitSegment = !0
                    }, t.generateInitSegment = function (e) {
                        var t = this.audioCodec, i = this.videoCodec;
                        if (!e || !e.byteLength) return this.initTracks = void 0, void (this.initData = void 0);
                        var r = this.initData = (0, f.parseInitSegment)(e),
                            t = t || n(r.audio, a.ElementaryStreamTypes.AUDIO),
                            i = i || n(r.video, a.ElementaryStreamTypes.VIDEO), s = {};
                        r.audio && r.video ? s.audiovideo = {
                            container: "video/mp4",
                            codec: t + "," + i,
                            initSegment: e,
                            id: "main"
                        } : r.audio ? s.audio = {
                            container: "audio/mp4",
                            codec: t,
                            initSegment: e,
                            id: "audio"
                        } : r.video ? s.video = {
                            container: "video/mp4",
                            codec: i,
                            initSegment: e,
                            id: "main"
                        } : m.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = s
                    }, t.remux = function (e, t, i, r, s) {
                        var a = this.initPTS, n = this.lastEndTime,
                            o = {audio: void 0, video: void 0, text: r, id3: i, initSegment: void 0},
                            t = ((0, u.isFiniteNumber)(n) || (n = this.lastEndTime = s || 0), t.samples);
                        if (!t || !t.length) return o;
                        var l = {initPTS: void 0, timescale: 1}, d = this.initData;
                        if (d && d.length || (this.generateInitSegment(t), d = this.initData), !d || !d.length) return m.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), o;
                        this.emitInitSegment && (l.tracks = this.initTracks, this.emitInitSegment = !1);
                        var h = (0, f.getStartDTS)(d, t),
                            c = ((0, u.isFiniteNumber)(a) || (this.initPTS = l.initPTS = a = h - s), (0, f.getDuration)(t, d)),
                            e = e ? h - a : n, h = e + c,
                            n = ((0, f.offsetStartDTS)(d, t, a), 0 < c ? this.lastEndTime = h : (m.logger.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp()), !!d.audio),
                            a = !!d.video, c = "", d = (n && (c += "audio"), a && (c += "video"), {
                                data1: t,
                                startPTS: e,
                                startDTS: e,
                                endPTS: h,
                                endDTS: h,
                                type: c,
                                hasAudio: n,
                                hasVideo: a,
                                nb: 1,
                                dropped: 0
                            }),
                            e = (o.audio = "audio" === d.type ? d : void 0, o.video = "audio" !== d.type ? d : void 0, o.initSegment = l, null != (t = this.initPTS) ? t : 0);
                        return o.id3 = (0, p.flushTextTrackMetadataCueSamples)(i, s, e, e), r.samples.length && (o.text = (0, p.flushTextTrackUserdataCueSamples)(r, s, e)), o
                    };
                    const r = s;

                    function s() {
                        this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndTime = null
                    }
                }, "./src/task-loop.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    (i = s.prototype).destroy = function () {
                        this.onHandlerDestroying(), this.onHandlerDestroyed()
                    }, i.onHandlerDestroying = function () {
                        this.clearNextTick(), this.clearInterval()
                    }, i.onHandlerDestroyed = function () {
                    }, i.hasInterval = function () {
                        return !!this._tickInterval
                    }, i.hasNextTick = function () {
                        return !!this._tickTimer
                    }, i.setInterval = function (e) {
                        return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, e), !0)
                    }, i.clearInterval = function () {
                        return !!this._tickInterval && (self.clearInterval(this._tickInterval), !(this._tickInterval = null))
                    }, i.clearNextTick = function () {
                        return !!this._tickTimer && (self.clearTimeout(this._tickTimer), !(this._tickTimer = null))
                    }, i.tick = function () {
                        this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), 1 < this._tickCallCount && this.tickImmediate(), this._tickCallCount = 0)
                    }, i.tickImmediate = function () {
                        this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
                    }, i.doTick = function () {
                    };
                    var r = s;

                    function s() {
                        this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
                    }
                }, "./src/types/cmcd.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        CMCDObjectType: () => r,
                        CMCDStreamType: () => a,
                        CMCDStreamingFormat: () => s,
                        CMCDVersion: () => n
                    });
                    var r, s, a, n = 1;
                    (i = r = r || {}).MANIFEST = "m", i.AUDIO = "a", i.VIDEO = "v", i.MUXED = "av", i.INIT = "i", i.CAPTION = "c", i.TIMED_TEXT = "tt", i.KEY = "k", i.OTHER = "o", (t = s = s || {}).DASH = "d", t.HLS = "h", t.SMOOTH = "s", t.OTHER = "o", (i = a = a || {}).VOD = "v", i.LIVE = "l"
                }, "./src/types/demuxer.ts": (e, t, i) => {
                    var r;
                    i.r(t), i.d(t, {MetadataSchema: () => r}), (i = r = r || {}).audioId3 = "org.id3", i.dateRange = "com.apple.quicktime.HLS", i.emsg = "https://aomedia.org/emsg/ID3"
                }, "./src/types/level.ts": (e, t, i) => {
                    function r(e, t) {
                        for (var i, r = 0; r < t.length; r++) {
                            var s = t[r];
                            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, "symbol" == typeof (i = function (e) {
                                if ("object" != typeof e || null === e) return e;
                                var t = e[Symbol.toPrimitive];
                                if (void 0 === t) return String(e);
                                t = t.call(e, "string");
                                if ("object" != typeof t) return t;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(s.key)) ? i : String(i), s)
                        }
                    }

                    i.r(t), i.d(t, {
                        HdcpLevels: () => a,
                        HlsSkip: () => s,
                        HlsUrlParameters: () => n,
                        Level: () => o,
                        getSkipValue: () => function (e, t) {
                            var i = e.canSkipUntil, r = e.canSkipDateRanges, e = e.endSN;
                            return i && (void 0 !== t ? t - e : 0) < i ? r ? s.v2 : s.Yes : s.No
                        }
                    });
                    var s, a = ["NONE", "TYPE-0", "TYPE-1", "TYPE-2", null];
                    (i = s = s || {}).No = "", i.Yes = "YES", i.v2 = "v2";
                    d.prototype.addDirectives = function (e) {
                        e = new self.URL(e);
                        return void 0 !== this.msn && e.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && e.searchParams.set("_HLS_part", this.part.toString()), this.skip && e.searchParams.set("_HLS_skip", this.skip), e.href
                    };
                    var n = d, o = (r((t = l).prototype, [{
                        key: "maxBitrate", get: function () {
                            return Math.max(this.realBitrate, this.bitrate)
                        }
                    }, {
                        key: "uri", get: function () {
                            return this.url[this._urlId] || ""
                        }
                    }, {
                        key: "urlId", get: function () {
                            return this._urlId
                        }, set: function (e) {
                            e %= this.url.length;
                            this._urlId !== e && (this.details = void 0, this._urlId = e)
                        }
                    }]), Object.defineProperty(t, "prototype", {writable: !1}), l);

                    function l(e) {
                        this.attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e.url], this.attrs = e.attrs, this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.unknownCodecs = e.unknownCodecs, this.codecSet = [e.videoCodec, e.audioCodec].filter(function (e) {
                            return e
                        }).join(",").replace(/\.[^.,]+/g, "")
                    }

                    function d(e, t, i) {
                        this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = i
                    }
                }, "./src/types/loader.ts": (e, t, i) => {
                    var r, s;
                    i.r(t), i.d(t, {
                        PlaylistContextType: () => r,
                        PlaylistLevelType: () => s
                    }), (i = r = r || {}).MANIFEST = "manifest", i.LEVEL = "level", i.AUDIO_TRACK = "audioTrack", i.SUBTITLE_TRACK = "subtitleTrack", (t = s = s || {}).MAIN = "main", t.AUDIO = "audio", t.SUBTITLE = "subtitle"
                }, "./src/types/transmuxer.ts": (e, t, i) => {
                    i.r(t), i.d(t, {ChunkMetadata: () => r});
                    var r = function (e, t, i, r, s, a) {
                        void 0 === r && (r = 0), void 0 === s && (s = -1), void 0 === a && (a = !1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        }, this.buffering = {
                            audio: {start: 0, executeStart: 0, executeEnd: 0, end: 0},
                            video: {start: 0, executeStart: 0, executeEnd: 0, end: 0},
                            audiovideo: {start: 0, executeStart: 0, executeEnd: 0, end: 0}
                        }, this.level = e, this.sn = t, this.id = i, this.size = r, this.part = s, this.partial = a
                    }
                }, "./src/utils/attr-list.ts": (e, t, i) => {
                    i.r(t), i.d(t, {AttrList: () => a});
                    var r = /^(\d+)x(\d+)$/, s = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,
                        a = ((i = n.prototype).decimalInteger = function (e) {
                            e = parseInt(this[e], 10);
                            return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e
                        }, i.hexadecimalInteger = function (e) {
                            if (this[e]) {
                                for (var t = (1 & (t = (this[e] || "0x").slice(2)).length ? "0" : "") + t, i = new Uint8Array(t.length / 2), r = 0; r < t.length / 2; r++) i[r] = parseInt(t.slice(2 * r, 2 * r + 2), 16);
                                return i
                            }
                            return null
                        }, i.hexadecimalIntegerAsNumber = function (e) {
                            e = parseInt(this[e], 16);
                            return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e
                        }, i.decimalFloatingPoint = function (e) {
                            return parseFloat(this[e])
                        }, i.optionalFloat = function (e, t) {
                            e = this[e];
                            return e ? parseFloat(e) : t
                        }, i.enumeratedString = function (e) {
                            return this[e]
                        }, i.bool = function (e) {
                            return "YES" === this[e]
                        }, i.decimalResolution = function (e) {
                            e = r.exec(this[e]);
                            if (null !== e) return {width: parseInt(e[1], 10), height: parseInt(e[2], 10)}
                        }, n.parseAttrList = function (e) {
                            var t, i = {};
                            for (s.lastIndex = 0; null !== (t = s.exec(e));) {
                                var r = t[2];
                                0 === r.indexOf('"') && r.lastIndexOf('"') === r.length - 1 && (r = r.slice(1, -1)), i[t[1]] = r
                            }
                            return i
                        }, n);

                    function n(e) {
                        for (var t in e = "string" == typeof e ? n.parseAttrList(e) : e) e.hasOwnProperty(t) && (this[t] = e[t])
                    }
                }, "./src/utils/binary-search.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    const r = {
                        search: function (e, t) {
                            for (var i, r, s = 0, a = e.length - 1; s <= a;) {
                                var n = t(r = e[i = (s + a) / 2 | 0]);
                                if (0 < n) s = 1 + i; else {
                                    if (!(n < 0)) return r;
                                    a = i - 1
                                }
                            }
                            return null
                        }
                    }
                }, "./src/utils/buffer-helper.ts": (e, t, i) => {
                    i.r(t), i.d(t, {BufferHelper: () => a});
                    var r = i("./src/utils/logger.ts"), s = {
                        length: 0, start: function () {
                            return 0
                        }, end: function () {
                            return 0
                        }
                    }, a = (n.isBuffered = function (e, t) {
                        try {
                            if (e) for (var i = n.getBuffered(e), r = 0; r < i.length; r++) if (t >= i.start(r) && t <= i.end(r)) return !0
                        } catch (e) {
                        }
                        return !1
                    }, n.bufferInfo = function (e, t, i) {
                        try {
                            if (e) {
                                for (var r = n.getBuffered(e), s = [], a = 0; a < r.length; a++) s.push({
                                    start: r.start(a),
                                    end: r.end(a)
                                });
                                return this.bufferedInfo(s, t, i)
                            }
                        } catch (e) {
                        }
                        return {len: 0, start: t, end: t, nextStart: void 0}
                    }, n.bufferedInfo = function (e, t, i) {
                        t = Math.max(0, t), e.sort(function (e, t) {
                            return e.start - t.start || t.end - e.end
                        });
                        var r = [];
                        if (i) for (var s = 0; s < e.length; s++) {
                            var a, n = r.length;
                            n ? (a = r[n - 1].end, e[s].start - a < i ? e[s].end > a && (r[n - 1].end = e[s].end) : r.push(e[s])) : r.push(e[s])
                        } else r = e;
                        for (var o, l = 0, d = t, h = t, c = 0; c < r.length; c++) {
                            var u = r[c].start, p = r[c].end;
                            if (u <= t + i && t < p) d = u, l = (h = p) - t; else if (t + i < u) {
                                o = u;
                                break
                            }
                        }
                        return {len: l, start: d || 0, end: h || 0, nextStart: o}
                    }, n.getBuffered = function (e) {
                        try {
                            return e.buffered
                        } catch (e) {
                            return r.logger.log("failed to get media.buffered", e), s
                        }
                    }, n);

                    function n() {
                    }
                }, "./src/utils/cea-608-parser.ts": (e, t, i) => {
                    i.r(t), i.d(t, {CaptionScreen: () => b, Row: () => A, default: () => L});

                    function a(e) {
                        var t = e;
                        return s.hasOwnProperty(e) && (t = s[e]), String.fromCharCode(t)
                    }

                    function l(e) {
                        for (var t = [], i = 0; i < e.length; i++) t.push(e[i].toString(16));
                        return t
                    }

                    var d, r = i("./src/utils/logger.ts"), s = {
                            42: 225,
                            92: 233,
                            94: 237,
                            95: 243,
                            96: 250,
                            123: 231,
                            124: 247,
                            125: 209,
                            126: 241,
                            127: 9608,
                            128: 174,
                            129: 176,
                            130: 189,
                            131: 191,
                            132: 8482,
                            133: 162,
                            134: 163,
                            135: 9834,
                            136: 224,
                            137: 32,
                            138: 232,
                            139: 226,
                            140: 234,
                            141: 238,
                            142: 244,
                            143: 251,
                            144: 193,
                            145: 201,
                            146: 211,
                            147: 218,
                            148: 220,
                            149: 252,
                            150: 8216,
                            151: 161,
                            152: 42,
                            153: 8217,
                            154: 9473,
                            155: 169,
                            156: 8480,
                            157: 8226,
                            158: 8220,
                            159: 8221,
                            160: 192,
                            161: 194,
                            162: 199,
                            163: 200,
                            164: 202,
                            165: 203,
                            166: 235,
                            167: 206,
                            168: 207,
                            169: 239,
                            170: 212,
                            171: 217,
                            172: 249,
                            173: 219,
                            174: 171,
                            175: 187,
                            176: 195,
                            177: 227,
                            178: 205,
                            179: 204,
                            180: 236,
                            181: 210,
                            182: 242,
                            183: 213,
                            184: 245,
                            185: 123,
                            186: 125,
                            187: 92,
                            188: 94,
                            189: 95,
                            190: 124,
                            191: 8764,
                            192: 196,
                            193: 228,
                            194: 214,
                            195: 246,
                            196: 223,
                            197: 165,
                            198: 164,
                            199: 9475,
                            200: 197,
                            201: 229,
                            202: 216,
                            203: 248,
                            204: 9487,
                            205: 9491,
                            206: 9495,
                            207: 9499
                        }, h = 15, n = 100, o = {17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14},
                        c = {17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15},
                        u = {25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14},
                        p = {25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15},
                        f = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"],
                        m = ((t = d = d || {})[t.ERROR = 0] = "ERROR", t[t.TEXT = 1] = "TEXT", t[t.WARNING = 2] = "WARNING", t[t.INFO = 2] = "INFO", t[t.DEBUG = 3] = "DEBUG", t[t.DATA = 3] = "DATA", k.prototype.log = function (e, t) {
                            this.verboseLevel >= e && (t = "function" == typeof t ? t() : t, r.logger.log(this.time + " [" + e + "] " + t))
                        }, k), g = ((i = T.prototype).reset = function () {
                            this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
                        }, i.setStyles = function (e) {
                            for (var t = ["foreground", "underline", "italics", "background", "flash"], i = 0; i < t.length; i++) {
                                var r = t[i];
                                e.hasOwnProperty(r) && (this[r] = e[r])
                            }
                        }, i.isDefault = function () {
                            return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
                        }, i.equals = function (e) {
                            return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
                        }, i.copy = function (e) {
                            this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
                        }, i.toString = function () {
                            return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
                        }, T), y = ((t = E.prototype).reset = function () {
                            this.uchar = " ", this.penState.reset()
                        }, t.setChar = function (e, t) {
                            this.uchar = e, this.penState.copy(t)
                        }, t.setPenState = function (e) {
                            this.penState.copy(e)
                        }, t.equals = function (e) {
                            return this.uchar === e.uchar && this.penState.equals(e.penState)
                        }, t.copy = function (e) {
                            this.uchar = e.uchar, this.penState.copy(e.penState)
                        }, t.isEmpty = function () {
                            return " " === this.uchar && this.penState.isDefault()
                        }, E), A = ((i = S.prototype).equals = function (e) {
                            for (var t = !0, i = 0; i < n; i++) if (!this.chars[i].equals(e.chars[i])) {
                                t = !1;
                                break
                            }
                            return t
                        }, i.copy = function (e) {
                            for (var t = 0; t < n; t++) this.chars[t].copy(e.chars[t])
                        }, i.isEmpty = function () {
                            for (var e = !0, t = 0; t < n; t++) if (!this.chars[t].isEmpty()) {
                                e = !1;
                                break
                            }
                            return e
                        }, i.setCursor = function (e) {
                            this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(d.DEBUG, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > n && (this.logger.log(d.DEBUG, "Too large cursor position " + this.pos), this.pos = n)
                        }, i.moveCursor = function (e) {
                            var t = this.pos + e;
                            if (1 < e) for (var i = this.pos + 1; i < t + 1; i++) this.chars[i].setPenState(this.currPenState);
                            this.setCursor(t)
                        }, i.backSpace = function () {
                            this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
                        }, i.insertChar = function (e) {
                            var t = this, i = (144 <= e && this.backSpace(), a(e));
                            this.pos >= n ? this.logger.log(d.ERROR, function () {
                                return "Cannot insert " + e.toString(16) + " (" + i + ") at position " + t.pos + ". Skipping it!"
                            }) : (this.chars[this.pos].setChar(i, this.currPenState), this.moveCursor(1))
                        }, i.clearFromPos = function (e) {
                            for (var t = e; t < n; t++) this.chars[t].reset()
                        }, i.clear = function () {
                            this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
                        }, i.clearToEndOfRow = function () {
                            this.clearFromPos(this.pos)
                        }, i.getTextString = function () {
                            for (var e = [], t = !0, i = 0; i < n; i++) {
                                var r = this.chars[i].uchar;
                                " " !== r && (t = !1), e.push(r)
                            }
                            return t ? "" : e.join("")
                        }, i.setPenStyles = function (e) {
                            this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState)
                        }, S), b = ((t = w.prototype).reset = function () {
                            for (var e = 0; e < h; e++) this.rows[e].clear();
                            this.currRow = 14
                        }, t.equals = function (e) {
                            for (var t = !0, i = 0; i < h; i++) if (!this.rows[i].equals(e.rows[i])) {
                                t = !1;
                                break
                            }
                            return t
                        }, t.copy = function (e) {
                            for (var t = 0; t < h; t++) this.rows[t].copy(e.rows[t])
                        }, t.isEmpty = function () {
                            for (var e = !0, t = 0; t < h; t++) if (!this.rows[t].isEmpty()) {
                                e = !1;
                                break
                            }
                            return e
                        }, t.backSpace = function () {
                            this.rows[this.currRow].backSpace()
                        }, t.clearToEndOfRow = function () {
                            this.rows[this.currRow].clearToEndOfRow()
                        }, t.insertChar = function (e) {
                            this.rows[this.currRow].insertChar(e)
                        }, t.setPen = function (e) {
                            this.rows[this.currRow].setPenStyles(e)
                        }, t.moveCursor = function (e) {
                            this.rows[this.currRow].moveCursor(e)
                        }, t.setCursor = function (e) {
                            this.logger.log(d.INFO, "setCursor: " + e), this.rows[this.currRow].setCursor(e)
                        }, t.setPAC = function (e) {
                            this.logger.log(d.INFO, function () {
                                return "pacData = " + JSON.stringify(e)
                            });
                            var t = e.row - 1;
                            if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
                                for (var i = 0; i < h; i++) this.rows[i].clear();
                                var r = this.currRow + 1 - this.nrRollUpRows, s = this.lastOutputScreen;
                                if (s) {
                                    var a = s.rows[r].cueStartTime, n = this.logger.time;
                                    if (a && null !== n && a < n) for (var o = 0; o < this.nrRollUpRows; o++) this.rows[t - this.nrRollUpRows + o + 1].copy(s.rows[r + o])
                                }
                            }
                            this.currRow = t;
                            a = this.rows[this.currRow], null !== e.indent && (n = e.indent, n = Math.max(n - 1, 0), a.setCursor(e.indent), e.color = a.chars[n].penState.foreground), a = {
                                foreground: e.color,
                                underline: e.underline,
                                italics: e.italics,
                                background: "black",
                                flash: !1
                            };
                            this.setPen(a)
                        }, t.setBkgData = function (e) {
                            this.logger.log(d.INFO, function () {
                                return "bkgData = " + JSON.stringify(e)
                            }), this.backSpace(), this.setPen(e), this.insertChar(32)
                        }, t.setRollUpRows = function (e) {
                            this.nrRollUpRows = e
                        }, t.rollUp = function () {
                            var e, t = this;
                            null !== this.nrRollUpRows ? (this.logger.log(d.TEXT, function () {
                                return t.getDisplayText()
                            }), e = this.currRow + 1 - this.nrRollUpRows, (e = this.rows.splice(e, 1)[0]).clear(), this.rows.splice(this.currRow, 0, e), this.logger.log(d.INFO, "Rolling up")) : this.logger.log(d.DEBUG, "roll_up but nrRollUpRows not set yet")
                        }, t.getDisplayText = function (e) {
                            e = e || !1;
                            for (var t = [], i = "", r = 0; r < h; r++) {
                                var s = this.rows[r].getTextString();
                                s && (e ? t.push("Row " + (r + 1) + ": '" + s + "'") : t.push(s.trim()))
                            }
                            return i = 0 < t.length ? e ? "[" + t.join(" | ") + "]" : t.join("\n") : i
                        }, t.getTextAndFormat = function () {
                            return this.rows
                        }, w), v = ((i = _.prototype).reset = function () {
                            this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
                        }, i.getHandler = function () {
                            return this.outputFilter
                        }, i.setHandler = function (e) {
                            this.outputFilter = e
                        }, i.setPAC = function (e) {
                            this.writeScreen.setPAC(e)
                        }, i.setBkgData = function (e) {
                            this.writeScreen.setBkgData(e)
                        }, i.setMode = function (e) {
                            e !== this.mode && (this.mode = e, this.logger.log(d.INFO, function () {
                                return "MODE=" + e
                            }), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
                        }, i.insertChars = function (e) {
                            for (var t = this, i = 0; i < e.length; i++) this.writeScreen.insertChar(e[i]);
                            var r = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                            this.logger.log(d.INFO, function () {
                                return r + ": " + t.writeScreen.getDisplayText(!0)
                            }), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(d.TEXT, function () {
                                return "DISPLAYED: " + t.displayedMemory.getDisplayText(!0)
                            }), this.outputDataUpdate())
                        }, i.ccRCL = function () {
                            this.logger.log(d.INFO, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
                        }, i.ccBS = function () {
                            this.logger.log(d.INFO, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
                        }, i.ccAOF = function () {
                        }, i.ccAON = function () {
                        }, i.ccDER = function () {
                            this.logger.log(d.INFO, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
                        }, i.ccRU = function (e) {
                            this.logger.log(d.INFO, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
                        }, i.ccFON = function () {
                            this.logger.log(d.INFO, "FON - Flash On"), this.writeScreen.setPen({flash: !0})
                        }, i.ccRDC = function () {
                            this.logger.log(d.INFO, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
                        }, i.ccTR = function () {
                            this.logger.log(d.INFO, "TR"), this.setMode("MODE_TEXT")
                        }, i.ccRTD = function () {
                            this.logger.log(d.INFO, "RTD"), this.setMode("MODE_TEXT")
                        }, i.ccEDM = function () {
                            this.logger.log(d.INFO, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
                        }, i.ccCR = function () {
                            this.logger.log(d.INFO, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
                        }, i.ccENM = function () {
                            this.logger.log(d.INFO, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
                        }, i.ccEOC = function () {
                            var e, t = this;
                            this.logger.log(d.INFO, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode && (e = this.displayedMemory, this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(d.TEXT, function () {
                                return "DISP: " + t.displayedMemory.getDisplayText()
                            })), this.outputDataUpdate(!0)
                        }, i.ccTO = function (e) {
                            this.logger.log(d.INFO, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
                        }, i.ccMIDROW = function (e) {
                            var t = {flash: !1};
                            t.underline = e % 2 == 1, t.italics = 46 <= e, t.italics ? t.foreground = "white" : (e = Math.floor(e / 2) - 16, t.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][e]), this.logger.log(d.INFO, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t)
                        }, i.outputDataUpdate = function (e) {
                            void 0 === e && (e = !1);
                            var t = this.logger.time;
                            null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory))
                        }, i.cueSplitAtTime = function (e) {
                            !this.outputFilter || this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e)
                        }, _);

                    function _(e, t, i) {
                        this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new b(i), this.nonDisplayedMemory = new b(i), this.lastOutputScreen = new b(i), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i
                    }

                    function w(e) {
                        this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
                        for (var t = 0; t < h; t++) this.rows.push(new A(e));
                        this.logger = e, this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset()
                    }

                    function S(e) {
                        this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
                        for (var t = 0; t < n; t++) this.chars.push(new y);
                        this.logger = e, this.pos = 0, this.currPenState = new g
                    }

                    function E(e, t, i, r, s, a) {
                        this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new g(t, i, r, s, a)
                    }

                    function T(e, t, i, r, s) {
                        this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = t || !1, this.italics = i || !1, this.background = r || "black", this.flash = s || !1
                    }

                    function k() {
                        this.time = null, this.verboseLevel = d.ERROR
                    }

                    function x(e, t, i) {
                        i.a = e, i.b = t
                    }

                    function C(e, t, i) {
                        return i.a === e && i.b === t
                    }

                    (t = D.prototype).getHandler = function (e) {
                        return this.channels[e].getHandler()
                    }, t.setHandler = function (e, t) {
                        this.channels[e].setHandler(t)
                    }, t.addData = function (e, t) {
                        var i, r = !1;
                        this.logger.time = e;
                        for (var s = 0; s < t.length; s += 2) {
                            var a, n = 127 & t[s], o = 127 & t[s + 1];
                            0 == n && 0 == o || (this.logger.log(d.DATA, "[" + l([t[s], t[s + 1]]) + "] -> (" + l([n, o]) + ")"), !(i = (i = (i = (i = this.parseCmd(n, o)) ? i : this.parseMidrow(n, o)) || this.parsePAC(n, o)) || this.parseBackgroundAttributes(n, o)) && (r = this.parseChars(n, o)) && ((a = this.currentChannel) && 0 < a ? this.channels[a].insertChars(r) : this.logger.log(d.WARNING, "No channel found yet. TEXT-MODE?")), i || r || this.logger.log(d.WARNING, "Couldn't parse cleaned data " + l([n, o]) + " orig: " + l([t[s], t[s + 1]])))
                        }
                    }, t.parseCmd = function (e, t) {
                        var i = this.cmdHistory;
                        if (!((20 === e || 28 === e || 21 === e || 29 === e) && 32 <= t && t <= 47 || (23 === e || 31 === e) && 33 <= t && t <= 35)) return !1;
                        if (C(e, t, i)) return x(null, null, i), this.logger.log(d.DEBUG, "Repeated command (" + l([e, t]) + ") is dropped"), !0;
                        var r = 20 === e || 21 === e || 23 === e ? 1 : 2, s = this.channels[r];
                        return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? s.ccRCL() : 33 === t ? s.ccBS() : 34 === t ? s.ccAOF() : 35 === t ? s.ccAON() : 36 === t ? s.ccDER() : 37 === t ? s.ccRU(2) : 38 === t ? s.ccRU(3) : 39 === t ? s.ccRU(4) : 40 === t ? s.ccFON() : 41 === t ? s.ccRDC() : 42 === t ? s.ccTR() : 43 === t ? s.ccRTD() : 44 === t ? s.ccEDM() : 45 === t ? s.ccCR() : 46 === t ? s.ccENM() : 47 === t && s.ccEOC() : s.ccTO(t - 32), x(e, t, i), this.currentChannel = r, !0
                    }, t.parseMidrow = function (e, t) {
                        if ((17 === e || 25 === e) && 32 <= t && t <= 47) {
                            if ((i = 17 === e ? 1 : 2) !== this.currentChannel) return this.logger.log(d.ERROR, "Mismatch channel in midrow parsing"), !1;
                            var i = this.channels[i];
                            return !!i && (i.ccMIDROW(t), this.logger.log(d.DEBUG, "MIDROW (" + l([e, t]) + ")"), !0)
                        }
                        return !1
                    }, t.parsePAC = function (e, t) {
                        var i = this.cmdHistory;
                        if (!((17 <= e && e <= 23 || 25 <= e && e <= 31) && 64 <= t && t <= 127 || (16 === e || 24 === e) && 64 <= t && t <= 95)) return !1;
                        if (C(e, t, i)) return x(null, null, i), !0;
                        var r = e <= 23 ? 1 : 2, s = this.channels[r];
                        return !!s && (s.setPAC(this.interpretPAC((64 <= t && t <= 95 ? 1 == r ? o : u : 1 == r ? c : p)[e], t)), x(e, t, i), this.currentChannel = r, !0)
                    }, t.interpretPAC = function (e, t) {
                        e = {
                            color: null,
                            italics: !1,
                            indent: null,
                            underline: !1,
                            row: e
                        }, t = 95 < t ? t - 96 : t - 64;
                        return e.underline = 1 == (1 & t), t <= 13 ? e.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(t / 2)] : t <= 15 ? (e.italics = !0, e.color = "white") : e.indent = 4 * Math.floor((t - 16) / 2), e
                    }, t.parseChars = function (e, t) {
                        var i, r = null, s = null;
                        return 17 <= (s = 25 <= e ? (i = 2, e - 8) : (i = 1, e)) && s <= 19 ? (this.logger.log(d.INFO, "Special char '" + a(s = 17 === s ? t + 80 : 18 === s ? t + 112 : t + 144) + "' in channel " + i), r = [s]) : 32 <= e && e <= 127 && (r = 0 === t ? [e] : [e, t]), r && (i = l(r), this.logger.log(d.DEBUG, "Char codes =  " + i.join(",")), x(e, t, this.cmdHistory)), r
                    }, t.parseBackgroundAttributes = function (e, t) {
                        var i;
                        if (!((16 === e || 24 === e) && 32 <= t && t <= 47 || (23 === e || 31 === e) && 45 <= t && t <= 47)) return !1;
                        var r = {};
                        return 16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), r.background = f[i], t % 2 == 1 && (r.background = r.background + "_semi")) : 45 === t ? r.background = "transparent" : (r.foreground = "black", 47 === t && (r.underline = !0)), this.channels[e <= 23 ? 1 : 2].setBkgData(r), x(e, t, this.cmdHistory), !0
                    }, t.reset = function () {
                        for (var e = 0; e < Object.keys(this.channels).length; e++) {
                            var t = this.channels[e];
                            t && t.reset()
                        }
                        this.cmdHistory = {a: null, b: null}
                    }, t.cueSplitAtTime = function (e) {
                        for (var t = 0; t < this.channels.length; t++) {
                            var i = this.channels[t];
                            i && i.cueSplitAtTime(e)
                        }
                    };
                    const L = D;

                    function D(e, t, i) {
                        this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
                        var r = new m;
                        this.channels = [null, new v(e, t, r), new v(e + 1, i, r)], this.cmdHistory = {
                            a: null,
                            b: null
                        }, this.logger = r
                    }
                }, "./src/utils/codecs.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        isCodecSupportedInMp4: () => function (e, t) {
                            return MediaSource.isTypeSupported((t || "video") + '/mp4;codecs="' + e + '"')
                        }, isCodecType: () => function (e, t) {
                            t = r[t];
                            return !!t && !0 === t[e.slice(0, 4)]
                        }
                    });
                    var r = {
                        audio: {
                            a3ds: !0,
                            "ac-3": !0,
                            "ac-4": !0,
                            alac: !0,
                            alaw: !0,
                            dra1: !0,
                            "dts+": !0,
                            "dts-": !0,
                            dtsc: !0,
                            dtse: !0,
                            dtsh: !0,
                            "ec-3": !0,
                            enca: !0,
                            g719: !0,
                            g726: !0,
                            m4ae: !0,
                            mha1: !0,
                            mha2: !0,
                            mhm1: !0,
                            mhm2: !0,
                            mlpa: !0,
                            mp4a: !0,
                            "raw ": !0,
                            Opus: !0,
                            opus: !0,
                            samr: !0,
                            sawb: !0,
                            sawp: !0,
                            sevc: !0,
                            sqcp: !0,
                            ssmv: !0,
                            twos: !0,
                            ulaw: !0
                        },
                        video: {
                            avc1: !0,
                            avc2: !0,
                            avc3: !0,
                            avc4: !0,
                            avcp: !0,
                            av01: !0,
                            drac: !0,
                            dva1: !0,
                            dvav: !0,
                            dvh1: !0,
                            dvhe: !0,
                            encv: !0,
                            hev1: !0,
                            hvc1: !0,
                            mjp2: !0,
                            mp4v: !0,
                            mvc1: !0,
                            mvc2: !0,
                            mvc3: !0,
                            mvc4: !0,
                            resv: !0,
                            rv60: !0,
                            s263: !0,
                            svc1: !0,
                            svc2: !0,
                            "vc-1": !0,
                            vp08: !0,
                            vp09: !0
                        },
                        text: {stpp: !0, wvtt: !0}
                    }
                }, "./src/utils/cues.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var f = i("./src/utils/vttparser.ts"), m = i("./src/utils/webvtt-parser.ts"),
                        g = i("./src/utils/texttrack-utils.ts"), y = /\s/;
                    const r = {
                        newCue: function (t, e, i, r) {
                            for (var s, a, n, o, l = [], d = self.VTTCue || self.TextTrackCue, h = 0; h < r.rows.length; h++) if (a = !0, n = 0, o = "", !(s = r.rows[h]).isEmpty()) {
                                for (var c = 0; c < s.chars.length; c++) y.test(s.chars[c].uchar) && a ? n++ : (o += s.chars[c].uchar, a = !1);
                                (s.cueStartTime = e) === i && (i += 1e-4), 16 <= n ? n-- : n++;
                                var u = (0, f.fixLineBreaks)(o.trim()), p = (0, m.generateCueId)(e, i, u);
                                t && t.cues && t.cues.getCueById(p) || ((u = new d(e, i, u)).id = p, u.line = h + 1, u.align = "left", u.position = 10 + Math.min(80, 10 * Math.floor(8 * n / 32)), l.push(u))
                            }
                            return t && l.length && (l.sort(function (e, t) {
                                return "auto" === e.line || "auto" === t.line ? 0 : 8 < e.line && 8 < t.line ? t.line - e.line : e.line - t.line
                            }), l.forEach(function (e) {
                                return (0, g.addCueToTrack)(t, e)
                            })), l
                        }
                    }
                }, "./src/utils/discontinuities.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        adjustSlidingStart: () => c,
                        alignMediaPlaylistByPDT: () => function (e, t) {
                            {
                                var i, r, s;
                                e.hasProgramDateTime && t.hasProgramDateTime && (i = e.fragments, t = t.fragments, i.length && t.length && (t = t[Math.round(t.length / 2) - 1], i = o(i, t.cc) || i[Math.round(i.length / 2) - 1], r = t.programDateTime, s = i.programDateTime, null !== r && null !== s && c((s - r) / 1e3 - (i.start - t.start), e)))
                            }
                        },
                        alignPDT: () => u,
                        alignStream: () => function (e, t, i) {
                            var r;
                            t && (l(e, e = t, r = i) && (e = d(e.details, r)) && (0, s.isFiniteNumber)(e.start) && (a.logger.log("Adjusting PTS using last level due to CC increase within current level " + r.url), c(e.start, r)), !i.alignedSliding && t.details && u(i, t.details), i.alignedSliding || !t.details || i.skippedSegments || (0, n.adjustSliding)(t.details, i))
                        },
                        findDiscontinuousReferenceFrag: () => d,
                        findFirstFragWithCC: () => o,
                        shouldAlignOnDiscontinuities: () => l
                    });
                    var s = i("./src/polyfills/number.ts"), a = i("./src/utils/logger.ts"),
                        n = i("./src/controller/level-helper.ts");

                    function o(e, t) {
                        for (var i = null, r = 0, s = e.length; r < s; r++) {
                            var a = e[r];
                            if (a && a.cc === t) {
                                i = a;
                                break
                            }
                        }
                        return i
                    }

                    function l(e, t, i) {
                        return !(!t.details || !(i.endCC > i.startCC || e && e.cc < i.startCC))
                    }

                    function d(e, t, i) {
                        e = e.fragments, t = t.fragments;
                        if (t.length && e.length) {
                            e = o(e, t[0].cc);
                            if (e && (!e || e.startPTS)) return e;
                            a.logger.log("No frag in previous level to align on")
                        } else a.logger.log("No fragments to align")
                    }

                    function h(e, t) {
                        e && (t = e.start + t, e.start = e.startPTS = t, e.endPTS = t + e.duration)
                    }

                    function c(e, t) {
                        for (var i = t.fragments, r = 0, s = i.length; r < s; r++) h(i[r], e);
                        t.fragmentHint && h(t.fragmentHint, e), t.alignedSliding = !0
                    }

                    function u(e, t) {
                        var i, r;
                        t.fragments.length && e.hasProgramDateTime && t.hasProgramDateTime && (i = t.fragments[0].programDateTime, (t = ((r = e.fragments[0].programDateTime) - i) / 1e3 + t.fragments[0].start) && (0, s.isFiniteNumber)(t) && (a.logger.log("Adjusting PTS using programDateTime delta " + (r - i) + "ms, sliding:" + t.toFixed(3) + " " + e.url + " "), c(t, e)))
                    }
                }, "./src/utils/ewma-bandwidth-estimator.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    var s = i("./src/utils/ewma.ts");
                    (t = a.prototype).update = function (e, t) {
                        var i = this.slow_, r = this.fast_;
                        this.slow_.halfLife !== e && (this.slow_ = new s.default(e, i.getEstimate(), i.getTotalWeight())), this.fast_.halfLife !== t && (this.fast_ = new s.default(t, r.getEstimate(), r.getTotalWeight()))
                    }, t.sample = function (e, t) {
                        e = (e = Math.max(e, this.minDelayMs_)) / 1e3, t = 8 * t / e;
                        this.fast_.sample(e, t), this.slow_.sample(e, t)
                    }, t.canEstimate = function () {
                        var e = this.fast_;
                        return e && e.getTotalWeight() >= this.minWeight_
                    }, t.getEstimate = function () {
                        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
                    }, t.destroy = function () {
                    };
                    const r = a;

                    function a(e, t, i) {
                        this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new s.default(e), this.fast_ = new s.default(t)
                    }
                }, "./src/utils/ewma.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    (i = s.prototype).sample = function (e, t) {
                        var i = Math.pow(this.alpha_, e);
                        this.estimate_ = t * (1 - i) + i * this.estimate_, this.totalWeight_ += e
                    }, i.getTotalWeight = function () {
                        return this.totalWeight_
                    }, i.getEstimate = function () {
                        if (this.alpha_) {
                            var e = 1 - Math.pow(this.alpha_, this.totalWeight_);
                            if (e) return this.estimate_ / e
                        }
                        return this.estimate_
                    };
                    const r = s;

                    function s(e, t, i) {
                        void 0 === t && (t = 0), void 0 === i && (i = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = i
                    }
                }, "./src/utils/fetch-loader.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        default: () => y, fetchSupported: () => function () {
                            if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
                                return new self.ReadableStream({}), !0
                            } catch (e) {
                            }
                            return !1
                        }
                    });
                    var c = i("./src/polyfills/number.ts"), r = i("./src/loader/load-stats.ts"),
                        d = i("./src/demux/chunk-cache.ts");

                    function s(e) {
                        var i = "function" == typeof Map ? new Map : void 0;
                        return (s = function (e) {
                            if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e;
                            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                            if (void 0 !== i) {
                                if (i.has(e)) return i.get(e);
                                i.set(e, t)
                            }

                            function t() {
                                return a(e, arguments, o(this).constructor)
                            }

                            return t.prototype = Object.create(e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), n(t, e)
                        })(e)
                    }

                    function a(e, t, i) {
                        return (a = function () {
                            if ("undefined" == typeof Reflect || !Reflect.construct) return;
                            if (Reflect.construct.sham) return;
                            if ("function" == typeof Proxy) return 1;
                            try {
                                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
                                })), 1
                            } catch (e) {
                                return
                            }
                        }() ? Reflect.construct.bind() : function (e, t, i) {
                            var r = [null], t = (r.push.apply(r, t), new (Function.bind.apply(e, r)));
                            return i && n(t, i.prototype), t
                        }).apply(null, arguments)
                    }

                    function n(e, t) {
                        return (n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        })(e, t)
                    }

                    function o(e) {
                        return (o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {
                            return e.__proto__ || Object.getPrototypeOf(e)
                        })(e)
                    }

                    function u() {
                        return (u = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    (t = l.prototype).destroy = function () {
                        this.loader = this.callbacks = null, this.abortInternal()
                    }, t.abortInternal = function () {
                        var e = this.response;
                        e && e.ok || (this.stats.aborted = !0, this.controller.abort())
                    }, t.abort = function () {
                        var e;
                        this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
                    }, t.load = function (r, s, a) {
                        var n = this, o = this.stats;
                        if (o.loading.start) throw new Error("Loader can only be used once.");
                        o.loading.start = self.performance.now();
                        var e = function (e, t) {
                                t = {
                                    method: "GET",
                                    mode: "cors",
                                    credentials: "same-origin",
                                    signal: t,
                                    headers: new self.Headers(u({}, e.headers))
                                };
                                return e.rangeEnd && t.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)), t
                            }(r, this.controller.signal), l = a.onProgress, d = "arraybuffer" === r.responseType,
                            h = d ? "byteLength" : "length";
                        this.context = r, this.config = s, this.callbacks = a, this.request = this.fetchSetup(r, e), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(function () {
                            n.abortInternal(), a.onTimeout(o, r, n.response)
                        }, s.timeout), self.fetch(this.request).then(function (e) {
                            var t, i;
                            if ((n.response = n.loader = e).ok) return o.loading.first = Math.max(self.performance.now(), o.loading.start), o.total = parseInt(e.headers.get("Content-Length") || "0"), l && (0, c.isFiniteNumber)(s.highWaterMark) ? n.loadProgressively(e, o, r, s.highWaterMark, l) : d ? e.arrayBuffer() : e.text();
                            throw t = e.status, i = e.statusText, new m(i || "fetch, bad network response", t, e)
                        }).then(function (e) {
                            var t = n.response,
                                i = (self.clearTimeout(n.requestTimeout), o.loading.end = Math.max(self.performance.now(), o.loading.first), e[h]),
                                i = (i && (o.loaded = o.total = i), {url: t.url, data: e});
                            l && !(0, c.isFiniteNumber)(s.highWaterMark) && l(o, r, e, t), a.onSuccess(i, o, r, t)
                        }).catch(function (e) {
                            var t, i;
                            self.clearTimeout(n.requestTimeout), o.aborted || (t = e && e.code || 0, i = e ? e.message : null, a.onError({
                                code: t,
                                text: i
                            }, r, e ? e.details : null))
                        })
                    }, t.getCacheAge = function () {
                        var e, t = null;
                        return t = this.response ? (e = this.response.headers.get("age")) ? parseFloat(e) : null : t
                    }, t.loadProgressively = function (r, s, a, n, o) {
                        void 0 === n && (n = 0);
                        var l = new d.default, e = r.body.getReader();
                        return function i() {
                            return e.read().then(function (e) {
                                if (e.done) return l.dataLength && o(s, a, l.flush(), r), Promise.resolve(new ArrayBuffer(0));
                                var e = e.value, t = e.length;
                                return s.loaded += t, t < n || l.dataLength ? (l.push(e), l.dataLength >= n && o(s, a, l.flush(), r)) : o(s, a, e, r), i()
                            }).catch(function () {
                                return Promise.reject()
                            })
                        }()
                    };
                    i = l;

                    function l(e) {
                        this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || h, this.controller = new self.AbortController, this.stats = new r.LoadStats
                    }

                    function h(e, t) {
                        return new self.Request(e.url, t)
                    }

                    p = s(Error), t = p, (f = g).prototype = Object.create(t.prototype), n(f.prototype.constructor = f, t);
                    var p, f, m = g;

                    function g(e, t, i) {
                        return (e = p.call(this, e) || this).code = void 0, e.details = void 0, e.code = t, e.details = i, e
                    }

                    const y = i
                }, "./src/utils/hex.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    const r = {
                        hexDump: function (e) {
                            for (var t = "", i = 0; i < e.length; i++) {
                                var r = e[i].toString(16);
                                t += r = r.length < 2 ? "0" + r : r
                            }
                            return t
                        }
                    }
                }, "./src/utils/imsc1-ttml-parser.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        IMSC1_CODEC: () => r, parseIMSC1: () => function (e, t, i, r, s) {
                            var a = (0, o.findBox)(new Uint8Array(e), ["mdat"]);
                            if (0 !== a.length) {
                                var a = a.map(function (e) {
                                    return (0, l.utf8ArrayToStr)(e)
                                }), n = (0, d.toTimescaleFromScale)(t, 1, i);
                                try {
                                    a.forEach(function (e) {
                                        return r(function (e, d) {
                                            var i = (new DOMParser).parseFromString(e, "text/xml").getElementsByTagName("tt")[0];
                                            if (!i) throw new Error("Invalid ttml");
                                            var r = {
                                                    frameRate: 30,
                                                    subFrameRate: 1,
                                                    frameRateMultiplier: 0,
                                                    tickRate: 0
                                                }, h = Object.keys(r).reduce(function (e, t) {
                                                    return e[t] = i.getAttribute("ttp:" + t) || r[t], e
                                                }, {}), c = "preserve" !== i.getAttribute("xml:space"),
                                                u = b(A(i, "styling", "style")), p = b(A(i, "layout", "region")),
                                                e = A(i, "body", "[begin]");
                                            return [].map.call(e, function (e) {
                                                var t = function r(e, s) {
                                                    return [].slice.call(e.childNodes).reduce(function (e, t, i) {
                                                        return "br" === t.nodeName && i ? e + "\n" : null != (i = t.childNodes) && i.length ? r(t, s) : s ? e + t.textContent.trim().replace(/\s+/g, " ") : e + t.textContent
                                                    }, "")
                                                }(e, c);
                                                if (!t || !e.hasAttribute("begin")) return null;
                                                var i = w(e.getAttribute("begin"), h), r = w(e.getAttribute("dur"), h),
                                                    s = w(e.getAttribute("end"), h);
                                                if (null === i) throw _(e);
                                                if (null === s) {
                                                    if (null === r) throw _(e);
                                                    s = i + r
                                                }
                                                var a, n, o, l, r = new f.default(i - d, s - d, t),
                                                    t = (r.id = (0, m.generateCueId)(r.startTime, r.endTime, r.text), a = p[e.getAttribute("region")], n = u[e.getAttribute("style")], i = u, o = "http://www.w3.org/ns/ttml#styling", (s = (l = null) != a && a.hasAttribute("style") ? a.getAttribute("style") : null) && i.hasOwnProperty(s) && (l = i[s]), ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce(function (e, t) {
                                                        var i = v(n, o, t) || v(a, o, t) || v(l, o, t);
                                                        return i && (e[t] = i), e
                                                    }, {})), e = t.textAlign;
                                                return e && ((i = y[e]) && (r.lineAlign = i), r.align = e), g(r, t), r
                                            }).filter(function (e) {
                                                return null !== e
                                            })
                                        }(e, n))
                                    })
                                } catch (e) {
                                    s(e)
                                }
                            } else s(new Error("Could not parse IMSC1 mdat"))
                        }
                    });
                    var o = i("./src/utils/mp4-tools.ts"), n = i("./src/utils/vttparser.ts"),
                        f = i("./src/utils/vttcue.ts"), l = i("./src/demux/id3.ts"),
                        d = i("./src/utils/timescale-conversion.ts"), m = i("./src/utils/webvtt-parser.ts");

                    function g() {
                        return (g = Object.assign ? Object.assign.bind() : function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i, r = arguments[t];
                                for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                            }
                            return e
                        }).apply(this, arguments)
                    }

                    var r = "stpp.ttml.im1t", h = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
                        c = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
                        y = {left: "start", center: "center", right: "end", start: "start", end: "end"};

                    function A(e, t, i) {
                        e = e.getElementsByTagName(t)[0];
                        return e ? [].slice.call(e.querySelectorAll(i)) : []
                    }

                    function b(e) {
                        return e.reduce(function (e, t) {
                            var i = t.getAttribute("xml:id");
                            return i && (e[i] = t), e
                        }, {})
                    }

                    function v(e, t, i) {
                        return e && e.hasAttributeNS(t, i) ? e.getAttributeNS(t, i) : null
                    }

                    function _(e) {
                        return new Error("Could not parse ttml timestamp " + e)
                    }

                    function w(r, e) {
                        if (!r) return null;
                        var t, i, s, a = (0, n.parseTimeStamp)(r);
                        return null === a && (h.test(r) ? (t = e, i = h.exec(r), s = (0 | i[4]) + (0 | i[5]) / t.subFrameRate, a = 3600 * (0 | i[1]) + 60 * (0 | i[2]) + (0 | i[3]) + s / t.frameRate) : c.test(r) && (a = function (e) {
                            var t = c.exec(r), i = Number(t[1]);
                            switch (t[2]) {
                                case"h":
                                    return 3600 * i;
                                case"m":
                                    return 60 * i;
                                case"ms":
                                    return 1e3 * i;
                                case"f":
                                    return i / e.frameRate;
                                case"t":
                                    return i / e.tickRate
                            }
                            return i
                        }(e))), a
                    }
                }, "./src/utils/keysystem-util.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        changeEndianness: () => function (e) {
                            function t(e, t, i) {
                                var r = e[t];
                                e[t] = e[i], e[i] = r
                            }

                            t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7)
                        }, convertDataUriToArrayBytes: () => function (e) {
                            var e = e.split(":"), t = null;
                            {
                                var i, r;
                                "data" === e[0] && 2 === e.length && (e = e[1].split(";"), 2 === (r = e[e.length - 1].split(",")).length && (i = "base64" === r[0], r = r[1], t = i ? (e.splice(-1, 1), (0, s.base64Decode)(r)) : (i = a(r).subarray(0, 16), (e = new Uint8Array(16)).set(i, 16 - i.length), e)))
                            }
                            return t
                        }, strToUtf8array: () => a
                    });
                    var s = i("./src/utils/numeric-encoding-utils.ts");

                    function a(e) {
                        return Uint8Array.from(unescape(encodeURIComponent(e)), function (e) {
                            return e.charCodeAt(0)
                        })
                    }
                }, "./src/utils/logger.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        enableLogs: () => function (e, t) {
                            if (self.console && !0 === e || "object" == typeof e) {
                                !function (i) {
                                    for (var e = arguments.length, t = new Array(1 < e ? e - 1 : 0), r = 1; r < e; r++) t[r - 1] = arguments[r];
                                    t.forEach(function (e) {
                                        var t;
                                        a[e] = i[e] ? i[e].bind(i) : (e = e, (t = self.console[e]) ? t.bind(self.console, "[" + e + "] >") : s)
                                    })
                                }(e, "debug", "log", "info", "warn", "error");
                                try {
                                    a.log('Debug logs enabled for "' + t + '"')
                                } catch (e) {
                                    a = r
                                }
                            } else a = r
                        }, logger: () => n
                    });

                    function s() {
                    }

                    var r = {trace: s, debug: s, log: s, warn: s, info: s, error: s}, a = r;
                    var n = r
                }, "./src/utils/mediakeys-helper.ts": (e, t, i) => {
                    var n, r, s;
                    i.r(t), i.d(t, {
                        KeySystemFormats: () => r,
                        KeySystemIds: () => s,
                        KeySystems: () => n,
                        getKeySystemsForConfig: () => function (e) {
                            var t = e.drmSystems, e = e.widevineLicenseUrl,
                                i = t ? [n.FAIRPLAY, n.WIDEVINE, n.PLAYREADY, n.CLEARKEY].filter(function (e) {
                                    return !!t[e]
                                }) : [];
                            return !i[n.WIDEVINE] && e && i.push(n.WIDEVINE), i
                        },
                        getSupportedMediaKeySystemConfigurations: () => function (e, t, i, r) {
                            var s;
                            switch (e) {
                                case n.FAIRPLAY:
                                    s = ["cenc", "sinf"];
                                    break;
                                case n.WIDEVINE:
                                case n.PLAYREADY:
                                    s = ["cenc"];
                                    break;
                                case n.CLEARKEY:
                                    s = ["cenc", "keyids"];
                                    break;
                                default:
                                    throw new Error("Unknown key-system: " + e)
                            }
                            var a = r;
                            return [{
                                initDataTypes: s,
                                persistentState: a.persistentState || "not-allowed",
                                distinctiveIdentifier: a.distinctiveIdentifier || "not-allowed",
                                sessionTypes: a.sessionTypes || [a.sessionType || "temporary"],
                                audioCapabilities: t.map(function (e) {
                                    return {
                                        contentType: 'audio/mp4; codecs="' + e + '"',
                                        robustness: a.audioRobustness || "",
                                        encryptionScheme: a.audioEncryptionScheme || null
                                    }
                                }),
                                videoCapabilities: i.map(function (e) {
                                    return {
                                        contentType: 'video/mp4; codecs="' + e + '"',
                                        robustness: a.videoRobustness || "",
                                        encryptionScheme: a.videoEncryptionScheme || null
                                    }
                                })
                            }]
                        },
                        keySystemDomainToKeySystemFormat: () => function (e) {
                            switch (e) {
                                case n.FAIRPLAY:
                                    return r.FAIRPLAY;
                                case n.PLAYREADY:
                                    return r.PLAYREADY;
                                case n.WIDEVINE:
                                    return r.WIDEVINE;
                                case n.CLEARKEY:
                                    return r.CLEARKEY
                            }
                        },
                        keySystemFormatToKeySystemDomain: () => function (e) {
                            switch (e) {
                                case r.FAIRPLAY:
                                    return n.FAIRPLAY;
                                case r.PLAYREADY:
                                    return n.PLAYREADY;
                                case r.WIDEVINE:
                                    return n.WIDEVINE;
                                case r.CLEARKEY:
                                    return n.CLEARKEY
                            }
                        },
                        keySystemIdToKeySystemDomain: () => function (e) {
                            if (e === s.WIDEVINE) return n.WIDEVINE
                        },
                        requestMediaKeySystemAccess: () => a
                    }), (i = n = n || {}).CLEARKEY = "org.w3.clearkey", i.FAIRPLAY = "com.apple.fps", i.PLAYREADY = "com.microsoft.playready", i.WIDEVINE = "com.widevine.alpha", (t = r = r || {}).CLEARKEY = "org.w3.clearkey", t.FAIRPLAY = "com.apple.streamingkeydelivery", t.PLAYREADY = "com.microsoft.playready", t.WIDEVINE = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", (s = s || {}).WIDEVINE = "edef8ba979d64acea3c827dcd51d21ed";
                    var a = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null
                }, "./src/utils/mediasource-helper.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        getMediaSource: () => function () {
                            return self.MediaSource || self.WebKitMediaSource
                        }
                    })
                }, "./src/utils/mp4-tools.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        RemuxerTrackIdConfig: () => l,
                        appendUint8Array: () => function (e, t) {
                            var i = new Uint8Array(e.length + t.length);
                            return i.set(e), i.set(t, e.length), i
                        },
                        bin2str: () => c,
                        computeRawDurationFromSamples: () => _,
                        discardEPB: () => T,
                        findBox: () => L,
                        getDuration: () => function (e, t) {
                            for (var i = 0, r = 0, s = 0, a = L(e, ["moof", "traf"]), n = 0; n < a.length; n++) {
                                var o = a[n], l = L(o, ["tfhd"])[0], d = t[x(l, 4)];
                                if (d) {
                                    var h = d.default, c = x(l, 0) | (null == h ? void 0 : h.flags),
                                        u = null == h ? void 0 : h.duration;
                                    8 & c && (u = x(l, 2 & c ? 12 : 8));
                                    for (var p = d.timescale || 9e4, f = L(o, ["trun"]), m = 0; m < f.length; m++) !(i = _(f[m])) && u && (i = u * x(f[m], 4)), d.type === k.ElementaryStreamTypes.VIDEO ? r += i / p : d.type === k.ElementaryStreamTypes.AUDIO && (s += i / p)
                                }
                            }
                            if (0 !== r || 0 !== s) return r || s;
                            for (var g = 0, y = L(e, ["sidx"]), A = 0; A < y.length; A++) {
                                var b = v(y[A]);
                                null != b && b.references && (g += b.references.reduce(function (e, t) {
                                    return e + t.info.duration || 0
                                }, 0))
                            }
                            return g
                        },
                        getStartDTS: () => function (a, e) {
                            return L(e, ["moof", "traf"]).reduce(function (e, t) {
                                var r = L(t, ["tfdt"])[0], s = r[0], t = L(t, ["tfhd"]).reduce(function (e, t) {
                                    t = x(t, 4), t = a[t];
                                    if (t) {
                                        var i = x(r, 4),
                                            i = (i = 1 === s ? (i *= Math.pow(2, 32)) + x(r, 8) : i) / (t.timescale || 9e4);
                                        if (isFinite(i) && (null === e || i < e)) return i
                                    }
                                    return e
                                }, null);
                                return null !== t && isFinite(t) && (null === e || t < e) ? t : e
                            }, null) || 0
                        },
                        mp4Box: () => u,
                        mp4pssh: () => function (e, t, i) {
                            if (16 !== e.byteLength) throw new RangeError("Invalid system id");
                            var r, s, a;
                            if (t) {
                                r = 1, s = new Uint8Array(16 * t.length);
                                for (var n = 0; n < t.length; n++) {
                                    var o = t[n];
                                    if (16 !== o.byteLength) throw new RangeError("Invalid key");
                                    s.set(o, 16 * n)
                                }
                            } else r = 0, s = new Uint8Array;
                            0 < r ? (a = new Uint8Array(4), 0 < t.length && new DataView(a.buffer).setUint32(0, t.length, !1)) : a = new Uint8Array;
                            var l = new Uint8Array(4);
                            return i && 0 < i.byteLength && new DataView(l.buffer).setUint32(0, i.byteLength, !1), u([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), e, a, s, l, i || new Uint8Array)
                        },
                        offsetStartDTS: () => function (i, e, s) {
                            L(e, ["moof", "traf"]).forEach(function (t) {
                                L(t, ["tfhd"]).forEach(function (e) {
                                    var r, e = x(e, 4), e = i[e];
                                    e && (r = e.timescale || 9e4, L(t, ["tfdt"]).forEach(function (e) {
                                        var t = e[0], i = x(e, 4);
                                        0 === t ? (i -= s * r, d(e, 4, i = Math.max(i, 0))) : (i = (i = (i *= Math.pow(2, 32)) + x(e, 8)) - s * r, i = Math.max(i, 0), t = Math.floor(i / (a + 1)), i = Math.floor(i % (a + 1)), d(e, 4, t), d(e, 8, i))
                                    }))
                                })
                            })
                        },
                        parseEmsg: () => function (e) {
                            var t = e[0], i = "", r = "", s = 0, a = 0, n = 0, o = 0, l = 0, d = 0;
                            if (0 === t) {
                                for (; "\0" !== c(e.subarray(d, d + 1));) i += c(e.subarray(d, d + 1)), d += 1;
                                for (i += c(e.subarray(d, d + 1)), d += 1; "\0" !== c(e.subarray(d, d + 1));) r += c(e.subarray(d, d + 1)), d += 1;
                                r += c(e.subarray(d, d + 1)), d += 1, s = x(e, 12), a = x(e, 16), o = x(e, 20), l = x(e, 24), d = 28
                            } else if (1 === t) {
                                s = x(e, d += 4);
                                var t = x(e, d += 4), h = x(e, d += 4);
                                for (d += 4, n = Math.pow(2, 32) * t + h, Number.isSafeInteger(n) || (n = Number.MAX_SAFE_INTEGER, console.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = x(e, d), l = x(e, d += 4), d += 4; "\0" !== c(e.subarray(d, d + 1));) i += c(e.subarray(d, d + 1)), d += 1;
                                for (i += c(e.subarray(d, d + 1)), d += 1; "\0" !== c(e.subarray(d, d + 1));) r += c(e.subarray(d, d + 1)), d += 1;
                                r += c(e.subarray(d, d + 1)), d += 1
                            }
                            return {
                                schemeIdUri: i,
                                value: r,
                                timeScale: s,
                                presentationTime: n,
                                presentationTimeDelta: a,
                                eventDuration: o,
                                id: l,
                                payload: e.subarray(d, e.byteLength)
                            }
                        },
                        parseInitSegment: () => function (e) {
                            for (var i = [], t = L(e, ["moov", "trak"]), r = 0; r < t.length; r++) {
                                var s, a, n, o = t[r], l = L(o, ["tkhd"])[0];
                                l && (a = l[0], l = x(l, 0 === a ? 12 : 20), (s = L(o, ["mdia", "mdhd"])[0]) && (s = x(s, 0 === (a = s[0]) ? 12 : 20), (a = L(o, ["mdia", "hdlr"])[0]) && (a = c(a.subarray(8, 12)), (a = {
                                    soun: k.ElementaryStreamTypes.AUDIO,
                                    vide: k.ElementaryStreamTypes.VIDEO
                                }[a]) && (o = L(o, ["mdia", "minf", "stbl", "stsd"])[0], n = void 0, o && (n = c(o.subarray(12, 16))), i[l] = {
                                    timescale: s,
                                    type: a
                                }, i[a] = {timescale: s, id: l, codec: n}))))
                            }
                            return L(e, ["moov", "mvex", "trex"]).forEach(function (e) {
                                var t = x(e, 4), t = i[t];
                                t && (t.default = {duration: x(e, 12), flags: x(e, 20)})
                            }), i
                        },
                        parsePssh: () => function (e) {
                            if (!(e instanceof ArrayBuffer) || e.byteLength < 32) return null;
                            var t = {version: 0, systemId: "", kids: null, data: null}, i = new DataView(e),
                                r = i.getUint32(0);
                            if (e.byteLength !== r && 44 < r) return null;
                            if (1886614376 !== i.getUint32(4)) return null;
                            if (t.version = i.getUint32(8) >>> 24, 1 < t.version) return null;
                            t.systemId = n.default.hexDump(new Uint8Array(e, 12, 16));
                            var s = i.getUint32(28);
                            if (0 === t.version) {
                                if (r - 32 < s) return null;
                                t.data = new Uint8Array(e, 32, s)
                            } else if (1 === t.version) {
                                t.kids = [];
                                for (var a = 0; a < s; a++) t.kids.push(new Uint8Array(e, 32 + 16 * a, 16))
                            }
                            return t
                        },
                        parseSEIMessageFromNALu: () => D,
                        parseSamples: () => function (v, _) {
                            var w = [], S = _.samples, E = _.timescale, a = _.id, T = !1;
                            return L(S, ["moof"]).map(function (e) {
                                var b = e.byteOffset - 8;
                                L(e, ["traf"]).map(function (s) {
                                    var e = L(s, ["tfdt"]).map(function (e) {
                                        var t = e[0], i = x(e, 4);
                                        return (i = 1 === t ? (i *= Math.pow(2, 32)) + x(e, 8) : i) / E
                                    })[0];
                                    return void 0 !== e && (v = e), L(s, ["tfhd"]).map(function (e) {
                                        var t = x(e, 4), i = 16777215 & x(e, 0), y = 0, A = 0, r = 8;
                                        t === a && (0 != (1 & i) && (r += 8), 0 != (2 & i) && (r += 4), 0 != (8 & i) && (y = x(e, r), r += 4), 0 != (16 & i) && (A = x(e, r), r += 4), 0 != (32 & i) && (r += 4), "video" === _.type && (T = function (e) {
                                            if (!e) return !1;
                                            var t = e.indexOf("."), e = t < 0 ? e : e.substring(0, t);
                                            return "hvc1" === e || "hev1" === e || "dvh1" === e || "dvhe" === e
                                        }(_.codec)), L(s, ["trun"]).map(function (e) {
                                            var t = e[0], i = 16777215 & x(e, 0), r = 0, s = 0 != (256 & i), a = 0,
                                                n = 0 != (512 & i), o = 0, l = 0 != (1024 & i), d = 0 != (2048 & i),
                                                h = 0, c = x(e, 4), u = 8;
                                            0 != (1 & i) && (r = x(e, u), u += 4), 0 != (4 & i) && (u += 4);
                                            for (var p = r + b, f = 0; f < c; f++) {
                                                if (s ? (a = x(e, u), u += 4) : a = y, n ? (o = x(e, u), u += 4) : o = A, l && (u += 4), d && (h = (0 === t ? x : C)(e, u), u += 4), _.type === k.ElementaryStreamTypes.VIDEO) for (var m = 0; m < o;) {
                                                    var g = x(S, p);
                                                    !function (e, t) {
                                                        if (e) return 39 == (e = t >> 1 & 63) || 40 == e;
                                                        return 6 == (31 & t)
                                                    }(T, S[p += 4]) || D(S.subarray(p, p + g), T ? 2 : 1, v + h / E, w), p += g, m += g + 4
                                                }
                                                v += a / E
                                            }
                                        }))
                                    })
                                })
                            }), w
                        },
                        parseSegmentIndex: () => v,
                        parseSinf: () => h,
                        patchEncyptionData: () => function (e, t) {
                            if (!e || !t) return e;
                            var r = t.keyId;
                            return r && t.isCommonEncryption && L(e, ["moov", "trak"]).forEach(function (e) {
                                var e = L(e, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8), t = L(e, ["enca"]),
                                    i = 0 < t.length;
                                (t = i ? t : L(e, ["encv"])).forEach(function (e) {
                                    L(i ? e.subarray(28) : e.subarray(78), ["sinf"]).forEach(function (e) {
                                        var t, e = h(e);
                                        e && !(t = e.subarray(8, 24)).some(function (e) {
                                            return 0 !== e
                                        }) && (s.logger.log("[eme] Patching keyId in 'enc" + (i ? "a" : "v") + ">sinf>>tenc' box: " + n.default.hexDump(t) + " -> " + n.default.hexDump(r)), e.set(r, 8))
                                    })
                                })
                            }), e
                        },
                        readSint32: () => C,
                        readUint16: () => E,
                        readUint32: () => x,
                        segmentValidRange: () => function (e) {
                            var t = {valid: null, remainder: null}, i = L(e, ["moof"]);
                            if (!i) return t;
                            if (i.length < 2) return t.remainder = e, t;
                            i = i[i.length - 1];
                            return t.valid = (0, r.sliceUint8)(e, 0, i.byteOffset - 8), t.remainder = (0, r.sliceUint8)(e, i.byteOffset - 8), t
                        },
                        writeUint32: () => d
                    });
                    var k = i("./src/loader/fragment.ts"), r = i("./src/utils/typed-array.ts"),
                        S = i("./src/demux/id3.ts"), s = i("./src/utils/logger.ts"), n = i("./src/utils/hex.ts"),
                        a = Math.pow(2, 32) - 1, o = [].push, l = {video: 1, audio: 2, id3: 3, text: 4};

                    function c(e) {
                        return String.fromCharCode.apply(null, e)
                    }

                    function E(e, t) {
                        e = e[t] << 8 | e[t + 1];
                        return e < 0 ? 65536 + e : e
                    }

                    function x(e, t) {
                        e = C(e, t);
                        return e < 0 ? 4294967296 + e : e
                    }

                    function C(e, t) {
                        return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
                    }

                    function d(e, t, i) {
                        e[t] = i >> 24, e[t + 1] = i >> 16 & 255, e[t + 2] = i >> 8 & 255, e[t + 3] = 255 & i
                    }

                    function L(e, t) {
                        var i = [];
                        if (!t.length) return i;
                        for (var r = e.byteLength, s = 0; s < r;) {
                            var a, n = x(e, s), n = 1 < n ? s + n : r;
                            c(e.subarray(s + 4, s + 8)) === t[0] && (1 === t.length ? i.push(e.subarray(s + 8, n)) : (a = L(e.subarray(s + 8, n), t.slice(1))).length && o.apply(i, a)), s = n
                        }
                        return i
                    }

                    function v(e) {
                        var t = [], i = e[0], r = 8, s = x(e, r), a = e.length + 0,
                            n = E(e, r = (r += 4) + (0 === i ? 8 : 16) + 2);
                        r += 2;
                        for (var o = 0; o < n; o++) {
                            var l = r, d = x(e, l), h = (l += 4, 2147483647 & d);
                            if (1 == (2147483648 & d) >>> 31) return console.warn("SIDX has hierarchical references (not supported)"), null;
                            d = x(e, l);
                            l += 4, t.push({
                                referenceSize: h,
                                subsegmentDuration: d,
                                info: {duration: d / s, start: a, end: a + h - 1}
                            }), a += h, r = l += 4
                        }
                        return {
                            earliestPresentationTime: 0,
                            timescale: s,
                            version: i,
                            referencesCount: n,
                            references: t
                        }
                    }

                    function h(e) {
                        var t = L(e, ["schm"])[0];
                        if (t) {
                            t = c(t.subarray(4, 8));
                            if ("cbcs" === t || "cenc" === t) return L(e, ["schi", "tenc"])[0]
                        }
                        return s.logger.error("[eme] missing 'schm' box"), null
                    }

                    function _(e) {
                        var t = x(e, 0), i = 8;
                        1 & t && (i += 4), 4 & t && (i += 4);
                        for (var r = 0, s = x(e, 4), a = 0; a < s; a++) 256 & t && (r += x(e, i), i += 4), 512 & t && (i += 4), 1024 & t && (i += 4), 2048 & t && (i += 4);
                        return r
                    }

                    function D(e, t, i, r) {
                        var s = T(e), a = 0;
                        a += t;
                        for (var n = 0, o = 0, l = !1, d = 0; a < s.length;) {
                            for (n = 0; !(a >= s.length) && (n += d = s[a++], 255 === d);) ;
                            for (o = 0; !(a >= s.length) && (o += d = s[a++], 255 === d);) ;
                            var h = s.length - a;
                            if (!l && 4 === n && a < s.length) {
                                if (l = !0, 181 === s[a++]) {
                                    var c = E(s, a);
                                    if (a += 2, 49 === c) {
                                        c = x(s, a);
                                        if (a += 4, 1195456820 === c) {
                                            c = s[a++];
                                            if (3 === c) {
                                                var u = s[a++], p = 64 & u, f = p ? 2 + 3 * (31 & u) : 0,
                                                    m = new Uint8Array(f);
                                                if (p) {
                                                    m[0] = u;
                                                    for (var g = 1; g < f; g++) m[g] = s[a++]
                                                }
                                                r.push({type: c, payloadType: n, pts: i, bytes: m})
                                            }
                                        }
                                    }
                                }
                            } else if (5 === n && o < h) {
                                if (l = !0, 16 < o) {
                                    for (var y = [], A = 0; A < 16; A++) {
                                        var b = s[a++].toString(16);
                                        y.push(1 == b.length ? "0" + b : b), 3 !== A && 5 !== A && 7 !== A && 9 !== A || y.push("-")
                                    }
                                    for (var v = o - 16, _ = new Uint8Array(v), w = 0; w < v; w++) _[w] = s[a++];
                                    r.push({
                                        payloadType: n,
                                        pts: i,
                                        uuid: y.join(""),
                                        userData: (0, S.utf8ArrayToStr)(_),
                                        userDataBytes: _
                                    })
                                }
                            } else if (o < h) a += o; else if (h < o) break
                        }
                    }

                    function T(e) {
                        for (var t = e.byteLength, i = [], r = 1; r < t - 2;) 0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (i.push(r + 2), r += 2) : r++;
                        if (0 === i.length) return e;
                        for (var s = t - i.length, a = new Uint8Array(s), n = 0, r = 0; r < s; n++, r++) n === i[0] && (n++, i.shift()), a[r] = e[n];
                        return a
                    }

                    function u(e) {
                        for (var t = arguments.length, i = new Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
                        for (var s = i.length, a = 8, n = s; n--;) a += i[n].byteLength;
                        var o = new Uint8Array(a);
                        for (o[0] = a >> 24 & 255, o[1] = a >> 16 & 255, o[2] = a >> 8 & 255, o[3] = 255 & a, o.set(e, 4), n = 0, a = 8; n < s; n++) o.set(i[n], a), a += i[n].byteLength;
                        return o
                    }
                }, "./src/utils/numeric-encoding-utils.ts": (e, t, i) => {
                    function r(e) {
                        return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
                    }

                    function s(e) {
                        return btoa(String.fromCharCode.apply(String, e))
                    }

                    i.r(t), i.d(t, {
                        base64Decode: () => function (e) {
                            return Uint8Array.from(atob(e), function (e) {
                                return e.charCodeAt(0)
                            })
                        }, base64DecodeToStr: () => function (e) {
                            return atob(e)
                        }, base64Encode: () => s, base64ToBase64Url: () => r, base64UrlEncode: () => function (e) {
                            return r(s(e))
                        }, strToBase64Encode: () => function (e) {
                            return btoa(e)
                        }
                    })
                }, "./src/utils/output-filter.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    (i = s.prototype).dispatchCue = function () {
                        null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
                    }, i.newCue = function (e, t, i) {
                        (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName)
                    }, i.reset = function () {
                        this.cueRanges = [], this.startTime = null
                    };
                    var r = s;

                    function s(e, t) {
                        this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t
                    }
                }, "./src/utils/texttrack-utils.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        addCueToTrack: () => function (e, t) {
                            var i = e.mode;
                            if ("disabled" === i && (e.mode = "hidden"), e.cues && !e.cues.getCueById(t.id)) try {
                                if (e.addCue(t), !e.cues.getCueById(t.id)) throw new Error("addCue is failed for: " + t)
                            } catch (i) {
                                s.logger.debug("[texttrack-utils]: " + i);
                                var r = new self.TextTrackCue(t.startTime, t.endTime, t.text);
                                r.id = t.id, e.addCue(r)
                            }
                            "disabled" === i && (e.mode = i)
                        }, clearCurrentCues: () => function (e) {
                            var t = e.mode;
                            if ("disabled" === t && (e.mode = "hidden"), e.cues) for (var i = e.cues.length; i--;) e.removeCue(e.cues[i]);
                            "disabled" === t && (e.mode = t)
                        }, getCuesInRange: () => o, removeCuesInRange: () => function (e, t, i, r) {
                            var s = e.mode;
                            if ("disabled" === s && (e.mode = "hidden"), e.cues && 0 < e.cues.length) for (var a = o(e.cues, t, i), n = 0; n < a.length; n++) r && !r(a[n]) || e.removeCue(a[n]);
                            "disabled" === s && (e.mode = s)
                        }, sendAddTrackEvent: () => function (e, t) {
                            var i;
                            try {
                                i = new Event("addtrack")
                            } catch (e) {
                                (i = document.createEvent("Event")).initEvent("addtrack", !1, !1)
                            }
                            i.track = e, t.dispatchEvent(i)
                        }
                    });
                    var s = i("./src/utils/logger.ts");

                    function o(e, t, i) {
                        var r = [], s = function (e, t) {
                            if (t < e[0].startTime) return 0;
                            var i = e.length - 1;
                            if (t > e[i].endTime) return -1;
                            for (var r = 0, s = i; r <= s;) {
                                var a = Math.floor((s + r) / 2);
                                if (t < e[a].startTime) s = a - 1; else {
                                    if (!(t > e[a].startTime && r < i)) return a;
                                    r = a + 1
                                }
                            }
                            return e[r].startTime - t < t - e[s].startTime ? r : s
                        }(e, t);
                        if (-1 < s) for (var a = s, n = e.length; a < n; a++) {
                            var o = e[a];
                            if (o.startTime >= t && o.endTime <= i) r.push(o); else if (o.startTime > i) return r
                        }
                        return r
                    }
                }, "./src/utils/time-ranges.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    const r = {
                        toString: function (e) {
                            for (var t = "", i = e.length, r = 0; r < i; r++) t += "[" + e.start(r).toFixed(3) + "-" + e.end(r).toFixed(3) + "]";
                            return t
                        }
                    }
                }, "./src/utils/timescale-conversion.ts": (e, t, i) => {
                    function s(e, t, i, r) {
                        e = e * t * (i = void 0 === i ? 1 : i);
                        return (r = void 0 === r ? !1 : r) ? Math.round(e) : e
                    }

                    i.r(t), i.d(t, {
                        toMpegTsClockFromTimescale: () => function (e, t) {
                            return s(e, 9e4, 1 / (t = void 0 === t ? 1 : t))
                        }, toMsFromMpegTsClock: () => function (e, t) {
                            return s(e, 1e3, 1 / 9e4, t = void 0 === t ? !1 : t)
                        }, toTimescaleFromBase: () => s, toTimescaleFromScale: () => function (e, t, i, r) {
                            return s(e, t, 1 / (i = void 0 === i ? 1 : i), r = void 0 === r ? !1 : r)
                        }
                    })
                }, "./src/utils/typed-array.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        sliceUint8: () => function (e, t, i) {
                            return Uint8Array.prototype.slice ? e.slice(t, i) : new Uint8Array(Array.prototype.slice.call(e, t, i))
                        }
                    })
                }, "./src/utils/vttcue.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => r});
                    const r = function () {
                        if ("undefined" != typeof self && self.VTTCue) return self.VTTCue;
                        var b = ["", "lr", "rl"], t = ["start", "middle", "end", "left", "right"];

                        function v(e, t) {
                            if ("string" != typeof t) return !1;
                            if (!Array.isArray(e)) return !1;
                            t = t.toLowerCase();
                            return !!~e.indexOf(t) && t
                        }

                        function _(e) {
                            return v(t, e)
                        }

                        function w(e) {
                            for (var t = arguments.length, i = new Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
                            for (var s = 1; s < arguments.length; s++) {
                                var a, n = arguments[s];
                                for (a in n) e[a] = n[a]
                            }
                            return e
                        }

                        function e(e, t, i) {
                            var r = this, s = {enumerable: !0}, a = (r.hasBeenReset = !1, ""), n = !1, o = e, l = t,
                                d = i, h = null, c = "", u = !0, p = "auto", f = "start", m = 50, g = "middle", y = 50,
                                A = "middle";
                            Object.defineProperty(r, "id", w({}, s, {
                                get: function () {
                                    return a
                                }, set: function (e) {
                                    a = "" + e
                                }
                            })), Object.defineProperty(r, "pauseOnExit", w({}, s, {
                                get: function () {
                                    return n
                                }, set: function (e) {
                                    n = !!e
                                }
                            })), Object.defineProperty(r, "startTime", w({}, s, {
                                get: function () {
                                    return o
                                }, set: function (e) {
                                    if ("number" != typeof e) throw new TypeError("Start time must be set to a number.");
                                    o = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "endTime", w({}, s, {
                                get: function () {
                                    return l
                                }, set: function (e) {
                                    if ("number" != typeof e) throw new TypeError("End time must be set to a number.");
                                    l = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "text", w({}, s, {
                                get: function () {
                                    return d
                                }, set: function (e) {
                                    d = "" + e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "region", w({}, s, {
                                get: function () {
                                    return h
                                }, set: function (e) {
                                    h = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "vertical", w({}, s, {
                                get: function () {
                                    return c
                                }, set: function (e) {
                                    e = v(b, e);
                                    if (!1 === e) throw new SyntaxError("An invalid or illegal string was specified.");
                                    c = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "snapToLines", w({}, s, {
                                get: function () {
                                    return u
                                }, set: function (e) {
                                    u = !!e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "line", w({}, s, {
                                get: function () {
                                    return p
                                }, set: function (e) {
                                    if ("number" != typeof e && "auto" !== e) throw new SyntaxError("An invalid number or illegal string was specified.");
                                    p = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "lineAlign", w({}, s, {
                                get: function () {
                                    return f
                                }, set: function (e) {
                                    e = _(e);
                                    if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                                    f = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "position", w({}, s, {
                                get: function () {
                                    return m
                                }, set: function (e) {
                                    if (e < 0 || 100 < e) throw new Error("Position must be between 0 and 100.");
                                    m = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "positionAlign", w({}, s, {
                                get: function () {
                                    return g
                                }, set: function (e) {
                                    e = _(e);
                                    if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                                    g = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "size", w({}, s, {
                                get: function () {
                                    return y
                                }, set: function (e) {
                                    if (e < 0 || 100 < e) throw new Error("Size must be between 0 and 100.");
                                    y = e, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(r, "align", w({}, s, {
                                get: function () {
                                    return A
                                }, set: function (e) {
                                    e = _(e);
                                    if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                                    A = e, this.hasBeenReset = !0
                                }
                            })), r.displayState = void 0
                        }

                        return e.prototype.getCueAsHTML = function () {
                            return self.WebVTT.convertCueToDOMTree(self, this.text)
                        }, e
                    }()
                }, "./src/utils/vttparser.ts": (e, t, i) => {
                    i.r(t), i.d(t, {VTTParser: () => n, fixLineBreaks: () => p, parseTimeStamp: () => l});
                    var o = i("./src/utils/vttcue.ts"), r = (s.prototype.decode = function (e, t) {
                        if (!e) return "";
                        if ("string" != typeof e) throw new Error("Error - expected string data.");
                        return decodeURIComponent(encodeURIComponent(e))
                    }, s);

                    function s() {
                    }

                    function l(e) {
                        function t(e, t, i, r) {
                            return 3600 * (0 | e) + 60 * (0 | t) + (0 | i) + parseFloat(r || 0)
                        }

                        e = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
                        return e ? 59 < parseFloat(e[2]) ? t(e[2], e[3], 0, e[4]) : t(e[1], e[2], e[3], e[4]) : null
                    }

                    (t = a.prototype).set = function (e, t) {
                        this.get(e) || "" === t || (this.values[e] = t)
                    }, t.get = function (e, t, i) {
                        return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t
                    }, t.has = function (e) {
                        return e in this.values
                    }, t.alt = function (e, t, i) {
                        for (var r = 0; r < i.length; ++r) if (t === i[r]) {
                            this.set(e, t);
                            break
                        }
                    }, t.integer = function (e, t) {
                        /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
                    }, t.percent = function (e, t) {
                        if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
                            t = parseFloat(t);
                            if (0 <= t && t <= 100) return this.set(e, t), !0
                        }
                        return !1
                    };
                    var d = a;

                    function a() {
                        this.values = Object.create(null)
                    }

                    function h(e, t, i, r) {
                        var s, a, n = r ? e.split(r) : [e];
                        for (s in n) "string" != typeof n[s] || 2 === (a = n[s].split(i)).length && t(a[0], a[1])
                    }

                    var c = new o.default(0, 0, ""), u = "middle" === c.align ? "middle" : "center";

                    function p(e) {
                        return e.replace(/<br(?: \/)?>/gi, "\n")
                    }

                    (i = f.prototype).parse = function (e) {
                        var r = this;

                        function t() {
                            for (var e = 0, t = p(t = r.buffer); e < t.length && "\r" !== t[e] && "\n" !== t[e];) ++e;
                            var i = t.slice(0, e);
                            return "\r" === t[e] && ++e, "\n" === t[e] && ++e, r.buffer = t.slice(e), i
                        }

                        e && (r.buffer += r.decoder.decode(e, {stream: !0}));
                        try {
                            var i = "";
                            if ("INITIAL" === r.state) {
                                if (!/\r\n|\n/.test(r.buffer)) return this;
                                var s = (i = t()).match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                                if (!s || !s[0]) throw new Error("Malformed WebVTT signature.");
                                r.state = "HEADER"
                            }
                            for (var a = !1; r.buffer;) {
                                if (!/\r\n|\n/.test(r.buffer)) return this;
                                switch (a ? a = !1 : i = t(), r.state) {
                                    case"HEADER":
                                        /:/.test(i) ? h(i, function (e, t) {
                                        }, /:/) : i || (r.state = "ID");
                                        continue;
                                    case"NOTE":
                                        i || (r.state = "ID");
                                        continue;
                                    case"ID":
                                        if (/^NOTE($|[ \t])/.test(i)) {
                                            r.state = "NOTE";
                                            break
                                        }
                                        if (!i) continue;
                                        if (r.cue = new o.default(0, 0, ""), r.state = "CUE", -1 === i.indexOf("--\x3e")) {
                                            r.cue.id = i;
                                            continue
                                        }
                                    case"CUE":
                                        if (!r.cue) {
                                            r.state = "BADCUE";
                                            continue
                                        }
                                        try {
                                            !function (t, e, s) {
                                                var i, a, r = t;

                                                function n() {
                                                    var e = l(t);
                                                    if (null === e) throw new Error("Malformed timestamp: " + r);
                                                    return t = t.replace(/^[^\sa-zA-Z-]+/, ""), e
                                                }

                                                function o() {
                                                    t = t.replace(/^\s+/, "")
                                                }

                                                if (o(), e.startTime = n(), o(), "--\x3e" !== t.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + r);
                                                t = t.slice(3), o(), e.endTime = n(), o(), i = t, e = e, a = new d, h(i, function (e, t) {
                                                    var i;
                                                    switch (e) {
                                                        case"region":
                                                            for (var r = s.length - 1; 0 <= r; r--) if (s[r].id === t) {
                                                                a.set(e, s[r].region);
                                                                break
                                                            }
                                                            break;
                                                        case"vertical":
                                                            a.alt(e, t, ["rl", "lr"]);
                                                            break;
                                                        case"line":
                                                            i = t.split(","), a.integer(e, i[0]), a.percent(e, i[0]) && a.set("snapToLines", !1), a.alt(e, i[0], ["auto"]), 2 === i.length && a.alt("lineAlign", i[1], ["start", u, "end"]);
                                                            break;
                                                        case"position":
                                                            i = t.split(","), a.percent(e, i[0]), 2 === i.length && a.alt("positionAlign", i[1], ["start", u, "end", "line-left", "line-right", "auto"]);
                                                            break;
                                                        case"size":
                                                            a.percent(e, t);
                                                            break;
                                                        case"align":
                                                            a.alt(e, t, ["start", u, "end", "left", "right"])
                                                    }
                                                }, /:/, /\s/), e.region = a.get("region", null), e.vertical = a.get("vertical", ""), "auto" === (i = a.get("line", "auto")) && -1 === c.line && (i = -1), e.line = i, e.lineAlign = a.get("lineAlign", "start"), e.snapToLines = a.get("snapToLines", !0), e.size = a.get("size", 100), e.align = a.get("align", u), "auto" === (i = a.get("position", "auto")) && 50 === c.position && (i = "start" === e.align || "left" === e.align ? 0 : "end" === e.align || "right" === e.align ? 100 : 50), e.position = i
                                            }(i, r.cue, r.regionList)
                                        } catch (e) {
                                            r.cue = null, r.state = "BADCUE";
                                            continue
                                        }
                                        r.state = "CUETEXT";
                                        continue;
                                    case"CUETEXT":
                                        var n = -1 !== i.indexOf("--\x3e");
                                        if (!i || n && (a = !0)) {
                                            r.oncue && r.cue && r.oncue(r.cue), r.cue = null, r.state = "ID";
                                            continue
                                        }
                                        if (null === r.cue) continue;
                                        r.cue.text && (r.cue.text += "\n"), r.cue.text += i;
                                        continue;
                                    case"BADCUE":
                                        i || (r.state = "ID")
                                }
                            }
                        } catch (e) {
                            "CUETEXT" === r.state && r.cue && r.oncue && r.oncue(r.cue), r.cue = null, r.state = "INITIAL" === r.state ? "BADWEBVTT" : "BADCUE"
                        }
                        return this
                    }, i.flush = function () {
                        var t = this;
                        try {
                            if (!t.cue && "HEADER" !== t.state || (t.buffer += "\n\n", t.parse()), "INITIAL" === t.state || "BADWEBVTT" === t.state) throw new Error("Malformed WebVTT signature.")
                        } catch (e) {
                            t.onparsingerror && t.onparsingerror(e)
                        }
                        return t.onflush && t.onflush(), this
                    };
                    var n = f;

                    function f() {
                        this.state = "INITIAL", this.buffer = "", this.decoder = new r, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
                    }
                }, "./src/utils/webvtt-parser.ts": (e, t, i) => {
                    i.r(t), i.d(t, {
                        generateCueId: () => S, parseWebVTT: () => function (e, t, i, s, a, n, r, o) {
                            var l, d = new y.VTTParser,
                                e = (0, A.utf8ArrayToStr)(new Uint8Array(e)).trim().replace(_, "\n").split("\n"),
                                h = [], c = (0, b.toMpegTsClockFromTimescale)(t, i), u = "00:00.000", p = 0, f = 0,
                                m = !0;
                            d.oncue = function (e) {
                                var t = s[a], i = s.ccOffset, r = (p - c) / 9e4,
                                    t = (null != t && t.new && (void 0 !== f ? i = s.ccOffset = t.start : function (e, t) {
                                        var i, r = e[a], s = e[r.prevCC];
                                        if (!s || !s.new && r.new) return e.ccOffset = e.presentationOffset = r.start, r.new = !1;
                                        for (; null != (i = s) && i.new;) e.ccOffset += r.start - s.start, r.new = !1, s = e[(r = s).prevCC];
                                        e.presentationOffset = t
                                    }(s, r)), r && (i = r - s.presentationOffset), e.endTime - e.startTime),
                                    r = (0, v.normalizePts)(9e4 * (e.startTime + i - f), 9e4 * n) / 9e4,
                                    i = (e.startTime = Math.max(r, 0), e.endTime = Math.max(r + t, 0), e.text.trim());
                                e.text = decodeURIComponent(encodeURIComponent(i)), e.id || (e.id = S(e.startTime, e.endTime, i)), 0 < e.endTime && h.push(e)
                            }, d.onparsingerror = function (e) {
                                l = e
                            }, d.onflush = function () {
                                l ? o(l) : r(h)
                            }, e.forEach(function (e) {
                                if (m) {
                                    if (w(e, "X-TIMESTAMP-MAP=")) {
                                        m = !1, e.slice(16).split(",").forEach(function (e) {
                                            w(e, "LOCAL:") ? u = e.slice(6) : w(e, "MPEGTS:") && (p = parseInt(e.slice(7)))
                                        });
                                        try {
                                            f = function (e) {
                                                var t = parseInt(e.slice(-3)), i = parseInt(e.slice(-6, -4)),
                                                    r = parseInt(e.slice(-9, -7)),
                                                    s = 9 < e.length ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
                                                if ((0, g.isFiniteNumber)(t) && (0, g.isFiniteNumber)(i) && (0, g.isFiniteNumber)(r) && (0, g.isFiniteNumber)(s)) return t + 1e3 * i + 6e4 * r + 36e5 * s;
                                                throw Error("Malformed X-TIMESTAMP-MAP: Local:" + e)
                                            }(u) / 1e3
                                        } catch (e) {
                                            l = e
                                        }
                                        return
                                    }
                                    "" === e && (m = !1)
                                }
                                d.parse(e + "\n")
                            }), d.flush()
                        }
                    });
                    var g = i("./src/polyfills/number.ts"), y = i("./src/utils/vttparser.ts"),
                        A = i("./src/demux/id3.ts"), b = i("./src/utils/timescale-conversion.ts"),
                        v = i("./src/remux/mp4-remuxer.ts"), _ = /\r\n|\n\r|\n|\r/g, w = function (e, t, i) {
                            return e.slice(i = void 0 === i ? 0 : i, i + t.length) === t
                        }, r = function (e) {
                            for (var t = 5381, i = e.length; i;) t = 33 * t ^ e.charCodeAt(--i);
                            return (t >>> 0).toString()
                        };

                    function S(e, t, i) {
                        return r(e.toString()) + r(t.toString()) + r(i)
                    }
                }, "./src/utils/xhr-loader.ts": (e, t, i) => {
                    i.r(t), i.d(t, {default: () => a});
                    var o = i("./src/utils/logger.ts"), r = i("./src/loader/load-stats.ts"), s = /^age:\s*[\d.]+\s*$/m;
                    (t = n.prototype).destroy = function () {
                        this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null
                    }, t.abortInternal = function () {
                        var e = this.loader;
                        self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort()))
                    }, t.abort = function () {
                        var e;
                        this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
                    }, t.load = function (e, t, i) {
                        if (this.stats.loading.start) throw new Error("Loader can only be used once.");
                        this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = i, this.retryDelay = t.retryDelay, this.loadInternal()
                    }, t.loadInternal = function () {
                        var e = this.config, t = this.context;
                        if (e) {
                            var i = this.loader = new self.XMLHttpRequest, r = this.stats,
                                r = (r.loading.first = 0, r.loaded = 0, this.xhrSetup);
                            try {
                                if (r) try {
                                    r(i, t.url)
                                } catch (e) {
                                    i.open("GET", t.url, !0), r(i, t.url)
                                }
                                i.readyState || i.open("GET", t.url, !0);
                                var s = this.context.headers;
                                if (s) for (var a in s) i.setRequestHeader(a, s[a])
                            } catch (e) {
                                return void this.callbacks.onError({code: i.status, text: e.message}, t, i)
                            }
                            t.rangeEnd && i.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), i.onreadystatechange = this.readystatechange.bind(this), i.onprogress = this.loadprogress.bind(this), i.responseType = t.responseType, self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), e.timeout), i.send()
                        }
                    }, t.readystatechange = function () {
                        var e, t, i, r, s = this.context, a = this.loader, n = this.stats;
                        s && a && (t = a.readyState, e = this.config, !n.aborted && 2 <= t && (self.clearTimeout(this.requestTimeout), 0 === n.loading.first && (n.loading.first = Math.max(self.performance.now(), n.loading.start)), 4 === t ? (a.onreadystatechange = null, a.onprogress = null, t = a.status, r = "arraybuffer" === a.responseType, 200 <= t && t < 300 && (r && a.response || null !== a.responseText) ? (n.loading.end = Math.max(self.performance.now(), n.loading.first), r = r ? (i = a.response).byteLength : (i = a.responseText).length, n.loaded = n.total = r, this.callbacks && ((r = this.callbacks.onProgress) && r(n, s, i, a), this.callbacks && (r = {
                            url: a.responseURL,
                            data: i
                        }, this.callbacks.onSuccess(r, n, s, a)))) : n.retry >= e.maxRetry || 400 <= t && t < 499 ? (o.logger.error(t + " while loading " + s.url), this.callbacks.onError({
                            code: t,
                            text: a.statusText
                        }, s, a)) : (o.logger.warn(t + " while loading " + s.url + ", retrying in " + this.retryDelay + "..."), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, e.maxRetryDelay), n.retry++)) : (self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), e.timeout))))
                    }, t.loadtimeout = function () {
                        o.logger.warn("timeout while loading " + this.context.url);
                        var e = this.callbacks;
                        e && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader))
                    }, t.loadprogress = function (e) {
                        var t = this.stats;
                        t.loaded = e.loaded, e.lengthComputable && (t.total = e.total)
                    }, t.getCacheAge = function () {
                        var e, t = null;
                        return t = this.loader && s.test(this.loader.getAllResponseHeaders()) ? (e = this.loader.getResponseHeader("age")) ? parseFloat(e) : null : t
                    };
                    const a = n;

                    function n(e) {
                        this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e ? e.xhrSetup : null, this.stats = new r.LoadStats, this.retryDelay = 0
                    }
                }, "./node_modules/eventemitter3/index.js": e => {
                    var r = Object.prototype.hasOwnProperty, p = "~";

                    function i() {
                    }

                    function a(e, t, i) {
                        this.fn = e, this.context = t, this.once = i || !1
                    }

                    function s(e, t, i, r, s) {
                        if ("function" != typeof i) throw new TypeError("The listener must be a function");
                        i = new a(i, r || e, s), r = p ? p + t : t;
                        return e._events[r] ? e._events[r].fn ? e._events[r] = [e._events[r], i] : e._events[r].push(i) : (e._events[r] = i, e._eventsCount++), e
                    }

                    function l(e, t) {
                        0 == --e._eventsCount ? e._events = new i : delete e._events[t]
                    }

                    function t() {
                        this._events = new i, this._eventsCount = 0
                    }

                    Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (p = !1)), t.prototype.eventNames = function () {
                        var e, t, i = [];
                        if (0 === this._eventsCount) return i;
                        for (t in e = this._events) r.call(e, t) && i.push(p ? t.slice(1) : t);
                        return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
                    }, t.prototype.listeners = function (e) {
                        var e = p ? p + e : e, t = this._events[e];
                        if (!t) return [];
                        if (t.fn) return [t.fn];
                        for (var i = 0, r = t.length, s = new Array(r); i < r; i++) s[i] = t[i].fn;
                        return s
                    }, t.prototype.listenerCount = function (e) {
                        e = p ? p + e : e, e = this._events[e];
                        return e ? e.fn ? 1 : e.length : 0
                    }, t.prototype.emit = function (e, t, i, r, s, a) {
                        var n = p ? p + e : e;
                        if (!this._events[n]) return !1;
                        var o, l = this._events[n], d = arguments.length;
                        if (l.fn) {
                            switch (l.once && this.removeListener(e, l.fn, void 0, !0), d) {
                                case 1:
                                    return l.fn.call(l.context), !0;
                                case 2:
                                    return l.fn.call(l.context, t), !0;
                                case 3:
                                    return l.fn.call(l.context, t, i), !0;
                                case 4:
                                    return l.fn.call(l.context, t, i, r), !0;
                                case 5:
                                    return l.fn.call(l.context, t, i, r, s), !0;
                                case 6:
                                    return l.fn.call(l.context, t, i, r, s, a), !0
                            }
                            for (u = 1, o = new Array(d - 1); u < d; u++) o[u - 1] = arguments[u];
                            l.fn.apply(l.context, o)
                        } else for (var h, c = l.length, u = 0; u < c; u++) switch (l[u].once && this.removeListener(e, l[u].fn, void 0, !0), d) {
                            case 1:
                                l[u].fn.call(l[u].context);
                                break;
                            case 2:
                                l[u].fn.call(l[u].context, t);
                                break;
                            case 3:
                                l[u].fn.call(l[u].context, t, i);
                                break;
                            case 4:
                                l[u].fn.call(l[u].context, t, i, r);
                                break;
                            default:
                                if (!o) for (h = 1, o = new Array(d - 1); h < d; h++) o[h - 1] = arguments[h];
                                l[u].fn.apply(l[u].context, o)
                        }
                        return !0
                    }, t.prototype.on = function (e, t, i) {
                        return s(this, e, t, i, !1)
                    }, t.prototype.once = function (e, t, i) {
                        return s(this, e, t, i, !0)
                    }, t.prototype.removeListener = function (e, t, i, r) {
                        e = p ? p + e : e;
                        if (!this._events[e]) return this;
                        if (!t) return l(this, e), this;
                        var s = this._events[e];
                        if (s.fn) s.fn !== t || r && !s.once || i && s.context !== i || l(this, e); else {
                            for (var a = 0, n = [], o = s.length; a < o; a++) (s[a].fn !== t || r && !s[a].once || i && s[a].context !== i) && n.push(s[a]);
                            n.length ? this._events[e] = 1 === n.length ? n[0] : n : l(this, e)
                        }
                        return this
                    }, t.prototype.removeAllListeners = function (e) {
                        return e ? (e = p ? p + e : e, this._events[e] && l(this, e)) : (this._events = new i, this._eventsCount = 0), this
                    }, t.prototype.off = t.prototype.removeListener, t.prototype.addListener = t.prototype.on, t.prefixed = p, e.exports = t.EventEmitter = t
                }, "./node_modules/url-toolkit/src/url-toolkit.js": function (e) {
                    var t = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/,
                        a = /^(?=([^\/?#]*))\1([^]*)$/, i = /(?:\/|^)\.(?=\/)/g,
                        r = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, n = {
                            buildAbsoluteURL: function (e, t, i) {
                                if (i = i || {}, e = e.trim(), !(t = t.trim())) {
                                    if (!i.alwaysNormalize) return e;
                                    var r = n.parseURL(e);
                                    if (r) return r.path = n.normalizePath(r.path), n.buildURLFromParts(r);
                                    throw new Error("Error trying to parse base URL.")
                                }
                                r = n.parseURL(t);
                                if (!r) throw new Error("Error trying to parse relative URL.");
                                if (r.scheme) return i.alwaysNormalize ? (r.path = n.normalizePath(r.path), n.buildURLFromParts(r)) : t;
                                t = n.parseURL(e);
                                if (!t) throw new Error("Error trying to parse base URL.");
                                !t.netLoc && t.path && "/" !== t.path[0] && (e = a.exec(t.path), t.netLoc = e[1], t.path = e[2]), t.netLoc && !t.path && (t.path = "/");
                                var s, e = {
                                    scheme: t.scheme,
                                    netLoc: r.netLoc,
                                    path: null,
                                    params: r.params,
                                    query: r.query,
                                    fragment: r.fragment
                                };
                                return r.netLoc || (e.netLoc = t.netLoc, "/" === r.path[0]) || (r.path ? (s = (s = t.path).substring(0, s.lastIndexOf("/") + 1) + r.path, e.path = n.normalizePath(s)) : (e.path = t.path, r.params || (e.params = t.params, r.query || (e.query = t.query)))), null === e.path && (e.path = i.alwaysNormalize ? n.normalizePath(r.path) : r.path), n.buildURLFromParts(e)
                            }, parseURL: function (e) {
                                e = t.exec(e);
                                return e ? {
                                    scheme: e[1] || "",
                                    netLoc: e[2] || "",
                                    path: e[3] || "",
                                    params: e[4] || "",
                                    query: e[5] || "",
                                    fragment: e[6] || ""
                                } : null
                            }, normalizePath: function (e) {
                                for (e = e.split("").reverse().join("").replace(i, ""); e.length !== (e = e.replace(r, "")).length;) ;
                                return e.split("").reverse().join("")
                            }, buildURLFromParts: function (e) {
                                return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
                            }
                        };
                    e.exports = n
                }
            }, r = {};

            function s(e) {
                var t = r[e];
                if (void 0 !== t) return t.exports;
                t = r[e] = {exports: {}};
                return i[e].call(t.exports, t, t.exports, s), t.exports
            }

            s.m = i, s.n = e => {
                var t = e && e.__esModule ? () => e.default : () => e;
                return s.d(t, {a: t}), t
            }, s.d = (e, t) => {
                for (var i in t) s.o(t, i) && !s.o(e, i) && Object.defineProperty(e, i, {enumerable: !0, get: t[i]})
            }, s.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), s.r = e => {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
            };
            var e = s("./src/hls.ts");
            return e.default
        })())
    }));

    class va extends e {
        constructor(e) {
            super(), (this.player = e)._opt, this.canVideoPlay = !1, this.$videoElement = null, this.canvasRenderInterval = null, this.bandwidthEstimateInterval = null, this.fpsInterval = null, this.hlsFps = 0, this.hlsPrevFrams = 0, this.isInitInfo = !1, this.eventsDestroy = [], ii() ? (this.$videoElement = this.player.video.$videoElement, this.canVideoPlay = !0) : r.isSupported() ? (this.$videoElement = this.player.video.$videoElement, this.hls = new r({}), this._initHls(), this._bindEvents()) : this.player.debug.error("HlsDecoder", "init hls error ,not support "), this.player.debug.log("HlsDecoder", "init")
        }

        destroy() {
            return new Promise((e, t) => {
                this.hls && (this.hls.destroy(), this.hls = null), this.eventsDestroy.length && (this.eventsDestroy.forEach(e => e()), this.eventsDestroy = []), this.isInitInfo = !1, this._stopCanvasRender(), this._stopBandwidthEstimateInterval(), this._stopFpsInterval(), this.$videoElement = null, this.hlsFps = 0, this.player.debug.log("HlsDecoder", "destroy"), setTimeout(() => {
                    e()
                }, 0)
            })
        }

        checkHlsBufferedDelay() {
            var e = this.$videoElement;
            let t = 0;
            const i = e.buffered, r = i.length ? i.end(i.length - 1) : 0;
            return (t = r - e.currentTime) < 0 && (this.player.debug.warn("HlsDecoder", "checkHlsBufferedDelay result < 0", t, r, e.currentTime), t = 0), t
        }

        getFps() {
            return this.hlsFps
        }

        _startCanvasRender() {
            this._stopCanvasRender(), this.canvasRenderInterval = setInterval(() => {
                this.player.video.render({$video: this.$videoElement, ts: 0})
            }, 40)
        }

        _stopCanvasRender() {
            this.canvasRenderInterval && (clearInterval(this.canvasRenderInterval), this.canvasRenderInterval = null)
        }

        _startBandwidthEstimateInterval() {
            this._stopBandwidthEstimateInterval(), this.bandwidthEstimateInterval = setInterval(() => {
                let e = 0;
                this.hls.bandwidthEstimate && (e = this.hls.bandwidthEstimate), this.player.emit(w.kBps, (e / 1024 / 8 / 10).toFixed(2))
            }, 1e3)
        }

        _stopBandwidthEstimateInterval() {
            this.bandwidthEstimateInterval && (clearInterval(this.bandwidthEstimateInterval), this.bandwidthEstimateInterval = null)
        }

        _startFpsInterval() {
            this._stopCanvasRender(), this.fpsInterval = setInterval(() => {
                var e = this.$videoElement.getVideoPlaybackQuality();
                this.hlsFps = e.totalVideoFrames - this.hlsPrevFrams, this.hlsPrevFrams = e.totalVideoFrames
            }, 1e3)
        }

        _stopFpsInterval() {
            this.fpsInterval && (clearInterval(this.fpsInterval), this.fpsInterval = null)
        }

        _initHls() {
            this.player._opt.useCanvasRender && (this.$videoElement = document.createElement("video"), this.$videoElement.muted = !0, It() && (this.$videoElement.style.position = "absolute"), this.initVideoEvents()), this.hls.attachMedia(this.$videoElement)
        }

        _bindEvents() {
            const i = this.player, e = this.player.events["proxy"];
            this.hls;
            var t = e(this.$videoElement, Qe, e => {
                this.hls && (e = parseInt(e.timeStamp, 10), i.handleRender(), i.updateStats({
                    ts: e,
                    dts: e,
                    fps: !0
                }), i.emit(w.videoTimeUpdate, e))
            });
            this.eventsDestroy.push(t), this._startBandwidthEstimateInterval(), this._startFpsInterval(), this.hls.on(r.Events.ERROR, (e, t) => {
                if (t.fatal) switch (t.type) {
                    case r.ErrorTypes.NETWORK_ERROR:
                        this.player.debug.warn("HlsDecoder", "fatal network error encountered, try to recover"), this.hls.startLoad();
                        break;
                    case r.ErrorTypes.MEDIA_ERROR:
                        this.player.debug.warn("HlsDecoder", "fatal media error encountered, try to recover"), this.hls.recoverMediaError()
                }
            }), this.hls.on(r.Events.MEDIA_ATTACHING, () => {
            }), this.hls.on(r.Events.MEDIA_ATTACHED, () => {
            }), this.hls.on(r.Events.MEDIA_DETACHING, () => {
            }), this.hls.on(r.Events.MEDIA_DETACHED, () => {
            }), this.hls.on(r.Events.BUFFER_RESET, () => {
            }), this.hls.on(r.Events.BUFFER_CODECS, () => {
            }), this.hls.on(r.Events.BUFFER_CREATED, () => {
            }), this.hls.on(r.Events.BUFFER_APPENDING, (e, t) => {
                this.player.debug.log("HlsDecoder", "BUFFER_APPENDING", t)
            }), this.hls.on(r.Events.BUFFER_APPENDED, () => {
            }), this.hls.on(r.Events.BUFFER_EOS, () => {
            }), this.hls.on(r.Events.BUFFER_FLUSHING, () => {
            }), this.hls.on(r.Events.BUFFER_FLUSHED, () => {
            }), this.hls.on(r.Events.MANIFEST_LOADING, () => {
                this.player.debug.log("HlsDecoder", "MANIFEST_LOADING 开始加载playlist m3u8资源")
            }), this.hls.on(r.Events.MANIFEST_LOADED, (e, t) => {
                this.player.debug.log("HlsDecoder", "MANIFEST_LOADED playlist m3u8文件加载完成", t)
            }), this.hls.on(r.Events.MANIFEST_PARSED, () => {
                this.player.debug.log("HlsDecoder", "MANIFEST_PARSED playlist m3u8解析完成"), i._times.demuxStart || (i._times.demuxStart = p())
            }), this.hls.on(r.Events.LEVEL_LOADING, () => {
            }), this.hls.on(r.Events.LEVEL_LOADED, (e, t) => {
            }), this.hls.on(r.Events.FRAG_LOADING, () => {
            }), this.hls.on(r.Events.FRAG_LOADED, (e, t) => {
                i._times.decodeStart || (i._times.decodeStart = p())
            }), this.hls.on(r.Events.BUFFER_APPENDING, () => {
                i._times.videoStart || (i._times.videoStart = p(), i.handlePlayToRenderTimes())
            }), this.hls.on(r.Events.FRAG_DECRYPTED, () => {
            }), this.hls.on(r.Events.KEY_LOADING, () => {
            }), this.hls.on(r.Events.KEY_LOADING, () => {
            }), this.hls.on(r.Events.FPS_DROP, e => {
            }), this.hls.on(r.Events.FPS_DROP_LEVEL_CAPPING, e => {
            }), this.hls.on(r.Events.FRAG_PARSING_INIT_SEGMENT, (e, s) => {
                this.player.debug.log("HlsDecoder", "FRAG_PARSING_INIT_SEGMENT", s);
                const t = !!(s && s.tracks && s.tracks.audio), i = !!(s && s.tracks && s.tracks.video);
                if (t && s.tracks.audio) {
                    var r = s.tracks.audio;
                    const t = r.metadata && r.metadata.channelCount ? r.metadata.channelCount : 0, i = r.codec;
                    this.player.audio && this.player.audio.updateAudioInfo({encType: i, channels: t, sampleRate: 44100})
                }
                if (i && s.tracks.video) {
                    let e = s.tracks.video, t = e.codec, i = e.metadata && e.metadata.width ? e.metadata.width : 0,
                        r = e.metadata && e.metadata.height ? e.metadata.height : 0;
                    this.player.video && this.player.video.updateVideoInfo({
                        encTypeCode: -1 !== t.indexOf("avc") ? 7 : 12,
                        width: i,
                        height: r
                    })
                }
            })
        }

        initVideoPlay(e) {
            this.player._opt.useCanvasRender && (this.$videoElement = document.createElement("video"), this.initVideoEvents()), this.$videoElement.muted = !0, this.$videoElement.src = e
        }

        initRenderSize() {
            this.isInitInfo || (this.player.video.updateVideoInfo({
                width: this.$videoElement.videoWidth,
                height: this.$videoElement.videoHeight
            }), this.player.video.initCanvasViewSize(), this.isInitInfo = !0)
        }

        initVideoEvents() {
            const e = this.player.events["proxy"], t = e(this.$videoElement, Ye, () => {
                this.player.debug.log("HlsDecoder", "video canplay"), this.$videoElement.play().then(() => {
                    this.player.debug.log("HlsDecoder", "video play"), this._startCanvasRender(), this.initRenderSize()
                }).catch(e => {
                    this.player.debug.warn("HlsDecoder", "video play error ", e)
                })
            }), i = e(this.$videoElement, Je, () => {
                this.player.debug.log("HlsDecoder", "video waiting")
            }), r = e(this.$videoElement, Qe, e => {
                e = parseInt(e.timeStamp, 10);
                this.player.handleRender(), this.player.updateStats({ts: e}), this.player.emit(w.videoTimeUpdate, e), this.$videoElement.paused && (this.player.debug.warn("HlsDecoder", "video is paused and next try to replay"), this.$videoElement.play().then(() => {
                    this.player.debug.log("HlsDecoder", "video is paused and replay success")
                }).catch(e => {
                    this.player.debug.warn("HlsDecoder", "video is paused and replay error ", e)
                }))
            }), s = e(this.$videoElement, Xe, () => {
                this.player.debug.log("HlsDecoder", "video playback Rate change", this.$videoElement && this.$videoElement.playbackRate)
            });
            this.eventsDestroy.push(t, i, r, s)
        }

        loadSource(i) {
            return new Promise((e, t) => {
                this.canVideoPlay ? (this.initVideoPlay(i), e()) : this.hls.on(r.Events.MEDIA_ATTACHED, () => {
                    this.hls.loadSource(i), e()
                })
            })
        }

        _handleUpdatePlaybackRate() {
            if (this.$videoElement) {
                const s = this.$videoElement;
                var t = (this.player._opt.videoBuffer + this.player._opt.videoBufferDelay) / 1e3;
                const a = s.buffered;
                a.length && a.start(0);
                var i = a.length ? a.end(a.length - 1) : 0;
                let e = s.currentTime;
                var r = i - e, t = Math.max(5, 3 + t),
                    t = (t < r ? (this.player.debug.warn("HlsDecoder", `handleUpdatePlaybackRate and delay buffer is more than ${t} is ${r} and new time is ${i} `), s.currentTime = i, e = s.currentTime) : r < 0 && this.player.debug.warn("HlsDecoder", `handleUpdatePlaybackRate and delay buffer is less than 0 is ${r} and new time is ` + i), this._getPlaybackRate(i - e));
                s.playbackRate !== t && (s.playbackRate = t)
            }
        }

        _getPlaybackRate(e) {
            var t = this.$videoElement, i = this.player._opt.videoBuffer, r = i + this.player._opt.videoBufferDelay;
            return e *= 1e3, 1 === t.playbackRate ? r < e ? 1.2 : 1 : e <= i ? 1 : t.playbackRate
        }

        getDecodePlaybackRate() {
            let e = 0;
            var t = this.$videoElement;
            return e = t ? t.playbackRate : e
        }
    }

    const _a = "fetch", wa = "arraybuffer", Sa = "real_time_speed", Ea = Object.prototype.toString;

    function Ta(e) {
        if ("[object Object]" === Ea.call(e)) return e = Object.getPrototypeOf(e), null === e || e === Object.prototype
    }

    function ka(t) {
        if (t && null !== t[0] && void 0 !== t[0] && (0 !== t[0] || null !== t[1] && void 0 !== t[1])) {
            let e = "bytes=" + t[0] + "-";
            return t[1] && (e += t[1]), e
        }
    }

    function xa(e) {
        return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }

    function Ca(t, r) {
        if (t) {
            if (!r) return t;
            let e;
            var i = Object.keys(r).map(i => {
                if (null != (e = r[i])) return Array.isArray(e) ? i += "[]" : e = [e], e.map(e => {
                    var t = e;
                    return "[object Date]" === Ea.call(t) ? e = e.toISOString() : null !== e && "object" == typeof e && (e = JSON.stringify(e)), xa(i) + "=" + xa(e)
                }).join("&")
            }).filter(Boolean).join("&");
            if (i) {
                const r = t.indexOf("#");
                -1 !== r && (t = t.slice(0, r)), t += (-1 === t.indexOf("?") ? "?" : "&") + i
            }
            return t
        }
    }

    function La(e, t, i, r, s, a, n, o, l, d, h) {
        return s = null != s ? parseFloat(s) : null, r = parseInt(r || "0", 10), {
            data: e,
            done: t,
            option: {
                range: l,
                vid: d,
                index: o,
                contentLength: r = Number.isNaN(r) ? 0 : r,
                age: s,
                startTime: a,
                firstByteTime: n,
                endTime: Date.now(),
                priOptions: h
            },
            response: i
        }
    }

    function Da(e, t) {
        return Math.round(8 * e * 1e3 / t / 1024)
    }

    class Ia extends Error {
        constructor(e, t, i, r) {
            super(r), s(this, "retryCount", 0), s(this, "isTimeout", !1), s(this, "loaderType", _a), s(this, "startTime", 0), s(this, "endTime", 0), s(this, "options", {}), this.url = e, this.request = t, this.response = i
        }
    }

    class Ra extends e {
        constructor(e) {
            super(), s(this, "_abortController", null), s(this, "_timeoutTimer", null), s(this, "_reader", null), s(this, "_response", null), s(this, "_aborted", !1), s(this, "_index", -1), s(this, "_range", null), s(this, "_receivedLength", 0), s(this, "_running", !1), s(this, "_logger", null), s(this, "_vid", ""), s(this, "_onProcessMinLen", 0), s(this, "_onCancel", null), s(this, "_priOptions", null), s(this, "TAG_NAME", "FetchLoader"), this.player = e
        }

        load(e) {
            let {
                url: a,
                vid: t,
                timeout: i,
                responseType: n,
                onProgress: o,
                index: l,
                onTimeout: r,
                onCancel: s,
                range: d,
                transformResponse: h,
                request: c,
                params: u,
                method: p,
                headers: f,
                body: m,
                mode: g,
                credentials: y,
                cache: A,
                redirect: b,
                referrer: v,
                referrerPolicy: _,
                onProcessMinLen: w,
                priOptions: S
            } = e;
            this._aborted = !1, this._onProcessMinLen = w, this._onCancel = s, this._abortController = "undefined" != typeof AbortController && new AbortController, this._running = !0, this._index = l, this._range = d || [0, 0], this._vid = t || a, this._priOptions = S || {};
            const E = {
                method: p,
                headers: f,
                body: m,
                mode: g,
                credentials: y,
                cache: A,
                redirect: b,
                referrer: v,
                referrerPolicy: _,
                signal: null == (e = this._abortController) ? void 0 : e.signal
            };
            let T = !1;
            clearTimeout(this._timeoutTimer), a = Ca(a, u);
            e = ka(d);
            e && (f = c ? c.headers : E.headers = E.headers || (Headers ? new Headers : {}), Headers && f instanceof Headers ? f.append("Range", e) : f.Range = e), i && (this._timeoutTimer = setTimeout(() => {
                if (T = !0, this.cancel(), r) {
                    const e = new Ia(a, E, null, "timeout");
                    e.isTimeout = !0, r(e, {
                        index: this._index,
                        range: this._range,
                        vid: this._vid,
                        priOptions: this._priOptions
                    })
                }
            }, i));
            const k = Date.now();
            return (x(l) || x(d)) && this.player.debug.log(this.TAG_NAME, "[fetch load start], index,", l, ",range,", d), new Promise((r, s) => {
                fetch(c || a, c ? void 0 : E).then(async t => {
                    if (clearTimeout(this._timeoutTimer), this._response = t, !this._aborted && this._running) {
                        if (!(t = h ? h(t, a) || t : t).ok) throw new Ia(a, E, t, "bad network response");
                        var i = Date.now();
                        let e;
                        if ("text" === n) e = await t.text(), this._running = !1; else if ("json" === n) e = await t.json(), this._running = !1; else {
                            if (o) return this.resolve = r, this.reject = s, void this._loadChunk(t, o, k, i);
                            {
                                e = await t.arrayBuffer(), e = new Uint8Array(e), this._running = !1;
                                const r = Date.now() - k, s = Da(e.byteLength, r);
                                this.emit(Sa, {
                                    speed: s,
                                    len: e.byteLength,
                                    time: r,
                                    vid: this._vid,
                                    index: this._index,
                                    range: this._range,
                                    priOptions: this._priOptions
                                })
                            }
                        }
                        (x(l) || x(d)) && this.player.debug.log(this.TAG_NAME, "[fetch load end], index,", l, ",range,", d), r(La(e, !0, t, t.headers.get("Content-Length"), t.headers.get("age"), k, i, l, d, this._vid, this._priOptions))
                    }
                }).catch(e => {
                    var t;
                    clearTimeout(this._timeoutTimer), this._running = !1, this._aborted && !T || ((e = e instanceof Ia ? e : new Ia(a, E, null, null == (t = e) ? void 0 : t.message)).startTime = k, e.endTime = Date.now(), e.isTimeout = T, e.options = {
                        index: this._index,
                        range: this._range,
                        vid: this._vid,
                        priOptions: this._priOptions
                    }, s(e))
                })
            })
        }

        async cancel() {
            if (!this._aborted) {
                if (this._aborted = !0, this._running = !1, this._response) {
                    try {
                        this._reader && await this._reader.cancel()
                    } catch (e) {
                    }
                    this._response = this._reader = null
                }
                if (this._abortController) {
                    try {
                        this._abortController.abort()
                    } catch (e) {
                    }
                    this._abortController = null
                }
                this._onCancel && this._onCancel({
                    index: this._index,
                    range: this._range,
                    vid: this._vid,
                    priOptions: this._priOptions
                })
            }
        }

        _loadChunk(s, a, n, o) {
            if (!s.body || !s.body.getReader) {
                this._running = !1;
                const a = new Ia(s.url, "", s, "onProgress of bad response.body.getReader");
                return a.options = {
                    index: this._index,
                    range: this._range,
                    vid: this._vid,
                    priOptions: this._priOptions
                }, void this.reject(a)
            }
            0 < this._onProcessMinLen && (this._cache = new Uint8Array(2097152), this._writeIdx = 0);
            const l = this._reader = s.body.getReader();
            let d, h, c;
            const u = async () => {
                h = Date.now();
                try {
                    d = await l.read(), c = Date.now()
                } catch (e) {
                    return c = Date.now(), void (this._aborted || (this._running = !1, e.options = {
                        index: this._index,
                        range: this._range,
                        vid: this._vid,
                        priOptions: this._priOptions
                    }, this.reject(e)))
                }
                var e = 0 < (null == (e = this._range) ? void 0 : e.length) ? this._range[0] : 0,
                    t = e + this._receivedLength;
                if (this._aborted) return this._running = !1, void a(void 0, !1, {
                    range: [t, t],
                    vid: this._vid,
                    index: this._index,
                    startTime: h,
                    endTime: c,
                    st: n,
                    firstByteTime: o,
                    priOptions: this._priOptions
                }, s);
                var i = d.value ? d.value.byteLength : 0;
                let r;
                if (this._receivedLength += i, this.player.debug.log(this.TAG_NAME, "【fetchLoader,onProgress call】,task,", this._range, ", start,", t, ", end,", e + this._receivedLength, ", done,", d.done), 0 < this._onProcessMinLen) {
                    if (this._writeIdx + i >= this._onProcessMinLen || d.done) (r = new Uint8Array(this._writeIdx + i)).set(this._cache.slice(0, this._writeIdx), 0), 0 < i && r.set(d.value, this._writeIdx), this._writeIdx = 0, this.player.debug.log(this.TAG_NAME, "【fetchLoader,onProgress enough】,done,", d.done, ",len,", r.byteLength, ", writeIdx,", this._writeIdx); else if (0 < i && this._writeIdx + i < 2097152) this._cache.set(d.value, this._writeIdx), this._writeIdx += i, this.player.debug.log(this.TAG_NAME, "【fetchLoader,onProgress cache】,len,", i, ", writeIdx,", this._writeIdx); else if (0 < i) {
                        const s = new Uint8Array(this._writeIdx + i + 2048);
                        this.player.debug.log(this.TAG_NAME, "【fetchLoader,onProgress extra start】,size,", this._writeIdx + i + 2048, ", datalen,", i, ", writeIdx,", this._writeIdx), s.set(this._cache.slice(0, this._writeIdx), 0), 0 < i && s.set(d.value, this._writeIdx), this._writeIdx += i, delete this._cache, this._cache = s, this.player.debug.log(this.TAG_NAME, "【fetchLoader,onProgress extra end】,len,", i, ", writeIdx,", this._writeIdx)
                    }
                } else r = d.value;
                if ((r && 0 < r.byteLength || d.done) && a(r, d.done, {
                    range: [this._range[0] + this._receivedLength - (r ? r.byteLength : 0), this._range[0] + this._receivedLength],
                    vid: this._vid,
                    index: this._index,
                    startTime: h,
                    endTime: c,
                    st: n,
                    firstByteTime: o,
                    priOptions: this._priOptions
                }, s), d.done) {
                    const a = Date.now() - n, l = Da(this._receivedLength, a);
                    this.emit(Sa, {
                        speed: l,
                        len: this._receivedLength,
                        time: a,
                        vid: this._vid,
                        index: this._index,
                        range: this._range,
                        priOptions: this._priOptions
                    }), this._running = !1, this.player.debug.log(this.TAG_NAME, "[fetchLoader onProgress end],task,", this._range, ",done,", d.done), this.resolve(La(d, !0, s, s.headers.get("Content-Length"), s.headers.get("age"), n, o, this._index, this._range, this._vid, this._priOptions))
                } else u()
            };
            u()
        }

        get receiveLen() {
            return this._receivedLength
        }

        get running() {
            return this._running
        }

        set running(e) {
            this._running = e
        }

        static isSupported() {
            return !("undefined" == typeof fetch)
        }
    }

    class Pa {
        constructor(e, t, i) {
            s(this, "TAG_NAME", "Task"), this.promise = function () {
                let i, r;
                const e = new Promise((e, t) => {
                    i = e, r = t
                });
                return e.used = !1, e.resolve = function () {
                    return e.used = !0, i(...arguments)
                }, e.reject = function () {
                    return e.used = !0, r(...arguments)
                }, e
            }(), this.alive = !!t.onProgress, this._loaderType = e, this.player = i, this._loader = new (e === _a && window.fetch ? Ra : Ba)(i), this._config = t, this._retryCount = 0, this._retryTimer = null, this._canceled = !1, this._retryCheckFunc = t.retryCheckFunc
        }

        exec() {
            const {retry: r, retryDelay: s, onRetryError: a, transformError: n, ...o} = this._config, l = async () => {
                try {
                    const r = await this._loader.load(o);
                    this.promise.resolve(r)
                } catch (e) {
                    if (this._loader.running = !1, this.player.debug.log(this.TAG_NAME, "[task request catch err]", e), this._canceled) return;
                    e.loaderType = this._loaderType, e.retryCount = this._retryCount;
                    let t = e, i = (n && (t = n(t) || t), a && 0 < this._retryCount && a(t, this._retryCount, {
                        index: o.index,
                        vid: o.vid,
                        range: o.range,
                        priOptions: o.priOptions
                    }), this._retryCount++, !0);
                    if ((i = this._retryCheckFunc ? this._retryCheckFunc(e) : i) && this._retryCount <= r) return clearTimeout(this._retryTimer), this.player.debug.log(this.TAG_NAME, "[task request setTimeout],retry", this._retryCount, ",retry range,", o.range), void (this._retryTimer = setTimeout(l, s));
                    this.promise.reject(t)
                }
            };
            return l(), this.promise
        }

        async cancel() {
            return clearTimeout(this._retryTimer), this._canceled = !0, this._loader.running = !1, this._loader.cancel()
        }

        get running() {
            return this._loader && this._loader.running
        }

        get loader() {
            return this._loader
        }
    }

    class Ba extends e {
        constructor(e) {
            super(), s(this, "_xhr", null), s(this, "_aborted", !1), s(this, "_timeoutTimer", null), s(this, "_range", null), s(this, "_receivedLength", 0), s(this, "_url", null), s(this, "_onProgress", null), s(this, "_index", -1), s(this, "_headers", null), s(this, "_currentChunkSizeKB", 384), s(this, "_timeout", null), s(this, "_xhr", null), s(this, "_withCredentials", null), s(this, "_startTime", -1), s(this, "_loadCompleteResolve", null), s(this, "_loadCompleteReject", null), s(this, "_runing", !1), s(this, "_logger", !1), s(this, "_vid", ""), s(this, "_responseType", void 0), s(this, "_credentials", void 0), s(this, "_method", void 0), s(this, "_transformResponse", void 0), s(this, "_firstRtt", void 0), s(this, "_onCancel", null), s(this, "_priOptions", null), s(this, "TAG_NAME", "XhrLoader"), this.player = e
        }

        load(e) {
            clearTimeout(this._timeoutTimer), this._range = e.range, this._onProgress = e.onProgress, this._index = e.index, this._headers = e.headers, this._withCredentials = "include" === e.credentials || "same-origin" === e.credentials, this._body = e.body || null, e.method && (this._method = e.method), this._timeout = e.timeout || null, this._runing = !0, this._vid = e.vid || e.url, this._responseType = e.responseType, this._firstRtt = -1, this._onTimeout = e.onTimeout, this._onCancel = e.onCancel, this._request = e.request, this._priOptions = e.priOptions || {}, this.player.debug.log(this.TAG_NAME, "【xhrLoader task】, range", this._range), this._url = Ca(e.url, e.params);
            const t = Date.now();
            return new Promise((e, t) => {
                this._loadCompleteResolve = e, this._loadCompleteReject = t, this._startLoad()
            }).catch(e => {
                if (clearTimeout(this._timeoutTimer), this._runing = !1, !this._aborted) throw(e = e instanceof Ia ? e : new Ia(this._url, this._request)).startTime = t, e.endTime = Date.now(), e.options = {
                    index: this._index,
                    vid: this._vid,
                    priOptions: this._priOptions
                }, e
            })
        }

        _startLoad() {
            let t = null;
            if (this._responseType === wa && this._range && 1 < this._range.length) if (this._onProgress) {
                this._firstRtt = -1;
                var i = 1024 * this._currentChunkSizeKB, r = this._range[0] + this._receivedLength;
                let e = this._range[1];
                i < this._range[1] - r && (e = r + i), t = [r, e], this.player.debug.log(this.TAG_NAME, "[xhr_loader->],tast :", this._range, ", SubRange, ", t)
            } else t = this._range, this.player.debug.log(this.TAG_NAME, "[xhr_loader->],tast :", this._range, ", allRange, ", t);
            this._internalOpen(t)
        }

        _internalOpen(t) {
            try {
                this._startTime = Date.now();
                const i = this._xhr = new XMLHttpRequest,
                    r = (i.open(this._method || "GET", this._url, !0), i.responseType = this._responseType, this._timeout && (i.timeout = this._timeout), i.withCredentials = this._withCredentials, i.onload = this._onLoad.bind(this), i.onreadystatechange = this._onReadyStatechange.bind(this), i.onerror = e => {
                        var t;
                        this._running = !1;
                        const i = new Ia(this._url, this._request, null == e || null == (t = e.currentTarget) ? void 0 : t.response, "xhr.onerror.status:" + (null == e || null == (t = e.currentTarget) ? void 0 : t.status) + ",statusText," + (null == e || null == (t = e.currentTarget) ? void 0 : t.statusText));
                        i.options = {
                            index: this._index,
                            range: this._range,
                            vid: this._vid,
                            priOptions: this._priOptions
                        }, this._loadCompleteReject(i)
                    }, i.ontimeout = e => {
                        this.cancel();
                        const t = new Ia(this._url, this._request, {status: 408}, "timeout");
                        this._onTimeout && (t.isTimeout = !0, this._onTimeout(t, {
                            index: this._index,
                            range: this._range,
                            vid: this._vid,
                            priOptions: this._priOptions
                        })), t.options = {
                            index: this._index,
                            range: this._range,
                            vid: this._vid,
                            priOptions: this._priOptions
                        }, this._loadCompleteReject(t)
                    }, this._headers || {}), e = ka(t);
                e && (r.Range = e), r && Object.keys(r).forEach(e => {
                    i.setRequestHeader(e, r[e])
                }), this.player.debug.log(this.TAG_NAME, "[xhr.send->] tast,", this._range, ",load sub range, ", t), i.send(this._body)
            } catch (e) {
                e.options = {
                    index: this._index,
                    range: t,
                    vid: this._vid,
                    priOptions: this._priOptions
                }, this._loadCompleteReject(e)
            }
        }

        _onReadyStatechange(e) {
            2 === e.target.readyState && this._firstRtt < 0 && (this._firstRtt = Date.now())
        }

        _onLoad(e) {
            var t;
            const i = e.target.status;
            if (i < 200 || 299 < i) {
                const t = new Ia(this._url, null, {...e.target.response, status: i}, "bad response,status:" + i);
                return t.options = {
                    index: this._index,
                    range: this._range,
                    vid: this._vid,
                    priOptions: this._priOptions
                }, this._loadCompleteReject(t)
            }
            let r, s = null, a = !1;
            var n, o = 0 < (null == (t = this._range) ? void 0 : t.length) ? this._range[0] : 0;
            if (this._responseType === wa) {
                const t = new Uint8Array(e.target.response);
                if (r = o + this._receivedLength, t && 0 < t.byteLength) {
                    this._receivedLength += t.byteLength;
                    const e = Date.now() - this._startTime, i = Da(this._receivedLength, e);
                    this.emit(Sa, {
                        speed: i,
                        len: this._receivedLength,
                        time: e,
                        vid: this._vid,
                        index: this._index,
                        range: [r, o + this._receivedLength],
                        priOptions: this._priOptions
                    })
                }
                s = t, a = !(1 < (null == (n = this._range) ? void 0 : n.length) && this._range[1] && this._receivedLength < this._range[1] - this._range[0]), this.player.debug.log(this.TAG_NAME, "[xhr load done->], tast :", this._range, ", start", r, "end ", o + this._receivedLength, ",dataLen,", t ? t.byteLength : 0, ",receivedLength", this._receivedLength, ",index,", this._index, ", done,", a)
            } else a = !0, s = e.target.response;
            let l = {
                ok: 200 <= i && i < 300,
                status: i,
                statusText: this._xhr.statusText,
                url: this._xhr.responseURL,
                headers: this._getHeaders(this._xhr),
                body: this._xhr.response
            };
            this._transformResponse && (l = this._transformResponse(l, this._url) || l), this._onProgress && this._onProgress(s, a, {
                index: this._index,
                vid: this._vid,
                range: [r, o + this._receivedLength],
                startTime: this._startTime,
                endTime: Date.now(),
                priOptions: this._priOptions
            }, l), a ? (this._runing = !1, this._loadCompleteResolve && this._loadCompleteResolve(La(this._onProgress ? null : s, a, l, l.headers["content-length"], l.headers.age, this._startTime, this._firstRtt, this._index, this._range, this._vid, this._priOptions))) : this._startLoad()
        }

        cancel() {
            if (!this._aborted) return this._aborted = !0, this._runing = !1, super.removeAllListeners(), this._onCancel && this._onCancel({
                index: this._index,
                range: this._range,
                vid: this._vid,
                priOptions: this._priOptions
            }), this._xhr ? this._xhr.abort() : void 0
        }

        static isSupported() {
            return "undefined" != typeof XMLHttpRequest
        }

        get receiveLen() {
            return this._receivedLength
        }

        get running() {
            return this._running
        }

        set running(e) {
            this._running = e
        }

        _getHeaders(e) {
            const t = e.getAllResponseHeaders().trim().split("\r\n"), i = {};
            for (const e of t) {
                const t = e.split(": ");
                i[t[0].toLowerCase()] = t.slice(1).join(": ")
            }
            return i
        }
    }

    class Ua extends e {
        constructor(e, t) {
            super(), s(this, "type", _a), s(this, "_queue", []), s(this, "_alive", []), s(this, "_currentTask", null), s(this, "_config", void 0), this.player = t, this._config = (t = e, {
                loaderType: _a,
                retry: 0,
                retryDelay: 0,
                timeout: 0,
                request: null,
                onTimeout: void 0,
                onProgress: void 0,
                onRetryError: void 0,
                transformRequest: void 0,
                transformResponse: void 0,
                transformError: void 0,
                responseType: "text",
                range: void 0,
                url: "",
                params: void 0,
                method: "GET",
                headers: {},
                body: void 0,
                mode: void 0,
                credentials: void 0,
                cache: void 0,
                redirect: void 0,
                referrer: void 0,
                referrerPolicy: void 0,
                integrity: void 0,
                onProcessMinLen: 0, ...t
            }), "xhr" !== this._config.loaderType && Ra.isSupported() || (this.type = "xhr")
        }

        destroy() {
            this._queue = [], this._alive = [], this._currentTask = null
        }

        isFetch() {
            return this.type === _a
        }

        static isFetchSupport() {
            return Ra.isSupported()
        }

        load(e) {
            let t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            "string" != typeof e && e ? t = e : t.url = e || t.url || this._config.url, (t = Object.assign({}, this._config, t)).params && (t.params = Object.assign({}, t.params)), t.headers && Ta(t.headers) && (t.headers = Object.assign({}, t.headers)), t.body && Ta(t.body) && (t.body = Object.assign({}, t.body)), t.transformRequest && (t = t.transformRequest(t) || t);
            const i = new Pa(this.type, t, this.player);
            return i.loader.on(Sa, e => {
                this.emit(Sa, e)
            }), this._queue.push(i), 1 !== this._queue.length || this._currentTask && this._currentTask.running || this._processTask(), i.promise
        }

        async cancel() {
            const e = this._queue.map(e => e.cancel()).concat(this._alive.map(e => e.cancel()));
            this._currentTask && e.push(this._currentTask.cancel()), this._queue = [], this._alive = [], await Promise.all(e), await function (e) {
                let t = 0 < arguments.length && void 0 !== e ? e : 0;
                return new Promise(e => setTimeout(e, t))
            }()
        }

        _processTask() {
            if (this._currentTask = this._queue.shift(), this._currentTask) {
                this._currentTask.alive && this._alive.push(this._currentTask);
                const e = this._currentTask.exec().catch(e => {
                });
                e && "function" == typeof e.finally && e.finally(() => {
                    var e;
                    null != (e = this._currentTask) && e.alive && 0 < (null == (e = this._alive) ? void 0 : e.length) && (this._alive = this._alive.filter(e => e && e !== this._currentTask)), this._processTask()
                })
            }
        }
    }

    const Fa = "network", Ma = "network_timeout", Oa = "other";

    class M extends Error {
        constructor(e, t, i, r, s) {
            super(s || (null == i ? void 0 : i.message)), this.errorType = e === Ma ? Fa : e, this.originError = i, this.ext = r, this.errorMessage = this.message
        }

        static create(e, t, i, r, s) {
            return e instanceof M ? e : (e instanceof Error && (i = e, e = ""), e = e || Oa, new M(e, t, i, r, s))
        }

        static network(e) {
            return new M(null != e && e.isTimeout ? Ma : Fa, null, e instanceof Error ? e : null, {
                url: null == e ? void 0 : e.url,
                response: null == e ? void 0 : e.response,
                httpCode: null == e || null == (e = e.response) ? void 0 : e.status
            })
        }
    }

    const Na = /^#(EXT[^:]*)(?::(.*))?$/, ja = /([^=]+)=(?:"([^"]*)"|([^",]*))(?:,|$)/g,
        za = /^(?:[a-zA-Z0-9+\-.]+:)?\/\//, Ga = /^((?:[a-zA-Z0-9+\-.]+:)?\/\/[^/?#]*)?([^?#]*\/)?/;

    function Ha(e) {
        const t = e.match(Na);
        if (t && t[1]) return [t[1].replace("EXT-X-", ""), t[2]]
    }

    function Wa(e) {
        const t = {};
        let i = ja.exec(e);
        for (; i;) t[i[1]] = i[2] || i[3], i = ja.exec(e);
        return t
    }

    function Va(e, t) {
        if (!t || !e || za.test(e)) return e;
        t = Ga.exec(t);
        return t ? "/" === e[0] ? t[1] + e : t[1] + t[2] + e : e
    }

    const Ka = {
        audio: [/^mp4a/, /^vorbis$/, /^opus$/, /^flac$/, /^[ae]c-3$/],
        video: [/^avc/, /^hev/, /^hvc/, /^vp0?[89]/, /^av1$/],
        text: [/^vtt$/, /^wvtt/, /^stpp/]
    };

    function $a(e, i) {
        const r = Ka[e];
        if (r && i && i.length) for (let t = 0; t < r.length; t++) for (let e = 0; e < i.length; e++) if (r[t].test(i[e])) return i[e]
    }

    class qa {
        constructor() {
            this.version = 0, this.streams = [], this.isMaster = !0
        }
    }

    class Ya {
        constructor() {
            s(this, "id", 0), s(this, "url", ""), s(this, "default", !1), s(this, "autoSelect", !1), s(this, "forced", !1), s(this, "group", ""), s(this, "name", ""), s(this, "lang", ""), s(this, "segments", []), s(this, "endSN", 0)
        }
    }

    class Ja extends Ya {
        constructor() {
            super(...arguments), s(this, "mediaType", "AUDIO"), s(this, "channels", 0)
        }
    }

    class Qa extends Ya {
        constructor() {
            super(...arguments), s(this, "mediaType", "SUBTITLE")
        }
    }

    class Xa {
        constructor() {
            s(this, "id", 0), s(this, "bitrate", 0), s(this, "width", 0), s(this, "height", 0), s(this, "name", ""), s(this, "url", ""), s(this, "audioCodec", ""), s(this, "videoCodec", ""), s(this, "textCodec", ""), s(this, "audioGroup", ""), s(this, "audioStreams", []), s(this, "subtitleStreams", []), s(this, "closedCaptionsStream", [])
        }
    }

    class Za {
        constructor() {
            s(this, "version", 0), s(this, "url", ""), s(this, "type", ""), s(this, "startCC", 0), s(this, "endCC", 0), s(this, "startSN", 0), s(this, "endSN", 0), s(this, "totalDuration", 0), s(this, "targetDuration", 0), s(this, "live", !0), s(this, "segments", [])
        }
    }

    class en {
        constructor() {
            s(this, "sn", 0), s(this, "cc", 0), s(this, "url", ""), s(this, "title", ""), s(this, "start", 0), s(this, "duration", 0), s(this, "key", null), s(this, "byteRange", null), s(this, "isInitSegment", !1), s(this, "initSegment", null), s(this, "isLast", !1), s(this, "hasAudio", !1), s(this, "hasVideo", !1)
        }

        get end() {
            return this.start + this.duration
        }

        setTrackExist(e, t) {
            this.hasVideo = e, this.hasAudio = t
        }

        setByteRange(e, t) {
            this.byteRange = [0];
            e = e.split("@");
            1 === e.length && t && t.byteRange ? (this.byteRange[0] = t.byteRange[1] || 0, this.byteRange[0] && (this.byteRange[0] += 1)) : this.byteRange[0] = parseInt(e[1]), this.byteRange[1] = this.byteRange[0] + parseInt(e[0]) - 1
        }
    }

    class tn {
        constructor(e) {
            s(this, "method", ""), s(this, "url", ""), s(this, "iv", null), s(this, "keyFormat", ""), s(this, "keyFormatVersions", ""), e instanceof tn && (this.method = e.method, this.url = e.url, this.keyFormat = e.keyFormat, this.keyFormatVersions = e.keyFormatVersions, e.iv && (this.iv = new Uint8Array(e.iv)))
        }

        clone(e) {
            const t = new tn(this);
            return null != e && t.setIVFromSN(e), t
        }

        setIVFromSN(t) {
            if (!this.iv && "AES-128" === this.method && "number" == typeof t && this.url) {
                this.iv = new Uint8Array(16);
                for (let e = 12; e < 16; e++) this.iv[e] = t >> 8 * (15 - e) & 255
            }
        }
    }

    class rn {
        static parse() {
            let e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
                t = 1 < arguments.length ? arguments[1] : void 0;
            if (!e.includes("#EXTM3U")) throw new Error("Invalid m3u8 file");
            var i = e.split(/[\r\n]/).map(e => e.trim()).filter(Boolean);
            return (rn.isMediaPlaylist(e) ? function (e, t) {
                const i = new Za;
                i.url = t;
                let r, s = new en, a = null, n = null, o = 0, l = 0, d = 0, h = 0, c = !1;
                for (; (r = e[h++]) && !c;) if ("#" !== r[0]) s.sn = l, s.cc = d, s.url = Va(r, t), n && (s.key = n.clone(l)), a && (s.initSegment = a), i.segments.push(s), s = new en, l++; else {
                    const e = Ha(r);
                    if (e) {
                        const [h, u] = e;
                        switch (h) {
                            case"VERSION":
                                i.version = parseInt(u);
                                break;
                            case"PLAYLIST-TYPE":
                                i.type = null == u ? void 0 : u.toUpperCase();
                                break;
                            case"TARGETDURATION":
                                i.targetDuration = parseFloat(u);
                                break;
                            case"ENDLIST": {
                                const e = i.segments[i.segments.length - 1];
                                e && (e.isLast = !0), i.live = !1, c = !0
                            }
                                break;
                            case"MEDIA-SEQUENCE":
                                l = i.startSN = parseInt(u);
                                break;
                            case"DISCONTINUITY-SEQUENCE":
                                d = i.startCC = parseInt(u);
                                break;
                            case"DISCONTINUITY":
                                d++;
                                break;
                            case"BYTERANGE":
                                s.setByteRange(u, i.segments[i.segments.length - 1]);
                                break;
                            case"EXTINF": {
                                const [e, t] = u.split(",");
                                s.start = o, s.duration = parseFloat(e), o += s.duration, s.title = t
                            }
                                break;
                            case"KEY": {
                                const e = Wa(u);
                                if ("NONE" === e.METHOD) {
                                    n = null;
                                    break
                                }
                                if ("AES-128" !== e.METHOD) throw new Error(`encrypt ${e.METHOD}/${e.KEYFORMAT} is not supported`);
                                if ((n = new tn).method = e.METHOD, n.url = /^blob:/.test(e.URI) ? e.URI : Va(e.URI, t), n.keyFormat = e.KEYFORMAT || "identity", n.keyFormatVersions = e.KEYFORMATVERSIONS, e.IV) {
                                    let i = e.IV.slice(2);
                                    i = (1 & i.length ? "0" : "") + i, n.iv = new Uint8Array(i.length / 2);
                                    for (let e = 0, t = i.length / 2; e < t; e++) n.iv[e] = parseInt(i.slice(2 * e, 2 * e + 2), 16)
                                }
                            }
                                break;
                            case"MAP": {
                                const e = Wa(u);
                                s.url = Va(e.URI, t), e.BYTERANGE && s.setByteRange(e.BYTERANGE), s.isInitSegment = !0, s.sn = 0, n && (s.key = n.clone(0)), a = s, s = new en
                            }
                        }
                    }
                }
                const u = i.segments[i.segments.length - 1];
                return u && (i.endSN = u.sn), i.totalDuration = o, i.endCC = d, i
            } : function (t, i) {
                const e = new qa;
                let r, s = 0;
                const a = [], n = [];
                for (; r = t[s++];) {
                    var o = Ha(r);
                    if (o) {
                        var [o, l] = o;
                        if ("VERSION" === o) e.version = parseInt(l); else if ("MEDIA" === o && l) {
                            const t = Wa(l);
                            let e;
                            switch (t.TYPE) {
                                case"AUDIO":
                                    e = new Ja;
                                    break;
                                case"SUBTITLES":
                                    e = new Qa;
                                    break;
                                default:
                                    e = new Ya
                            }
                            e.url = Va(t.URI, i), e.default = "YES" === t.DEFAULT, e.autoSelect = "YES" === t.AUTOSELECT, e.group = t["GROUP-ID"], e.name = t.NAME, e.lang = t.LANGUAGE, t.CHANNELS && (e.channels = Number(t.CHANNELS.split("/")[0]), Number.isNaN(e.channels) && (e.channels = 0)), "AUDIO" === t.TYPE && t.URI && a.push(e), "SUBTITLES" === t.TYPE && n.push(e)
                        } else if ("STREAM-INF" === o && l) {
                            const r = new Xa, a = Wa(l);
                            if (r.bitrate = parseInt(a["AVERAGE-BANDWIDTH"] || a.BANDWIDTH), r.name = a.NAME, r.url = Va(t[s++], i), a.RESOLUTION) {
                                const [t, i] = a.RESOLUTION.split("x");
                                r.width = parseInt(t), r.height = parseInt(i)
                            }
                            if (a.CODECS) {
                                const t = a.CODECS.split(/[ ,]+/).filter(Boolean);
                                r.videoCodec = $a("video", t), r.audioCodec = $a("audio", t), r.textCodec = $a("text", t)
                            }
                            r.audioGroup = a.AUDIO, r.subtitleGroup = a.SUBTITLES, e.streams.push(r)
                        }
                    }
                }
                return e.streams.forEach((e, t) => {
                    e.id = t
                }), a.length && (a.forEach((e, t) => {
                    e.id = t
                }), e.streams.forEach(t => {
                    t.audioGroup && (t.audioStreams = a.filter(e => e.group === t.audioGroup))
                })), n.length && (n.forEach((e, t) => {
                    e.id = t
                }), e.streams.forEach(t => {
                    t.subtitleGroup && (t.subtitleStreams = n.filter(e => e.group === t.subtitleGroup))
                })), e
            })(i, t)
        }

        static isMediaPlaylist(e) {
            return e.includes("#EXTINF:") || e.includes("#EXT-X-TARGETDURATION:")
        }
    }

    class sn {
        constructor(e) {
            s(this, "_onLoaderRetry", (e, t) => {
                this.hls.emit(ht, {error: M.network(e), retryTime: t})
            }), this.hls = e, this.player = e.player, this.TAG_NAME = "HlsManifestLoader", this._timer = null;
            var {retryCount: e, retryDelay: t, loadTimeout: i, fetchOptions: r} = this.hls.config;
            this._loader = new Ua({
                ...r,
                responseType: "text",
                retry: e,
                retryDelay: t,
                timeout: i,
                onRetryError: this._onLoaderRetry
            }, this.player), this._audioLoader = new Ua({
                ...r,
                responseType: "text",
                retry: e,
                retryDelay: t,
                timeout: i,
                onRetryError: this._onLoaderRetry
            }, this.player), this._subtitleLoader = new Ua({
                ...r,
                responseType: "text",
                retry: e,
                retryDelay: t,
                timeout: i,
                onRetryError: this._onLoaderRetry
            }, this.player)
        }

        async destroy() {
            await this.stopPoll(), this._audioLoader && (this._audioLoader.destroy(), this._audioLoader = null), this._subtitleLoader && (this._subtitleLoader.destroy(), this._subtitleLoader = null), this._loader && (this._loader.destroy(), this._loader = null)
        }

        async load(e, t, i) {
            this.player.debug.log(this.TAG_NAME, "load()", e, t, i);
            const r = [this._loader.load(e)];
            let s, a, n, o, l, d;
            t && r.push(this._audioLoader.load(t)), i && r.push(this._subtitleLoader.load(i));
            try {
                const [e, i, o] = await Promise.all(r);
                if (!e) return [];
                s = e.data, n = t ? (a = null == i ? void 0 : i.data, null == o ? void 0 : o.data) : null == i ? void 0 : i.data
            } catch (e) {
                throw M.network(e)
            }
            try {
                var h;
                if (!1 === (null == (h = o = rn.parse(s, e)) ? void 0 : h.live) && o.segments && !o.segments.length) throw new Error("empty segments list");
                a && (l = rn.parse(a, t)), n && (d = rn.parse(n, i))
            } catch (e) {
                throw new M("manifest", "hls", e)
            }
            return o && (o.isMaster ? this.hls.emit("hls-manifest-loaded", {playlist: o}) : this.hls.emit("hls-level-loaded", {playlist: o})), [o, l, d]
        }

        poll(e, t, i, r, s, a) {
            clearTimeout(this._timer), a = a || 3e3;
            let n = this.hls.config.pollRetryCount;
            const o = async () => {
                clearTimeout(this._timer);
                try {
                    const s = await this.load(e, t, i);
                    if (!s[0]) return;
                    n = this.hls.config.pollRetryCount, r(s[0], s[1], s[2])
                } catch (e) {
                    --n <= 0 && s(e)
                }
                this._timer = setTimeout(o, a)
            };
            this._timer = setTimeout(o, a)
        }

        stopPoll() {
            return clearTimeout(this._timer), this.cancel()
        }

        cancel() {
            return Promise.all([this._loader.cancel(), this._audioLoader.cancel()])
        }
    }

    class an {
        constructor() {
            s(this, "_chunkSpeeds", []), s(this, "_speeds", [])
        }

        addRecord(e, t) {
            e && t && (this._speeds.push(8e3 * e / t), this._speeds = this._speeds.slice(-3))
        }

        addChunkRecord(e, t) {
            e && t && (this._chunkSpeeds.push(8e3 * e / t), this._chunkSpeeds = this._chunkSpeeds.slice(-100))
        }

        getAvgSpeed() {
            return this._chunkSpeeds.length || this._speeds.length ? this._speeds.length ? this._speeds.reduce((e, t) => e + t) / this._speeds.length : this._chunkSpeeds.reduce((e, t) => e + t) / this._chunkSpeeds.length : 0
        }

        getLatestSpeed() {
            return this._chunkSpeeds.length || this._speeds.length ? this._speeds.length ? this._speeds[this._speeds.length - 1] : this._chunkSpeeds[this._chunkSpeeds.length - 1] : 0
        }

        reset() {
            this._chunkSpeeds = [], this._speeds = []
        }
    }

    class nn {
        constructor(e) {
            s(this, "_emitOnLoaded", (e, t) => {
                var {data: e, response: i, option: r} = e, {
                    firstByteTime: r,
                    startTime: s,
                    endTime: a,
                    contentLength: n
                } = r || {}, a = a - s;
                this._bandwidthService.addRecord(n || e.byteLength, a), this.hls.emit("speed", {
                    time: a,
                    byteLength: n,
                    url: t
                }), this.hls.emit("load-complete", {url: t, elapsed: a || 0}), this.hls.emit("ttfb", {
                    url: t,
                    responseUrl: i.url,
                    elapsed: r - s
                }), this.hls.emit("load-response-headers", {headers: i.headers})
            }), s(this, "_onLoaderRetry", (e, t) => {
                this.hls.emit(ht, {error: M.network(e), retryTime: t})
            }), this.hls = e, this.player = e.player, this._bandwidthService = new an;
            var {retryCount: e, retryDelay: t, loadTimeout: i, fetchOptions: r} = this.hls.config;
            this._segmentLoader = new Ua({
                ...r,
                responseType: "arraybuffer",
                retry: e,
                retryDelay: t,
                timeout: i,
                onRetryError: this._onLoaderRetry
            }, this.player), this._audioSegmentLoader = new Ua({
                ...r,
                responseType: "arraybuffer",
                retry: e,
                retryDelay: t,
                timeout: i,
                onRetryError: this._onLoaderRetry
            }, this.player), this._keyLoader = new Ua({
                ...r,
                responseType: "arraybuffer",
                retry: e,
                retryDelay: t,
                timeout: i,
                onRetryError: this._onLoaderRetry
            }, this.player)
        }

        destroy() {
            this.reset(), this._keyLoader && (this._keyLoader.destroy(), this._keyLoader = null), this._audioSegmentLoader && (this._audioSegmentLoader.destroy(), this._audioSegmentLoader = null), this._segmentLoader && (this._segmentLoader.destroy(), this._segmentLoader = null)
        }

        speedInfo() {
            return {speed: this._bandwidthService.getLatestSpeed(), avgSpeed: this._bandwidthService.getAvgSpeed()}
        }

        load(e, t, i) {
            var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : i;
            const s = [];
            return e && (s[0] = this.loadVideoSegment(e, i)), t && (s[1] = this.loadAudioSegment(t, r)), Promise.all(s)
        }

        loadVideoSegment(e, t) {
            return this._loadSegment(this._segmentLoader, e, t)
        }

        loadAudioSegment(e, t) {
            return this._loadSegment(this._audioSegmentLoader, e, t)
        }

        async _loadSegment(e, t, i) {
            var r;
            let s, a, n, o, l;
            const d = [];
            if (this.hls.emit(ct, {url: t.url}), d[0] = e.load(t.url), i && t.initSegment) {
                const i = t.initSegment.url,
                    r = ((s = this._mapCache[i]) || (this.hls.emit(ct, {url: i}), d[1] = e.load(i).then(e => {
                        e && (30 < Object.keys(this._mapCache) && (this._mapCache = {}), s = this._mapCache[i] = e.data, this._emitOnLoaded(e, i))
                    })), null == (e = t.initSegment.key) ? void 0 : e.url);
                r && (l = t.initSegment.key.iv, (o = this._keyCache[r]) || (this.hls.emit(ct, {url: r}), d[2] = this._keyLoader.load(r).then(e => {
                    e && (o = this._keyCache[r] = e.data, this._emitOnLoaded(e, r))
                })))
            }
            const h = null == (r = t.key) ? void 0 : r.url;
            h && (n = t.key.iv, (a = this._keyCache[h]) || (this.hls.emit(ct, {url: h}), d[3] = this._keyLoader.load(h).then(e => {
                e && (a = this._keyCache[h] = e.data, this._emitOnLoaded(e, h))
            })));
            var [i] = await Promise.all(d);
            if (i) return e = i.data, this._emitOnLoaded(i, t.url), {
                data: e,
                map: s,
                key: a,
                mapKey: o,
                keyIv: n,
                mapKeyIv: l
            }
        }

        reset() {
            this.error = null, this._mapCache = {}, this._keyCache = {}, this._bandwidthService.reset()
        }

        async cancel() {
            await Promise.all([this._keyLoader.cancel(), this._segmentLoader.cancel(), this._audioSegmentLoader.cancel()])
        }
    }

    class on {
        constructor(e, t, i) {
            this.live = void 0, this.id = 0, this.bitrate = 0, this.width = 0, this.height = 0, this.name = "", this.url = "", this.audioCodec = "", this.videoCodec = "", this.textCodec = "", this.startCC = 0, this.endCC = 0, this.startSN = 0, this.endSN = -1, this.totalDuration = 0, this.targetDuration = 0, this.snDiff = null, this.segments = [], this.audioStreams = [], this.subtitleStreams = [], this.closedCaptions = [], this.currentAudioStream = null, this.currentSubtitleStream = null, this.TAG_NAME = "HlsStream", this.update(e, t, i)
        }

        get lastSegment() {
            return this.segments.length ? this.segments[this.segments.length - 1] : null
        }

        get segmentDuration() {
            var e;
            return this.targetDuration || (null == (e = this.segments[0]) ? void 0 : e.duration) || 0
        }

        get liveEdge() {
            return this.endTime
        }

        get endTime() {
            var e;
            return (null == (e = this.lastSegment) ? void 0 : e.end) || 0
        }

        get currentSubtitleEndSn() {
            var e;
            return (null == (e = this.currentSubtitleStream) ? void 0 : e.endSN) || 0
        }

        clearOldSegment(e, t) {
            return this._clearSegments(e, t)
        }

        getAudioSegment(e) {
            if (e && this.currentAudioStream) {
                const t = e.sn - this.snDiff;
                return this.currentAudioStream.segments.find(e => e.sn === t)
            }
        }

        update(e, t) {
            this.url = e.url, Array.isArray(e.segments) ? (null !== this.live && void 0 !== this.live || (this.live = e.live), this._updateSegments(e, this), this.startCC = e.startCC, this.endCC = e.endCC, this.startSN = e.startSN, this.endSN = e.endSN || -1, this.totalDuration = e.totalDuration, this.targetDuration = e.targetDuration, this.live = e.live, t && this.currentAudioStream && Array.isArray(t.segments) && (this._updateSegments(t, this.currentAudioStream), (null === this.snDiff || void 0 === this.snDiff) && e.segments.length && t.segments.length && (this.snDiff = e.segments[0].sn - t.segments[0].sn))) : (this.id = e.id, this.bitrate = e.bitrate, this.width = e.width, this.height = e.height, this.name = e.name, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.textCodec = e.textCodec, this.audioStreams = e.audioStreams, this.subtitleStreams = e.subtitleStreams, !this.currentAudioStream && this.audioStreams.length && (this.currentAudioStream = this.audioStreams.find(e => e.default) || this.audioStreams[0]), !this.currentSubtitleStream && this.subtitleStreams.length && (this.currentSubtitleStream = this.subtitleStreams.find(e => e.default) || this.subtitleStreams[0]))
        }

        updateSubtitle(e) {
            if (e && this.currentSubtitleStream && Array.isArray(e.segments)) {
                const t = this._updateSegments(e, this.currentSubtitleStream), i = this.currentSubtitleStream.segments;
                return 100 < i.length && (this.currentSubtitleStream.segments = i.slice(100)), t ? t.map(e => ({
                    sn: e.sn,
                    url: e.url,
                    duration: e.duration,
                    start: e.start,
                    end: e.end,
                    lang: this.currentSubtitleStream.lang
                })) : void 0
            }
        }

        switchSubtitle(t) {
            const e = this.subtitleStreams.find(e => e.lang === t), i = this.currentSubtitleStream;
            e && (this.currentSubtitleStream = e, i.segments = [])
        }

        _clearSegments(i, e) {
            let r = 0;
            var s = this.segments;
            for (let e = 0, t = s.length; e < t; e++) if (s[e].end >= i) {
                r = e;
                break
            }
            return (r = r > e ? e : r) && (this.segments = this.segments.slice(r), this.currentAudioStream && (this.currentAudioStream.segments = this.currentAudioStream.segments.slice(r))), e - r
        }

        _updateSegments(e, i) {
            const t = i.segments;
            if (this.live) {
                const r = t[t.length - 1], s = (null == r ? void 0 : r.sn) || -1;
                if (s < e.endSN && e.segments.length) {
                    const a = e.segments.findIndex(e => e.sn === s), n = a < 0 ? e.segments : e.segments.slice(a + 1);
                    if (t.length && n.length) {
                        let t = r.end;
                        n.forEach(e => {
                            e.start = t, t = e.end
                        });
                        const i = (null == r ? void 0 : r.cc) || -1;
                        i > n[0].cc && n.forEach(e => e.cc += i)
                    }
                    return i.endSN = e.endSN, i.segments = t.concat(n), n
                }
            } else i.segments = e.segments
        }
    }

    class ln {
        constructor(e) {
            this.hls = e, this.player = e.player, this.streams = [], this.currentStream = null, this.dvrWindow = 0, this._segmentPointer = -1, this.TAG_NAME = "HlsPlaylist"
        }

        destroy() {
            this.reset()
        }

        get lastSegment() {
            var e;
            return null == (e = this.currentStream) ? void 0 : e.lastSegment
        }

        get currentSegment() {
            var e;
            return null == (e = this.currentSegments) ? void 0 : e[this._segmentPointer]
        }

        get nextSegment() {
            var e;
            return null == (e = this.currentSegments) ? void 0 : e[this._segmentPointer + 1]
        }

        get currentSegments() {
            var e;
            return null == (e = this.currentStream) ? void 0 : e.segments
        }

        get currentSubtitleEndSn() {
            var e;
            return null == (e = this.currentStream) ? void 0 : e.currentSubtitleEndSn
        }

        get liveEdge() {
            var e;
            return null == (e = this.currentStream) ? void 0 : e.liveEdge
        }

        get totalDuration() {
            var e;
            return (null == (e = this.currentStream) ? void 0 : e.totalDuration) || 0
        }

        get seekRange() {
            var e = this.currentSegments;
            if (e && e.length) return [e[0].start, e[e.length - 1].end]
        }

        get isEmpty() {
            var e;
            return !(null != (e = this.currentSegments) && e.length)
        }

        get isLive() {
            var e;
            return null == (e = this.currentStream) ? void 0 : e.live
        }

        get hasSubtitle() {
            var e;
            return !(null == (e = this.currentStream) || !e.currentSubtitleStream)
        }

        getAudioSegment(e) {
            var t;
            return null == (t = this.currentStream) ? void 0 : t.getAudioSegment(e)
        }

        moveSegmentPointer(e) {
            var t;
            null == e && (e = this._segmentPointer + 1), this._segmentPointer = E(e, -1, null == (t = this.currentSegments) ? void 0 : t.length), this.player.debug.log(this.TAG_NAME, "moveSegmentPointer()", e, this._segmentPointer)
        }

        reset() {
            this.streams = [], this.currentStream = null, this.dvrWindow = 0, this._segmentPointer = -1
        }

        getSegmentByIndex(e) {
            var t;
            return null == (t = this.currentSegments) ? void 0 : t[e]
        }

        setNextSegmentByIndex() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
            this._segmentPointer = e - 1, this.player.debug.log(this.TAG_NAME, "setNextSegmentByIndex()", e, this._segmentPointer)
        }

        findSegmentIndexByTime(r) {
            var s = this.currentSegments;
            if (s) {
                for (let e, t = 0, i = s.length; t < i; t++) if (r >= (e = s[t]).start && r < e.end) return t;
                var e = s[s.length - 1];
                if (Math.abs(r - e.end) < .2) return s.length - 1
            }
        }

        upsertPlaylist(e, t, i) {
            if (e) {
                if (e.isMaster) this.streams.length = e.streams.length, e.streams.filter(e => e.url).forEach((e, t) => {
                    this.streams[t] ? this.streams[t].update(e) : this.streams[t] = new on(e)
                }), this.currentStream = this.streams[0]; else if (Array.isArray(e.segments)) {
                    const s = this.currentStream;
                    var r;
                    s ? (s.update(e, t, i), (r = s.updateSubtitle(i)) && this.hls.emit("subtitle-segments", {list: r})) : (this.reset(), this.currentStream = this.streams[0] = new on(e, t, i))
                }
                this.currentStream && this.hls.isLive && !this.dvrWindow && (this.dvrWindow = this.currentSegments.reduce((e, t) => e += t.duration, 0))
            } else this.player.debug.warn(this.TAG_NAME, "upsertPlaylist() playlist is null")
        }

        switchSubtitle(e) {
            var t;
            null != (t = this.currentStream) && t.switchSubtitle(e)
        }

        clearOldSegment() {
            var e, t, i = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 50;
            const r = this.currentStream;
            this.dvrWindow && r && ((e = r.endTime - this.dvrWindow) <= 0 ? this.player.debug.log(this.TAG_NAME, `clearOldSegment() stream.endTime:${r.endTime}, this.dvrWindow:${this.dvrWindow}  startTime <= 0`) : (t = r.segments).length <= i ? this.player.debug.log(this.TAG_NAME, `clearOldSegment() segments.length:${t.length} <= maxPlaylistSize:` + i) : (t = this._segmentPointer, this._segmentPointer = r.clearOldSegment(e, t), this.player.debug.log(this.TAG_NAME, "clearOldSegment() update _segmentPointer:", t, this._segmentPointer), this.player.debug.log(this.TAG_NAME, "currentSegments", this.currentSegments)))
        }

        checkSegmentTrackChange(e, t) {
            var i = this.findSegmentIndexByTime(e), r = this.getSegmentByIndex(i);
            if (r && (r.hasAudio || r.hasVideo)) return 2 !== t && r.hasAudio && r.hasVideo ? r : .3 < r.end - e || !(t = this.getSegmentByIndex(i + 1)) || !t.hasAudio && !t.hasVideo || t.hasAudio === r.hasAudio && t.hasVideo === r.hasVideo ? void 0 : t
        }
    }

    function dn() {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
        if ((t = t.filter(Boolean)).length < 2) return t[0];
        const r = new Uint8Array(t.reduce((e, t) => e + t.byteLength, 0));
        let s = 0;
        return t.forEach(e => {
            r.set(e, s), s += e.byteLength
        }), r
    }

    class hn {
        constructor() {
            var e = window.crypto || window.msCrypto;
            this.subtle = e && (e.subtle || e.webkitSubtle), this.externalDecryptor = null
        }

        decrypt(e, t) {
            if (e || t) {
                const i = [];
                return e && (i[0] = this._decryptSegment(e)), t && (i[1] = this._decryptSegment(t)), Promise.all(i)
            }
        }

        async _decryptSegment(e) {
            let t = e.data;
            return e.key && (t = await this._decryptData(e.data, e.key, e.keyIv)), e.map ? dn(e.map, t) : t
        }

        async _decryptData(e, t, i) {
            if (this.externalDecryptor) return this.externalDecryptor.decrypt(e, t, i);
            if (!this.subtle) throw new Error("crypto is not defined");
            t = await this.subtle.importKey("raw", t, {name: "AES-CBC"}, !1, ["encrypt", "decrypt"]);
            return new Uint8Array(await this.subtle.decrypt({name: "AES-CBC", iv: i}, t, e))
        }
    }

    class cn extends Ur {
        constructor(e) {
            super(e), this.player = e, this._pmtId = -1, this._remainingPacketData = null, this._videoPesData = [], this._audioPesData = [], this._gopId = 0, this._videoPid = -1, this._audioPid = -1, this._codecType = 7, this._audioCodecType = 10, this._vps = null, this._sps = null, this._pps = null, this.TAG_NAME = "TsLoader", this.videoTrack = cn.initVideoTrack(), this.audioTrack = cn.initAudioTrack(), this._baseDts = -1, this._baseDtsInited = !1, this._basefps = 25, this._baseFpsInterval = null, this._tempSampleTsList = [], this._hasAudio = !1, this._hasVideo = !1, this._audioNextPts = void 0, this._videoNextDts = void 0, this._audioTimestampBreak = !1, this._videoTimestampBreak = !1, this._lastAudioExceptionGapDot = 0, this._lastAudioExceptionOverlapDot = 0, this._lastAudioExceptionLargeGapDot = 0, this._isSendAACSeqHeader = !1, this.workerClearTimeout = null, this.workerUrl = null, this.loopWorker = null, this.tempSampleListInfo = {}, this._initLoopWorker(), this.player.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.workerUrl && (URL.revokeObjectURL(this.workerUrl), this.workerUrl = null), this.workerClearTimeout && (clearTimeout(this.workerClearTimeout), this.workerClearTimeout = null), this.loopWorker && (this.loopWorker.postMessage({cmd: "destroy"}), this.loopWorker.terminate(), this.loopWorker = null), this._stopDecodeLoopInterval(), this.videoTrack = null, this.audioTrack = null, this.tempSampleListInfo = {}, this._baseDts = -1, this._baseDtsInited = !1, this._basefps = 50, this._hasCalcFps = !1, this._audioNextPts = void 0, this._videoNextDts = void 0, this._audioTimestampBreak = !1, this._videoTimestampBreak = !1, this._lastAudioExceptionGapDot = 0, this._lastAudioExceptionOverlapDot = 0, this._lastAudioExceptionLargeGapDot = 0, this._isSendAACSeqHeader = !1, this.player.debug.log(this.TAG_NAME, "destroy")
        }

        static initVideoTrack() {
            return {samples: []}
        }

        static initAudioTrack() {
            return {samples: []}
        }

        static probe(e) {
            return !!e.length && 71 === e[0] && 71 === e[188] && 71 === e[376]
        }

        static _parsePES(i) {
            var r = i[8];
            if (!(null == r || i.length < r + 9) && 1 == (i[0] << 16 | i[1] << 8 | i[2])) {
                var s = (i[4] << 8) + i[5];
                if (!(s && s > i.length - 6)) {
                    let e, t;
                    s = i[7];
                    return 192 & s && (e = 536870912 * (14 & i[9]) + 4194304 * (255 & i[10]) + 16384 * (254 & i[11]) + 128 * (255 & i[12]) + (254 & i[13]) / 2, 64 & s ? (t = 536870912 * (14 & i[14]) + 4194304 * (255 & i[15]) + 16384 * (254 & i[16]) + 128 * (255 & i[17]) + (254 & i[18]) / 2, 54e5 < e - t && (e = t)) : t = e), {
                        data: i.subarray(9 + r),
                        pts: e,
                        dts: t,
                        originalPts: e,
                        originalDts: t
                    }
                }
            }
        }

        _demux(i) {
            let r = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
                s = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2],
                a = (r && (this._pmtId = -1, this.videoTrack = cn.initVideoTrack(), this.audioTrack = cn.initAudioTrack()), !s || r ? (this._remainingPacketData = null, this._videoPesData = [], this._audioPesData = []) : (this.videoTrack.samples = [], this.audioTrack.samples = [], this._remainingPacketData && (i = dn(this._remainingPacketData, i), this._remainingPacketData = null)), i.length);
            var e = a % 188;
            e && (this._remainingPacketData = i.subarray(a - e), a -= e);
            for (let t = 0; t < a; t += 188) {
                if (71 !== i[t]) throw new Error("TS packet did not start with 0x47");
                const s = !!(64 & i[t + 1]), a = ((31 & i[t + 1]) << 8) + i[t + 2];
                let e;
                if (1 < (48 & i[t + 3]) >> 4) {
                    if ((e = t + 5 + i[t + 4]) === t + 188) continue
                } else e = t + 4;
                switch (a) {
                    case 0:
                        s && (e += i[e] + 1), this._pmtId = (31 & i[e + 10]) << 8 | i[e + 11];
                        break;
                    case this._pmtId: {
                        s && (e += i[e] + 1);
                        const r = e + 3 + ((15 & i[e + 1]) << 8 | i[e + 2]) - 4;
                        for (e += 12 + ((15 & i[e + 10]) << 8 | i[e + 11]); e < r;) {
                            const r = (31 & i[e + 1]) << 8 | i[e + 2];
                            switch (i[e]) {
                                case 15:
                                    this._audioPid = r, this._audioCodecType = 10;
                                    break;
                                case 27:
                                    this._videoPid = r, this._codecType = 7;
                                    break;
                                case 36:
                                    this._videoPid = r, this._codecType = 12;
                                    break;
                                default:
                                    console.warn(`Unsupported stream. type: ${i[e]}, pid: ` + r)
                            }
                            e += 5 + ((15 & i[e + 3]) << 8 | i[e + 4])
                        }
                    }
                        break;
                    case this._videoPid:
                        s && this._videoPesData.length && this._parseVideoData(), this._videoPesData.push(i.subarray(e, t + 188));
                        break;
                    case this._audioPid:
                        s && this._audioPesData.length && this._parseAudioData(), this._audioPesData.push(i.subarray(e, t + 188));
                        break;
                    case 17:
                    case 8191:
                        break;
                    default:
                        console.warn("Unknown pid: " + a)
                }
            }
            this._parseVideoData(), this._parseAudioData(), this.audioTrack.formatTimescale = this.videoTrack.formatTimescale = this.videoTrack.timescale = 9e4, this.audioTrack.timescale = this.audioTrack.sampleRate || 0
        }

        demuxAndFix(e, t, i, r) {
            this.player._times.demuxStart || (this.player._times.demuxStart = p()), this._demux(e, t, i, r), this._fix(r, t, i)
        }

        _parseVideoData() {
            var e, t;
            this._videoPesData.length ? (e = cn._parsePES(dn(...this._videoPesData))) ? (this.player.updateStats({vbps: e.data.byteLength}), (t = function (e) {
                var t = e.length;
                let i = 2, r = 0;
                for (; null !== e[i] && void 0 !== e[i] && 1 !== e[i];) i++;
                if (i++, (r = i + 2) >= t) return [];
                const s = [];
                for (; r < t;) switch (e[r]) {
                    case 0:
                        if (0 !== e[r - 1]) {
                            r += 2;
                            break
                        }
                        if (0 !== e[r - 2]) {
                            r++;
                            break
                        }
                        for (i !== r - 2 && s.push(e.subarray(i, r - 2)); 1 !== e[++r] && r < t;) ;
                        i = r + 1, r = i + 2;
                        break;
                    case 1:
                        if (0 !== e[r - 1] || 0 !== e[r - 2]) {
                            r += 3;
                            break
                        }
                        i !== r - 2 && s.push(e.subarray(i, r - 2)), i = r + 1, r = i + 2;
                        break;
                    default:
                        r += 3
                }
                return i < t && s.push(e.subarray(i)), s
            }(e.data)) ? this._createVideoSample(t, e.pts, e.dts) : this.player.debug.warn(this.TAG_NAME, "Cannot parse avc units", e), this._videoPesData = []) : console.warn("Cannot parse video pes", this._videoPesData) : console.log("_parseVideoData", "no video pes data")
        }

        _createVideoSample(t, i, r) {
            if (t.length) {
                const l = 12 === this._codecType, d = {
                    isIFrame: !1,
                    type: 2,
                    isHevc: l,
                    vps: null,
                    sps: null,
                    pps: null,
                    pts: i,
                    dts: r,
                    payload: null
                };
                t.forEach(s => {
                    const e = l ? s[0] >>> 1 & 63 : 31 & s[0];
                    switch (e) {
                        case 5:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                            if (!l && 5 !== e || l && 5 === e) break;
                            d.isIFrame = !0, this._gopId++;
                            break;
                        case 6:
                        case 39:
                        case 40:
                            if (!l && 6 !== e || l && 6 === e) break;
                        {
                            var a = function (e) {
                                const t = e.byteLength, i = [];
                                let r = 1;
                                for (; r < t - 2;) 0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (i.push(r + 2), r += 2) : r++;
                                if (!i.length) return e;
                                const s = t - i.length, a = new Uint8Array(s);
                                let n = 0;
                                for (r = 0; r < s; n++, r++) n === i[0] && (n++, i.shift()), a[r] = e[n];
                                return a
                            }(s);
                            var n = l;
                            var o = a.length;
                            let t = n ? 2 : 1, e = 0, i = 0, r = "";
                            for (; 255 === a[t];) e += 255, t++;
                            for (e += a[t++]; 255 === a[t];) i += 255, t++;
                            if (i += a[t++], 5 === e && o > t + 16) for (let e = 0; e < 16; e++) r += a[t].toString(16), t++;
                            a.subarray(t)
                        }
                            return void (this.player._opt.isEmitSEI && this.player.emit(w.videoSEI, {
                                ts: r / 90,
                                data: s
                            }));
                        case 32:
                            if (!l) break;
                            d.vps || (d.vps = s);
                            break;
                        case 7:
                        case 33:
                            if (!l && 7 !== e || l && 7 === e) break;
                            d.sps || (d.sps = s);
                            break;
                        case 8:
                        case 34:
                            if (!l && 8 !== e || l && 8 === e) break;
                            d.pps || (d.pps = s)
                    }
                    if (l && Sr(e) || !l && gr(e)) {
                        const e = Ar(s);
                        if (d.payload) {
                            this.player.debug.log(this.TAG_NAME, "append nal unit to payload");
                            const s = new Uint8Array(d.payload.byteLength + e.byteLength);
                            s.set(d.payload, 0), s.set(e, d.payload.byteLength), d.payload = s
                        } else d.payload = e
                    }
                });
                let e = null;
                l ? d.sps && d.vps && d.pps && (e = vr({
                    vps: d.vps,
                    sps: d.sps,
                    pps: d.pps
                })) : d.sps && d.pps && (e = ur({
                    sps: d.sps,
                    pps: d.pps
                })), e && (this.player.debug.log(this.TAG_NAME, "_createVideoSample", "seqHeader"), this._doDecodeByHls(e, 2, d.pts, !0, 0)), d.isIFrame && this.calcIframeIntervalTimestamp(d.dts / 90), this.videoTrack.samples = this.videoTrack.samples.concat(d)
            }
        }

        _parseAudioData() {
            if (this._audioPesData.length) {
                const r = cn._parsePES(dn(...this._audioPesData));
                if (r) {
                    if (this.player._opt.hasAudio) {
                        if (this.player.updateStats({abps: r.data.byteLength}), 10 === this._audioCodecType) {
                            const e = function (r, s) {
                                var a = r.length;
                                let n = 0;
                                for (; n + 2 < a && (255 !== r[n] || 240 != (246 & r[n + 1]));) n++;
                                if (!(n >= a)) {
                                    const h = n, c = [], u = (60 & r[n + 2]) >>> 2, p = gt[u];
                                    if (!p) throw new Error("Invalid sampling index: " + u);
                                    var o = 1 + ((192 & r[n + 2]) >>> 6),
                                        l = (1 & r[n + 2]) << 2 | (192 & r[n + 3]) >>> 6;
                                    let e, t, i = 0;
                                    for (var d = At(p); n + 7 < a;) if (255 === r[n] && 240 == (246 & r[n + 1])) {
                                        if (t = (3 & r[n + 3]) << 11 | r[n + 4] << 3 | (224 & r[n + 5]) >> 5, a - n < t) break;
                                        e = 2 * (1 & ~r[n + 1]), c.push({
                                            pts: s + i * d,
                                            data: r.subarray(n + 7 + e, n + t)
                                        }), i++, n += t
                                    } else n++;
                                    return {
                                        skip: h,
                                        remaining: n >= a ? void 0 : r.subarray(n),
                                        frames: c,
                                        samplingFrequencyIndex: u,
                                        sampleRate: p,
                                        objectType: o,
                                        channelCount: l,
                                        originCodec: "mp4a.40." + o
                                    }
                                }
                            }(r.data, r.originalPts);
                            if (e) {
                                if (this.audioTrack.codec = e.codec, this.audioTrack.sampleRate = e.sampleRate, this.audioTrack.channelCount = e.channelCount, !this._isSendAACSeqHeader) {
                                    const r = mt({
                                        profile: e.objectType,
                                        sampleRate: e.samplingFrequencyIndex,
                                        channel: e.channelCount
                                    });
                                    this._isSendAACSeqHeader = !0, this.player.debug.log(this.TAG_NAME, "aac seq header", `profile: ${e.objectType}, sampleRate:${e.sampleRate},sampleRateIndex: ${e.samplingFrequencyIndex}, channel: ` + e.channelCount), this._doDecodeByHls(r, 1, 0, !1, 0)
                                }
                                if (this._isSendAACSeqHeader) {
                                    const r = [];
                                    e.frames.forEach(e => {
                                        const t = e.pts, i = new Uint8Array(e.data.length + 2);
                                        i.set([175, 1], 0), i.set(e.data, 2);
                                        e = {type: 1, pts: t, dts: t, payload: i};
                                        r.push(e)
                                    }), this.audioTrack.samples = this.audioTrack.samples.concat(r)
                                } else this.player.debug.warn(this.TAG_NAME, "aac seq header not send")
                            } else this.player.debug.warn(this.TAG_NAME, "aac parseADTS error")
                        }
                        this._audioPesData = []
                    }
                } else console.warn("Cannot parse audio pes", this._audioPesData)
            }
        }

        _fix() {
            let i = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                r = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
                s = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2];
            i = Math.round(9e4 * i);
            const a = this.videoTrack, n = this.audioTrack, o = a.samples, l = n.samples;
            if (o.length || l.length) {
                var d = o[0], h = l[0];
                let e = 0;
                if (o.length && l.length && (e = d.dts - h.pts), this._baseDtsInited || this._calculateBaseDts(), r && (this._calculateBaseDts(), this._baseDts -= i), !s) {
                    this._videoNextDts = 0 < e ? i + e : i, this._audioNextPts = 0 < e ? i : i - e;
                    const r = d ? d.dts - this._baseDts - this._videoNextDts : 0,
                        s = h ? h.pts - this._baseDts - this._audioNextPts : 0;
                    9e4 < Math.abs(r || s) && (this._calculateBaseDts(this.audioTrack, this.videoTrack), this._baseDts -= i)
                }
                this._resetBaseDtsWhenStreamBreaked(), this._fixAudio(n), this._fixVideo(a);
                let t = a.samples.concat(n.samples);
                (t = t.map(e => (e.dts = e.dts / 90, e.pts = e.pts / 90, e.cts = e.pts - e.dts, e)).sort((e, t) => e.dts - t.dts)).forEach(e => {
                    var t = new Uint8Array(e.payload);
                    delete e.payload, this.loopWorker.postMessage({...e, payload: t, cmd: "sample"}, [t.buffer])
                }), C(this._hasCalcFps) && (this._hasCalcFps = !0, this._calcDecodeFps(t))
            }
        }

        _calculateBaseDts() {
            const e = this.audioTrack, t = this.videoTrack, i = e.samples, r = t.samples;
            if (!i.length && !r.length) return !1;
            let s = 1 / 0, a = 1 / 0;
            i.length && (e.baseDts = s = i[0].pts), r.length && (t.baseDts = a = r[0].dts), this._baseDts = Math.min(s, a);
            var n = a - s;
            return Number.isFinite(n) && 45e3 < Math.abs(n) && this.player.debug.warn(this.TAG_NAME, `large av first frame gap,
                video pts: ${a},
                audio pts: ${s},
                base dts: ${this._baseDts},
                detect is: ` + n), this._baseDtsInited = !0
        }

        _resetBaseDtsWhenStreamBreaked() {
            this._baseDtsInited && this._videoTimestampBreak && this._audioTimestampBreak && this._calculateBaseDts(this.audioTrack, this.videoTrack) && (this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts), this._audioLastSample = null, this._videoLastSample = null, this._videoTimestampBreak = !1, this._audioTimestampBreak = !1)
        }

        _fixAudio(e) {
            const t = e.samples;
            t.length && (t.forEach(e => {
                e.pts -= this._baseDts, e.dts = e.pts
            }), this._doFixAudioInternal(e, t, 9e4))
        }

        _fixVideo(i) {
            const r = i.samples;
            if (r.length) {
                if (r.forEach(e => {
                    e.dts -= this._baseDts, e.pts -= this._baseDts
                }), void 0 === this._videoNextDts) {
                    const i = r[0];
                    this._videoNextDts = i.dts
                }
                const n = r.length;
                let t = 0;
                const o = r[0], l = r[1], d = this._videoNextDts - o.dts;
                45e3 < Math.abs(d) && (o.dts += d, o.pts += d, this.player.debug.warn(this.TAG_NAME, `large video gap between chunk,
             next dts is ${this._videoNextDts},
             first dts is ${o.dts},
             next dts is ${l.dts},
             duration is ` + d), l && 9e4 < Math.abs(l.dts - o.dts) && (this._videoTimestampBreak = !0, r.forEach((e, t) => {
                    0 !== t && (e.dts += d, e.pts += d)
                })));
                var e = i.samples[0], s = i.samples[n - 1], a = 1 === n ? 9e3 : Math.floor((s.dts - e.dts) / (n - 1));
                for (let e = 0; e < n; e++) {
                    const l = r[e].dts, d = r[e + 1];
                    if (9e4 < (t = e < n - 1 ? d.dts - l : r[e - 1] ? Math.min(l - r[e - 1].dts, a) : a) || t < 0) {
                        this._videoTimestampBreak = !0, t = this._audioTimestampBreak ? a : Math.max(t, 2700);
                        const n = this._audioNextPts || 0;
                        d && d.dts > n && (t = a), this.player.debug.warn(this.TAG_NAME, `large video gap between frames,
                time is ${l / i.timescale},
                dts is ${l},
                origin dts is ${r[e].originalDts},
                next dts is ${this._videoNextDts},
                sample Duration is ${t} ,
                ref Sample DurationInt is ` + a)
                    }
                    r[e].duration = t, this._videoNextDts += t
                }
            }
        }

        _doFixAudioInternal(e, i, t) {
            e.sampleDuration || (e.sampleDuration = At(e.timescale, t));
            var r, s, a = e.sampleDuration;
            if (void 0 === this._audioNextPts) {
                const e = i[0];
                this._audioNextPts = e.pts
            }
            for (let t = 0; t < i.length; t++) {
                const o = this._audioNextPts, l = i[t], d = l.pts - o;
                if (!this._audioTimestampBreak && 3 * a <= d && d <= 9e4 && !It()) {
                    r = e.codec, s = e.channelCount, ("mp4a.40.2" === r ? 1 === s ? new Uint8Array([0, 200, 0, 128, 35, 128]) : 2 === s ? new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]) : 3 === s ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]) : 4 === s ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]) : 5 === s ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]) : 6 === s && new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) : 1 === s ? new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) : (2 === s || 3 === s) && new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])) || i[0].data.subarray();
                    var n = Math.floor(d / a);
                    45e4 < Math.abs(l.pts - this._lastAudioExceptionGapDot) && (this._lastAudioExceptionGapDot = l.pts), this.player.debug.warn(this.TAG_NAME, `audio gap detected,
                pts is ${i.pts},
                originPts is ${i.originalPts},
                count is ${n},
                nextPts is ${o},
                ref sample duration is ` + a);
                    for (let e = 0; e < n; e++) this._audioNextPts += a, t++;
                    t--
                } else d <= -3 * a && -9e4 <= d ? (45e4 < Math.abs(l.pts - this._lastAudioExceptionOverlapDot) && (this._lastAudioExceptionOverlapDot = l.pts, this.player.debug.warn(this.TAG_NAME, `audio overlap detected,
                    pts is ${l.pts},
                    originPts is ${l.originalPts},
                    nextPts is ${o},
                    ref sample duration is ` + a)), i.splice(t, 1), t--) : (9e4 <= Math.abs(d) && (this._audioTimestampBreak = !0, 45e4 < Math.abs(l.pts - this._lastAudioExceptionLargeGapDot) && (this._lastAudioExceptionLargeGapDot = l.pts, this.player.debug.warn(this.TAG_NAME, `large audio gap detected,
                        time is ${l.pts / 1e3}
                        pts is ${l.pts},
                        originPts is ${l.originalPts},
                        nextPts is ${o},
                        sample duration is ${d}
                        ref sample duration is ` + a))), l.dts = l.pts = o, this._audioNextPts += a)
            }
        }

        _calcDecodeFps(e) {
            e = oi(e.map(e => ({ts: e.dts || e.pts, type: e.type})), 2);
            e && (this._basefps = e, this._postMessageToLoopWorker("updateBaseFps", {baseFps: this._basefps}), this.player.debug.log(this.TAG_NAME, `_calcDecodeFps()  video fps is ${e}, update base fps is ` + this._basefps))
        }

        _initLoopWorker() {
            var e = mi(function () {
                let i = new class {
                    constructor() {
                        this.baseFps = 0, this.fpsInterval = null, this.preLoopTimestamp = null, this.startBpsTime = null, this.allSampleList = []
                    }

                    destroy() {
                        this._clearInterval(), this.baseFps = 0, this.allSampleList = [], this.preLoopTimestamp = null, this.startBpsTime = null
                    }

                    updateBaseFps(e) {
                        this.baseFps = e, this._clearInterval(), this._startInterval()
                    }

                    pushSample(e) {
                        delete e.cmd, this.allSampleList.push(e)
                    }

                    _startInterval() {
                        const i = Math.ceil(1e3 / this.baseFps);
                        this.fpsInterval = setInterval(() => {
                            var e = (new Date).getTime(),
                                t = (this.preLoopTimestamp || (this.preLoopTimestamp = e), this.startBpsTime || (this.startBpsTime = e), e - this.preLoopTimestamp);
                            t > 2 * i && console.warn(`JbPro:[TsLoader LoopWorker] loop interval is ${t}ms, more than ${i} * 2ms`), this._loop(), this.preLoopTimestamp = (new Date).getTime(), this.startBpsTime && 1e3 <= e - this.startBpsTime && (this._calcSampleList(), this.startBpsTime = e)
                        }, i)
                    }

                    _clearInterval() {
                        this.fpsInterval && (clearInterval(this.fpsInterval), this.fpsInterval = null)
                    }

                    _calcSampleList() {
                        const t = {
                            buferredDuration: 0,
                            allListLength: this.allSampleList.length,
                            audioListLength: 0,
                            videoListLength: 0
                        };
                        this.allSampleList.forEach(e => {
                            2 === e.type ? (t.videoListLength++, e.duration && (t.buferredDuration += e.duration / 90)) : 1 === e.type && t.audioListLength++
                        }), postMessage({cmd: "sampleListInfo", ...t})
                    }

                    _loop() {
                        let t = null;
                        if (this.allSampleList.length) if (2 === (t = this.allSampleList.shift()).type) {
                            postMessage({cmd: "decodeVideo", ...t}, [t.payload.buffer]);
                            let e = this.allSampleList[0];
                            for (; e && 1 === e.type;) t = this.allSampleList.shift(), postMessage({cmd: "decodeAudio", ...t}, [t.payload.buffer]), e = this.allSampleList[0]
                        } else 1 === t.type && (postMessage({cmd: "decodeAudio", ...t}, [t.payload.buffer]), this.allSampleList.length && 2 === this.allSampleList[0].type && (t = this.allSampleList.shift(), postMessage({cmd: "decodeVideo", ...t}, [t.payload.buffer])))
                    }
                };
                self.onmessage = e => {
                    var t = e.data;
                    switch (t.cmd) {
                        case"updateBaseFps":
                            i.updateBaseFps(t.baseFps);
                            break;
                        case"sample":
                            i.pushSample(t);
                            break;
                        case"destroy":
                            i.destroy(), i = null
                    }
                }
            }.toString()), e = new Blob([e], {type: "text/javascript"}), e = URL.createObjectURL(e);
            let t = new Worker(e);
            this.workerUrl = e, this.workerClearTimeout = setTimeout(() => {
                window.URL.revokeObjectURL(this.workerUrl), this.workerUrl = null, this.workerClearTimeout = null
            }, re), t.onmessage = e => {
                var t = e.data;
                switch (t.cmd) {
                    case"decodeVideo":
                        this._doDecodeVideo(t);
                        break;
                    case"decodeAudio":
                        this._doDecodeAudio(t);
                        break;
                    case"sampleListInfo":
                        this.tempSampleListInfo = t
                }
            }, this.loopWorker = t
        }

        _postMessageToLoopWorker(e, t) {
            this.loopWorker ? this.loopWorker.postMessage({cmd: e, ...t}) : this.player.debug.warn(this.TAG_NAME, "loop worker is not init, can not post message")
        }

        _doDecodeAudio(e) {
            var t = new Uint8Array(e.payload);
            this._doDecodeByHls(t, 1, e.dts, !1, 0)
        }

        _doDecodeVideo(e) {
            var t = new Uint8Array(e.payload), t = (e.isHevc ? _r : pr)(t, e.isIFrame),
                i = (this.player.updateStats({dts: e.dts}), e.pts - e.dts);
            this._doDecodeByHls(t, 2, e.dts, e.isIFrame, i)
        }

        _stopDecodeLoopInterval() {
            this._baseFpsInterval && (clearInterval(this._baseFpsInterval), this._baseFpsInterval = null)
        }

        getBuferredDuration() {
            return this.tempSampleListInfo.buferredDuration || 0
        }

        getSampleListLength() {
            return this.tempSampleListInfo.allListLength || 0
        }

        getSampleAudioListLength() {
            return this.tempSampleListInfo.audioListLength || 0
        }

        getSampleVideoListLength() {
            return this.tempSampleListInfo.videoListLength || 0
        }
    }

    class un extends Ur {
        constructor(e) {
            super(e), this.player = e, this.TAG_NAME = "HlsFmp4Loader", this.tempSampleListInfo = {}, this.isInitVideo = !1, this.isInitAudio = !1, e.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.isInitVideo = !1, this.isInitAudio = !1, this.player.debug.log(this.TAG_NAME, "destroy")
        }

        dispatch(e) {
            let n = I.createFile(), t = (n.onReady = e => {
                const t = e.videoTracks[0], i = e.audioTracks[0];
                if (t && C(this.isInitVideo)) {
                    this.videoTrackId = t.id;
                    const e = this.getSeqHeader(n, t);
                    e && (this.player.debug.log(this.TAG_NAME, "seqHeader", e), this._doDecodeByFmp4(e, 2, 0, !0, 0), this.isInitVideo = !0), n.setExtractionOptions(t.id)
                }
                if (i && C(this.isInitAudio)) {
                    this.audioTrackId = i.id;
                    const e = i.audio || {}, t = yt.indexOf(e.sample_rate), a = i.codec.replace("mp4a.40.", "");
                    n.setExtractionOptions(i.id);
                    var r = {profile: parseInt(a, 10), sampleRate: t, channel: e.channel_count}, s = mt(r);
                    this.player.debug.log(this.TAG_NAME, "aacADTSHeader", s, "config", r), this._doDecodeByFmp4(s, 1, 0, !1, 0), this.isInitAudio = !0
                }
                n.start()
            }, n.onError = e => {
                this.player.debug.error(this.TAG_NAME, "mp4Box onError", e)
            }, n.onSamples = (e, t, i) => {
                if (e === this.videoTrackId) for (const e of i) {
                    const t = e.data, i = e.is_sync, s = 1e3 * e.cts / e.timescale;
                    e.duration, e.timescale, this.player.updateStats({
                        vbps: t.byteLength,
                        dts: s
                    }), i && this.calcIframeIntervalTimestamp(s);
                    var r = (this.isHevc ? _r : pr)(t, i);
                    this.player._opt.isEmitSEI && this.findSei(r, s), this.player.debug.log(this.TAG_NAME, "onSamples: video", "timestamp", s), this._doDecodeByFmp4(r, 2, s, i, 0)
                } else if (e === this.audioTrackId) for (const e of i) {
                    const t = e.data, i = (this.player.updateStats({abps: t.byteLength}), 1e3 * e.cts / e.timescale),
                        a = 1e3 * e.duration / e.timescale, n = new Uint8Array(t.byteLength + 2);
                    n.set([175, 1], 0), n.set(t, 2), this.player.debug.log(this.TAG_NAME, "onSamples: audio", "timestamp", i, "duration", a), this._doDecodeByFmp4(n, 1, i, !1, 0)
                } else this.player.debug.warn(this.TAG_NAME, "onSamples() trackId error", e)
            }, new Uint8Array(e));
            t.buffer.fileStart = 0, n.appendBuffer(t.buffer), n.flush()
        }

        getSeqHeader(t, i) {
            if (t) {
                i = t.getTrackById(i.id);
                for (const t of i.mdia.minf.stbl.stsd.entries) if (t.avcC || t.hvcC) {
                    const i = new I.DataStream(void 0, 0, I.DataStream.BIG_ENDIAN);
                    let e = [];
                    e = t.avcC ? (t.avcC.write(i), [23, 0, 0, 0, 0]) : (this.isHevc = !0, t.hvcC.write(i), [28, 0, 0, 0, 0]);
                    const r = new Uint8Array(i.buffer, 8), s = new Uint8Array(e.length + r.length);
                    return s.set(e, 0), s.set(r, e.length), s
                }
            }
            return null
        }

        getBuferredDuration() {
            return this.tempSampleListInfo.buferredDuration || 0
        }

        getSampleListLength() {
            return this.tempSampleListInfo.allListLength || 0
        }

        getSampleAudioListLength() {
            return this.tempSampleListInfo.audioListLength || 0
        }

        getSampleVideoListLength() {
            return this.tempSampleListInfo.videoListLength || 0
        }
    }

    class pn {
        constructor(e, t) {
            this.hls = e, this.player = this.hls.player, this.isMP4 = t, this._initSegmentId = "", this.TAG_NAME = "HlsTransmuxer", this._demuxer = new (t ? un : cn)(this.hls.player)
        }

        destroy() {
            this._demuxer && (this._demuxer.destroy(), this._demuxer = null)
        }

        transmux(e, t, i, r, s, a) {
            this.player.debug.log(this.TAG_NAME, `transmux videoChunk:${e && e.byteLength}, audioChunk:${t && t.byteLength}, discontinuity:${i}, contiguous:${r}, startTime:${s}, needInit:` + a);
            const n = this._demuxer;
            try {
                this.isMP4 || n.demuxAndFix(dn(e, t), i, r, s)
            } catch (e) {
                throw new M("demux", "hls", e)
            }
        }
    }

    function fn(e, t) {
        t = 1 < arguments.length && void 0 !== t ? t : 0;
        return (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + (e[t + 3] || 0)
    }

    class mn {
        static probe(e) {
            return !!mn.findBox(e, ["ftyp"])
        }

        static findBox(e, t) {
            let i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            const r = [];
            if (!e) return r;
            let s = 0, a, n = 0;
            for (; 7 < e.length;) {
                if (s = fn(e), a = String.fromCharCode.apply(null, e.subarray(4, 8)), n = 8, 1 === s ? (s = function (e, t) {
                    var t = 1 < arguments.length && void 0 !== t ? t : 0, i = Math.pow(2, 32);
                    return fn(e, t) * i + fn(e, t + 4)
                }(e, 8), n += 8) : s = s || e.length, !t[0] || a === t[0]) {
                    const o = e.subarray(0, s);
                    if (!(t.length < 2)) return mn.findBox(o.subarray(n), t.slice(1), i + n);
                    r.push({start: i, size: s, headerSize: n, type: a, data: o})
                }
                i += s, e = e.subarray(s)
            }
            return r
        }
    }

    class gn {
        constructor(e) {
            this.hls = e, this.player = e.player, this._decryptor = new hn, this._transmuxer = null, this._mse = null, this._softVideo = null, this._sourceCreated = !1, this._needInitSegment = !0, this._directAppend = !1, this.TAG_NAME = "HlsBufferService"
        }

        async destroy() {
            this._softVideo = null, this._transmuxer && (this._transmuxer.destroy(), this._transmuxer = null)
        }

        get baseDts() {
            var e;
            return null == (e = this._transmuxer) || null == (e = e._demuxer) ? void 0 : e._baseDts
        }

        get nbSb() {
            return 0
        }

        async updateDuration(e) {
            this.player.debug.log(this.TAG_NAME, "updateDuration()", e)
        }

        getBuferredDuration() {
            var e;
            return null == (e = this._transmuxer) || null == (e = e._demuxer) ? void 0 : e.getBuferredDuration()
        }

        getBufferedSegments() {
            var e;
            return null == (e = this._transmuxer) || null == (e = e._demuxer) ? void 0 : e.getSampleListLength()
        }

        getBufferedAudioSegments() {
            var e;
            return null == (e = this._transmuxer) || null == (e = e._demuxer) ? void 0 : e.getSampleAudioListLength()
        }

        getBufferedVideoSegments() {
            var e;
            return null == (e = this._transmuxer) || null == (e = e._demuxer) ? void 0 : e.getSampleVideoListLength()
        }

        createSource(e, t, i, r) {
            this._sourceCreated || (e = e || t) && (cn.probe(e) ? this._transmuxer || (this._transmuxer = new pn(this.hls, !1)) : mn.probe(e) ? this._transmuxer || (this._transmuxer = new pn(this.hls, !0)) : console.error("createSource error: chunk is not ts"))
        }

        async appendBuffer(e, t, i, r, s, a, n) {
            if (null != i && i.length || null != r && r.length) return this._needInitSegment, this._transmuxer.transmux(i, r, s, a, n, this._needInitSegment || s), !0
        }

        async clearAllBuffer() {
            this.player.debug.log(this.TAG_NAME, "clearAllBuffer")
        }

        decryptBuffer(e, t) {
            return this._decryptor.decrypt(e, t)
        }

        async reset() {
            this._transmuxer = null, this._needInitSegment = !0, this._directAppend = !1
        }

        async endOfStream() {
            this._softVideo && this._softVideo.endOfStream()
        }

        async setLiveSeekableRange(e, t) {
        }

        seamlessSwitch() {
            this._needInitSegment = !0
        }
    }

    class yn {
        constructor(e) {
            this.emitter = e, this._seiSet = new Set, e.on("sei", e => {
                e && this._seiSet.add(e)
            })
        }

        throw(e) {
            if (null != e && this._seiSet.size) {
                const t = e - .2, i = e + .2, r = [];
                this._seiSet.forEach(e => {
                    e.time >= t && e.time <= i && r.push(e)
                }), r.forEach(e => {
                    this._seiSet.delete(e), this.emitter.emit("sei-in-time", e)
                })
            }
        }

        reset() {
            this._seiSet.clear()
        }
    }

    class An {
        constructor(e) {
            this._timescale = e, this.encodeType = "", this.audioCodec = "", this.videoCodec = "", this.domain = "", this.fps = 0, this.bitrate = 0, this.width = 0, this.height = 0, this.samplerate = 0, this.channelCount = 0, this.gop = 0, this._bitsAccumulateSize = 0, this._bitsAccumulateDuration = 0
        }

        getStats() {
            return {
                encodeType: this.encodeType,
                audioCodec: this.audioCodec,
                videoCodec: this.videoCodec,
                domain: this.domain,
                fps: this.fps,
                bitrate: this.bitrate,
                width: this.width,
                height: this.height,
                samplerate: this.samplerate,
                channelCount: this.channelCount,
                gop: this.gop
            }
        }

        setEncodeType(e) {
            this.encodeType = e
        }

        setFpsFromScriptData(e) {
            var e = e["data"], e = null == e || null == (e = e.onMetaData) ? void 0 : e.framerate;
            e && 0 < e && e < 100 && (this.fps = e)
        }

        setVideoMeta(e) {
            this.width = e.width, this.height = e.height, this.videoCodec = e.codec, this.encodeType = e.codecType, e.fpsNum && e.fpsDen && 0 < (e = e.fpsNum / e.fpsDen) && e < 100 && (this.fps = e)
        }

        setAudioMeta(e) {
            this.audioCodec = e.codec, this.samplerate = e.sampleRate, this.channelCount = e.channelCount
        }

        setDomain(e) {
            this.domain = e.split("/").slice(2, 3)[0]
        }

        updateBitrate(e) {
            var t;
            (!this.fps || 100 <= this.fps) && e.length && (t = e.reduce((e, t) => e + t.duration, 0) / e.length, this.fps = Math.round(this._timescale / t)), e.forEach(e => {
                1 === e.gopId && this.gop++, this._bitsAccumulateDuration += e.duration / (this._timescale / 1e3), this._bitsAccumulateSize += e.units.reduce((e, t) => e + t.length, 0), 1e3 <= this._bitsAccumulateDuration && (this.bitrate = 8 * this._bitsAccumulateSize, this._bitsAccumulateDuration = 0, this._bitsAccumulateSize = 0)
            })
        }
    }

    class bn {
        constructor(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1e3;
            s(this, "_core", null), s(this, "_samples", []), this._core = e, this._timescale = t, this._stats = new An(t), this._bindEvents()
        }

        getStats() {
            var e, t, {currentTime: i = 0, decodeFps: r = 0} = (null == (i = this._core) ? void 0 : i.media) || {};
            return {
                ...this._stats.getStats(),
                downloadSpeed: (null == (e = this._core) || null == (t = e.speedInfo) ? void 0 : t.call(e).speed) || 0,
                avgSpeed: (null == (t = this._core) || null == (e = t.speedInfo) ? void 0 : e.call(t).avgSpeed) || 0,
                currentTime: i,
                bufferEnd: (null == (e = this._core) || null == (t = e.bufferInfo()) ? void 0 : t.remaining) || 0,
                decodeFps: r
            }
        }

        _bindEvents() {
            this._core.on("demuxed-track", e => this._stats.updateBitrate(e.samples)), this._core.on("flv-script-data", e => {
                this._stats.setFpsFromScriptData(e)
            }), this._core.on("metadata-parsed", e => {
                "video" === e.type ? this._stats.setVideoMeta(e.track) : this._stats.setAudioMeta(e.track)
            }), this._core.on("ttfb", e => {
                this._stats.setDomain(e.responseUrl)
            })
        }

        reset() {
            this._samples = [], this._stats = new An(this._timescale)
        }
    }

    class vn extends e {
        constructor(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            super(), s(this, "_loadSegment", async () => {
                var e, t;
                {
                    if (this.player.debug.log(this.TAG_NAME, "_loadSegment()", "_segmentProcessing", this._segmentProcessing), !this._segmentProcessing) return e = this._playlist.currentSegment, t = this._playlist.nextSegment, this.player.debug.log(this.TAG_NAME, "_loadSegment()", "curSeg", e, "nextSeg", t), t ? this._loadSegmentDirect() : void this.player.debug.log(this.TAG_NAME, "nextSeg is null and return");
                    this.player.debug.warn("_loadSegment()", "_segmentProcessing is ture and return")
                }
            }), this.player = e, this.config = null, this._manifestLoader = null, this._segmentLoader = null, this._playlist = null, this._bufferService = null, this._seiService = null, this._stats = null, this._prevSegSn = null, this._prevSegCc = null, this._tickTimer = null, this._tickInterval = 500, this._segmentProcessing = !1, this._reloadOnPlay = !1, this._switchUrlOpts = null, this._disconnectTimer = null, this.TAG_NAME = "Hls256", this.canVideoPlay = !1, this.$videoElement = null, this.config = {
                isLive: !0,
                maxPlaylistSize: 50,
                retryCount: 3,
                retryDelay: 1e3,
                pollRetryCount: 2,
                loadTimeout: 1e4,
                preloadTime: 30,
                softDecode: !1,
                bufferBehind: 10,
                maxJumpDistance: 3,
                startTime: 0,
                targetLatency: 10,
                maxLatency: 20,
                allowedStreamTrackChange: !0, ...t
            }, this._manifestLoader = new sn(this), this._segmentLoader = new nn(this), this._playlist = new ln(this), this._bufferService = new gn(this), this._seiService = new yn(this), this._stats = new bn(this, 9e4), this.player.debug.log(this.TAG_NAME, "init")
        }

        async destroy() {
            this.player.debug.log(this.TAG_NAME, "destroy()"), this._playlist.reset(), this._segmentLoader.reset(), this._seiService.reset(), await Promise.all([this._clear(), this._bufferService.destroy()]), this._manifestLoader && (await this._manifestLoader.destroy(), this._manifestLoader = null), this._segmentLoader && (this._segmentLoader.destroy(), this._segmentLoader = null), this._playlist && (this._playlist.destroy(), this._playlist = null), this.player.debug.log(this.TAG_NAME, "destroy end")
        }

        _startTick() {
            this._stopTick(), this._tickTimer = setTimeout(() => {
                this._tick()
            }, this._tickInterval)
        }

        _stopTick() {
            this._tickTimer && clearTimeout(this._tickTimer), this._tickTimer = null
        }

        _tick() {
            this._startTick(), this._loadSegment()
        }

        get isLive() {
            return this._playlist.isLive
        }

        get streams() {
            return this._playlist.streams
        }

        get currentStream() {
            return this._playlist.currentStream
        }

        get hasSubtitle() {
            return this._playlist.hasSubtitle
        }

        get baseDts() {
            var e;
            return null == (e = this._bufferService) ? void 0 : e.baseDts
        }

        speedInfo() {
            return this._segmentLoader.speedInfo()
        }

        getStats() {
            return this._stats.getStats()
        }

        async loadSource(e) {
            return this.player.debug.log(this.TAG_NAME, "loadSource() " + e), await this._reset(), await this._loadData(e), this._startTick(), !0
        }

        async _loadData(e) {
            this.player.debug.log(this.TAG_NAME, "_loadData() " + e);
            try {
                e = e && e.trim()
            } catch (e) {
            }
            if (!e) throw this._emitError(new M(Oa, Oa, null, null, "m3u8 url is missing"));
            const t = await this._loadM3U8(e), i = this._playlist["currentStream"];
            if (this._urlSwitching) {
                var r;
                0 === i.bitrate && null != (r = this._switchUrlOpts) && r.bitrate && (i.bitrate = null == (r = this._switchUrlOpts) ? void 0 : r.bitrate);
                const e = this._getSeamlessSwitchPoint(),
                    t = (this.config.startTime = e, this._playlist.findSegmentIndexByTime(e)),
                    s = this._playlist.getSegmentByIndex(t + 1);
                if (s) {
                    const e = s.start;
                    this.player.debug.warn(this.TAG_NAME, "clear buffer from " + e)
                }
            }
            t && (this.isLive ? (this.player.debug.log(this.TAG_NAME, "is live"), this._bufferService.setLiveSeekableRange(0, 4294967295), this.config.targetLatency < this._playlist.totalDuration && (this.config.targetLatency = this._playlist.totalDuration, this.config.maxLatency = 1.5 * this.config.targetLatency), t.isMaster || this._pollM3U8(e)) : (this.player.debug.log(this.TAG_NAME, `is vod and totalDuration is ${i.totalDuration} s`), await this._bufferService.updateDuration(i.totalDuration))), await this._loadSegment()
        }

        async _loadM3U8(e) {
            let t;
            this.player.debug.log(this.TAG_NAME, "load m3u8: " + e);
            try {
                [t] = await this._manifestLoader.load(e)
            } catch (e) {
                throw this._emitError(M.create(e))
            }
            var i;
            if (t) return this._playlist.upsertPlaylist(t), t.isMaster ? (null != (i = this._playlist.currentStream.subtitleStreams) && i.length && this.emit("subtitle-playlist", {list: this._playlist.currentStream.subtitleStreams}), await this._refreshM3U8()) : this.player.debug.warn(this.TAG_NAME, "_loadM3U8() is not master playlist"), this.emit("stream-parsed"), t;
            this.player.debug.warn(this.TAG_NAME, "_loadM3U8() playlist is empty")
        }

        _refreshM3U8() {
            this.player.debug.log(this.TAG_NAME, "_refreshM3U8()");
            var e, t = this._playlist.currentStream;
            if (!t || !t.url) throw this._emitError(M.create(null, null, new Error("m3u8 url is not defined")));
            const r = t.url, s = null == (e = t.currentAudioStream) ? void 0 : e.url,
                a = null == (e = t.currentSubtitleStream) ? void 0 : e.url;
            return this._manifestLoader.load(r, s, a).then(e => {
                var [e, t, i] = e;
                e ? (this._playlist.upsertPlaylist(e, t, i), this.isLive && this._pollM3U8(r, s, a)) : this.player.debug.warn(this.TAG_NAME, "_refreshM3U8() mediaPlaylist is empty")
            }).catch(e => {
                throw this._emitError(M.create(e))
            })
        }

        _pollM3U8(e, t, i) {
            let r = this._playlist.isEmpty;
            this._manifestLoader.poll(e, t, i, (e, t, i) => {
                this._playlist.upsertPlaylist(e, t, i), this._playlist.clearOldSegment(), e && r && !this._playlist.isEmpty && this._loadSegment(), r = r && this._playlist.isEmpty
            }, e => {
                this._emitError(M.create(e))
            }, 1e3 * ((null == (e = this._playlist.lastSegment) ? void 0 : e.duration) || 0))
        }

        async _loadSegmentDirect() {
            this.player.debug.log(this.TAG_NAME, "_loadSegmentDirect()");
            var i = this._playlist.nextSegment;
            if (i) {
                let e = !1, t = null;
                try {
                    this._segmentProcessing = !0, e = await this._reqAndBufferSegment(i, this._playlist.getAudioSegment(i))
                } catch (i) {
                    t = i
                } finally {
                    this._segmentProcessing = !1
                }
                return t ? this._emitError(M.create(t)) : (e ? (this._urlSwitching && (this._urlSwitching = !1, this.emit("switch-url-success", {url: this.config.url})), this._playlist.moveSegmentPointer(), this.player.debug.log(this.TAG_NAME, "_loadSegmentDirect()", "seg.isLast", i.isLast), i.isLast ? (this.player.debug.log(this.TAG_NAME, "_loadSegmentDirect()", "seg.isLast"), this._end()) : (this.player.debug.log(this.TAG_NAME, "_loadSegmentDirect()", "and next _loadSegment()"), this._loadSegment())) : this.player.debug.log(this.TAG_NAME, "_loadSegmentDirect() not appended"), e)
            }
            this.player.debug.log(this.TAG_NAME, "_loadSegmentDirect() !seg")
        }

        async _reqAndBufferSegment(e, t) {
            this.player.debug.log(this.TAG_NAME, "video seg", e && e.url, "audio seg", t && t.url);
            var i = (e || t).cc, r = this._prevSegCc !== i;
            let s = [];
            try {
                s = await this._segmentLoader.load(e, t, r)
            } catch (e) {
                throw e.fatal = !1, this._segmentLoader.error = e
            }
            if (s[0]) {
                var a, n, o, l = await this._bufferService.decryptBuffer(...s);
                if (l) return a = (e || t).sn, n = (e || t).start, o = this._playlist.currentStream, this._bufferService.createSource(l[0], l[1], null == o ? void 0 : o.videoCodec, null == o ? void 0 : o.audioCodec), await this._bufferService.appendBuffer(e, t, l[0], l[1], r, this._prevSegSn === a - 1, n), this._prevSegCc = i, this._prevSegSn = a, !0;
                this.player.debug.log(this.TAG_NAME, "decryptBuffer return null")
            }
        }

        async _clear() {
            this.player.debug.log(this.TAG_NAME, "_clear()"), clearTimeout(this._disconnectTimer), this._stopTick(), await Promise.all([this._segmentLoader.cancel(), this._manifestLoader.stopPoll()]), this._segmentProcessing = !1
        }

        async _reset() {
            var e = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            return this.player.debug.log(this.TAG_NAME, "_reset()"), this._reloadOnPlay = !1, this._prevSegSn = null, this._prevSegCc = null, this._switchUrlOpts = null, this._playlist.reset(), this._segmentLoader.reset(), this._seiService.reset(), this._stats.reset(), await this._clear(), this._bufferService.reset(e)
        }

        _end() {
            this.player.debug.log(this.TAG_NAME, "_end()"), this._clear()
        }

        _emitError(e) {
            var t, i = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
            return !1 === (null == (t = e.originError) ? void 0 : t.fatal) ? console.warn(e) : (console.table(e), console.error(e), console.error(null == (t = this.media) ? void 0 : t.error), this._stopTick(), this._urlSwitching && (this._urlSwitching = !1, this.emit("switch-url-failed", e)), i && this._end(), this._seiService.reset(), this.emit("error", e)), e
        }

        _getSeamlessSwitchPoint() {
            var e, t = this["media"];
            let i = t.currentTime;
            return t.paused || (t = this._playlist.findSegmentIndexByTime(t.currentTime), t = this._playlist.getSegmentByIndex(t), e = null == (e = this._stats) ? void 0 : e.getStats().downloadSpeed, i += e && t ? t.duration * this._playlist.currentStream.bitrate / e + 1 : 5), i
        }

        getDemuxBuferredDuration() {
            return this._bufferService.getBuferredDuration() || 0
        }

        getDemuxBufferedListLength() {
            return this._bufferService.getBufferedSegments() || 0
        }

        getDemuxAudioBufferedListLength() {
            return this._bufferService.getBufferedAudioSegments() || 0
        }

        getDemuxVideoBufferedListLength() {
            return this._bufferService.getBufferedVideoSegments() || 0
        }
    }

    class _n extends e {
        constructor(e) {
            super(), s(this, "TAG_NAME", "Hls256Decoder"), this.player = e, this.canVideoPlay = !1, this.$videoElement = this.player.video.$videoElement, this.hls = null, this.eventsDestroy = [], this.bandwidthEstimateInterval = null, ii() ? this.canVideoPlay = !0 : (this.hls = new vn(e), this._bindEvents())
        }

        async destroy() {
            return this._stopBandwidthEstimateInterval(), this.hls && (await this.hls.destroy(), this.hls = null), this.eventsDestroy.length && (this.eventsDestroy.forEach(e => e()), this.eventsDestroy = []), this.$videoElement = null, this.player.debug.log(this.TAG_NAME, "destroy"), !0
        }

        _bindEvents() {
            this.hls.on("error", e => {
                this.player.emitError(S.hlsError, e)
            }), this._startBandwidthEstimateInterval()
        }

        _startBandwidthEstimateInterval() {
            this._stopBandwidthEstimateInterval(), this.bandwidthEstimateInterval = setInterval(() => {
                var e = this.hls.speedInfo();
                this.player.emit(w.kBps, (e.avgSpeed / 1024 / 8).toFixed(2))
            }, 1e3)
        }

        _stopBandwidthEstimateInterval() {
            this.bandwidthEstimateInterval && (clearInterval(this.bandwidthEstimateInterval), this.bandwidthEstimateInterval = null)
        }

        initVideoPlay(e) {
            this.$videoElement.muted = !0, this.$videoElement.src = e
        }

        async loadSource(e) {
            return this.player.debug.log(this.TAG_NAME, "loadSource() " + e), this.url = e, this.canVideoPlay ? this.initVideoPlay(e) : await this.hls.loadSource(e), !0
        }

        checkHlsBufferedDelay() {
            let e = 0;
            return e = this.hls ? this.hls.getDemuxBuferredDuration() : e
        }

        getDemuxBufferedListLength() {
            let e = 0;
            return e = this.hls ? this.hls.getDemuxBufferedListLength() : e
        }

        getDemuxAudioBufferedListLength() {
            let e = 0;
            return e = this.hls ? this.hls.getDemuxAudioBufferedListLength() : e
        }

        getDemuxVideoBufferedListLength() {
            let e = 0;
            return e = this.hls ? this.hls.getDemuxVideoBufferedListLength() : e
        }
    }

    class wn extends e {
        constructor(t) {
            super(), this.TAG_NAME = "WebrtcDecoder", this.player = t, this.rtcPeerConnection = null, this.rtcPeerConnectionDataChannel = null, this.videoStream = null, this.isDisconnected = !1, this._initRtcPeerConnection(), this.player.isWebrtcH265() && (this.streamRate = Tt(e => {
                t.emit(w.kBps, (e / 1024).toFixed(2))
            })), this.player.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            this.isDisconnected = !1, this.stopStreamRateInterval(), this.player.isWebrtcH264() && (this.videoStream && (this.videoStream.getTracks().forEach(e => e.stop()), this.videoStream = null), this.player.video.$videoElement.srcObject = null), this.rtcPeerConnectionDataChannel && (this.rtcPeerConnectionDataChannel.onopen = o, this.rtcPeerConnectionDataChannel.onclose = o, this.rtcPeerConnectionDataChannel.onmessage = o, this.rtcPeerConnectionDataChannel.close(), this.rtcPeerConnectionDataChannel = null), this.rtcPeerConnection && (this.rtcPeerConnection.onicecandidate = o, this.rtcPeerConnection.ontrack = o, this.rtcPeerConnection.onconnectionstatechange = o, this.rtcPeerConnection.ondatachannel = o, this.rtcPeerConnection.close(), this.rtcPeerConnection = null), this.player.debug.log(this.TAG_NAME, "destroy")
        }

        _initRtcPeerConnection() {
            const i = new RTCPeerConnection, r = this.player;
            i.addTransceiver("video", {direction: "recvonly"}), i.addTransceiver("audio", {direction: "recvonly"}), i.onsignalingstatechange = e => {
                this.player.debug.log(this.TAG_NAME, "onsignalingstatechange", e)
            }, i.oniceconnectionstatechange = e => {
                this.player.debug.log(this.TAG_NAME, "oniceconnectionstatechange", i.iceConnectionState);
                var t = i.iceConnectionState;
                switch (this.player.emit(w.webrtcOnIceConnectionStateChange, t), this.isDisconnected = "disconnected" === t, i.iceConnectionState) {
                    case"new":
                    case"checking":
                    case"closed":
                    case"connected":
                    case"completed":
                        break;
                    case"failed":
                        r.emit(w.webrtcFailed);
                        break;
                    case"disconnected":
                        r.emit(w.webrtcDisconnect);
                        break;
                    case"closed":
                        r.emit(w.webrtcClosed)
                }
            }, i.onicecandidate = e => {
                this.player.debug.log(this.TAG_NAME, "onicecandidate", e), e.candidate && this.player.debug.log(this.TAG_NAME, "Remote ICE candidate: ", e.candidate.candidate)
            }, i.ontrack = e => {
                this.player.debug.log(this.TAG_NAME, "ontrack", e);
                const t = r.video.$videoElement;
                "video" === e.track.kind && r.isWebrtcH264() && (e = e.streams[0], t.autoplay = !0, t.srcObject = e, this.videoStream = e)
            }, i.onicecandidateerror = e => {
                this.player.debug.log(this.TAG_NAME, "onicecandidateerror", e), this.player.emitError(S.webrtcIceCandidateError, e)
            }, i.onconnectionstatechange = e => {
                switch (r.debug.log(this.TAG_NAME, "sdp connect status " + i.connectionState), i.connectionState) {
                    case"new":
                    case"connecting":
                    case"connected":
                    case"disconnected":
                        break;
                    case"failed":
                        this.isDisconnected && r.emit(w.webrtcFailed)
                }
            }, i.ondatachannel = e => {
                const t = e.channel;
                this.player.debug.log(this.TAG_NAME, "ondatachannel"), t.onopen = () => {
                    this.player.debug.log(this.TAG_NAME, "ondatachannel and onopen")
                }, t.onmessage = e => {
                    e = e.data;
                    if (this.player.isWebrtcH264()) return this.player.debug.warn(this.TAG_NAME, "ondatachannel is H265 but decode is h264 so emit webrtcStreamH265 "), void this.player.emit(w.webrtcStreamH265);
                    this.player.isDestroyed() ? this.player.debug.warn(this.TAG_NAME, "ondatachannel and player is destroyed") : (this.streamRate && this.streamRate(e.byteLength), this.player.demux && this.player.demux.dispatch(e))
                }, t.onclose = () => {
                    this.player.debug.warn(this.TAG_NAME, "ondatachannel and onclose")
                }, this.rtcPeerConnectionDataChannel = t
            }, i.createDataChannel("signal").onmessage = e => {
                this.player.debug.log(this.TAG_NAME, "signalChannel,onmessage", e), JSON.parse(e.data).type
            }, this.rtcPeerConnection = i
        }

        startStreamRateInterval() {
            this.stopStreamRateInterval(), this.streamRateInterval = setInterval(() => {
                this.streamRate && this.streamRate(0)
            }, 1e3)
        }

        stopStreamRateInterval() {
            this.streamRateInterval && (clearInterval(this.streamRateInterval), this.streamRateInterval = null)
        }

        loadSource(s) {
            return new Promise((t, i) => {
                const r = this.rtcPeerConnection;
                r.createOffer().then(e => {
                    r.setLocalDescription(e), this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp loadSource"), e = e.sdp, fetch(s, {
                        method: "POST",
                        mode: "cors",
                        cache: "no-cache",
                        credentials: "include",
                        redirect: "follow",
                        referrerPolicy: "no-referrer",
                        headers: {"Content-Type": "application/sdp"},
                        body: e
                    }).then(e => {
                        e.text().then(e => {
                            this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp response"), r.setRemoteDescription(new RTCSessionDescription({
                                type: "answer",
                                sdp: e
                            })), this.player.isWebrtcH265() && this.startStreamRateInterval(), t()
                        }).catch(e => {
                            this.player.debug.error(this.TAG_NAME, "loadSource response.text() error", e), i(e)
                        })
                    }).catch(e => {
                        this.player.debug.error(this.TAG_NAME, "loadSource getWebRtcRemoteSdp response error", e), i(e)
                    })
                }).catch(e => {
                    this.player.debug.error(this.TAG_NAME, "loadSource rtcPeerConnection.createOffer() error", e), i(e)
                })
            })
        }
    }

    class Sn extends e {
        constructor(e) {
            super(), this.player = e, this.rtcPeerConnection = null, this.videoStream = null, this.isDisconnected = !1, this._initRtcPeerConnection()
        }

        destroy() {
            this.isDisconnected = !1, this.videoStream && (this.videoStream.getTracks().forEach(e => e.stop()), this.videoStream = null), this.player.video.$videoElement.srcObject = null, this.rtcPeerConnection && (this.rtcPeerConnection.onicecandidate = o, this.rtcPeerConnection.ontrack = o, this.rtcPeerConnection.onconnectionstatechange = o, this.rtcPeerConnection.ondatachannel = o, this.rtcPeerConnection.close(), this.rtcPeerConnection = null)
        }

        _initRtcPeerConnection() {
            const i = new RTCPeerConnection, r = this.player;
            i.addTransceiver("video", {direction: "recvonly"}), i.addTransceiver("audio", {direction: "recvonly"}), i.onsignalingstatechange = e => {
                this.player.debug.log(this.TAG_NAME, "onsignalingstatechange", e)
            }, i.oniceconnectionstatechange = e => {
                this.player.debug.log(this.TAG_NAME, "oniceconnectionstatechange", i.iceConnectionState);
                var t = i.iceConnectionState;
                switch (this.player.emit(w.webrtcOnIceConnectionStateChange, t), this.isDisconnected = "disconnected" === t, i.iceConnectionState) {
                    case"new":
                    case"checking":
                    case"closed":
                    case"connected":
                    case"completed":
                        break;
                    case"failed":
                        r.emit(w.webrtcFailed);
                        break;
                    case"disconnected":
                        r.emit(w.webrtcDisconnect);
                        break;
                    case"closed":
                        r.emit(w.webrtcClosed)
                }
            }, i.onicecandidate = e => {
                this.player.debug.log(this.TAG_NAME, "onicecandidate", e), e.candidate && this.player.debug.log(this.TAG_NAME, "Remote ICE candidate: ", e.candidate.candidate)
            }, i.ontrack = e => {
                const t = r.video.$videoElement;
                this.player.debug.log(this.TAG_NAME, "ontrack", e), "video" === e.track.kind && (this.player.debug.log(this.TAG_NAME, "ontrack audio"), e = e.streams[0], t.autoplay = !0, t.srcObject = e, this.videoStream = e)
            }, i.onicecandidateerror = e => {
                this.player.debug.log(this.TAG_NAME, "onicecandidateerror", e), this.player.emitError(S.webrtcIceCandidateError, e)
            }, i.onconnectionstatechange = e => {
                switch (this.player.debug.log(this.TAG_NAME, "onconnectionstatechange", e), this.player.emit(w.webrtcOnConnectionStateChange, i.connectionState), i.connectionState) {
                    case"new":
                    case"connecting":
                    case"connected":
                    case"disconnected":
                        break;
                    case"failed":
                        this.isDisconnected && r.emit(w.webrtcFailed)
                }
            }, this.rtcPeerConnection = i
        }
    }

    class En extends Sn {
        constructor(e) {
            super(e), this.TAG_NAME = "WebrtcForZLMDecoder", this.player.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.player.debug.log(this.TAG_NAME, "destroy")
        }

        loadSource(s) {
            return new Promise((t, i) => {
                const r = this.rtcPeerConnection;
                r.createOffer().then(e => {
                    r.setLocalDescription(e), this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp loadSource"), e = e.sdp, Xr({
                        url: s,
                        type: "POST",
                        data: e,
                        contentType: "text/plain;charset=utf-8",
                        processData: !1,
                        dataType: "json"
                    }).then(e => {
                        this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp response and code is " + e.code);
                        if (0 !== e.code) return i(e.msg);
                        r.setRemoteDescription(new RTCSessionDescription({type: "answer", sdp: e.sdp})), t()
                    }).catch(e => {
                        this.player.debug.error(this.TAG_NAME, "loadSource getWebRtcRemoteSdp response error", e), i(e)
                    })
                }).catch(e => {
                    this.player.debug.error(this.TAG_NAME, "loadSource rtcPeerConnection.createOffer() error", e), i(e)
                })
            })
        }
    }

    class Tn extends e {
        constructor(e, t) {
            if (super(), this.player = e, this.player.$container.classList.add("jessibuca-container-playback"), this._showPrecision = null, this._startTime = null, this._playStartTime = null, this._playingTimestamp = null, this._fps = parseInt(t.fps, 10) || e._opt.playbackFps, this._isUseFpsRender = !!k(t.isUseFpsRender), this._rate = 1, this._audioTimestamp = 0, this._videoTimestamp = 0, this.controlType = t.controlType || _, this._currentLocalTimestamp = 0, this._localOneFrameTimestamp = t.localOneFrameTimestamp || 40, this._localCalculateTimeInterval = null, this._isUseLocalCalculateTime = !!k(t.isUseLocalCalculateTime), this._isPlaybackPauseClearCache = !C(t.isPlaybackPauseClearCache), this._isCacheBeforeDecodeForFpsRender = !!k(t.isCacheBeforeDecodeForFpsRender), this._startfpsTime = null, this._startFpsTimestamp = null, this._checkStatsInterval = null, this._playbackTs = 0, this._renderFps = 0, this._isUseLocalCalculateTime ? this._startLocalCalculateTime() : this._listen(), this.playbackList = [], this._playbackListStartTimestamp = null, this._totalDuration = 0, t.controlType === _) this.initPlaybackList(t.playList, t.showPrecision, t.startTime); else if (t.controlType === te) {
                t.duration && (this._totalDuration = 1e3 * t.duration);
                let e = t.startTime || 0;
                e > this.totalDuration && (e = this.totalDuration), this.setStartTime(e)
            }
            this.player.on(w.playbackPause, e => {
                e ? this.pause() : this.resume()
            });
            t = {
                fps: this._fps,
                isUseFpsRender: this._isUseFpsRender,
                localOneFrameTimestamp: this._localOneFrameTimestamp,
                isUseLocalCalculateTime: this._isUseLocalCalculateTime,
                uiUsePlaybackPause: t.uiUsePlaybackPause,
                showControl: t.showControl
            };
            e.debug.log("Playback", "init", JSON.stringify(t))
        }

        destroy() {
            this._startTime = null, this._showPrecision = null, this._playStartTime = null, this._playingTimestamp = null, this._totalDuration = 0, this._audioTimestamp = 0, this._videoTimestamp = 0, this._fps = null, this._isUseFpsRender = !1, this._rate = 1, this.playbackList = [], this._playbackListStartTimestamp = null, this._localCalculateTimeInterval = null, this._currentLocalTimestamp = 0, this._startfpsTime = null, this._startFpsTimestamp = null, this._renderFps = 0, this._playbackTs = 0, this._stopLocalCalculateTime(), this.clearStatsInterval(), this.player.$container && this.player.$container.classList.remove("jessibuca-container-playback"), this.off(), this.player.debug.log("Playback", "destroy")
        }

        _listen() {
            this.player.on(w.stats, e => {
                e = e.ts, this._playStartTime || (this._playStartTime = e), e -= this._playStartTime;
                this.setPlayingTimestamp(e)
            })
        }

        pause() {
            this.clearStatsInterval()
        }

        resume() {
            this.startCheckStatsInterval()
        }

        updateStats() {
            var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {},
                t = (this._startFpsTimestamp || (this._startFpsTimestamp = p()), x(t.ts) && (this.player.updateStats({
                    fps: !0,
                    ts: t.ts
                }), this._playbackTs = t.ts, this._startfpsTime || (this._startfpsTime = t.ts), this._renderFps += 1), p()),
                i = t - this._startFpsTimestamp;
            if (!(i < 1e3)) {
                let e = null;
                this._startfpsTime && (e = this._playbackTs - this._startfpsTime), this.player.emit(w.playbackStats, {
                    fps: this._renderFps,
                    rate: this.rate,
                    start: this._startfpsTime,
                    end: this._playbackTs,
                    timestamp: i,
                    dataTimestamp: e,
                    audioBufferSize: this.player.audio ? this.player.audio.bufferSize : 0,
                    videoBufferSize: this.player.video ? this.player.video.bufferSize : 0,
                    ts: this._playbackTs
                }), this._renderFps = 0, this._startfpsTime = this._playbackTs, this._startFpsTimestamp = t
            }
        }

        updateLocalOneFrameTimestamp(e) {
            this._localOneFrameTimestamp = e
        }

        _startLocalCalculateTime() {
            this._stopLocalCalculateTime(), this._localCalculateTimeInterval = setInterval(() => {
                var e = this._currentLocalTimestamp,
                    e = (this._playStartTime || (this._playStartTime = e), e - this._playStartTime);
                this.setPlayingTimestamp(e)
            }, 1e3)
        }

        startCheckStatsInterval() {
            this.clearStatsInterval(), this._checkStatsInterval = setInterval(() => {
                this.updateStats()
            }, 1e3)
        }

        _stopLocalCalculateTime() {
            this._localCalculateTimeInterval && (clearInterval(this._localCalculateTimeInterval), this._localCalculateTimeInterval = null)
        }

        clearStatsInterval() {
            this._checkStatsInterval && (clearInterval(this._checkStatsInterval), this._checkStatsInterval = null)
        }

        increaseLocalTimestamp() {
            this._isUseLocalCalculateTime && (this._currentLocalTimestamp += this._localOneFrameTimestamp)
        }

        initPlaybackList(t, e, i) {
            this.playbackList = t || [];
            let r = 0;
            if (this.playbackList.forEach((e, t) => {
                10 === Jt(e.start) && (e.startTimestamp = 1e3 * e.start, e.startTime = Rt(e.startTimestamp)), 10 === Jt(e.end) && (e.endTimestamp = 1e3 * e.end, e.endTime = Rt(e.endTimestamp)), e.duration = e.end - e.start, r += e.duration
            }), this._totalDuration = r, this.player.debug.log("Playback", this.playbackList), 0 < this.playbackList.length) {
                const t = this.playbackList[0].startTimestamp;
                let e = this._playbackListStartTimestamp = t;
                i && (10 === Jt(i) && (i *= 1e3), this._isTimeInPlaybackList(i) && (e = i)), this.setStartTime(e)
            }
            t = e || Pe;
            this.setShowPrecision(t)
        }

        get totalDuration() {
            return (this._totalDuration || 0) / 1e3
        }

        get startTime() {
            return this._startTime || 0
        }

        setStartTime(e) {
            this._startTime = e, this._playingTimestamp = e, this._playStartTime = null
        }

        setRate(e) {
            this._rate = e, this.player.emit(w.playbackRateChange, e)
        }

        get fps() {
            return this._fps
        }

        get rate() {
            return this._rate
        }

        get isUseFpsRender() {
            return this._isUseFpsRender
        }

        get isUseLocalCalculateTime() {
            return this._isUseLocalCalculateTime
        }

        get showPrecision() {
            return this._showPrecision
        }

        get is60Min() {
            return this.showPrecision === Pe
        }

        get is30Min() {
            return this.showPrecision === Be
        }

        get is10Min() {
            return "tenMin" === this.showPrecision
        }

        get is5Min() {
            return this.showPrecision === Ue
        }

        get is1Min() {
            return this.showPrecision === Ue
        }

        get isPlaybackPauseClearCache() {
            return this._isPlaybackPauseClearCache
        }

        get isCacheBeforeDecodeForFpsRender() {
            return this._isCacheBeforeDecodeForFpsRender
        }

        setShowPrecision(e) {
            Me.includes(e) || (this.player.debug.warn("Playback", "setShowPrecision()", "type is not in PLAYBACK_CONTROL_TIME_PRECISION_ARRAY", e), e = Pe), this._showPrecision && this._showPrecision === e || (this._showPrecision = e, this.player.emit(w.playbackPrecision, this._showPrecision, this.playbackList), this.player.emit(w.playbackShowPrecisionChange, this._showPrecision))
        }

        setPlayingTimestamp(e) {
            let t;
            if (this.controlType === _) {
                t = this.startTime + e, this._playingTimestamp = t, this.player.emit(w.playbackTime, t);
                const i = new Date(t);
                this.player.emit(w.playbackTimestamp, {
                    ts: t,
                    hour: i.getHours(),
                    min: i.getMinutes(),
                    second: i.getSeconds()
                })
            } else this.controlType === te && (t = this.startTime + parseInt(e / 1e3, 10), this._playingTimestamp = t, this.player.emit(w.playbackTime, t), this.player.emit(w.playbackTimestamp, {ts: t}))
        }

        get playingTimestamp() {
            return this._playingTimestamp
        }

        narrowPrecision() {
            var e = Me.indexOf(this.showPrecision) - 1;
            0 <= e && (e = Me[e], this.setShowPrecision(e))
        }

        expandPrecision() {
            var e = Me.indexOf(this.showPrecision) + 1;
            e <= Me.length - 1 && (e = Me[e], this.setShowPrecision(e))
        }

        seek(i) {
            if (this.player.debug.log("Playback", "seek()", i), this.controlType === _) {
                if ("true" === i.hasRecord) {
                    let e = i.time, t = function (e) {
                        let t = {};
                        return t = -1 < e ? {
                            hour: Math.floor(e / 60 / 60) % 60,
                            min: Math.floor(e / 60) % 60,
                            second: e % 60
                        } : t
                    }(e = "min" === i.type ? 60 * i.time : e);
                    if (this._playbackListStartTimestamp) {
                        const i = new Date(this._playbackListStartTimestamp).setHours(t.hour, t.min, t.second, 0);
                        t.timestamp = i;
                        var r = this._findMoreInfoByTimestamp(i);
                        t && r.more && (t.more = r.more)
                    }
                    this.player.emit(w.playbackSeek, t)
                }
            } else this.controlType === te && (r = i.time, this.player.emit(w.playbackSeek, {ts: r}))
        }

        currentTimeScroll() {
            this.player.emit(w.playbackTimeScroll)
        }

        _findMoreInfoByTimestamp(i) {
            let r = null;
            return this.playbackList.forEach((e, t) => {
                e.startTimestamp <= i && e.endTimestamp >= i && (r = e)
            }), r
        }

        _isTimeInPlaybackList(i) {
            let r = !1;
            return this.playbackList.forEach((e, t) => {
                e.startTimestamp <= i && e.endTimestamp >= i && (r = !0)
            }), r
        }

        getControlType() {
            return this.controlType
        }

        isControlTypeNormal() {
            return this.controlType === _
        }

        isControlTypeSimple() {
            return this.controlType === te
        }
    }

    class kn extends e {
        constructor(e) {
            super(), this.player = e, this.bindEvents = [], this.isDragging = !1, this.currentZoom = 1, this.prevVideoElementStyleTransform = null, this.prevVideoElementStyleScale = null, this.tempPosition = {
                x: 0,
                y: 0
            }, this.videoPosition = {left: 0, top: 0};
            const {proxy: t} = this.player["events"];
            this.player.on(w.zooming, e => {
                if (e) {
                    this.player.$container.classList.add("jessibuca-zoom-control"), this._bindEvents();
                    const e = this.player.video.$videoElement.style.transform;
                    var i = this.player.video.$videoElement.style.left, r = this.player.video.$videoElement.style.top,
                        i = parseFloat(i), r = parseFloat(r);
                    i && (this.videoPosition.left = i), r && (this.videoPosition.top = r);
                    let t = (this.prevVideoElementStyleTransform = e).match(/scale\([0-9., ]*\)/g);
                    if (t && t[0]) {
                        let e = t[0].replace("scale(", "").replace(")", "");
                        this.prevVideoElementStyleScale = e.split(",")
                    }
                } else this.player.$container.classList.remove("jessibuca-zoom-control"), this._unbindEvents(), this._resetVideoPosition(), this.player.$container.style.cursor = "auto", this.player.video.$videoElement.style.transform = this.prevVideoElementStyleTransform, this.prevVideoElementStyleTransform = null, this.prevVideoElementStyleScale = null
            });
            var i = t(window, y() ? "touchend" : "mouseup", e => {
                this.handleMouseUp(e)
            });
            this.bindEvents.push(i), e.debug.log("zoom", "init")
        }

        destroy() {
            this.bindEvents = [], this.isDragging = !1, this.currentZoom = 1, this.prevVideoElementStyleTransform = null, this.prevVideoElementStyleScale = null, this.tempPosition = {
                x: 0,
                y: 0
            }, this.videoPosition = {left: 0, top: 0}, this.off(), this.player.debug.log("zoom", "destroy")
        }

        _bindEvents() {
            const e = this.player["events"]["proxy"],
                t = e(this.player.$container, y() ? "touchmove" : "mousemove", e => {
                    this.handleMouseMove(e)
                });
            this.bindEvents.push(t);
            var i = e(this.player.$container, y() ? "touchstart" : "mousedown", e => {
                this.handleMouseDown(e)
            }), i = (this.bindEvents.push(i), e(window, y() ? "touchend" : "mouseup", e => {
                this.handleMouseUp(e)
            }));
            this.bindEvents.push(i)
        }

        _unbindEvents() {
            this.bindEvents.forEach(e => {
                e && e()
            })
        }

        handleMouseMove(e) {
            var t, i, r;
            e.stopPropagation(), this.isDragging && this.player.zooming && (e.preventDefault(), {
                posX: e,
                posY: t
            } = ti(e), i = this.tempPosition.x - e, r = this.tempPosition.y - t, this.videoPosition.left = this.videoPosition.left - i, this.videoPosition.top = this.videoPosition.top - r, this.tempPosition.x = e, this.tempPosition.y = t, this.updateVideoPosition())
        }

        handleMouseDown(e) {
            e.stopPropagation();
            const t = ei(e);
            if (this.player.zooming && (t.matches("video") || t.matches("canvas"))) {
                e.preventDefault();
                const {posX: t, posY: i} = ti(e);
                this.player.$container.style.cursor = "grabbing", this.tempPosition.x = t, this.tempPosition.y = i, this.isDragging = !0, this.player.debug.log("zoom", "handleMouseDown is dragging true")
            }
        }

        handleMouseUp(e) {
            e.stopPropagation(), this.isDragging && this.player.zooming && (e.preventDefault(), this.tempPosition = {
                x: 0,
                y: 0
            }, this.isDragging = !1, this.player.$container.style.cursor = "grab", this.player.debug.log("zoom", "handleMouseUp is dragging false"))
        }

        updateVideoPosition() {
            const e = this.player.video.$videoElement;
            e.style.left = this.videoPosition.left + "px", e.style.top = this.videoPosition.top + "px"
        }

        _resetVideoPosition() {
            this.player.resize(), this.tempPosition = {x: 0, y: 0}, this.videoPosition = {
                left: 0,
                top: 0
            }, this.currentZoom = 1, this.isDragging = !1
        }

        narrowPrecision() {
            this.currentZoom <= 1 || (--this.currentZoom, this.updateVideoElementScale())
        }

        expandPrecision() {
            5 <= this.currentZoom || (this.currentZoom += 1, this.updateVideoElementScale())
        }

        updateVideoElementScale() {
            const e = this.player.video.$videoElement;
            let t = e.style.transform, i = 1, r = 1;
            if (this.prevVideoElementStyleScale) {
                const e = this.prevVideoElementStyleScale[0],
                    t = (void 0 !== e && (i = e, r = e), this.prevVideoElementStyleScale[1]);
                void 0 !== t && (r = t)
            }
            r = Bt(r);
            var s = .5 * (i = Bt(i)) * (this.currentZoom - 1) + i, a = .5 * r * (this.currentZoom - 1) + r,
                n = -1 === t.indexOf("scale(") ? t + ` scale(${s},${a})` : t.replace(/scale\([0-9., ]*\)/, `scale(${s},${a})`);
            this.player.debug.log("zoom", `updateVideoElementScale end is ${s}, ${a} style is ` + n), e.style.transform = n
        }
    }

    class xn extends e {
        constructor(e) {
            super(), this.player = e, this.faceDetector = null, this.objectDetector = null, this.initFaceDetector(), this.initObjectDetector(), this.player.debug.log("AiLoader", "init")
        }

        initFaceDetector() {
            if (this.player._opt.useFaceDetector && window.JessibucaProFaceDetector) {
                const e = new JessibucaProFaceDetector({detectWidth: this.player._opt.aiFaceDetectWidth});
                e.load().then(() => {
                    this.player.debug.log("AiLoader", "init face detector success"), this.faceDetector = e
                })
            }
        }

        initObjectDetector() {
            if (this.player._opt.useObjectDetector && window.JessibucaProObjectDetector) {
                const e = new JessibucaProObjectDetector({detectWidth: this.player._opt.aiObjectDetectWidth});
                e.load().then(() => {
                    this.player.debug.log("AiLoader", "init object detector success"), this.objectDetector = e, this.objectDetector.on("jessibuca-pro-object-detector-info", e => {
                        e && 0 < e.length && this.player.emit(w.aiObjectDetectorInfo, e)
                    })
                })
            }
        }

        destroy() {
            this.faceDetector && (this.faceDetector.destroy(), this.faceDetector = null), this.objectDetector && (this.objectDetector.destroy(), this.objectDetector = null), this.off()
        }
    }

    class Cn extends e {
        constructor(e) {
            super(), this.player = e, this.LOG_NAME = "Contextmenu", this.menuList = [], this.$contextmenus = e.control.$contextmenus, y() ? this.player.debug.warn(this.LOG_NAME, "not support mobile") : this.init(), e.debug.log(this.LOG_NAME, "init")
        }

        destroy() {
            this.menuList = [], this.player.debug.log(this.LOG_NAME, "destroy")
        }

        get isShow() {
            return this.player.$container.classList.contains("jessibuca-contextmenus-show")
        }

        show() {
            this.player.$container.classList.add("jessibuca-contextmenus-show")
        }

        hide() {
            this.player.$container.classList.remove("jessibuca-contextmenus-show")
        }

        init() {
            const {proxy: e} = this.player["events"];
            0 < this.player._opt.contextmenuBtns.length && this.player._opt.contextmenuBtns.forEach(e => {
                this.addMenuItem(e)
            }), e(this.player.$container, "contextmenu", e => {
                e.preventDefault(), this.show();
                var t = e.clientX, e = e.clientY, {
                    height: i,
                    width: r,
                    left: s,
                    top: a
                } = this.player.$container.getBoundingClientRect(), {
                    height: n,
                    width: o
                } = this.$contextmenus.getBoundingClientRect();
                let l = t - s, d = e - a;
                s + r < t + o && (l = r - o), a + i < e + n && (d = i - n), T(this.$contextmenus, {
                    left: l + "px",
                    top: d + "px"
                })
            }), e(this.player.$container, "click", e => {
                ua(e, this.$contextmenus) || this.hide()
            }), this.player.on(w.blur, () => {
                this.hide()
            })
        }

        _validateMenuItem(e) {
            let t = !0;
            return e.content || (this.player.debug.warn(this.LOG_NAME, "content is required"), t = !1), t
        }

        addMenuItem() {
            let t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            var e = di(at);
            if (t = Object.assign({}, e, t), this._validateMenuItem(t)) {
                const i = this.player["events"]["proxy"], r = Ut(), s = `
            <div class="jessibuca-contextmenu jessibuca-contextmenu-${r}">
                ${t.content}
            </div>
        `, a = Array.from(this.$contextmenus.children)[t.index];
                a ? a.insertAdjacentHTML("beforebegin", s) : ca(this.$contextmenus, s);
                e = this.$contextmenus.querySelector(".jessibuca-contextmenu-" + r);
                t.click && i(e, "click", e => {
                    e.preventDefault(), t.click.call(this.player, this, e), this.hide()
                }), this.menuList.push({uuid: r, $menuItem: e})
            }
        }
    }

    class Ln extends Sn {
        constructor(e) {
            super(e), this.TAG_NAME = "WebrtcForSRSDecoder", this.player.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.player.debug.log(this.TAG_NAME, "destroy")
        }

        loadSource(s) {
            return new Promise((t, i) => {
                const r = this.rtcPeerConnection;
                r.createOffer().then(e => {
                    r.setLocalDescription(e), this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp loadSource"), e = e.sdp, fetch(s, {
                        method: "POST",
                        mode: "cors",
                        cache: "no-cache",
                        credentials: "include",
                        redirect: "follow",
                        referrerPolicy: "no-referrer",
                        headers: {"Content-Type": "application/sdp"},
                        body: e
                    }).then(e => {
                        this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp response and code is " + e.code);
                        if (0 !== e.code) return i(e.msg);
                        r.setRemoteDescription(new RTCSessionDescription({type: "answer", sdp: e})), t()
                    }).catch(e => {
                        this.player.debug.error(this.TAG_NAME, "loadSource getWebRtcRemoteSdp response error", e), i(e)
                    })
                }).catch(e => {
                    this.player.debug.error(this.TAG_NAME, "loadSource rtcPeerConnection.createOffer() error", e), i(e)
                })
            })
        }
    }

    class Dn extends Sn {
        constructor(e) {
            super(e), this.TAG_NAME = "WebrtcForOthersDecoder", this.player.debug.log(this.TAG_NAME, "init")
        }

        destroy() {
            super.destroy(), this.player.debug.log(this.TAG_NAME, "destroy")
        }

        loadSource(s) {
            return new Promise((t, i) => {
                const r = this.rtcPeerConnection;
                r.createOffer().then(e => {
                    r.setLocalDescription(e), this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp loadSource"), e = e.sdp, fetch(s, {
                        method: "POST",
                        mode: "cors",
                        cache: "no-cache",
                        credentials: "include",
                        redirect: "follow",
                        referrerPolicy: "no-referrer",
                        headers: {"Content-Type": "application/sdp"},
                        body: e
                    }).then(e => {
                        this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp response and code is " + e.code), e.text().then(e => {
                            this.player.debug.log(this.TAG_NAME, "getWebRtcRemoteSdp response"), r.setRemoteDescription(new RTCSessionDescription({
                                type: "answer",
                                sdp: e
                            })), t()
                        }).catch(e => {
                            this.player.debug.error(this.TAG_NAME, "loadSource response.text() error", e), i(e)
                        })
                    }).catch(e => {
                        this.player.debug.error(this.TAG_NAME, "loadSource getWebRtcRemoteSdp response error", e), i(e)
                    })
                }).catch(e => {
                    this.player.debug.error(this.TAG_NAME, "loadSource rtcPeerConnection.createOffer() error", e), i(e)
                })
            })
        }
    }

    class In extends e {
        constructor(e) {
            let t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            super(), this._opt = {}, this.$container = e;
            var i, e = ci();
            if (this._opt = Object.assign({}, e, t), this.debug = new ut(this), this._opt.forceNoOffscreen = !0, y() && (this._opt.controlAutoHide = !1), this.isPlayback() && (this._opt.useMSE = !1), this._opt.watermarkConfig = {
                image: {
                    src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAS4AAABgCAYAAACjZZ/rAAAK4mlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU1kagO976SEhkIQISAm9SW8BpIQeivQqKiEJJJQQE4KCDZXBERwVRESwDOCoiIKjIyBjQSxYUWzYB2RQUNbBgg2VfcASZmbP7p7937nvfufPf/9yz705/wOAHMKVSDJhFQCyxDnSyABvZnxCIhP3DOAAA9CBA7Dm8mQSdnh4CEBkev6rvL8LoIn5luWEr3///b8KlS+Q8QCAkhBO4ct4WQi3I2OEJ5HmAIA6jOgNluRIJvg2wnQpkiDCgxOcNsVfJjhlktEqkzbRkT4IGwKAJ3G50jQASDaInpnLS0P8kMIRthHzRWKECxD24Am5fISRuGBOVlb2BA8jbIrYSwAg0xFmpfzJZ9pf/Kco/HO5aQqeqmtS8L4imSSTm/d/bs3/lqxM+XQMY2SQhNLASGRWR/bvXkZ2sILFKfPCplnEn7SfZKE8MGaaeTKfxGnmc32DFWsz54VMc6rIn6Pwk8OJnmaBzC9qmqXZkYpYqVIf9jRzpTNx5RkxCr1QwFH4zxdGx01zrih23jTLMqKCZ2x8FHqpPFKRv0Ac4D0T119Re5bsT/WKOIq1OcLoQEXt3Jn8BWL2jE9ZvCI3vsDXb8YmRmEvyfFWxJJkhivsBZkBCr0sN0qxNgc5nDNrwxV7mM4NCp9m4Av8QAjyMEEMsAPOwBawQAQIzREszZkoxidbkicVpQlzmGzkxgmYHDHPag7TzsbODoCJ+zt1JN5GTt5LiHFqRpe9BznK75E7UzqjSykHoKUICf1gRme4CwBKIQDNHTy5NHdKh554YQARUJB/Bg2gAwyAKbBE8nMCbsALyTgIhIFokAAWAh4QgiwgBUvAcrAaFIESsBlsBVVgN6gD+8EhcAS0gBPgDLgAroAb4A54CHrBAHgJRsB7MAZBEA4iQzRIA9KFjCALyA5iQR6QHxQCRUIJUDKUBokhObQcWguVQGVQFVQD1UM/Q8ehM9AlqBu6D/VBQ9Ab6DOMgkkwHdaGjWFrmAWz4WA4Gl4Ap8GL4Xy4EN4IV8K18EG4GT4DX4HvwL3wS3gUBVBKKAZKD2WJYqF8UGGoRFQqSopaiSpGVaBqUY2oNlQn6haqFzWM+oTGomloJtoS7YYORMegeejF6JXoDegq9H50M/oc+ha6Dz2C/oYhY7QwFhhXDAcTj0nDLMEUYSowezHHMOcxdzADmPdYLJaBNcE6YwOxCdh07DLsBuxObBO2HduN7ceO4nA4DZwFzh0XhuPicnBFuO24g7jTuJu4AdxHvBJeF2+H98cn4sX4NfgK/AH8KfxN/HP8GEGFYERwJYQR+IQ8wibCHkIb4TphgDBGVCWaEN2J0cR04mpiJbGReJ74iPhWSUlJX8lFKUJJpFSgVKl0WOmiUp/SJxKVZE7yISWR5KSNpH2kdtJ90lsymWxM9iInknPIG8n15LPkJ+SPyjRlK2WOMl95lXK1crPyTeVXFALFiMKmLKTkUyooRynXKcMqBBVjFR8VrspKlWqV4yo9KqOqNFVb1TDVLNUNqgdUL6kOUnFUY6oflU8tpNZRz1L7aSiaAc2HxqOtpe2hnacN0LF0EzqHnk4voR+id9FH1KhqDmqxakvVqtVOqvUyUAxjBoeRydjEOMK4y/g8S3sWe5Zg1vpZjbNuzvqgPlvdS12gXqzepH5H/bMGU8NPI0OjVKNF47EmWtNcM0JzieYuzfOaw7Pps91m82YXzz4y+4EWrGWuFam1TKtO66rWqLaOdoC2RHu79lntYR2GjpdOuk65zimdIV2aroeuSLdc97TuC6Yak83MZFYyzzFH9LT0AvXkejV6XXpj+ib6Mfpr9Jv0HxsQDVgGqQblBh0GI4a6hqGGyw0bDB8YEYxYRkKjbUadRh+MTYzjjNcZtxgPmqibcEzyTRpMHpmSTT1NF5vWmt42w5qxzDLMdprdMIfNHc2F5tXm1y1gCycLkcVOi+45mDkuc8Rzauf0WJIs2Za5lg2WfVYMqxCrNVYtVq+sDa0TrUutO62/2TjaZNrssXloS7UNsl1j22b7xs7cjmdXbXfbnmzvb7/KvtX+tYOFg8Bhl8M9R5pjqOM6xw7Hr07OTlKnRqchZ0PnZOcdzj0sOiuctYF10QXj4u2yyuWEyydXJ9cc1yOuf7hZumW4HXAbnGsyVzB3z9x+d313rnuNe68H0yPZ40ePXk89T65nredTLwMvvtder+dsM3Y6+yD7lbeNt9T7mPcHH1efFT7tvijfAN9i3y4/ql+MX5XfE399/zT/Bv+RAMeAZQHtgZjA4MDSwB6ONofHqeeMBDkHrQg6F0wKjgquCn4aYh4iDWkLhUODQreEPppnNE88ryUMhHHCtoQ9DjcJXxz+awQ2IjyiOuJZpG3k8sjOKFrUoqgDUe+jvaM3RT+MMY2Rx3TEUmKTYutjP8T5xpXF9cZbx6+Iv5KgmSBKaE3EJcYm7k0cne83f+v8gSTHpKKkuwtMFixdcGmh5sLMhScXURZxFx1NxiTHJR9I/sIN49ZyR1M4KTtSRng+vG28l3wvfjl/SOAuKBM8T3VPLUsdTHNP25I2JPQUVgiHRT6iKtHr9MD03ekfMsIy9mWMZ8ZlNmXhs5Kzjoup4gzxuWyd7KXZ3RILSZGkd7Hr4q2LR6TB0r0ySLZA1ppDRxqlq3JT+XfyvlyP3Orcj0tilxxdqrpUvPRqnnne+rzn+f75Py1DL+Mt61iut3z18r4V7BU1K6GVKSs7VhmsKlw1UBBQsH81cXXG6mtrbNaUrXm3Nm5tW6F2YUFh/3cB3zUUKRdJi3rWua3b/T36e9H3Xevt129f/62YX3y5xKakouTLBt6Gyz/Y/lD5w/jG1I1dm5w27dqM3SzefLfUs3R/mWpZfln/ltAtzeXM8uLyd1sXbb1U4VCxextxm3xbb2VIZet2w+2bt3+pElbdqfaubtqhtWP9jg87+Ttv7vLa1bhbe3fJ7s8/in68VxNQ01xrXFtRh63LrXu2J3ZP50+sn+r3au4t2ft1n3hf7/7I/efqnevrD2gd2NQAN8gbhg4mHbxxyPdQa6NlY00To6nkMDgsP/zi5+Sf7x4JPtJxlHW08RejX3Ycox0rboaa85pHWoQtva0Jrd3Hg453tLm1HfvV6td9J/ROVJ9UO7npFPFU4anx0/mnR9sl7cNn0s70dyzqeHg2/uztcxHnus4Hn794wf/C2U525+mL7hdPXHK9dPwy63LLFacrzVcdrx675njtWJdTV/N15+utN1xutHXP7T510/PmmVu+ty7c5ty+cmfene67MXfv9ST19N7j3xu8n3n/9YPcB2MPCx5hHhU/Vnlc8UTrSe1vZr819Tr1nuzz7bv6NOrpw35e/8vfZb9/GSh8Rn5W8Vz3ef2g3eCJIf+hGy/mvxh4KXk5Nlz0D9V/7Hhl+uqXP7z+uDoSPzLwWvp6/M2Gtxpv971zeNcxGj765H3W+7EPxR81Pu7/xPrU+Tnu8/OxJV9wXyq/mn1t+xb87dF41vi4hCvlTrYCKGTAqakAvNmH9McJANBuAECcP9VfTwo09U0wSeA/8VQPPilOANT1ABC9DICQawBsr0JaWsQ/BfkuCKcgejcA29srxr9ElmpvN+WL5Im0Jo/Hx9+aAoArBeBr6fj4WN34+Nc6JNmHALTnTfX1E6JyEIAacxtH+5D7VPMC8DeZ6vn/VOPfZzCRgQP4+/xPeFgcU9phDh8AAABsZVhJZk1NACoAAAAIAAQBGgAFAAAAAQAAAD4BGwAFAAAAAQAAAEYBKAADAAAAAQACAACHaQAEAAAAAQAAAE4AAAAAAAAAkAAAAAEAAACQAAAAAQACoAIABAAAAAEAAAEuoAMABAAAAAEAAABgAAAAADApncsAAAAJcEhZcwAAFiUAABYlAUlSJPAAAB1BSURBVHgB7V0HeBTVFj6b3fRCAgSQ3qSKIuoDRESx8OzloaIIiqhYUIEHiIJIU6QpVkRRwMaTp4INBBsoRZQiIFhACL1DQtpusuWdf8IsM7Ozu0nYDQzvnO/bzMyd2+a/N/+ce+65d2w+FhIRBAQBQcBCCMRYqK5SVUFAEBAEFASEuKQjCAKCgOUQEOKyXJNJhQUBQUCIS/qAICAIWA4BIS7LNZlUWBAQBIS4pA8IAoKA5RAQ4rJck0mFBQFBQIhL+oAgIAhYDgEhLss1mVRYEBAEhLikDwgCgoDlEBDislyTSYUFAUFAiEv6gCAgCFgOASEuyzWZVFgQEASEuKQPCAKCgOUQEOKyXJNJhQUBQUCIS/qAICAIWA4BIS7LNZlUWBAQBIS4pA8IAoKA5RAQ4rJck0mFBQFBQIhL+oAgIAhYDgEhLss1mVRYEBAEhLikDwgCgoDlEBDislyTSYUFAUFAiEv6gCAgCFgOASEuyzWZVFgQEASEuKQPCAKCgOUQEOKyXJNJhQUBQcBxqkDgK8gmT+5+Ik8RuTYvJtefC6l430YiO9fQxj+mWHvluhTX4GJKaNKFYhLSKSaRf8nV+L7w76nSjlIPQaAiELD5WCqioGBlFGetJOfGb8nNJFW07RciX3EJUamEpR7BTfgdIzGcO6o1pbja7Siu1gUU37BLsCIkXBAQBE4zBE4qcR2adDV5cnYxVxWUkJKWnFTCUo/ae+r5saMtLoHsabUordMzFFvjvNOsieRxBAFBwIhAhROXz5VPBd+/SfmLppHP42LC8lGMzcOjPS/5mIhsdi+H8bmdL2LwYyUsxkY+W2yJtqXRuBQNjO9rNbHElt0piX+O9DONzyrX/0cIbNuxm5yuImrcoA7Z7Xj7iZxOCFQocRVvX0f5C14h18bvFdtVrLeQSctNNlsx2RwgK4bWwSNXPvrY+uaz8zkfvUxiIC6fL5a8nqQSolIJSz1qCM2eXo/SLhxJcTU7nE5tJc9SCgQKCp3Ub9hztHzlWiV2g7q16OWxQ6le7TN0qQ8dyaZNW7bpwtIrpVGzxg10YXJxaiJQYcTlWruQjr4/mLxF+WRnO1a8O5e1K59CVipBBSMukBgnUjQyctjI40xnEovTE5iGuFRNLLXdcEpqdicnxk1ryr4Dh2jjn3/rKp+YGE/tzjtHFyYXJQhMmjKTZvxnrg6O885pSTNeGqMLm//tEho8apIu7KK2bWjK+Kd0YXJxaiIASoi6OFfNY9J6nMhdSHFuF8V62KYFzapc4iN78mHyulOYBJM5h+CklLvqObaf5VByy/uZ5JjoLCi/rPmNnnhmsq7mdWrWoHmzpujC5KIEgdXreCbaIGs3/MEvOh9r9sH7iiGJXJ7iCGCgFVVxrf2ajr43hMhVQPGF+RTHx0iILSGPbMk5nFUIAmTXivyNb5Nrz5JIFCl5WACB2mdUD6hlzerVhLQCULF2QFSJy5t7iPK/eZt8RYUU73KSw10UHi28FRPSKCa1JtmrNKH4s3tRUscxFN+sO9krNWK/rZqsrSUq+djinGRLyg2Zp68ol7IX9yFPwb6Q8eTm6YHAQ/fcThlsq1IlNtZBg/r2Ui/leJogENWhYt6ciVS8eSVrWYUUW+xSDO6hcLMlVaa49veQo3FnctRtx1FNVHufh1xbPqaiXQvIuX022RLz2XDP1nwnho3B5ch3d1LGJdPInlIveCS5Y3kEYISfM/NFgg3LxbOKl3S4gBrVr2P555IH0CMQNeJy78uiwmUfM2k5FW1L8YDXl627sjfqRAk3jCM7O5WGFCap+Ea3Uly9aym+8W2Us+QORevyFUELC65AevK2k2vvckpqLMQVEt/T4GaVjHS6s+u1p8GTyCMEQyD4f3qwFKUI97F2dWRsV7J5veQoYk/4MGKvfS4l3zc3PGlp8rE5ktjd4UpKa/8G2eIqkS0t21RB8yfxeSl39Qj2HSv0B8mJICAIWBOBqGhczhWfk4+N8Ha3mxzF7pBDxNhzb6aEnm+WG734OjdTWoydcpb3YNsX29A8IWYPeZiZt34SpbYeVu7yrJgwNy+fdu7ZR3v2HqD8wkKqnlmFzqieSbVqVGMf3/K/u5xOF/35dxYdPpJD2UdzKSU5iapkVKKGPDRLT0stF1TRyLNcFTmWyOv10a69+2jrtl38fIlUu2Z1yqxS+ZQ29hcVF9PuPftp74GDtO/AYUpMiKeqVTKobq0zqGrl9HLDgZnZv7N2cL6H6Eh2DhtybFSZ27ta1crKcLwiZ20jTlw+1mzcO34nn7uY7EXukCDFZDaiuC7sJmFmywqZUn8zvtYNlNZ2KuUsGsTEpb9nvCrY9M7/BXGhky395Vea9cmXtGTFasI/oFHQ4bped6Xyy+SOXVpZ+vMaev/jL+nn1evIZaJRx/BKh3NaNqV/XXMFXdflUiZHE1ulobBI5Tn70wU04bXputxv/GdnGtqfXWLKIAcPZ9Pz7BO2cPEyxVamTVqtahXqeet1Cm7JSSUTRdr76vnAERNp8fKV6qVyHDnoIbr68ot1YcaLT7/6nsa8MFUXfPnF7Wjs0H66MOPF739toY++WEhffv0D5RcEjixALGiXa6/sRF2vvaLUKwqwCmHa+5/QDz+tVF5SxnJxDUK8pMM/6L4eXakmvxSjLREnLu/BXeRa841S74RCNsiHWG1hb345xVSPzNIcR/q55Khcm9x7DoXBzEcuNuzH1zp9F2VDw8I/zTImrlCy/+Bhem36f2j6rLk0dthjdFlHTIgEF/wzPDFmMn2/9OfgkfgOSHLN+j+U3wdz5tGLY4ZQjWpVTdNEOk+3x03Q2rQCDaQsMu+bH2j081MpL9/cdWf/wUM08bUZCnm/OWkE1avDM90mgnKNdXF7wrxZOR83j1SM6YpMXhBqkR7OE/V576Mv1CDTI15mv/72h/L7+POv6ZknH6UzGwa3+SL+5Knv0szZnxHKCCUg+o8+X0hffL2YBjxwF91+01Whop/wvfKPE4IU7XPmk+fwbnavCnzDG5PEXTvUGFTua0dqM3LUaFmq9M6d80oVz4qRdu87QN0ffDwsaWmfrdDppP5PjVcITBuuPcc/0oODR4UlLW0anMPrv9djwwgd2yjRyNNYRlmvUd+nnnslKGlp89vDWPfo+wRt3rpdG1yh52i7ewc8HZa0jJX6fdMWuvvRYbRl207jLf/10GdfordnzQlLWv4EfII2fXbyGzRn3rfa4IifR5y4irPWK5W0u0MztK1SDbIlpET0gRJq3liq/HxerhsPaU83gaYzZPTztHX7roBHgy0Lw4TrrrzEVJVX3q5vvENmnufIDENDaFFGObdVM+rT8xYa9XhfuvWGLooNyBhn5+59/OZ+xxgclTwDCilDAJZXDXh6Amk1NIfDTkmJCUFzOZJ9lIaPe0XxzA8aKYo3oGmt/HWDaQkYsrVt04qan9nQ9BmO5ubRg4NGBWh3yOyr75bQ5wsXmeabkZ5Gl/KwsGO786iWicMvEo1hjRW2z2hJxIeKzqVzlLrGeEITQ8Jdr0f8meKqdipVnl7nAfK6DvFmhNEfi5eqQhGK9P7HX5iSC1T3rtddQakpx33dtu3cw8O+F2j975v8pYP4ho19mT6ZPpkS2KCrlZkffqq9VM773d+Dene/2R9+09WXKeewVz02dKzO/oV/gn59euqMw9HI01+ZcpxoF11f0am9Yq9p2qi+MoFx4NAR+viLr9nW83GAzQsYQsO4+ZrLy1Fq+ZMAZ9j0jAIj/MjBD9P5rY+PQGCLfO+/n9Or02dRMU+YqQINfdac+dTrdv1Lf8qMD9Uo/iPyGzHwId3QGC+8+Uxyw8a+pMsX5D/7swX0wF23+tNH8iTiGlfR5jVK/Xj1dsh62ng300iLLfa4x3SovD1528hbwMPZ00jcrOFOfWd2wBPdc/tNSqfUkhYiwVHzpWefVGYXtYl27N5L3/64QhtEsIUdyTmqC8Nb9+5uN+jC1IsO/ziXut10tXqpHEGK6zb86Q+LRp7+zE/wpHPHtvT8qMGKpqLOumLyAv+ETw14wDR3aKQVLW+xwdwo8XGxSt21pIU4CMdL5ul/P2hMEjDMhA3POITETPSkEYN0pIWMYPC/+rKOdH+PWwLyXbP+94CwSAVEXOMiNo7C2dQTbg8kdmE4WQJty+M6gh1zThv5iWf4co7m6Z4HuyL069NDF6a9wEzQ+OEDqMfDT2iDlWHCNVccn/mCsd8oCfHxIWelHul9R4ATaFrqcdNANPI01rE81yD0Z554NGjSG/55KWu1vyvalzbSX+wWsnf/waCTENq4kTiHzXDVug0BWQ3u25uaNq4fEK4G3HBVZ8KEiXbHERDVLnaXUYd9aSkpitatpsERbg/4BRO8rF59e5bu9q69+3XXkbyI2v+u1xFGmeMF0CKRQ2DBd0sDMmt//jlh/Y3ObsHrQfltrHVrWPrLGmU4FB9f4hPXoG5tZZipJRsYpqfOnE19ggwFkDbYTCIqGo08AwAoR0D/B3oq/mihkg55pDfNnf9dgNH6x59W0S3XV8xs9XesFUOL1QrWaMLOGE7688sMu45oRTt8hJkg1GyjNp16Dtcao+Tlmc/KGuOV5zpqxOUL49joO/A3UbVG5amzpDFBQGufUW9XYY0KQ7JwUomdRbXx0In38VsYthII/LBghP9h+SpdVq/wG/YLdh3AUAFvXBiBsai5NBKNPEtTbrg4zZuE75P4x67PLhBwxtQK7IYVJVk7Aidg4PhbGsFebpHaz83Lq2NymaCgsVWklK6XlaFGtvgEdj51Kim8TF687Z9p6sKZD1PK+OOGYdNIUQq0J9XkLwRVj1LuJydbGI+NMnLCa8agUl8f5PxU4kKi3nfczG/pDYTpd61k8QwmfMHwi4uNpeZNGlLrs5oRtL3zW5+laHPa+NrzaOSpzb+s5/D8L63zZOMGdQOICzOMFSUHDwe2d+NSEldZ64jZ1kXLfqE/N2cpBIVrkFVePm/DzjvOngyJOHHFt76MnCtLDJXO5ARKLAi0jygPmn+IvHk8s5dSpcKf255Sl0Bep4tgyICtiCMpRr+rNme3oNcnPMW+XKODdlbMJK1lAzx+mDGEVzlm2u7t/i9T+0g08jwRDJqEcMY05ouh1ILv9cPzwxFuA2OZ2muzF1Wkd8GAFj/+len006q12qJPifMwhqiy1zGxY1d/IuwVD60rmLhm3hfsVlTDbXEZvCFqcENjVAuPSua8rXWE/dLMPLxBNLOmTqDu/7pGt+dVsEeCV/y7PAUP4z+m3c0kGnmalVOaMFuIvmpMb7YuT29xMqaI7HWMybdEuRdErBD4cXXtPeCUJC08ZMQ1rpi0qn7wPA4HudlIG1tsrk569/5F3m0rKabe+f40FXFi1ukqotxolYEp+8rplQK808fxjKF2U72ylB/MONuwXm0a8ui9NPChXgRjNNbiQcPasm1HgLFYLW/7rj10V98n6d1Xx5oa7KORp1p2WY5mdsJg6Tdv3RZwC21QUWK2WNpocytvXTb8uVnZLhz2K63AGfcCHv5Ds8N6zdTUZEpj30C42hTw4v1+w8Zpo0f1POLEZUvJ4E0AW/BC641KxV1syAxGXL4c/oTU7AGUNHARO4QE18zCIVC46UNKPPO2cNFO+n34WsFhTyvhjNlGmxLSqrN92nyqVs4IIC6QFmxN0RB04ksv+ofyQ/5Y17du419swF9J8775McDvC64CXy9eTj1uuS5odaKRZ9DCTG7AkxyuAfinDCebtmwPiBLKXUCNXGhYR6mGa4+wL4YT7PZglL+zdhqDynX9xrsf8XpJvW0as88TRwwM8PtTC4DdqyKl/GwRpJb2jOq8zXJ7/13MLuamp8NTzR+mPfHs/o2ODqrC2zuXferUx9vU5K8ZzYurW2mzLMW5eV1KkfCEolx9x4PU5vJbdD/1M1rBMsZyGaOY7eRQnz/DZRSsR6sogWH7wgtaK9rYlx+8xt8zDHQwXrW25GVW2jpFI89wZf+xKStcFMV1xGxWTzuZgUxiecRhFLiRhJOsneGdo/HZNaNsMcxyGu+r1/DhwioA7U9br+W/BNq04O+HrZCCSUWv14w4ceHB4pq3I1usZn0Xk1ZBcjJvsRy8uIIpXaj41w+D4RIQ7snfRQVrx1LeL7wdcxmX7sSwjetkSKvmZwYUiy1nQskqk6/WmPnMYImKUcw6oDEOrjGVjc6MIcJvf2xWlgFp/XqghYBAtT/tej5jnhg6GJeQIM4fm7f6o0YjT3/mJ3DyAq+pNNNytVlOfHV6gEaC+x3btdFGU/Ym0wXwBfANJfCVW/JT6D6B9J0vaqssRdLmhdUNHzEhhRI822P83ckRPOOs/akjAcyMGp8fLxDVOTVY3kZXmWDxIhUe+EqIQM5xZ3WimPRM8hw67uficcRSoT2VkgpzTEvw7PmNCub2I8eqt3nf+YcotsX1HC9QM/J53VS4bhK5smZT0W72UcL3Fcso3uLcMqaITHQscl64aJkus8947yWs8TPTUDC0gv3IKDBoG+ViXvCamJCg63SYDXp52vv0yL3djdH91/A9uvXeAbqZQnTSeR9M8ceZ8OoMxZveH8AnqDMWVgcTh4m2gWUjqkQjTzXvEzlCcxgx/jWCfdBM5n37I/1n7vyAW/BWN2okZkPOFavWKS8Gs5cYMkV7YVPGcIJh6QW8dnDF6vW6qM+9NI1acz8z60+I+PqM2YqHvzYRXEBq8qaSELMF5TADYCiobT9tetgG5zMuFSnBVaATqQVrWFXGLOQPWRxf4oHsvLwMKD8lnWca7ea5sxHfvX0FFXx0F2U/m0HZL9Sm/C96UQFvEJg793o6PK0m/ypTwc/jqWgH2wE85eRd/iDtyZDzeQmOUdBJ7+3/NH224HtF84FrA4zZr7NXuvGDpUgLL/crL7nQmI2yKNpsn3XYK/CBVLO9pRYvW0n38ZYoRl+cbjf+U3E6VQvBDgNGwaJi7FtlJujkM3iPL6PATqJKNPJU8z7RI8gJ37KEsVvVRNBO2OIFpGYmd9x8TUBw+wvM7YsPsUsJXmCq1oo2x44ejzzxrLLgOSCjIAH3sG+dUfCBkP7Dx+sWzyMO9tPC0PCd/35mTEK333x8XSnsp2YE9eQzL5rODGPPt5488WJcyxpQSIQDovol6/yveDO2TyeWfMMCFIkflCibj2J9Lr4sIrutmDcbZIM1c1C4L1l7KY47Ujx/DDaR8+KMjuWZefcy/mxZyfh73zQejqllqeWBJ1HusfCEuldTpbYvckDFC9RzdKBgYmdyD7VpG1wRMKtnJhjedesziLBuziiYeWzBzqFnt2hKBw4dpr/4LYmdLY2CGb73p4zTLXvBP8P1PfqadlzEx0zTua2a01Ee5sDOgs3kjEQJb/P5s1737w4RjTzxLB/wjq9jX5ymeyz4kmG3BK2YfckadsI8fgatDxv+kRP4Z1wHqs0L2hMwM5utvur2B5Qhtja+eo42qVkjkw4dztFpylgvafTCx8tq0shBalL/ceTEKcoGfv4AzQnapk6tGtwWhUyMO023mYGW+Pl7r+ochaH14YVnJphRbNvmbEUDw6aEqv8gNDXjCxAfLVk0d7pZNiccVk6VpXTlJl12FxX9vZKKNi7SJ2CNrNjONjBbPE8m8pepyUUOG4zz+hk3JPL52Pe+OJGN9/yDjQxGfhCQRpxbF1DSWXcqITZHPG+15dLcPbVOBz3ci31j1gVdIhGKtJo0qk/9eYuaYIIZShhR+wwcqXQsbTxMbcO+EsrGgjft1IlP60gLeeCfd9SQR+jhIWMCtnTBLgL4ffjpV9ridOf4B8WWxdop/GjkqSu0HBf4mOw9d9ykaMCqKwAIFr9ggplbDJnNSAtphva7X3HaNUuPMoyTLxfx0qnL2F5Z2lUP6E94Waw22YlBbRuzshEGW+Rr44bpSAvhPW69XlnepbVJIhwCLdTodoF8Xhj9OOM2vCRSBfw1UEBkS4SBPr33CxRbu3mQjG1MVTHkjkkkZ0wV/lUlJ2WS05tJLk8mq9LVeI+fTNawUpjAVLUpMKvcJaPBcMqNytfPCYxgCPHk7yRvYeBsnSFaVC7hTY6tjEOt4DcrGPaxV58bGtDJjHHxRvzwzYnUhjWgsgjWrr31wihTPyvkg6Hd1AnDlQ8jlCVf2GKeHzXIdJ/1aORZlrqZxYX2CI02nJsK0oLoZ77ybFB7EuJc1LYN9eWdMoIRG+KoglnJ0bwzBQYHpRVoOm9NHl2qxdXaPNFP0N5mtjB86GTGy89Q2/PO1iYxPUf5aF+s3axIsY9giWaBNkccxbfqTO79W8hzMKtkyIaWCfcDpSKOegwZn7W2lBoUm9mS1yBWJnf2ZvLk8OyNmsaQh6/oIMVV73DSPg4LzQMfqUjntzXUbdXWwU8bIDCcwpaBoY52W5iAiJoAdKbru1xC0NDgm7SLv/hiJvCbAiGOYW3qwV63cX1SzaL5w2DA7XbjVcpSHgynDmebT7QgAYYp3XjfcWiAzRo38OdhPIl0ntjUzzhTi/WT2LFTKzDCY/JDK3V5iHbtFZ0IQ7+reOH4Tt6bDPuTGVzveLYwnfef6kpjmGTM7EHaPHEO22bLpo2V/Mz8nbDGEx+ZGDf834pDJz56gbWBWgHRdLm0gzbIfw6NtlP78xV3FGhxWWwCCKa544V592030Ghu8+rVjk+W+DM7doI6XdW5IzlZ29zOEzhOl34Ug76DPjyZX8JNGtZXPs7xDu9NrxX0w7u73agNith5VG1c2lrCT+vIy3dS8Q6eBQGRqGSinmuPIBxVwVKP6n3cU881x7ha7Sjj2rf5XizPNi6hnMX9yFvM/1javNT4HJbSaiAlN+2jreJJOcce3TDMlqj1O9gB8oiyrg++Wi2aNqJzecFyad7WoSoPOwSGJHACzWYjM8gQH3jA58lgUyuvYEcJzChl5+QqBJnMn++C9zhIS52lKmve0cizrHXQxsd2P7APwR4It4DaNWsouOEftzyCfLbyzg77+bNhldJSFKzQFiCKSAlsTdvYFwztDTwT4uKUz5PVq13TdGvtcOWCBGETRZ29vLSsfp1aVIdxKC8G4corzf0KIy61MtnT+1LRX0vJV5x3XKNSCUU9asmmlMQFgko6525KbT9UKSp/w9uU9+vzPJXJb4ogeWRes5xi4o8vUVLrKEdBQBA4tRGocOLyuYuoOGsN5cz6N3mPsp1JJSvtsZzEFZOUQZk9f/Yj7tr5PeWtnUzunI16kkT+XF5c9Qspo8NMf3w5EQQEAWsgUOHEpYXFufozyp03lrzObDauu4+TWFmIi4c6MUmVKK5+Z6rUaTQTVOBEac6ygeTau5iLYMc+G6/BOkZccKlIOrMXpbYYzGHlU/21zyPngoAgUDEInFTiUh6RPxVWsGIWf4sxi4p3r6finatLiEUd3qlHVSM7Rjr2Kg0pvkEnsqeeQYln3c58pVliZIKdj73lC7d+wiS5l5z8QVhP4Q6FKG3xaZTS7BFKanC3SSoJEgQEgVMRgZNPXCoqbPTz5rPxL++gEuIpOMhLhrbwcHKXsqNqTEZtcmQ24ZnAkp1LbfGpZE/DFCyYrGwCdwifO4/c/LWfgi1v8Ycz9lHm5YvLlonEFgQEgZOGwKlDXCcNAilYEBAErIYABmAigoAgIAhYCgEhLks1l1RWEBAEgIAQl/QDQUAQsBwCQlyWazKpsCAgCAhxSR8QBAQByyEgxGW5JpMKCwKCgBCX9AFBQBCwHAJCXJZrMqmwICAICHFJHxAEBAHLISDEZbkmkwoLAoKAEJf0AUFAELAcAkJclmsyqbAgIAgIcUkfEAQEAcshIMRluSaTCgsCgoAQl/QBQUAQsBwCQlyWazKpsCAgCAhxSR8QBAQByyEgxGW5JpMKCwKCgBCX9AFBQBCwHAJCXJZrMqmwICAICHFJHxAEBAHLISDEZbkmkwoLAoKAEJf0AUFAELAcAkJclmsyqbAgIAgIcUkfEAQEAcshIMRluSaTCgsCgsD/AFt/MVAlcetCAAAAAElFTkSuQmCC",
                    width: 75,
                    height: 24
                }, opacity: .1, right: 10, top: 10
            }, this._opt.forceNoOffscreen || ("undefined" == typeof OffscreenCanvas ? (this._opt.forceNoOffscreen = !0, this._opt.useOffscreen = !1) : this._opt.useOffscreen = !0), this._opt.isMpeg4 && (this._opt.useWCS = !1, this._opt.useMSE = !1, this._opt.isNakedFlow = !1, this._opt.useSIMD = !1, this._opt.isFmp4 = !1), (this.isOldHls() || this.isWebrtcH264()) && (this._opt.useWCS = !1, this._opt.useMSE = !1, this._opt.isNakedFlow = !1), this._opt.isNakedFlow, !this.isOldHls() && !this.isWebrtcH264()) {
                if (this._opt.useWCS) {
                    const e = "VideoEncoder" in window, t = Nt();
                    this._opt.useWCS = e, this._opt.useWCS && this._opt.isH265 && (this._opt.useWCS = t), this._opt.useWCS || this.debug.warn("Player", `
                    useWCS is true,
                    and supportWCS is ${e}, supportHevcWCS is ${t} , _opt.isH265 is ${this._opt.isH265}
                     so set useWCS false`), this._opt.useWCS && (this._opt.useOffscreen ? this._opt.wcsUseVideoRender = !1 : this._opt.wcsUseVideoRender && (this._opt.wcsUseVideoRender = jt() && zt(), this._opt.wcsUseVideoRender || this.debug.warn("Player", "wcsUseVideoRender is true, but not support so set wcsUseVideoRender false")))
                }
                if (this._opt.useMSE) {
                    const e = function () {
                        let e = !1;
                        return e = "MediaSource" in window && window.MediaSource.isTypeSupported(Ie) ? !0 : e
                    }(), t = Ot();
                    this._opt.useMSE = e, this._opt.useMSE && this._opt.isH265 && (this._opt.useMSE = t), this._opt.useMSE || this.debug.warn("Player", `
                    useMSE is true,
                    and supportMSE is ${e}, supportHevcMSE is ${t} , _opt.isH265 is ${this._opt.isH265}
                     so set useMSE false`)
                }
            }
            if (this._opt.useMSE ? (this._opt.useWCS && this.debug.warn("Player", "useMSE is true and useWCS is true then useWCS set true->false"), this._opt.forceNoOffscreen || this.debug.warn("Player", "useMSE is true and forceNoOffscreen is false then forceNoOffscreen set false->true"), this._opt.useWCS = !1, this._opt.forceNoOffscreen = !0) : this._opt.useWCS, this._opt.isWebrtc && this._opt.demuxUseWorker && (this.debug.warn("Player", "isWebrtc is true and demuxUseWorker is true then demuxUseWorker set true->false"), this._opt.demuxUseWorker = !1), this._opt.isHls && this._opt.demuxUseWorker && (this.debug.warn("Player", "isHls is true and demuxUseWorker is true then demuxUseWorker set true->false"), this._opt.demuxUseWorker = !1), this.isStreamWebTransport() && this._opt.demuxUseWorker && (this.debug.warn("Player", "is stream use webTransport is true and demuxUseWorker is true then demuxUseWorker set true->false"), this._opt.demuxUseWorker = !1), this._opt.useSIMD || -1 !== this._opt.decoder.indexOf("-simd")) {
                const e = WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11])),
                    t = /iphone/i.test(navigator.userAgent);
                this._opt.useSIMD = e && C(t), this._opt.useSIMD || this.debug.warn("Player", `useSIMD is true, but not support（isSupportSimd is ${e} ,isIphone is ${t}） so set useSIMD false`)
            }
            this._opt.useSIMD ? -1 === this._opt.decoder.indexOf("-simd") && (this._opt.decoder = this._opt.decoder.replace("decoder-pro", "decoder-pro-simd")) : -1 !== this._opt.decoder.indexOf("-simd") && (this._opt.decoder = this._opt.decoder.replace("decoder-pro-simd", "decoder-pro")), -1 !== this._opt.decoder.indexOf("-simd") ? this._opt.decoderAudio = this._opt.decoder.replace("decoder-pro-simd", "decoder-pro-audio") : this._opt.decoderAudio = this._opt.decoder.replace("decoder-pro", "decoder-pro-audio"), -1 !== this._opt.decoder.indexOf("-simd") ? this._opt.decoderHard = this._opt.decoder.replace("decoder-pro-simd", "decoder-pro-hard") : this._opt.decoderHard = this._opt.decoder.replace("decoder-pro", "decoder-pro-hard"), C(this._opt.hasAudio) && (this._opt.operateBtns.audio = !1), C(this._opt.hasVideo) && (this._opt.operateBtns.fullscreen = !1, this._opt.operateBtns.screenshot = !1, this._opt.operateBtns.record = !1, this._opt.operateBtns.ptz = !1, this._opt.operateBtns.quality = !1, this._opt.operateBtns.zoom = !1), this._opt.qualityConfig && 0 === this._opt.qualityConfig.length && this._opt.operateBtns.quality && (this._opt.operateBtns.quality = !1, this.debug.warn("Player", "_opt.qualityConfig is empty, so set operateBtns.quality false")), k(this._opt.useWebGPU) && (this._opt.useWebGPU = function () {
                let e = !1;
                return e = "gpu" in navigator ? !0 : e
            }(), C(this._opt.useWebGPU) && this.debug.warn("Player", "useWebGPU is true, but not support so set useWebGPU false")), this._opt.hasControl = this._hasControl(), this._loading = !1, this._playing = !1, this._playbackPause = !1, this._hasLoaded = !1, this._zooming = !1, this._destroyed = !1, this._checkHeartTimeout = null, this._checkLoadingTimeout = null, this._checkStatsInterval = null, this._checkVisibleHiddenTimeout = null, this._startBpsTime = null, this._isPlayingBeforePageHidden = !1, this._stats = {
                buf: 0,
                netBuf: 0,
                fps: 0,
                maxFps: 0,
                dfps: 0,
                abps: 0,
                vbps: 0,
                ts: 0,
                mseTs: 0,
                pTs: 0,
                dts: 0
            }, this._allStatsData = {}, this._faceDetectActive = !1, this._objectDetectActive = !1, this._times = {
                playInitStart: "",
                playStart: "",
                streamStart: "",
                streamResponse: "",
                demuxStart: "",
                decodeStart: "",
                videoStart: "",
                playTimestamp: "",
                streamTimestamp: "",
                streamResponseTimestamp: "",
                demuxTimestamp: "",
                decodeTimestamp: "",
                videoTimestamp: "",
                allTimestamp: ""
            }, this._videoTimestamp = 0, this._audioTimestamp = 0, this._videoIframeIntervalTs = 0, this._streamQuality = this._opt.defaultStreamQuality || "", this._visibility = !0, this._lastestVisibilityChangeTimestamp = null, this._tempWorkerStats = null, this._historyFpsList = [], this._tempStreamList = [], this._tempInnerPlayBgobj = null, this._flvMetaData = null, C(this._opt.useMSE) && C(this._opt.useWCS) && !this.isWebrtcH264() && !this.isOldHls() && (this._opt.useWasm = !0), (this.isOldHls() || this.isWebrtcH264()) && (this._opt.hasVideo = !0, this._opt.hasAudio = !0), this._opt.hasVideo || (this._opt.useMSE = !1, this._opt.useWCS = !1), this._opt.useWasm && (this._opt.useOffscreen ? this._opt.wasmUseVideoRender = !1 : this._opt.wasmUseVideoRender && (this._opt.wasmUseVideoRender = Pt() && jt() && zt(), this._opt.wasmUseVideoRender || this.debug.warn("Player", "use wasm video render, but not support so set wasmUseVideoRender false")), this._opt.useSIMD ? this.debug.log("Player", "use simd wasm") : this.debug.log("Player", "use wasm")), this._opt.useWasm && (this._opt.useFaceDetector && window.JessibucaProFaceDetector || this._opt.useObjectDetector && window.JessibucaProObjectDetector) ? (this.ai = new xn(this), this._opt.useFaceDetector && window.JessibucaProFaceDetector || (this._opt.operateBtns.aiFace = !1), this._opt.useObjectDetector && window.JessibucaProObjectDetector || (this._opt.operateBtns.aiObject = !1)) : (this._opt.operateBtns.aiObject = !1, this._opt.operateBtns.aiFace = !1), !this._opt.useFaceDetector || this._opt.useWasm && window.JessibucaProFaceDetector || this.debug.warn("Player", `use face detector, useWasm is ${this._opt.useWasm} and window.JessibucaProFaceDetector is ` + !!window.JessibucaProFaceDetector), !this._opt.useObjectDetector || this._opt.useWasm && window.JessibucaProObjectDetector || this.debug.warn("Player", `use object detector, useWasm is ${this._opt.useWasm} and window.JessibucaProObjectDetector is ` + !!window.JessibucaProObjectDetector), this._opt.useVideoRender && (this._opt.useWasm && !this._opt.useOffscreen ? (this._opt.wasmUseVideoRender = Pt() && jt() && zt(), this._opt.wasmUseVideoRender || this.debug.warn("Player", "use wasm video render, but not support so set wasmUseVideoRender false")) : this._opt.useWCS && !this._opt.useOffscreen && (this._opt.wcsUseVideoRender = jt() && zt(), this._opt.wcsUseVideoRender || this.debug.warn("Player", "use wcs video render, but not support so set wcsUseVideoRender false"))), this._opt.useCanvasRender && (this._opt.useMSE && (this._opt.mseUseCanvasRender = !0), this._opt.useWasm && (this._opt.wasmUseVideoRender = !1), this._opt.useWCS && (this._opt.wcsUseVideoRender = !1), this.isOldHls() && !It() && (this._opt.hlsUseCanvasRender = !0)), this._opt.useVideoRender = !1, this._opt.useCanvasRender = !1, this._opt.useWasm ? this._opt.wasmUseVideoRender ? this._opt.useVideoRender = !0 : this._opt.useCanvasRender = !0 : this._opt.useWCS ? this._opt.wcsUseVideoRender ? this._opt.useVideoRender = !0 : this._opt.useCanvasRender = !0 : this._opt.useMSE ? this._opt.mseUseCanvasRender ? this._opt.useCanvasRender = !0 : this._opt.useVideoRender = !0 : this.isOldHls() ? this._opt.hlsUseCanvasRender ? this._opt.useCanvasRender = !0 : this._opt.useVideoRender = !0 : this.isWebrtcH264() && (this._opt.useVideoRender = !0), i = this, Object.defineProperty(i, "rect", {
                get: () => {
                    const e = i.$container.getBoundingClientRect();
                    return e.width = Math.max(e.width, i.$container.clientWidth), e.height = Math.max(e.height, i.$container.clientHeight), e
                }
            }), ["bottom", "height", "left", "right", "top", "width"].forEach(e => {
                Object.defineProperty(i, e, {get: () => i.rect[e]})
            }), this.events = new gi(this), this._opt.hasVideo && (this.video = new Mi(this), this.recorder = new Lr(this)), this.isOldHls() ? (this.hlsDecoder = new va(this), this.loaded = !0) : this.isWebrtcH264() ? (this._opt.isWebrtcForZLM ? this.webrtc = new En(this) : this._opt.isWebrtcForSRS ? this.webrtc = new Ln(this) : this._opt.isWebrtcForOthers ? this.webrtc = new Dn(this) : this.webrtc = new wn(this), this.loaded = !0) : (this.isUseHls265() && (this.hlsDecoder = new _n(this)), this.isWebrtcH265() && (this.webrtc = new wn(this)), ri(this._opt) ? this.loaded = !0 : this.decoderWorker = new Br(this)), this._opt.hasAudio && (this.audio = new er(this)), this.stream = null, this.demux = null, this._lastVolume = null, this._isInZoom = !1, this._playingStartTimestamp = null, this._opt.useWCS && (this.webcodecsDecoder = new sa(this), !this._opt.hasAudio && C(this._opt.demuxUseWorker) && (this.loaded = !0)), this._opt.useMSE && (this.mseDecoder = new ya(this), !this._opt.hasAudio && C(this._opt.demuxUseWorker) && (this.loaded = !0)), this.control = new ga(this), 0 < this._opt.contextmenuBtns.length && xt() && (this.contextmenu = new Cn(this)), this.isPlayback() && (this.playback = new Tn(this, this._opt.playbackConfig)), this._opt.operateBtns.zoom && (this.zoom = new kn(this)), /(iphone|ipad|ipod|ios|android)/i.test(window.navigator.userAgent.toLowerCase()) && C(this._opt.supportLockScreenPlayAudio && Dt()) && (this.keepScreenOn = new ba(this));
            var r = this;
            try {
                const a = e => {
                    ei(e) === r.$container && (r.emit(fe.fullscreen, r.fullscreen), r.fullscreen && !r._opt.useMSE || r.resize())
                };
                g.on("change", a), r.events.destroys.push(() => {
                    g.off("change", a)
                })
            } catch (r) {
            }
            if (r.on(w.decoderWorkerInit, () => {
                r.debug.log("player", "listen decoderWorkerInit and set loaded true"), r.loaded = !0
            }), r.on(w.play, () => {
                r.loading = !1
            }), r.on(w.fullscreen, e => {
                if (e) try {
                    g.request(r.$container).then(() => {
                    }).catch(e => {
                        r.debug.error("player", "fullscreen request error", e), y() && r._opt.useWebFullScreen && (r.webFullscreen = !0)
                    })
                } catch (e) {
                    y() && r._opt.useWebFullScreen && (r.webFullscreen = !0)
                } else try {
                    g.exit().then(() => {
                        r.webFullscreen && (r.webFullscreen = !1)
                    }).catch(e => {
                        r.debug.error("player", "fullscreen exit error", e), r.webFullscreen && (r.webFullscreen = !1)
                    })
                } catch (e) {
                    r.webFullscreen && (r.webFullscreen = !1)
                }
            }), y() && r.on(w.webFullscreen, e => {
                e ? r.$container.classList.add("jessibuca-fullscreen-web") : r.$container.classList.remove("jessibuca-fullscreen-web"), r.emit(fe.fullscreen, r.fullscreen)
            }), r.on(w.resize, () => {
                r.video && r.video.resize()
            }), r._opt.debug) {
                const n = [w.timeUpdate], o = [w.stats, w.playbackStats, w.playbackTimestamp, w.flvMetaData];
                Object.keys(w).forEach(t => {
                    r.on(w[t], e => {
                        n.includes(t) || (o.includes(t) && (e = JSON.stringify(e)), r.debug.log("player events", w[t], e))
                    })
                }), Object.keys(S).forEach(t => {
                    r.on(S[t], e => {
                        r.debug.warn("player event error", S[t], e)
                    })
                })
            }
            {
                var s = this;
                const {_opt: l, debug: d, events: {proxy: h}} = s;
                if (l.supportDblclickFullscreen && h(s.$container, "dblclick", e => {
                    e = ei(e).nodeName.toLowerCase();
                    "canvas" !== e && "video" !== e || (s.fullscreen = !s.fullscreen)
                }), h(document, "visibilitychange", () => {
                    s.visibility = "visible" === document.visibilityState, d.log("visibilitychange", document.visibilityState), l.hiddenAutoPause && (d.log("visibilitychange", "hiddenAutoPause is true ", document.visibilityState, s._isPlayingBeforePageHidden), "visible" === document.visibilityState ? s._isPlayingBeforePageHidden && s.play() : (s._isPlayingBeforePageHidden = s.playing, s.playing && s.pause()))
                }), xt() && h(document, ["click", "contextmenu"], e => {
                    ua(e, s.$container) ? (s.isInput = "INPUT" === e.target.tagName, s.isFocus = !0, s.emit(w.focus)) : (s.isInput = !1, s.isFocus = !1, s.emit(w.blur))
                }), l.autoResize) {
                    const l = Ft(() => {
                        s.resize()
                    }, 500);
                    h(window, ["resize", "orientationchange"], () => {
                        l()
                    }), screen && screen.orientation && screen.orientation.onchange && h(screen.orientation, "change", () => {
                        l()
                    })
                }
            }
            this.singleWatermark = new Bi(this), this._opt.watermarkConfig && this.updateWatermark(this._opt.watermarkConfig), this._opt.useWCS && this.debug.log("Player", "use WCS"), this._opt.useMSE && this.debug.log("Player", "use MSE"), this._opt.useOffscreen && this.debug.log("Player", "use offscreen"), this._opt.isHls && (this._opt.supportHls265 ? this.debug.log("Player", "use hls 265") : this.debug.log("Player", "use hls")), this._opt.isWebrtc && (this._opt.isWebrtcH265 ? this.debug.log("Player", "use webrtc h265") : this._opt.isWebrtcForZLM ? this.debug.log("Player", "use webrtc for ZLM") : this._opt.isWebrtcForSRS ? this.debug.log("Player", "use webrtc for SRS") : this._opt.isWebrtcForOthers ? this.debug.log("Player", "use webrtc for Others") : this.debug.log("Player", "use webrtc for M7S")), this._opt.isFmp4 && this.debug.log("Player", "use fmp4"), this._opt.isMpeg4 && this.debug.log("Player", "use mpeg4"), this.isPlayback() && this.debug.log("Player", "use playback"), this._opt.hasVideo && (0 === this.width && this.debug.warn("Player", "container width is 0, please check the container width"), 0 === this.height && this.debug.warn("Player", "container height is 0, please check the container height")), this.debug.log("Player options", JSON.stringify(this._opt))
        }

        async destroy() {
            this._destroyed = !0, this.emit("destroy"), this.off(), this.events && (this.events.destroy(), this.events = null), this.clearCheckHeartTimeout(), this.clearCheckLoadingTimeout(), this.clearStatsInterval(), this.clearVisibilityHiddenTimeout(), this.decoderWorker && (await this.decoderWorker.destroy(), this.decoderWorker = null), await this._destroy()
        }

        async _destroy() {
            this._loading = !1, this._playing = !1, this._playbackPause = !1, this._hasLoaded = !1, this._lastVolume = null, this._zooming = !1, this._faceDetectActive = !1, this._objectDetectActive = !1, this._times = {
                playInitStart: "",
                playStart: "",
                streamStart: "",
                streamResponse: "",
                demuxStart: "",
                decodeStart: "",
                videoStart: "",
                playTimestamp: "",
                streamTimestamp: "",
                streamResponseTimestamp: "",
                demuxTimestamp: "",
                decodeTimestamp: "",
                videoTimestamp: "",
                allTimestamp: ""
            }, this.singleWatermark && (this.singleWatermark.destroy(), this.singleWatermark = null), this.stream && (this.stream.destroy(), this.stream = null), this.hlsDecoder && (await this.hlsDecoder.destroy(), this.hlsDecoder = null), this.mseDecoder && (this.mseDecoder.destroy(), this.mseDecoder = null), this.webrtc && (this.webrtc.destroy(), this.webrtc = null), this.video && (this.video.destroy(), this.video = null), this.audio && (this.audio.destroy(), this.audio = null), this.recorder && (this.recorder.destroy(), this.recorder = null), this.control && (this.control.destroy(), this.control = null), this.webcodecsDecoder && (this.webcodecsDecoder.destroy(), this.webcodecsDecoder = null), this.demux && (this.demux.destroy(), this.demux = null), this.playback && (this.playback.destroy(), this.playback = null), this.zoom && (this.zoom.destroy(), this.zoom = null), this.ai && (this.ai.destroy(), this.ai = null), this.keepScreenOn && (this.releaseWakeLock(), this.keepScreenOn.destroy(), this.keepScreenOn = null), this.resetStats(), this._audioTimestamp = 0, this._videoTimestamp = 0, this._streamQuality = "", this._visibility = !0, this._isInZoom = !1, this._playingStartTimestamp = null, this._lastestVisibilityChangeTimestamp = null, this._videoIframeIntervalTs = null, this._tempWorkerStats = null, this._tempStreamList = [], this._tempInnerPlayBgobj = {}, this._flvMetaData = null, this.debug.log("play", "destroy end"), this._opt = ci(), this.$container = null
        }

        set fullscreen(e) {
            y() && this._opt.useWebFullScreen ? (this.emit(w.webFullscreen, e), setTimeout(() => {
                this.updateOption({rotate: e ? 270 : 0}), this.resize()
            }, 10)) : this.emit(w.fullscreen, e)
        }

        get fullscreen() {
            return g.isFullscreen || this.webFullscreen
        }

        set webFullscreen(e) {
            this.emit(w.webFullscreen, e)
        }

        get webFullscreen() {
            return this.$container.classList.contains("jessibuca-fullscreen-web")
        }

        set loaded(e) {
            this._hasLoaded = e
        }

        get loaded() {
            return this._hasLoaded || this.isOldHls() || this.isWebrtcH264() || this._opt.useMSE && C(this._opt.hasAudio) && C(this._opt.demuxUseWorker) || this._opt.useWCS && !this._opt.hasAudio && C(this._opt.demuxUseWorker)
        }

        set playing(e) {
            e && (this.loading = !1), this.playing !== e && (this._playing = e, this.emit(w.playing, e), this.emit(w.volumechange, this.volume), e ? this.emit(w.play) : this.emit(w.pause))
        }

        get playing() {
            return this._playing
        }

        get volume() {
            return this.audio && this.audio.volume || 0
        }

        set volume(e) {
            e !== this.volume && (this.audio ? (this.audio.setVolume(e), this._lastVolume = this.volume) : this.debug.warn("Player", "set volume error, audio is null"))
        }

        get lastVolume() {
            return this._lastVolume
        }

        set loading(e) {
            this.loading !== e && (this._loading = e, this.emit(w.loading, this._loading))
        }

        get loading() {
            return this._loading
        }

        set zooming(e) {
            this.zooming !== e && (this.zoom || (this.zoom = new kn(this)), this._zooming = e, this.emit(w.zooming, this.zooming))
        }

        get zooming() {
            return this._zooming
        }

        set recording(e) {
            e ? this.playing && !this.recording && (this.recorder && this.recorder.startRecord(), this.isDemuxInWorker() && this.decoderWorker.updateWorkConfig({
                key: "isRecording",
                value: !0
            })) : this.recording && (this.isDemuxInWorker() && this.decoderWorker.updateWorkConfig({
                key: "isRecording",
                value: !1
            }), this.recorder && this.recorder.stopRecordAndSave().then(() => {
            }).catch(e => {
            }))
        }

        get recording() {
            return !!this.recorder && this.recorder.isRecording
        }

        set audioTimestamp(e) {
            null !== e && (this._audioTimestamp = e)
        }

        get audioTimestamp() {
            return this._audioTimestamp
        }

        set videoTimestamp(e) {
            null !== e && (this._videoTimestamp = e, this._opt.useWCS || this._opt.useMSE || this.audioTimestamp && this.videoTimestamp && this.audio && this.audio.emit(w.videoSyncAudio, {
                audioTimestamp: this.audioTimestamp,
                videoTimestamp: this.videoTimestamp,
                diff: this.audioTimestamp - this.videoTimestamp
            }))
        }

        set streamQuality(e) {
            this.streamQuality !== e && (this._streamQuality = e, this.emit(w.streamQualityChange, e))
        }

        get streamQuality() {
            return this._streamQuality
        }

        get videoTimestamp() {
            return this._videoTimestamp
        }

        get isDebug() {
            return k(this._opt.debug)
        }

        get scaleType() {
            var e = this._opt, t = e.isResize, e = e.isFullResize;
            let i = 0;
            return C(e) && C(t) ? i = 0 : C(e) && k(t) ? i = 1 : k(e) && k(t) && (i = 2), i
        }

        set visibility(e) {
            this._visibility !== e && (this._visibility = e, this.emit(w.visibilityChange, e), this._lastestVisibilityChangeTimestamp = p(), e ? this.clearVisibilityHiddenTimeout() : this.startVisibilityHiddenTimeout())
        }

        get visibility() {
            return this._visibility
        }

        set playbackPause(e) {
            this._playbackPause !== e && (this._playbackPause = e, this.emit(w.playbackPause, e), this.emit(w.playbackPauseOrResume, e))
        }

        get playbackPause() {
            return this._playbackPause
        }

        set videoIframeIntervalTs(e) {
            this._videoIframeIntervalTs = e
        }

        get videoIframeIntervalTs() {
            return this._videoIframeIntervalTs
        }

        set faceDetectActive(e) {
            this._faceDetectActive !== e && (this._faceDetectActive = e, this.emit(w.faceDetectActive, e))
        }

        get faceDetectActive() {
            return this._faceDetectActive
        }

        set objectDetectActive(e) {
            this._objectDetectActive !== e && (this._objectDetectActive = e, this.emit(w.objectDetectActive, e))
        }

        get objectDetectActive() {
            return this._objectDetectActive
        }

        get isUseWorkerDemuxAndDecode() {
            return this.stream && this.stream.getStreamType() === N
        }

        isDestroyed() {
            return this._destroyed
        }

        updateOption(t) {
            var e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
            this._opt = Object.assign({}, this._opt, t), k(e) && this.decoderWorker && Object.keys(t).forEach(e => {
                this.decoderWorker.updateWorkConfig({key: e, value: t[e]})
            })
        }

        init() {
            return new Promise((e, t) => {
                this.video || this._opt.hasVideo && (this.video = new Mi(this)), this.audio || this._opt.hasAudio && (this.audio = new er(this)), this.stream || (this.stream = new or(this)), this.isOldHls() ? (this.hlsDecoder || (this.hlsDecoder = new va(this), this.loaded = !0), e()) : this.isWebrtcH264() ? (this.webrtc || (this._opt.isWebrtcForZLM ? this.webrtc = new En(this) : this._opt.isWebrtcForSRS ? this.webrtc = new Ln(this) : this._opt.isWebrtcForOthers ? this.webrtc = new Dn(this) : this.webrtc = new wn(this), this.loaded = !0), e()) : (this.demux || this._opt.hasVideo && !this.isUseWorkerDemuxAndDecode && (this.demux = new ra(this)), this._opt.useWCS && !this.webcodecsDecoder && (this.webcodecsDecoder = new sa(this)), this._opt.useMSE && !this.mseDecoder && (this.mseDecoder = new ya(this)), this.isUseHls265() && !this.hlsDecoder && (this.hlsDecoder = new _n(this)), this.isWebrtcH265() && !this.webrtc && (this.webrtc = new wn(this)), this.decoderWorker ? this.loaded ? e() : this.once(w.decoderWorkerInit, () => {
                    this.isDestroyed() ? (this.debug.error("player", "init() failed and player is destroyed"), t("init() failed and player is destroyed")) : (this.loaded = !0, e())
                }) : ri(this._opt) ? e() : (this.decoderWorker = new Br(this), this.once(w.decoderWorkerInit, () => {
                    this.isDestroyed() ? (this.debug.error("player", "init() failed and player is destroyed"), t("init() failed and player is destroyed")) : (this.loaded = !0, e())
                })))
            })
        }

        play(e) {
            let r = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            return new Promise((t, i) => {
                if (!e && !this._opt.url) return i("url is empty");
                this.loading = !0, this.playing = !1, this._times.playInitStart = p(), e = e || this._opt.url, this._opt.url = e, this.clearCheckHeartTimeout(), this.control && this._opt.loadingBackground && this.control.initLoadingBackground(), this.init().then(() => {
                    this.debug.log("player", "play() init and next fetch stream"), this._times.playStart = p(), this._opt.isNotMute && this.mute(!1), this.webcodecsDecoder && this.webcodecsDecoder.once(S.webcodecsH265NotSupport, () => {
                        this.emitError(S.webcodecsH265NotSupport)
                    }), this.mseDecoder && (this.mseDecoder.once(S.mediaSourceH265NotSupport, () => {
                        this.emitError(S.mediaSourceH265NotSupport)
                    }), this.mseDecoder.once(S.mediaSourceFull, () => {
                        this.emitError(S.mediaSourceFull)
                    }), this.mseDecoder.once(S.mediaSourceAppendBufferError, () => {
                        this.emitError(S.mediaSourceAppendBufferError)
                    }), this.mseDecoder.once(S.mediaSourceBufferListLarge, () => {
                        this.emitError(S.mediaSourceBufferListLarge)
                    }), this.mseDecoder.once(S.mediaSourceAppendBufferEndTimeout, () => {
                        this.emitError(S.mediaSourceAppendBufferEndTimeout)
                    }), this.mseDecoder.once(S.mediaSourceDecoderConfigurationError, () => {
                        this.emitError(S.mediaSourceDecoderConfigurationError)
                    }), this.mseDecoder.once(S.mediaSourceTsIsMaxDiff, () => {
                        this.emitError(S.mediaSourceTsIsMaxDiff)
                    })), this.enableWakeLock(), this.checkLoadingTimeout(), this.stream ? (this.stream.once(S.fetchError, e => {
                        this.emitError(S.fetchError, e)
                    }), this.stream.once(S.websocketError, e => {
                        this.emitError(S.websocketError, e)
                    }), this.stream.once(w.streamEnd, () => {
                        this.emit(w.streamEnd)
                    }), this.stream.once(S.hlsError, e => {
                        this.emitError(S.hlsError, e)
                    }), this.stream.once(S.webrtcError, e => {
                        this.emitError(S.webrtcError, e)
                    }), this.stream.once(w.streamSuccess, () => {
                        t(), this._times.streamResponse = p(), this.video && this.video.play(), this.checkStatsInterval(), this.isPlayback() && this.playback && this.playback.startCheckStatsInterval();
                        var e = Number("1") || 1;
                        setTimeout(() => {
                            this.destroy(), console.error("jessibuca pro 体验结束,请刷新页面再次体验"), alert("jessibuca pro 体验结束,请刷新页面再次体验，如需要购买商业授权，可以联系微信：bosswancheng"), window.location.reload()
                        }, 60 * e * 60 * 1e3)
                    }), this.stream.fetchStream(e, r)) : (this.debug.warn("player", "play() this.stream is null and is destroy is " + this.isDestroyed()), i("this.stream is null"))
                }).catch(e => {
                    i(e)
                })
            })
        }

        playForControl() {
            return new Promise((t, i) => {
                if (this.debug.log("player", "playForControl() and pauseAndNextPlayUseLastFrameShow is " + this._opt.pauseAndNextPlayUseLastFrameShow), this._opt.pauseAndNextPlayUseLastFrameShow && this._tempInnerPlayBgobj && this._tempInnerPlayBgobj.loadingBackground) {
                    const t = this.getVideoInfo();
                    this.updateOption({
                        loadingBackground: this._tempInnerPlayBgobj.loadingBackground,
                        loadingBackgroundWidth: t.width,
                        loadingBackgroundHeight: t.height
                    })
                }
                this.play().then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                })
            })
        }

        close() {
            return new Promise((e, t) => {
                this._close().then(() => {
                    this.video && this.video.clearView(), e()
                }).catch(e => {
                    t(e)
                })
            })
        }

        resumeAudioAfterPause() {
            this.lastVolume && (this.volume = this.lastVolume)
        }

        _close() {
            return new Promise((e, t) => {
                const i = () => {
                    this.stream && (this.stream.destroy(), this.stream = null), this.demux && (this.demux.destroy(), this.demux = null), this.webcodecsDecoder && (this.webcodecsDecoder.destroy(), this.webcodecsDecoder = null), this.mseDecoder && (this.mseDecoder.destroy(), this.mseDecoder = null), this.hlsDecoder && (this.hlsDecoder.destroy(), this.hlsDecoder = null), this.webrtc && (this.webrtc.destroy(), this.webrtc = null), this.audio && (this.audio.destroy(), this.audio = null), this.clearCheckHeartTimeout(), this.clearCheckLoadingTimeout(), this.clearStatsInterval(), this.isPlayback() && this.playback && this.playback.clearStatsInterval(), this.loading = !1, this.recording = !1, this.zooming = !1, this.playing = !1, this.video && (this.video.resetInit(), this.video.pause(!0)), this.releaseWakeLock(), this.resetStats(), this._audioTimestamp = 0, this._videoTimestamp = 0, this._times = {
                        playInitStart: "",
                        playStart: "",
                        streamStart: "",
                        streamResponse: "",
                        demuxStart: "",
                        decodeStart: "",
                        videoStart: "",
                        playTimestamp: "",
                        streamTimestamp: "",
                        streamResponseTimestamp: "",
                        demuxTimestamp: "",
                        decodeTimestamp: "",
                        videoTimestamp: "",
                        allTimestamp: ""
                    }
                };
                this.decoderWorker ? this.decoderWorker.destroy().then(() => {
                    this.decoderWorker = null, i(), setTimeout(() => {
                        e()
                    }, 0)
                }).catch(e => {
                    this.debug && this.debug.error("player", "close() decoderWorker.destroy() error", e), t()
                }) : (i(), setTimeout(() => {
                    e()
                }, 0))
            })
        }

        pause() {
            let i = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            return new Promise((e, t) => {
                i ? this.close().then(() => {
                    e()
                }).catch(e => {
                    t(e)
                }) : this._close().then(() => {
                    e()
                }).catch(e => {
                    t(e)
                })
            })
        }

        pauseForControl() {
            return new Promise((t, i) => {
                if (this.debug.log("player", "_pauseInner()"), this._opt.pauseAndNextPlayUseLastFrameShow && this.video) {
                    const t = this.video.screenshot("", "png", .92, "base64");
                    if (t) {
                        const i = this.getVideoInfo();
                        this._tempInnerPlayBgobj = {
                            loadingBackground: t,
                            loadingBackgroundWidth: i.width,
                            loadingBackgroundHeight: i.height
                        }
                    }
                }
                this.pause().then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                })
            })
        }

        isAudioMute() {
            let e = !0;
            return e = this.audio ? this.audio.isMute : e
        }

        isAudioNotMute() {
            return !this.isAudioMute()
        }

        mute(e) {
            this.audio && this.audio.mute(e)
        }

        resize() {
            this.video && this.video.resize()
        }

        startRecord(e, t) {
            this.recording || (this.recorder.setFileName(e, t), this.recording = !0)
        }

        stopRecordAndSave(e, r) {
            return new Promise((t, i) => {
                this.recorder || i("recorder is null"), this.recording ? (this._opt.useWasm && this.decoderWorker.updateWorkConfig({
                    key: "isRecording",
                    value: !1
                }), this.recorder.stopRecordAndSave(e, r).then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                })) : i("recorder is not recording")
            })
        }

        _hasControl() {
            let e = !1, t = !1;
            return Object.keys(this._opt.operateBtns).forEach(e => {
                this._opt.operateBtns[e] && -1 === ("" + e).indexOf("Fn") && (t = !0)
            }), (this._opt.showBandwidth || t) && (e = !0), e = this.isPlayback() && this._opt.playbackConfig.showControl ? !0 : e
        }

        useWasmDecode() {
            return C(this._opt.useMSE) && C(this._opt.useWCS)
        }

        canVideoTrackWritter() {
            var e = this._opt;
            return !this.isOldHls() && !this.isWebrtcH264() && C(e.useMSE) && (e.useWCS && C(e.useOffscreen) && e.wcsUseVideoRender || this.useWasmDecode())
        }

        checkHeart() {
            this.clearCheckHeartTimeout(), this.checkHeartTimeout()
        }

        checkHeartTimeout() {
            this._checkHeartTimeout = setTimeout(() => {
                C(this.playbackPause) && this.playing ? this.isDestroyed() ? this.debug && this.debug.warn("player", "checkHeartTimeout but player is destroyed") : 0 !== this._stats.fps ? this.debug && this.debug.warn("player", "checkHeartTimeout but fps is " + this._stats.fps) : C(this.visibility) && 0 !== this._stats.vbps ? this.debug && this.debug.warn("player", "checkHeartTimeout but page is not visibility and vbps is " + this._stats.vbps) : (this.debug.warn("player", `checkHeartTimeout and
                pause and emit delayTimeout event and
                current vbps is ${this._stats.vbps} and
                current fps is ${this._stats.fps} and
                current visibility is ${this.visibility} and`), this.emit(w.timeout, w.delayTimeout), this.emit(w.delayTimeout)) : this.debug.warn("player", `playbackPause is ${this.playbackPause}, playing is ` + this.playing)
            }, 1e3 * this._opt.heartTimeout)
        }

        checkHeartTimeout$2() {
            var e;
            C(this.playbackPause) && this.playing ? this.isDestroyed() ? this.debug && this.debug.warn("player", "checkHeartTimeout$2 but player is destroyed") : C(this.isHistoryFpsListAllZero()) ? this.debug && this.debug.warn("player", "checkHeartTimeout$2 but fps is not all zero") : 0 !== this._stats.fps ? this.debug && this.debug.warn("player", "checkHeartTimeout$2 but fps is " + this._stats.fps) : C(this.visibility) && 0 !== this._stats.vbps ? this.debug && this.debug.warn("player", "checkHeartTimeout$2 but page is not visibility and vbps is " + this._stats.vbps) : (e = this._historyFpsList.join(","), this.debug.warn("player", `checkHeartTimeout$2 and
                pause and emit delayTimeout event and
                current vbps is ${this._stats.vbps} and
                current fps is ${this._stats.fps} and
                history FpsList is ${e} and
                current visibility is ${this.visibility} and`), this.emit(w.timeout, w.delayTimeout), this.emit(w.delayTimeout)) : this.debug.log("player", `checkHeartTimeout$2 playbackPause is ${this.playbackPause}, playing is ` + this.playing)
        }

        checkStatsInterval() {
            this._checkStatsInterval = setInterval(() => {
                this.updateStats()
            }, 1e3)
        }

        clearCheckHeartTimeout() {
            this._checkHeartTimeout && (clearTimeout(this._checkHeartTimeout), this._checkHeartTimeout = null)
        }

        checkLoadingTimeout() {
            this._checkLoadingTimeout = setTimeout(() => {
                this.playing ? this.debug.warn("player", `checkLoadingTimeout but loading is ${this.loading} and playing is ` + this.playing) : this.isDestroyed() ? this.debug && this.debug.warn("player", "checkLoadingTimeout but player is destroyed") : (this.debug.warn("player", "checkLoadingTimeout and pause and emit loadingTimeout event"), this.emit(w.timeout, w.loadingTimeout), this.emit(w.loadingTimeout))
            }, 1e3 * this._opt.loadingTimeout)
        }

        clearCheckLoadingTimeout() {
            this._checkLoadingTimeout && (this.debug.log("player", "clearCheckLoadingTimeout"), clearTimeout(this._checkLoadingTimeout), this._checkLoadingTimeout = null)
        }

        clearStatsInterval() {
            this._checkStatsInterval && (clearInterval(this._checkStatsInterval), this._checkStatsInterval = null)
        }

        handleRender() {
            this.isDestroyed() ? this.debug && this.debug.warn("player", "handleRender but player is destroyed") : (this.loading && (this.clearCheckLoadingTimeout(), this.loading = !1, this.emit(w.start)), this.playing || (this.playing = !0))
        }

        updateStats() {
            var A = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            if (this._startBpsTime || (this._startBpsTime = p()), x(A.ts)) {
                const b = parseInt(A.ts, 10);
                this._stats.ts = b, null === this._playingStartTimestamp && 0 < b && (this._playingStartTimestamp = b)
            }
            x(A.dts) && (this._stats.dts = parseInt(A.dts, 10)), x(A.mseTs) && (this._stats.mseTs = A.mseTs), x(A.buf) && (this._stats.buf = A.buf), x(A.netBuf) && (this._stats.netBuf = A.netBuf), A.fps && (this._stats.fps += 1), A.dfps && (this._stats.dfps += 1), A.abps && (this._stats.abps += A.abps), A.vbps && (this._stats.vbps += A.vbps), A.workerStats && (this._tempWorkerStats = A.workerStats), A.mseVideoBufferDelayTime && (this._stats.mseVideoBufferDelayTime = parseInt(1e3 * A.mseVideoBufferDelayTime, 10));
            const b = p();
            if (!(b - this._startBpsTime < 1e3)) {
                null !== this._playingStartTimestamp && 0 < this._stats.fps && (this._stats.pTs += 1);
                let e = 0, t = 0, i = 0,
                    r = (this._opt.useMSE && this.mseDecoder && (e = this.mseDecoder.checkSourceBufferDelay(), e = parseInt(1e3 * e, 10), t = this.mseDecoder.getDecodeDiffTimes(), i = this.mseDecoder.getDecodePlaybackRate()), this._opt.useWCS && this.webcodecsDecoder && (t = this.webcodecsDecoder.getDecodeDiffTimes()), this.isOldHls() && this.hlsDecoder && (e = this.hlsDecoder.checkHlsBufferedDelay(), e = parseInt(1e3 * e, 10), i = this.hlsDecoder.getDecodePlaybackRate()), 0),
                    s = 0, a = 0,
                    n = (this.isUseHls265() && this.hlsDecoder && (e = (e = this.hlsDecoder.checkHlsBufferedDelay()).toFixed(2), r = this.hlsDecoder.getDemuxBufferedListLength(), a = this.hlsDecoder.getDemuxVideoBufferedListLength(), s = this.hlsDecoder.getDemuxAudioBufferedListLength()), 0),
                    o = 0, l = 0, d = !1, h = !1, c = 0,
                    u = (this.demux && (d = this.demux.isDropping()), this._opt.useWasm || this._opt.demuxUseWorker ? this._tempWorkerStats && (o = this._tempWorkerStats.demuxBufferDelay, l = this._tempWorkerStats.audioDemuxBufferDelay, n = this._tempWorkerStats.flvBufferByteLength, this._stats.netBuf = this._tempWorkerStats.netBuf, d = this._tempWorkerStats.isDropping, c = this._tempWorkerStats.pushLatestDelay, h = this._tempWorkerStats.isStreamTsMoreThanLocal) : this.demux && (n = this.demux.getInputByteLength(), c = this.demux.getPushLatestDelay(), h = this.demux.getIsStreamTsMoreThanLocal(), this.demux.bufferList && (o = this.demux.bufferList.length)), 0),
                    p = 0,
                    f = (this.audio && this.audio.bufferList && (u = this.audio.bufferList.length, p = parseInt(u * this.audio.oneBufferDuration, 10)), 0),
                    m = 0;
                if (this.isPlayback() && this.video) {
                    this._opt.playbackConfig.isUseFpsRender && (f = this.video.bufferList && this.video.bufferList.length || 0);
                    A = this.video.getStreamFps();
                    const b = 0 < A ? 1e3 / A : 0;
                    m = parseInt(b * f + b * o, 10)
                }
                var A = this._stats.dts - this._stats.ts, v = A + this._stats.netBuf;
                this.isOldHls() && (this._stats.fps = this.hlsDecoder.getFps()), this._stats.fps > this._stats.maxFps && (this._stats.maxFps = this._stats.fps);
                let g = this.getVideoCurrentTime();
                var _ = this._stats.videoCurrentTime;
                let y = 0;
                _ && g && (y = (g - _).toFixed(2), g = g.toFixed(2)), this._allStatsData = Object.assign(this._stats, {
                    audioBuffer: u,
                    audioBufferDelayTs: p,
                    audioTs: this.audioTimestamp,
                    playbackVideoBuffer: f,
                    playbackVideoWaitingBuffer: 0,
                    playbackAudioWaitingBuffer: 0,
                    playbackCacheDataDuration: m,
                    demuxBuffer: o,
                    pushLatestDelay: c,
                    audioDemuxBuffer: l,
                    flvBuffer: n,
                    mseDelay: e,
                    mseDecodeDiffTimes: t,
                    mseDecodePlaybackRate: i,
                    wcsDecodeDiffTimes: t,
                    hlsDelay: e,
                    hlsDemuxLength: r,
                    hlsDemuxAudioLength: s,
                    hlsDemuxVideoLength: a,
                    hlsDecodePlaybackRate: i,
                    delayTs: A,
                    totalDelayTs: v,
                    isDropping: d,
                    isStreamTsMoreThanLocal: h,
                    videoCurrentTime: g,
                    videoCurrentTimeDiff: y
                }), this.emit(w.stats, this._allStatsData), 1048576 < this._allStatsData.flvBuffer && this.emit(S.flvDemuxBufferSizeTooLarge, this._allStatsData.flvBuffer), this.updateHistoryFpsList(this._stats.fps), this._opt.hasVideo && this.isPlayer() && this.isWebrtcH265() && (this.emit(w.performance, function (e) {
                    let t = 0;
                    return 24 <= e ? t = 2 : 15 <= e && (t = 1), t
                }(this._stats.fps)), this.emit(w.videoSmooth, this.checkVideoSmooth(this._stats))), this._stats.fps = 0, this._stats.dfps = 0, this._stats.abps = 0, this._stats.vbps = 0, this._startBpsTime = b
            }
        }

        resetStats() {
            this._startBpsTime = null, this._playingStartTimestamp = null, this._historyFpsList = [], this._stats = {
                buf: 0,
                netBuf: 0,
                fps: 0,
                maxFps: 0,
                dfps: 0,
                abps: 0,
                vbps: 0,
                ts: 0,
                mseTs: 0,
                pTs: 0,
                dts: 0
            }, this._allStatsData = {}
        }

        checkVideoSmooth(e) {
            let t = !0;
            const i = this._opt.videoBuffer + this._opt.videoBufferDelay;
            if ((t = (t = (t = (t = (t = 0 === e.vbps ? !1 : t) && e.isDropping ? !1 : t) && e.pushLatestDelay > i ? !1 : t) && e.netBuf > this._opt.networkDelay ? !1 : t) && e.delayTs > i ? !1 : t) && this.visibility && this._historyFpsList.length >= this._opt.heartTimeout) {
                const i = this._historyFpsList.reduce((e, t) => e + t, 0) / this._historyFpsList.length;
                e.fps < i && (t = !1)
            }
            return t = t && this.visibility && 2 < e.videoCurrentTimeDiff ? !1 : t
        }

        enableWakeLock() {
            this._opt.keepScreenOn && this.keepScreenOn && this.keepScreenOn.enable()
        }

        releaseWakeLock() {
            this._opt.keepScreenOn && this.keepScreenOn && this.keepScreenOn.disable()
        }

        clearBufferDelay() {
            this._opt.useWasm ? this.decoderWorker && this.decoderWorker.clearWorkBuffer(!0) : this.demux && this.demux.clearBuffer(!0)
        }

        doDestroy() {
            this.emit(w.beforeDestroy)
        }

        handlePlayToRenderTimes() {
            var e = this.getPlayToRenderTimes();
            this.emit(w.playToRenderTimes, e)
        }

        getPlayToRenderTimes() {
            const e = this._times;
            return e.playTimestamp = e.playStart - e.playInitStart, e.streamTimestamp = e.streamStart - e.playStart, e.streamResponseTimestamp = e.streamResponse - e.streamStart, e.demuxTimestamp = 0 < e.demuxStart - e.streamResponse ? e.demuxStart - e.streamResponse : 0, e.decodeTimestamp = 0 < e.decodeStart - e.demuxStart ? e.decodeStart - e.demuxStart : 0, e.videoTimestamp = e.videoStart - e.decodeStart, e.allTimestamp = e.videoStart - e.playInitStart, e
        }

        getOption() {
            return this._opt
        }

        getPlayType() {
            return this._opt.playType
        }

        isPlayer() {
            return this._opt.playType === n
        }

        isPlayback() {
            return this._opt.playType === A
        }

        isDemuxSetCodecInit() {
            let e = !0, t = this._opt;
            return t.useWCS && !t.useOffscreen ? e = this.webcodecsDecoder.hasInit : t.useMSE && (e = this.mseDecoder.hasInit), e
        }

        isDemuxDecodeFirstIIframeInit() {
            let e = !0, t = this._opt;
            return t.useWCS && !t.useOffscreen ? e = !!this.webcodecsDecoder && this.webcodecsDecoder.isDecodeFirstIIframe : t.useMSE && (e = !!this.mseDecoder && this.mseDecoder.isDecodeFirstIIframe), e
        }

        isAudioPlaybackRateSpeed() {
            let e = !1;
            return e = this.audio ? this.audio.isPlaybackRateSpeed() : e
        }

        getPlayingTimestamp() {
            return this._stats.pTs
        }

        getRecordingType() {
            let e = null;
            return e = this.recorder ? this.recorder.getType() : e
        }

        getRecordingByteLength() {
            let e = 0;
            return e = this.recording ? this.recorder.getToTalByteLength() : e
        }

        getRecordingDuration() {
            let e = 0;
            return e = this.recording ? this.recorder.getTotalDuration() : e
        }

        getDecodeType() {
            let e = "";
            var t = this.getOption();
            return t.useMSE && (e += "mse "), t.useWCS && (e += "wcs "), t.useWasm && (e += "wasm ", t.useSIMD && (e += "simd ")), t.useOffscreen && (e += "offscreen "), e
        }

        getDemuxType() {
            return this.getOption().demuxType
        }

        getRenderType() {
            let e = "";
            return e = this.video ? this.video.getType() : e
        }

        getCanvasRenderType() {
            let e = "";
            return e = this.video ? this.video.getCanvasType() : e
        }

        getAudioEngineType() {
            let e = "";
            return e = this.audio ? this.audio.getEngineType() : e
        }

        getStreamType() {
            let e = "";
            return e = this.stream ? this.stream.getStreamType() : e
        }

        getAllStatsData() {
            return this._allStatsData
        }

        togglePerformancePanel(e) {
            this.updateOption({showPerformance: e}), this.emit(w.togglePerformancePanel, e)
        }

        setScaleMode(e) {
            let t = {isFullResize: !1, isResize: !1, aspectRatio: "default"};
            switch (e = Number(e)) {
                case 0:
                    t.isFullResize = !1, t.isResize = !1;
                    break;
                case 1:
                    t.isFullResize = !1, t.isResize = !0;
                    break;
                case 2:
                    t.isFullResize = !0, t.isResize = !0
            }
            this.updateOption(t), this.resize(), this.emit(w.viewResizeChange, e)
        }

        startVisibilityHiddenTimeout() {
            this.clearVisibilityHiddenTimeout(), 0 < this._opt.pageVisibilityHiddenTimeout && (this.visibilityHiddenTimeout = setTimeout(() => {
                this.emit(w.visibilityHiddenTimeout)
            }, 1e3 * this._opt.pageVisibilityHiddenTimeout))
        }

        clearVisibilityHiddenTimeout() {
            this._checkVisibleHiddenTimeout && (clearTimeout(this._checkVisibleHiddenTimeout), this._checkVisibleHiddenTimeout = null)
        }

        faceDetect(e) {
            this.faceDetectActive = e
        }

        objectDetect(e) {
            this.objectDetectActive = e
        }

        downloadNakedFlowFile() {
            this.demux && this.demux.downloadNakedFlowFile && this.demux.downloadNakedFlowFile()
        }

        downloadFmp4File() {
            this.demux && this.demux.downloadFmp4File && this.demux.downloadFmp4File()
        }

        downloadMpeg4File() {
            var e = new Blob([this._tempStreamList]);
            try {
                const t = document.createElement("a");
                t.href = window.URL.createObjectURL(e), t.download = Date.now() + ".mpeg4", t.click(), window.URL.revokeObjectURL(t.href)
            } catch (e) {
                console.error("downloadMpeg4File", e)
            }
        }

        hasCacheOnGopBuffer() {
            var e = this.videoIframeIntervalTs, t = this._allStatsData.demuxBuffer, i = this._allStatsData.maxFps;
            let r = e && t && i ? e < 1e3 / i * t : !1;
            return r
        }

        addContentToCanvas() {
            this.video && this.video.addContentToCanvas(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [])
        }

        sendWebsocketMessage(e) {
            var t = this.getStreamType();
            t === O || t === N + " " + O ? this.stream.sendMessage(e) : this.debug.warn("player", "sendWebsocketMessage: stream type is not websocket, current stream type is " + this.getStreamType())
        }

        checkIsInRender() {
            var e = this._stats;
            return 0 < e.vbps && 0 < e.fps
        }

        setControlHtml(e) {
            this.control && this.control.$controlHtml && (this.control.$controlHtml.innerHTML = e)
        }

        clearControlHtml() {
            this.control && this.control.$controlHtml && (this.control.$controlHtml.innerHTML = "")
        }

        updateWatermark(e) {
            this.singleWatermark && this.singleWatermark.update(e)
        }

        removeWatermark() {
            this.singleWatermark && this.singleWatermark.remove()
        }

        getVideoInfo() {
            let e = null;
            return e = this.video ? this.video.getVideoInfo() : e
        }

        getAudioInfo() {
            let e = null;
            return e = this.audio ? this.audio.getAudioInfo() : e
        }

        getVideoPlaybackQuality() {
            let e = null;
            return e = this.video ? this.video.getPlaybackQuality() : e
        }

        emitError(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
            this.emit(w.error, e, t), this.emit(e, t)
        }

        updateHistoryFpsList(e) {
            this._historyFpsList.length > this._opt.heartTimeout && this._historyFpsList.shift(), this._historyFpsList.push(e), this.isHistoryFpsListAllZero() && this.checkHeartTimeout$2()
        }

        isHistoryFpsListAllZero() {
            let t = !0;
            if (t = this._historyFpsList.length < this._opt.heartTimeout ? !1 : t) for (let e = 0; e < this._historyFpsList.length; e++) if (0 < this._historyFpsList[e]) {
                t = !1;
                break
            }
            return t
        }

        isUseHls265() {
            return k(this._opt.isHls) && k(this._opt.supportHls265)
        }

        isOldHls() {
            return k(this._opt.isHls) && C(this._opt.supportHls265)
        }

        isWebrtcH264() {
            return k(this._opt.isWebrtc) && C(this._opt.isWebrtcH265)
        }

        isWebrtcH265() {
            return k(this._opt.isWebrtc) && k(this._opt.isWebrtcH265)
        }

        isStreamWebTransport() {
            return this.getStreamType() === i
        }

        isPlaybackCacheBeforeDecodeForFpsRender() {
            return k(this.isPlayback()) && k(this._opt.playbackConfig.isCacheBeforeDecodeForFpsRender) && this._opt.useWCS
        }

        isPlaybackUseWCS() {
            return k(this.isPlayback()) && this._opt.useWCS
        }

        isInWebFullscreen() {
            return this._opt.useWebFullScreen && y() && this.fullscreen
        }

        getPlaybackRate() {
            let e = 1;
            return e = k(this.isPlayback()) && this.playback ? this.playback.rate : e
        }

        isPlaybackOnlyDecodeIFrame() {
            return k(this.isPlayback()) && this.getPlaybackRate() >= this._opt.playbackForwardMaxRateDecodeIFrame
        }

        pushTempStream(e) {
            e = new Uint8Array(e);
            this._tempStreamList.push(e)
        }

        updateLoadingText(e) {
            this.loading && this.control && this.control.updateLoadingText(e)
        }

        getVideoCurrentTime() {
            let e = 0;
            return e = this.video && this._opt.useMSE ? this.video.getCurrentTime() : e
        }

        addMemoryLog(e) {
            for (var t = arguments.length, i = new Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
            this.emit(w.memoryLog, ` [${e}] `, ...i)
        }

        downloadMemoryLog() {
            this.emit(w.downloadMemoryLog)
        }

        isInMulti() {
            return -1 !== this._opt.multiIndex
        }

        isWebrtcForM7S() {
            return C(this._opt.isWebrtcForZLM) && C(this._opt.isWebrtcForSRS) && C(this._opt.isWebrtcForOthers)
        }

        updateMetaData(e) {
            this._flvMetaData = e, this.emit(w.flvMetaData, e)
        }

        getMetaData() {
            return this._flvMetaData
        }

        getExtendBtnList() {
            return this.control.getExtendBtnList().map(e => ({
                name: e.name,
                $container: e.$iconContainer,
                $btn: e.$iconWrap,
                $activeBtn: e.$activeIconWrap
            }))
        }

        isRecordTypeFlv() {
            return this.recorder && this._opt.recordType === G
        }

        isRecordTypeMp4() {
            return this.recorder && this._opt.recordType === u
        }

        isRecordTypeWebm() {
            return this.recorder && this._opt.recordType === z
        }

        isDemuxInWorker() {
            return this._opt.useWasm || this._opt.demuxUseWorker
        }
    }

    class Rn {
        constructor(e) {
            var {fromSampleRate: e, toSampleRate: t, channels: i, inputBufferSize: r} = e;
            if (!e || !t || !i) throw new Error("Invalid settings specified for the resampler.");
            this.resampler = null, this.fromSampleRate = e, this.toSampleRate = t, this.channels = i || 0, this.inputBufferSize = r, this.initialize()
        }

        initialize() {
            this.fromSampleRate == this.toSampleRate ? (this.resampler = e => e, this.ratioWeight = 1) : (this.fromSampleRate < this.toSampleRate ? (this.linearInterpolation(), this.lastWeight = 1) : (this.multiTap(), this.tailExists = !1, this.lastWeight = 0), this.initializeBuffers(), this.ratioWeight = this.fromSampleRate / this.toSampleRate)
        }

        bufferSlice(t) {
            try {
                return this.outputBuffer.subarray(0, t)
            } catch (e) {
                try {
                    return this.outputBuffer.length = t, this.outputBuffer
                } catch (e) {
                    return this.outputBuffer.slice(0, t)
                }
            }
        }

        initializeBuffers() {
            this.outputBufferSize = Math.ceil(this.inputBufferSize * this.toSampleRate / this.fromSampleRate / this.channels * 1.0000004768371582) + this.channels + this.channels;
            try {
                this.outputBuffer = new Float32Array(this.outputBufferSize), this.lastOutput = new Float32Array(this.channels)
            } catch (e) {
                this.outputBuffer = [], this.lastOutput = []
            }
        }

        linearInterpolation() {
            this.resampler = e => {
                let t, i, r, s, a, n, o, l, d, h = e.length, c = this.channels;
                if (h % c != 0) throw new Error("Buffer was of incorrect sample length.");
                if (h <= 0) return [];
                for (t = this.outputBufferSize, i = this.ratioWeight, r = this.lastWeight, s = 0, a = 0, n = 0, o = 0, l = this.outputBuffer; r < 1; r += i) for (a = r % 1, s = 1 - a, this.lastWeight = r % 1, d = 0; d < this.channels; ++d) l[o++] = this.lastOutput[d] * s + e[d] * a;
                for (--r, h -= c, n = Math.floor(r) * c; o < t && n < h;) {
                    for (a = r % 1, s = 1 - a, d = 0; d < this.channels; ++d) l[o++] = e[n + (0 < d ? d : 0)] * s + e[n + (c + d)] * a;
                    r += i, n = Math.floor(r) * c
                }
                for (d = 0; d < c; ++d) this.lastOutput[d] = e[n++];
                return this.bufferSlice(o)
            }
        }

        multiTap() {
            this.resampler = e => {
                let t, i, r, s, a, n, o, l, d, h, c, u = e.length, p = this.channels;
                if (u % p != 0) throw new Error("Buffer was of incorrect sample length.");
                if (u <= 0) return [];
                for (t = this.outputBufferSize, i = [], r = this.ratioWeight, s = 0, n = 0, l = !this.tailExists, this.tailExists = !1, d = this.outputBuffer, h = 0, c = 0, a = 0; a < p; ++a) i[a] = 0;
                do {
                    if (l) for (s = r, a = 0; a < p; ++a) i[a] = 0; else {
                        for (s = this.lastWeight, a = 0; a < p; ++a) i[a] = this.lastOutput[a];
                        l = !0
                    }
                    for (; 0 < s && n < u;) {
                        if (o = 1 + n - c, !(s >= o)) {
                            for (a = 0; a < p; ++a) i[a] += e[n + (0 < a ? a : 0)] * s;
                            c += s, s = 0;
                            break
                        }
                        for (a = 0; a < p; ++a) i[a] += e[n++] * o;
                        c = n, s -= o
                    }
                    if (0 !== s) {
                        for (this.lastWeight = s, a = 0; a < p; ++a) this.lastOutput[a] = i[a];
                        this.tailExists = !0;
                        break
                    }
                    for (a = 0; a < p; ++a) d[h++] = i[a] / r
                } while (n < u && h < t);
                return this.bufferSlice(h)
            }
        }

        resample(e) {
            return this.fromSampleRate == this.toSampleRate ? this.ratioWeight = 1 : (this.fromSampleRate < this.toSampleRate ? this.lastWeight = 1 : (this.tailExists = !1, this.lastWeight = 0), this.initializeBuffers(), this.ratioWeight = this.fromSampleRate / this.toSampleRate), this.resampler(e)
        }
    }

    const Pn = [255, 511, 1023, 2047, 4095, 8191, 16383, 32767];

    function Bn(t, i, r) {
        for (let e = 0; e < r; e++) if (t <= i[e]) return e;
        return r
    }

    class Un extends e {
        constructor(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                e = (super(), this._opt = {}, e && (this.player = e), this.tag = "talk", di(et));
            this._opt = Object.assign({}, e, t), this._opt.sampleRate = parseInt(this._opt.sampleRate, 10), this._opt.sampleBitsWidth = parseInt(this._opt.sampleBitsWidth, 10), this.audioContext = null, this.gainNode = null, this.recorder = null, this.workletRecorder = null, this.biquadFilter = null, this.userMediaStream = null, this.clearWorkletUrlTimeout = null, this.bufferSize = 512, this._opt.audioBufferLength = this.calcAudioBufferLength(), this.audioBufferList = [], this.socket = null, this.socketStatus = ge, this.mediaStreamSource = null, this.heartInterval = null, this.checkGetUserMediaTimeout = null, this.wsUrl = null, this.startTimestamp = 0, this.sequenceId = 0, this.tempTimestamp = null, this.tempRtpBufferList = [], this.events = new gi(this), this._initTalk(), this.player || (this.debug = new ut(this)), this._opt.encType !== $e && this._opt.encType !== qe || 8e3 === this._opt.sampleRate && 16 === this._opt.sampleBitsWidth || this.warn(this.tag, `
            encType is ${this._opt.encType} and sampleBitsWidth is ${this._opt.sampleBitsWidth}, set sampleBitsWidth to ${this._opt.sampleBitsWidth}。
            ${this._opt.encType} only support sampleRate 8000 and sampleBitsWidth 16`), this.log(this.tag, "init", JSON.stringify(this._opt))
        }

        destroy() {
            this.clearWorkletUrlTimeout && (clearTimeout(this.clearWorkletUrlTimeout), this.clearWorkletUrlTimeout = null), this.userMediaStream && (this.userMediaStream.getTracks && this.userMediaStream.getTracks().forEach(e => {
                e.stop()
            }), this.userMediaStream = null), this.mediaStreamSource && (this.mediaStreamSource.disconnect(), this.mediaStreamSource = null), this.recorder && (this.recorder.disconnect(), this.recorder.onaudioprocess = null, this.recorder = null), this.biquadFilter && (this.biquadFilter.disconnect(), this.biquadFilter = null), this.gainNode && (this.gainNode.disconnect(), this.gainNode = null), this.workletRecorder && (this.workletRecorder.disconnect(), this.workletRecorder = null), this.socket && (this.socketStatus === ye && this._sendClose(), this.socket.close(), this.socket = null), this._stopHeartInterval(), this._stopCheckGetUserMediaTimeout(), this.audioContext = null, this.gainNode = null, this.recorder = null, this.audioBufferList = [], this.sequenceId = 0, this.wsUrl = null, this.tempTimestamp = null, this.tempRtpBufferList = [], this.startTimestamp = 0, this.log("talk", "destroy")
        }

        addRtpToBuffer(e) {
            const t = e.length + this.tempRtpBufferList.length, i = new Uint8Array(t);
            i.set(this.tempRtpBufferList, 0), i.set(e, this.tempRtpBufferList.length), this.tempRtpBufferList = i
        }

        downloadRtpFile() {
            var e = new Blob([this.tempRtpBufferList]);
            try {
                const t = document.createElement("a");
                t.href = window.URL.createObjectURL(e), t.download = Date.now() + ".rtp", t.click(), window.URL.revokeObjectURL(t.href)
            } catch (e) {
                console.error("downloadRtpFile", e)
            }
        }

        calcAudioBufferLength() {
            var e = this._opt["sampleRate"];
            return 8 * e * .02 / 8
        }

        get socketStatusOpen() {
            return this.socketStatus === ye
        }

        log() {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
            this._log("log", ...t)
        }

        warn() {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
            this._log("warn", ...t)
        }

        error() {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
            this._log("error", ...t)
        }

        _log(e) {
            for (var t = arguments.length, i = new Array(1 < t ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
            (this.player ? this.player.debug : this.debug || console)[e](...i)
        }

        _getSequenceId() {
            return ++this.sequenceId
        }

        _createWebSocket() {
            return new Promise((e, t) => {
                const i = this.events.proxy;
                this.socket = new WebSocket(this.wsUrl), this.socket.binaryType = "arraybuffer", this.emit(w.talkStreamStart), i(this.socket, "open", () => {
                    this.socketStatus = ye, this.log(this.tag, "websocket open -> do talk"), this.emit(w.talkStreamOpen), e(), this._doTalk()
                }), i(this.socket, "message", e => {
                    this.log(this.tag, "websocket message", e.data)
                }), i(this.socket, "close", e => {
                    this.socketStatus = "close", this.warn(this.tag, "websocket close -> reject", e), this.emit(w.talkStreamClose), t(e)
                }), i(this.socket, "error", e => {
                    this.socketStatus = "error", this.error(this.tag, "websocket error -> reject", e), this.emit(w.talkStreamError, e), t(e)
                })
            })
        }

        _sendClose() {
        }

        _initTalk() {
            this._initMethods(), this._opt.engine === Ze ? this._initWorklet() : "script" === this._opt.engine && this._initScriptProcessor(), this.log(this.tag, "audioContext samplerate", this.audioContext.sampleRate)
        }

        _initMethods() {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)({sampleRate: 48e3}), this.gainNode = this.audioContext.createGain(), this.gainNode.gain.value = 1, this.biquadFilter = this.audioContext.createBiquadFilter(), this.biquadFilter.type = "lowpass", this.biquadFilter.frequency.value = 3e3, this.resampler = new Rn({
                fromSampleRate: this.audioContext.sampleRate,
                toSampleRate: this._opt.sampleRate,
                channels: this._opt.numberChannels,
                inputBufferSize: this.bufferSize
            })
        }

        _initScriptProcessor() {
            const e = this.audioContext.createScriptProcessor || this.audioContext.createJavaScriptNode;
            this.recorder = e.apply(this.audioContext, [this.bufferSize, this._opt.numberChannels, this._opt.numberChannels]), this.recorder.onaudioprocess = e => this._onaudioprocess(e)
        }

        _initWorklet() {
            const e = si(function () {
                class e extends AudioWorkletProcessor {
                    constructor(e) {
                        super(), this._cursor = 0, this._bufferSize = e.processorOptions.bufferSize, this._buffer = new Float32Array(this._bufferSize)
                    }

                    process(t, e, i) {
                        if (!t.length || !t[0].length) return !0;
                        for (let e = 0; e < t[0][0].length; e++) this._cursor += 1, this._cursor === this._bufferSize && (this._cursor = 0, this.port.postMessage({
                            eventType: "data",
                            buffer: this._buffer
                        })), this._buffer[this._cursor] = t[0][0][e];
                        return !0
                    }
                }

                registerProcessor("talk-processor", e)
            });
            this.audioContext.audioWorklet && this.audioContext.audioWorklet.addModule(e).then(() => {
                const e = new AudioWorkletNode(this.audioContext, "talk-processor", {processorOptions: {bufferSize: this.bufferSize}});
                e.connect(this.gainNode), e.port.onmessage = e => {
                    "data" === e.data.eventType && this._encodeAudioData(e.data.buffer)
                }, this.workletRecorder = e
            }), this.clearWorkletUrlTimeout = setTimeout(() => {
                URL.revokeObjectURL(e), this.clearWorkletUrlTimeout = null
            }, re)
        }

        _onaudioprocess(e) {
            e = e.inputBuffer.getChannelData(0);
            this._encodeAudioData(new Float32Array(e))
        }

        _encodeAudioData(e) {
            if (0 === e[0] && 0 === e[1]) this.log(this.tag, "empty audio data"); else {
                const r = this.resampler.resample(e);
                let t = r;
                if (16 === this._opt.sampleBitsWidth ? t = function (e) {
                    let t = e.length, i = new Int16Array(t);
                    for (; t--;) {
                        var r = Math.max(-1, Math.min(1, e[t]));
                        i[t] = r < 0 ? 32768 * r : 32767 * r
                    }
                    return i
                }(r) : 8 === this._opt.sampleBitsWidth && (t = function (e) {
                    let t = e.length, i = new Int8Array(t);
                    for (; t--;) {
                        var r = Math.max(-1, Math.min(1, e[t]));
                        i[t] = parseInt(255 / (65535 / (32768 + (r < 0 ? 32768 * r : 32767 * r))), 10)
                    }
                    return i
                }(r)), null !== t.buffer) {
                    let e = null;
                    this._opt.encType === $e ? e = function (e) {
                        const i = [];
                        return Array.prototype.slice.call(e).forEach((e, t) => {
                            i[t] = function (e) {
                                let t, i, r;
                                return 0 <= e ? t = 213 : (t = 85, (e = -e - 1) < 0 && (e = 32767)), 8 <= (i = Bn(e, Pn, 8)) ? 127 ^ t : (r = i << 4, (r |= i < 2 ? e >> 4 & 15 : e >> i + 3 & 15) ^ t)
                            }(e)
                        }), i
                    }(t) : this._opt.encType === qe ? e = function (e) {
                        const i = [];
                        return Array.prototype.slice.call(e).forEach((e, t) => {
                            i[t] = function (e) {
                                let t = 0;
                                t = e < 0 ? (e = 132 - e, 127) : (e += 132, 255);
                                var i = Bn(e, Pn, 8);
                                return 8 <= i ? 127 ^ t : (i << 4 | e >> i + 3 & 15) ^ t
                            }(e)
                        }), i
                    }(t) : "pcm" === this._opt.encType && (e = t);
                    const r = new Uint8Array(e);
                    for (let e = 0; e < r.length; e++) {
                        var i = this.audioBufferList.length;
                        this.audioBufferList[+i] = r[e], this.audioBufferList.length === this._opt.audioBufferLength && (this._sendTalkMsg(new Uint8Array(this.audioBufferList)), this.audioBufferList = [])
                    }
                }
            }
        }

        _parseAudioMsg(e) {
            let t = null;
            return "rtp" !== this._opt.packetType || this._opt.encType !== $e && this._opt.encType !== qe ? "empty" === this._opt.packetType && (t = e) : t = this.rtpPacket(e), t
        }

        rtpPacket(e) {
            const t = [];
            let i = 0, r, s;
            var a = this._opt.rtpSsrc, n = e.length;
            this._opt.encType === $e ? i = 8 : this._opt.encType === qe ? i = 0 : "opus" === this._opt.encType && (i = 98), this.startTimestamp || (this.startTimestamp = p()), s = p() - this.startTimestamp, r = this._getSequenceId();
            let o = 0;
            if ("tcp" === this._opt.packetTcpSendType) {
                const e = n + 12;
                t[o++] = 255 & e >> 8, t[o++] = 255 & e >> 0
            }
            t[o++] = 128, t[o++] = 128 + i, t[o++] = r / 256, t[o++] = r % 256, t[o++] = s / 65536 / 256, t[o++] = s / 65536 % 256, t[o++] = s % 65536 / 256, t[o++] = s % 65536 % 256, t[o++] = a / 65536 / 256, t[o++] = a / 65536 % 256, t[o++] = a % 65536 / 256, t[o++] = a % 65536 % 256;
            let l = t.concat([...e]), d = new Uint8Array(l.length);
            for (let e = 0; e < l.length; e++) d[e] = l[e];
            return d
        }

        opusPacket(e) {
            return e
        }

        _sendTalkMsg(e) {
            null === this.tempTimestamp && (this.tempTimestamp = p());
            var t = p(), i = t - this.tempTimestamp, r = this._parseAudioMsg(e);
            this.log(this.tag, `'send talk msg and diff is ${i} and byteLength is ${r.byteLength} and length is ${r.length}, and g711 length is ` + e.length), k(this._opt.saveRtpToFile) && "rtp" === this._opt.packetType && this.addRtpToBuffer(r), r && (this.socketStatusOpen ? this.socket.send(r.buffer) : this.emit(S.tallWebsocketClosedByError)), this.tempTimestamp = t
        }

        _doTalk() {
            this._getUserMedia()
        }

        _getUserMedia() {
            this.log(this.tag, "getUserMedia"), void 0 === window.navigator.mediaDevices && (window.navigator.mediaDevices = {}), void 0 === window.navigator.mediaDevices.getUserMedia && (this.log(this.tag, "window.navigator.mediaDevices.getUserMedia is undefined and init function"), window.navigator.mediaDevices.getUserMedia = function (i) {
                var r = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
                return r ? new Promise(function (e, t) {
                    r.call(navigator, i, e, t)
                }) : Promise.reject(new Error("getUserMedia is not implemented in this browser"))
            }), this._opt.checkGetUserMediaTimeout && this._startCheckGetUserMediaTimeout(), window.navigator.mediaDevices.getUserMedia({
                audio: this._opt.audioConstraints,
                video: !1
            }).then(e => {
                this.log(this.tag, "getUserMedia success"), this.userMediaStream = e, this.mediaStreamSource = this.audioContext.createMediaStreamSource(e), this.mediaStreamSource.connect(this.biquadFilter), this.recorder ? (this.biquadFilter.connect(this.recorder), this.recorder.connect(this.gainNode)) : this.workletRecorder && (this.biquadFilter.connect(this.workletRecorder), this.workletRecorder.connect(this.gainNode)), this.gainNode.connect(this.audioContext.destination), this.emit(w.talkGetUserMediaSuccess), null === e.oninactive && (e.oninactive = e => {
                    this._handleStreamInactive(e)
                })
            }).catch(e => {
                this.error(this.tag, "getUserMedia error", e.toString()), this.emit(w.talkGetUserMediaFail, e.toString())
            }).finally(() => {
                this.log(this.tag, "getUserMedia finally"), this._stopCheckGetUserMediaTimeout()
            })
        }

        _getUserMedia2() {
            this.log(this.tag, "getUserMedia"), navigator.mediaDevices ? navigator.mediaDevices.getUserMedia({audio: !0}).then(e => {
                this.log(this.tag, "getUserMedia2 success")
            }) : navigator.getUserMedia({audio: !0}, this.log(this.tag, "getUserMedia2 success"), this.log(this.tag, "getUserMedia2 fail"))
        }

        async _getUserMedia3() {
            this.log(this.tag, "getUserMedia3");
            try {
                var e = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        latency: !0,
                        noiseSuppression: !0,
                        autoGainControl: !0,
                        echoCancellation: !0,
                        sampleRate: 48e3,
                        channelCount: 1
                    }, video: !1
                });
                console.log("getUserMedia() got stream:", e), this.log(this.tag, "getUserMedia3 success")
            } catch (e) {
                this.log(this.tag, "getUserMedia3 fail")
            }
        }

        _handleStreamInactive(e) {
            this.userMediaStream && (this.warn(this.tag, "stream oninactive", e), this.emit(w.talkStreamInactive))
        }

        _startCheckGetUserMediaTimeout() {
            this._stopCheckGetUserMediaTimeout(), this.checkGetUserMediaTimeout = setTimeout(() => {
                this.log(this.tag, "check getUserMedia timeout"), this.emit(w.talkGetUserMediaTimeout)
            }, this._opt.getUserMediaTimeout)
        }

        _stopCheckGetUserMediaTimeout() {
            this.checkGetUserMediaTimeout && (this.log(this.tag, "stop checkGetUserMediaTimeout"), clearTimeout(this.checkGetUserMediaTimeout), this.checkGetUserMediaTimeout = null)
        }

        _startHeartInterval() {
            this.heartInterval = setInterval(() => {
                this.log(this.tag, "heart interval");
                var e = [35, 36, 0, 0, 0, 0, 0, 0], e = new Uint8Array(e);
                this.socket.send(e.buffer)
            }, 15e3)
        }

        _stopHeartInterval() {
            this.heartInterval && (this.log(this.tag, "stop heart interval"), clearInterval(this.heartInterval), this.heartInterval = null)
        }

        startTalk(i) {
            return new Promise((e, t) => {
                if (!function () {
                    let e = !1;
                    var t = window.navigator;
                    return e = t ? (e = !(!t.mediaDevices || !t.mediaDevices.getUserMedia)) || !!(t.getUserMedia || t.webkitGetUserMedia || t.mozGetUserMedia || t.msGetUserMedia) : e
                }()) return t("not support getUserMedia");
                if (this.wsUrl = i, this._opt.testMicrophone) this._doTalk(); else {
                    if (!this.wsUrl) return t("wsUrl is null");
                    this._createWebSocket().catch(e => {
                        t(e)
                    })
                }
                this.once(w.talkGetUserMediaFail, () => {
                    t("getUserMedia fail")
                }), this.once(w.talkGetUserMediaSuccess, () => {
                    e()
                })
            })
        }

        setVolume(e) {
            e = parseFloat(e).toFixed(2), isNaN(e) || (e = E(e, 0, 1), this.gainNode.gain.value = e)
        }

        getOption() {
            return this._opt
        }

        get volume() {
            return this.gainNode ? parseFloat(100 * this.gainNode.gain.value).toFixed(0) : null
        }
    }

    class Fn {
        constructor(e) {
            this.player = e, this.globalSetting = null;
            e = Ut();
            this.defaultSettings = {
                watermark_id: "JessibucaPro_" + e,
                watermark_prefix: "JessibucaPro_mask_" + e,
                watermark_txt: "JessibucaPro 测试水印",
                watermark_x: 0,
                watermark_y: 0,
                watermark_rows: 0,
                watermark_cols: 0,
                watermark_x_space: 0,
                watermark_y_space: 0,
                watermark_font: "微软雅黑",
                watermark_color: "black",
                watermark_fontsize: "18px",
                watermark_alpha: .15,
                watermark_width: 150,
                watermark_height: 100,
                watermark_angle: 15,
                watermark_parent_width: 0,
                watermark_parent_height: 0,
                watermark_parent_node: null
            }, this.player.debug.log("Watermark", "int")
        }

        destroy() {
            this._removeMark(), this.globalSetting = null, this.defaultSettings = {
                watermark_id: "",
                watermark_prefix: "",
                watermark_txt: "JessibucaPro 测试水印",
                watermark_x: 0,
                watermark_y: 0,
                watermark_rows: 0,
                watermark_cols: 0,
                watermark_x_space: 0,
                watermark_y_space: 0,
                watermark_font: "微软雅黑",
                watermark_color: "black",
                watermark_fontsize: "18px",
                watermark_alpha: .15,
                watermark_width: 150,
                watermark_height: 100,
                watermark_angle: 15,
                watermark_parent_width: 0,
                watermark_parent_height: 0,
                watermark_parent_node: null
            }, this.player.debug.log("Watermark", "destroy")
        }

        remove() {
            this._removeMark()
        }

        load(e) {
            this.globalSetting = e, this._loadMark(e)
        }

        resize() {
            this.globalSetting && this._loadMark(this.globalSetting)
        }

        _loadMark() {
            let e = this.defaultSettings;
            if (1 === arguments.length && "object" == typeof arguments[0]) {
                var t, i = arguments[0] || {};
                for (t in i) i[t] && e[t] && i[t] === e[t] || !i[t] && 0 !== i[t] || (e[t] = i[t])
            }
            var r = document.getElementById(e.watermark_id),
                s = (r && r.parentNode && r.parentNode.removeChild(r), "string" == typeof e.watermark_parent_node ? document.getElementById(e.watermark_parent_node) : e.watermark_parent_node),
                r = s || document.body, a = r.getBoundingClientRect(),
                n = Math.max(r.scrollWidth, r.clientWidth, a.width),
                o = Math.max(r.scrollHeight, r.clientHeight, a.height), a = arguments[0] || {},
                a = ((a.watermark_parent_width || a.watermark_parent_height) && r && (e.watermark_x = e.watermark_x + 0, e.watermark_y = e.watermark_y + 0), document.getElementById(e.watermark_id)),
                l = null;
            a ? a.shadowRoot && (l = a.shadowRoot) : ((a = document.createElement("div")).id = e.watermark_id, a.setAttribute("style", "pointer-events: none !important; display: block !important"), l = "function" == typeof a.attachShadow ? a.attachShadow({mode: "open"}) : a, (h = r.children)[c = Math.floor(Math.random() * (h.length - 1))] ? r.insertBefore(a, h[c]) : r.appendChild(a)), e.watermark_cols = parseInt((n - e.watermark_x) / (e.watermark_width + e.watermark_x_space));
            var d, h = parseInt((n - e.watermark_x - e.watermark_width * e.watermark_cols) / e.watermark_cols);
            e.watermark_x_space = h && e.watermark_x_space, e.watermark_rows = parseInt((o - e.watermark_y) / (e.watermark_height + e.watermark_y_space));
            var c = parseInt((o - e.watermark_y - e.watermark_height * e.watermark_rows) / e.watermark_rows);
            e.watermark_y_space = c && e.watermark_y_space;
            for (var u = s ? (d = e.watermark_x + e.watermark_width * e.watermark_cols + e.watermark_x_space * (e.watermark_cols - 1), e.watermark_y + e.watermark_height * e.watermark_rows + e.watermark_y_space * (e.watermark_rows - 1)) : (d = 0 + e.watermark_x + e.watermark_width * e.watermark_cols + e.watermark_x_space * (e.watermark_cols - 1), 0 + e.watermark_y + e.watermark_height * e.watermark_rows + e.watermark_y_space * (e.watermark_rows - 1)), p = 0; p < e.watermark_rows; p++) for (var f = s ? 0 + e.watermark_y + (o - u) / 2 + (e.watermark_y_space + e.watermark_height) * p : e.watermark_y + (o - u) / 2 + (e.watermark_y_space + e.watermark_height) * p, m = 0; m < e.watermark_cols; m++) {
                var g = s ? 0 + e.watermark_x + (n - d) / 2 + (e.watermark_width + e.watermark_x_space) * m : e.watermark_x + (n - d) / 2 + (e.watermark_width + e.watermark_x_space) * m,
                    y = document.createElement("div"), A = document.createTextNode(e.watermark_txt);
                y.appendChild(A), y.id = e.watermark_prefix + p + m, y.style.webkitTransform = "rotate(-" + e.watermark_angle + "deg)", y.style.MozTransform = "rotate(-" + e.watermark_angle + "deg)", y.style.msTransform = "rotate(-" + e.watermark_angle + "deg)", y.style.OTransform = "rotate(-" + e.watermark_angle + "deg)", y.style.transform = "rotate(-" + e.watermark_angle + "deg)", y.style.visibility = "", y.style.position = "absolute", y.style.left = g + "px", y.style.top = f + "px", y.style.overflow = "hidden", y.style.zIndex = "9999999", y.style.opacity = e.watermark_alpha, y.style.fontSize = e.watermark_fontsize, y.style.fontFamily = e.watermark_font, y.style.color = e.watermark_color, y.style.textAlign = "center", y.style.width = e.watermark_width + "px", y.style.height = e.watermark_height + "px", y.style.display = "block", y.style["-ms-user-select"] = "none", l.appendChild(y)
            }
        }

        _removeMark() {
            var e, t = this.defaultSettings, t = document.getElementById(t.watermark_id);
            t && (e = t.parentNode) && e.removeChild(t)
        }
    }

    const Mn = {
            stop: 0,
            fiStop: 0,
            right: 1,
            left: 2,
            up: 8,
            down: 4,
            leftUp: 10,
            leftDown: 6,
            rightUp: 9,
            rightDown: 5,
            zoomExpand: 16,
            zoomNarrow: 32,
            apertureFar: 72,
            apertureNear: 68,
            focusFar: 66,
            focusNear: 65,
            setPos: 129,
            calPos: 130,
            delPos: 131,
            wiperOpen: 140,
            wiperClose: 141
        }, On = [25, 50, 75, 100, 125, 150, 175, 200, 225, 250], Nn = [1, 2, 3, 4, 5, 6, 7, 8, 9, 16],
        jn = [16, 48, 80, 112, 144, 160, 176, 192, 208, 224];
    const zn = ["Boolean", "Number", "String", "Undefined", "Null", "Date", "Object"];

    function Gn(e, t, i) {
        i = i || 1, t = t || 2;
        const r = {};
        if (!e || "object" != typeof e) return e;
        const s = Object.prototype.toString.call(e).slice(8, -1);
        if (!zn.includes(s)) return s;
        if (!(t < i)) {
            for (const s in e) Object.prototype.hasOwnProperty.call(e, s) && (i === t ? r[s] = function (e) {
                if ("object" != typeof e) return e;
                var t = Object.prototype.toString.call(e).slice(8, -1);
                switch (t) {
                    case"Array":
                    case"Uint8Array":
                    case"ArrayBuffer":
                        return t + "[" + e.length + "]";
                    case"Object":
                        return "{}";
                    default:
                        return t
                }
            }(e[s]) : "object" == typeof e[s] ? r[s] = Gn(e[s], t, i + 1) : r[s] = e[s]);
            return r
        }
    }

    function Hn() {
        return (new Date).toLocaleString()
    }

    class Wn {
        constructor(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            this.player = e, this.logMaxSize = (null == t ? void 0 : t.logMaxSize) || 204800, this.logSize = 0, this.logTextArray = []
        }

        destroy() {
            this.clear()
        }

        clear() {
            this.logSize = 0, this.logTextArray = []
        }

        logCache() {
            let e = "";
            try {
                for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
                var s = i.map(e => Gn(e));
                e = "[JbPro] " + Hn() + JSON.stringify(s)
            } catch (e) {
                return
            }
            if (this.logSize += e.length, this.logTextArray.push(e), this.logSize > this.logMaxSize) {
                const e = this.logTextArray.shift();
                this.logSize -= e.length
            }
        }

        download() {
            var e = this.logTextArray.join("\n"), e = (this.clear(), new Blob([e], {type: "text/plain"}));
            Li(e, "JbPro-" + Hn() + ".log")
        }
    }

    class Vn extends e {
        constructor() {
            let t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            super(), this._opt = {}, Object.keys(t).forEach(e => {
                if (void 0 === t[e]) throw new Error(`JbPro option "${e}" can not be undefined`)
            }), this.originalOptions = t;
            var e, i = hi();
            let r = Object.assign({}, i, t),
                s = (r.url = "", r.isMulti && (r.debugUuid = "xxxx".replace(/[xy]/g, function (e) {
                    var t = 16 * Math.random() | 0;
                    return ("x" == e ? t : 3 & t | 8).toString(16)
                })), this.debug = new ut(this), t.container);
            if (!(s = "string" == typeof t.container ? document.querySelector(t.container) : s)) throw this.debug.error("JbPro", "JbPro need container option and now container is", t.container), new Error("JbPro need container option");
            if ("CANVAS" === s.nodeName || "VIDEO" === s.nodeName) throw this.debug.error("JbPro", `JbPro container type can not be ${s.nodeName} type`), new Error(`JbPro container type can not be ${s.nodeName} type`);
            if (r.videoBuffer >= r.heartTimeout) throw this.debug.error("JbPro", `JbPro videoBuffer ${r.videoBuffer}s must be less than heartTimeout ${r.heartTimeout}s`), new Error(`JbPro videoBuffer ${r.videoBuffer}s must be less than heartTimeout ${r.heartTimeout}s`);
            if (this._checkHasCreated(s)) throw this.debug.error("JbPro", "JbPro container has been created and can not be created again", s), new Error("JbPro container has been created and can not be created again", s);
            if (s.classList.add("jessibuca-container"), i = s, ie, e = Ut(), i && (i.dataset ? i.dataset.jbprov = e : i.setAttribute("data-jbprov", e)), C(r.isLive)) {
                const t = document.createElement("video");
                return t.muted = !0, t.setAttribute("controlsList", "nodownload"), t.disablePictureInPicture = "disablePictureInPicture", t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.height = "100%", t.style.width = "100%", s.appendChild(t), this.$videoElement = t, this.$container = s, void (this._opt = r)
            }
            delete r.container, x(r.videoBuffer) && (r.videoBuffer = 1e3 * Number(r.videoBuffer)), x(r.videoBufferDelay) && (r.videoBufferDelay = 1e3 * Number(r.videoBufferDelay)), x(r.networkDelay) && (r.networkDelay = 1e3 * Number(r.networkDelay)), x(r.timeout) && (c(r.loadingTimeout) && (r.loadingTimeout = r.timeout), c(r.heartTimeout) && (r.heartTimeout = r.timeout)), this._opt = r, this._destroyed = !1, this.$container = s, this._tempPlayBgObj = {}, this._loadingTimeoutReplayTimes = 0, this._heartTimeoutReplayTimes = 0, this.events = new gi(this), this.watermark = new Fn(this), this.memoryLogger = new Wn(this), this._initPlayer(s, r), this._initWatermark(), this.debug.log("JbPro", 'init success and version is "8-23-2023"'), console.log('JbPro version is "8-23-2023"')
        }

        destroy() {
            return new Promise((e, t) => {
                this.debug.log("JbPro", "destroy()"), this._destroyed = !0, this.off(), this.$videoElement && (this.$videoElement.pause(), this.$videoElement.currentTime = 0, this.$videoElement.srcObject && (this.$videoElement.srcObject = null, this.$videoElement.removeAttribute("srcObject")), this.$videoElement.src && (this.$videoElement.src = "", this.$videoElement.removeAttribute("src")), this.$container && this.$container.removeChild(this.$videoElement), this.$videoElement = null), this.player ? this.player.destroy().then(() => {
                    this.player = null, this._destroy(), setTimeout(() => {
                        e()
                    }, 0)
                }).catch(() => {
                    t()
                }) : (this._destroy(), setTimeout(() => {
                    e()
                }, 0))
            })
        }

        _destroy() {
            var e;
            this.events && (this.events.destroy(), this.events = null), this.talk && (this.talk.destroy(), this.talk = null), this.watermark && (this.watermark.destroy(), this.watermark = null), this.memoryLogger && (this.memoryLogger.destroy(), this.memoryLogger = null), this.$container && (this.$container.classList.remove("jessibuca-container"), e = this.$container, ie, e && (e.dataset ? delete e.dataset.jbprov : e.removeAttribute("data-jbprov")), this.$container = null), this.debug && this.debug.log("JbPro", "destroy end"), this._resetOpt(), this._tempPlayBgObj = null, this._loadingTimeoutReplayTimes = 0, this._heartTimeoutReplayTimes = 0
        }

        _resetOpt() {
            this._opt = hi()
        }

        _getOriginalOpt() {
            var e = hi();
            return Object.assign({}, e, this.originalOptions)
        }

        _initPlayer(e, t) {
            this.player = new In(e, t), this._bindEvents()
        }

        _initTalk() {
            let e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            this.talk && (this.talk.destroy(), this.talk = null), this.player && (e.debug = this.player._opt.debug), this.talk = new Un(this.player, e), this.debug.log("JbPro", "_initTalk", this.talk.getOption()), this._bindTalkEvents()
        }

        _resetPlayer() {
            let r = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            return new Promise((e, t) => {
                const i = () => {
                    this._opt.url = "", this._opt.playOptions = {}, this._opt = Object.assign(this._opt, r), this._initPlayer(this.$container, this._opt)
                };
                this.player ? this.player.destroy().then(() => {
                    this.player = null, i(), setTimeout(() => {
                        e()
                    }, 0)
                }) : (i(), setTimeout(() => {
                    e()
                }, 0))
            })
        }

        _bindEvents() {
            var s = this;
            Object.keys(fe).forEach(r => {
                this.player.on(fe[r], function () {
                    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                    s.emit(r, ...t)
                })
            }), this.player.once(w.beforeDestroy, () => {
                this.emit(w.close), this.destroy().then(() => {
                }).catch(e => {
                })
            }), this.player.on(w.resize, () => {
                this.watermark && this.watermark.resize(), this.player && this.player.singleWatermark && this.player.singleWatermark.resize()
            }), this.player.on(w.fullscreen, () => {
                this.watermark && this.watermark.resize(), this.player && this.player.singleWatermark && this.player.singleWatermark.resize()
            }), this.player.on(w.videoInfo, () => {
                this.player && this.player.singleWatermark && this.player.singleWatermark.resize()
            }), this.player.on(w.memoryLog, function () {
                s.memoryLogger.logCache(...arguments)
            }), this.player.on(w.downloadMemoryLog, () => {
                this.downloadMemoryLog()
            })
        }

        _bindTalkEvents() {
            Object.keys(me).forEach(t => {
                this.player.on(me[t], e => {
                    this.emit(t, e)
                })
            })
        }

        _initWatermark() {
            var e;
            this._opt.fullscreenWatermarkConfig.text = decodeURIComponent("JessibucaPro%20%E4%BD%93%E9%AA%8C"), this._opt.fullscreenWatermarkConfig.color = "white", Qt(this._opt.fullscreenWatermarkConfig) && ((e = Vt(this.$container, this._opt.fullscreenWatermarkConfig)).watermark_txt ? this.watermark.load(e) : this.debug.warn("JbPro", "fullscreenWatermarkConfig text is empty"))
        }

        _checkHasCreated(e) {
            return !!e && (e = e, ie, !!(e ? e.dataset ? e.dataset.jbprov : e.getAttribute("data-jbprov") : ""))
        }

        isDestroyed() {
            return this._destroyed
        }

        getOption() {
            return this.player ? this.player.getOption() : {}
        }

        setDebug(e) {
            this.debug.log("JbPro", "setDebug() " + e), this._opt.debug = !!e, this.player ? this.player.updateOption({debug: !!e}, !0) : this.debug.warn("JbPro", "player is not init")
        }

        getIsDebug() {
            let e = !1;
            return e = this.player ? this.player._opt.debug : e
        }

        mute() {
            this.debug.log("JbPro", "mute()"), this.player && this.player.mute(!0)
        }

        cancelMute() {
            this.debug.log("JbPro", "cancelMute()"), this.player && this.player.mute(!1)
        }

        setVolume(e) {
            this.debug.log("JbPro", "setVolume() " + e), this.player && (this.player.volume = e)
        }

        getVolume() {
            let e = null;
            return this.player && (e = this.player.volume, e = parseFloat(e).toFixed(2)), e
        }

        audioResume() {
            this.debug.log("JbPro", "audioResume()"), this.player && this.player.audio ? this.player.audio.audioEnabled(!0) : this.debug.warn("JbPro", "audioResume error")
        }

        setTimeout(e) {
            this.debug.log("JbPro", "setTimeout() " + e), e = Number(e), isNaN(e) ? this.debug.warn("JbPro", `setTimeout error: ${e} is not a number`) : (this._opt.timeout = e, this._opt.loadingTimeout = e, this._opt.heartTimeout = e, this.player && this.player.updateOption({
                timeout: e,
                loadingTimeout: e,
                heartTimeout: e
            }))
        }

        setScaleMode(e) {
            this.debug.log("JbPro", "setScaleMode() " + e), this.player ? this.player.setScaleMode(e) : this.debug.warn("JbPro", "setScaleMode() player is null")
        }

        pause() {
            let e = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            return new Promise((t, i) => {
                this.debug.log("JbPro", "pause() " + e), this._opt.pauseAndNextPlayUseLastFrameShow && (this._tempPlayBgObj = this._getVideoLastIframeInfo()), this._pause(e).then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                })
            })
        }

        _pause() {
            let e = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            return new Promise((t, i) => {
                if (this.debug.log("JbPro", "_pause() " + e), this.isDestroyed()) return i("JbPro is destroyed");
                this.player ? this.player.pause(e).then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                }) : i("player is null")
            })
        }

        close() {
            return new Promise((e, t) => {
                this.debug.log("JbPro", "close()"), this._opt.url = "", this._loadingTimeoutReplayTimes = 0, this._heartTimeoutReplayTimes = 0, this.player ? this.player.close().then(() => {
                    e()
                }).catch(e => {
                    t(e)
                }) : t("player is null")
            })
        }

        clearView() {
            this.debug.log("JbPro", "clearView()"), this.player && this.player.video ? this.getRenderType() === Y ? this.player.video.clearView() : this.debug.warn("JbPro", "clearView", "render type is video, not support clearView, please use canvas render type") : this.debug.warn("JbPro", "clearView", "player is null")
        }

        play() {
            let a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
                n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            return new Promise((i, r) => {
                if (this.debug.log("JbPro", "play() " + a, JSON.stringify(n)), !a && !this._opt.url) return this.emit(w.error, S.playError), void r("url is null and this._opt.url is null");
                if (a && (-1 === (a = ("" + a).trim()).indexOf("http:") && -1 === a.indexOf("https:") && -1 === a.indexOf("webrtc:") && -1 === a.indexOf("ws:") && -1 === a.indexOf("wss:") && -1 === a.indexOf("wt:"))) return r(`url ${a} must be "http:" or "https:" or "webrtc:" or "ws:" or "wss：" or "wt:" protocol`);
                if (C(this._opt.isLive)) return this.$videoElement.controls = "controls", this.$videoElement.muted = !1, this.$videoElement.src = a, this.$videoElement.play(), void i(this.$videoElement);
                if (this._opt.isCrypto) {
                    var e, t = n.cryptoKey || this._opt.playOptions.cryptoKey,
                        s = n.cryptoIV || this._opt.playOptions.cryptoIV;
                    if (!t || !s) return e = a || this._opt.url, void this._cryptoPlay(e).then(e => {
                        var {cryptoIV: e, cryptoKey: t} = e;
                        this._opt.playOptions.cryptoKey = t, this._opt.playOptions.cryptoIV = e, n.cryptoIV = e, n.cryptoKey = t, this._playBefore(a, n).then(() => {
                            i()
                        }).catch(e => {
                            r(e)
                        })
                    }).catch(e => {
                        r(e)
                    });
                    this._opt.playOptions.cryptoKey = t, this._opt.playOptions.cryptoIV = s, n.cryptoIV = s, n.cryptoKey = t
                }
                this._playBefore(a, n).then(() => {
                    i()
                }).catch(e => {
                    r(e)
                })
            })
        }

        _playBefore(r, s) {
            return new Promise((t, i) => {
                var e;
                this.player ? r ? this._opt.url ? r === this._opt.url ? this.player.playing ? (this.debug.log("JbPro", "_playBefore", "playing and resolve()"), t()) : (this.debug.log("JbPro", "_playBefore", "this._opt.url === url and pause ->  play"), e = this._opt.playOptions, this._opt.pauseAndNextPlayUseLastFrameShow && this._tempPlayBgObj && this._tempPlayBgObj.loadingBackground && this.player.updateOption({...this._tempPlayBgObj}), this.player.play(this._opt.url, e).then(() => {
                    t(), this.player.resumeAudioAfterPause()
                }).catch(e => {
                    this.debug.error("JbPro", "_playBefore this.player.play error", e), this.emit(w.crashLog, this.getCrashLog("this.player.play 1", e)), this.player.pause().then(() => {
                        i(e)
                    })
                })) : (this.debug.log("JbPro", "_playBefore", `
                            this._url.url is ${this._opt.url}
                            and new url is ${r}
                            and destroy and play new url`), this._pause().then(() => {
                    var e = this._getOriginalOpt();
                    this._resetPlayer(e).then(() => {
                        this._play(r, s).then(() => {
                            t()
                        }).catch(e => {
                            this.debug.error("JbPro", "_play error", e), this.emit(w.crashLog, this.getCrashLog("this.player.play 2", e)), i(e)
                        })
                    }).catch(() => {
                    })
                }).catch(e => {
                    this.debug.error("JbPro", "this.player.pause error", e), i(e)
                })) : this._play(r, s).then(() => {
                    t()
                }).catch(e => {
                    this.debug.error("JbPro", "_play error", e), this.emit(w.crashLog, this.getCrashLog("this.player.play 3", e)), i(e)
                }) : this.player.play(this._opt.url, this._opt.playOptions).then(() => {
                    t(), this.player.resumeAudioAfterPause()
                }).catch(e => {
                    this.debug.error("JbPro", "this.player.play error", e), this.emit(w.crashLog, this.getCrashLog("this.player.play 4", e)), this.player.pause().then(() => {
                        i(e)
                    })
                }) : r ? this._play(r, s).then(() => {
                    t()
                }).catch(e => {
                    this.debug.error("JbPro", "_play error", e), this.emit(w.crashLog, this.getCrashLog("this.player.play 5", e)), i(e)
                }) : this._play(this._opt.url, this._opt.playOptions).then(() => {
                    t()
                }).catch(e => {
                    this.debug.error("JbPro", "_play error", e), this.emit(w.crashLog, this.getCrashLog("this.player.play 6", e)), i(e)
                })
            })
        }

        _cryptoPlay(n) {
            return new Promise((r, s) => {
                var e, t = function () {
                    const e = (n || document.location.toString()).split("//"), t = e[1].indexOf("/");
                    let i = e[1].substring(t);
                    return i = -1 != i.indexOf("?") ? i.split("?")[0] : i
                }();
                let i = this._opt.cryptoKeyUrl, a = "";
                if (i) a = i; else {
                    const r = function (e) {
                        const t = /(msie|trident)/i.test(navigator.userAgent), i = document.createElement("a");
                        let r = e;
                        return t && (i.setAttribute("href", r), r = i.href), i.setAttribute("href", r), {
                            origin: i.origin,
                            href: i.href,
                            protocol: i.protocol ? i.protocol.replace(/:$/, "") : "",
                            host: i.host,
                            search: i.search ? i.search.replace(/^\?/, "") : "",
                            hash: i.hash ? i.hash.replace(/^#/, "") : "",
                            hostname: i.hostname,
                            port: i.port,
                            pathname: "/" === i.pathname.charAt(0) ? i.pathname : "/" + i.pathname
                        }
                    }(n);
                    i = r.origin + "/crypto/", a = i + "?stream=" + t
                }
                e = a, new Promise((t, i) => {
                    Xr.get(e).then(e => {
                        t(e)
                    }).catch(e => {
                        i(e)
                    })
                }).then(e => {
                    if (e) {
                        const t = e.split("."), i = li(t[0]), a = li(t[1]);
                        a && i ? r({cryptoIV: a, cryptoKey: i}) : s("get cryptoIV or cryptoKey error")
                    } else s(`cryptoKeyUrl: getM7SCryptoStreamKey ${a} res is null`)
                }).catch(e => {
                    s(e)
                })
            })
        }

        playback(s) {
            let a = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            return new Promise((e, t) => {
                if (this.debug.log("JbPro", "playback() " + s), C(this._opt.isLive)) return t("this._opt.isLive is false, can not playback");
                const i = ci(), r = Object.assign({}, i.playbackConfig, this._opt.playbackConfig, a);
                r.isUseFpsRender || r.isCacheBeforeDecodeForFpsRender && (r.isCacheBeforeDecodeForFpsRender = !1, this.debug.warn("JbPro", "playbackConfig.isUseFpsRender is false, isCacheBeforeDecodeForFpsRender can not be ture, isCacheBeforeDecodeForFpsRender is set to false")), 0 === r.rateConfig.length && r.showRateBtn && (r.showRateBtn = !1, this.debug.warn("JbPro", "playbackConfig.rateConfig.length is 0, showRateBtn can not be ture, showRateBtn is set to false")), r.controlType, this._resetPlayer({
                    videoBuffer: 0,
                    playbackConfig: r,
                    playType: A,
                    openWebglAlignment: !0,
                    useMSE: !1,
                    useWCS: r.useWCS,
                    useSIMD: !0
                }).then(() => {
                    this.play(s, a).then(() => {
                        e()
                    }).catch(e => {
                        t(e)
                    })
                }).catch(e => {
                    t(e)
                })
            })
        }

        playbackPause() {
            let i = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            return this.debug.log("JbPro", "playbackPause() " + i), this._opt.playType === n ? Promise.reject("playType is player, can not call playbackPause method") : new Promise((e, t) => {
                if (!this.player) return t("player is null");
                k(i) ? this._pause().then(() => {
                    e()
                }).catch(e => {
                    t(e)
                }) : (this.player.playbackPause = !0, e())
            })
        }

        playbackResume() {
            return this.debug.log("JbPro", "playbackResume()"), this._opt.playType === n ? Promise.reject("playType is player, can not call playbackResume method") : new Promise((e, t) => {
                if (!this.player) return t();
                this.player.playbackPause = !1, e()
            })
        }

        forward(i) {
            return this.debug.log("JbPro", "forward() " + i), C(this._opt.isLive) || this._opt.playType === n ? Promise.reject("forward() method only just for playback type") : h(Number(i)) ? new Promise((e, t) => {
                this.player ? (i = E(Number(i), .1, 32), this.player.decoderWorker && this.player.decoderWorker.updateWorkConfig({
                    key: "playbackRate",
                    value: i
                }), this.player.playback.setRate(i), this.player.video && this.player.video.setRate(i), this.player.audio && this.player.audio.setRate(i), this.player.isPlaybackUseWCS() && (this.player.demux.dropBuffer$2(), this.player.isPlaybackCacheBeforeDecodeForFpsRender() && this.player.demux.initPlaybackCacheLoop()), e()) : t("player is not playing")
            }) : Promise.reject(`forward() params "rate": ${i} must be number type`)
        }

        playbackForward(e) {
            return this.forward(e)
        }

        normal() {
            return this.forward(1)
        }

        playbackNormal() {
            return this.normal()
        }

        updatePlaybackForwardMaxRateDecodeIFrame(e) {
            this.debug.log("JbPro", "updatePlaybackForwardMaxRateDecodeIFrame() " + e), e = Number(e), e = E(e = parseInt(e, 10), 1, 8), this._opt.playbackForwardMaxRateDecodeIFrame = e, this.player ? this.player.updateOption({playbackForwardMaxRateDecodeIFrame: e}, !0) : this.debug.warn("JbPro", "updatePlaybackForwardMaxRateDecodeIFrame() player is null")
        }

        setPlaybackStartTime(e) {
            this.debug.log("JbPro", "setPlaybackStartTime() " + e);
            var t = Jt(e);
            this.player ? this.player.isPlayback() ? t < 10 && 0 !== e && this.player.playback.isControlTypeNormal() ? this.debug.warn("JbPro", `setPlaybackStartTime() control type is normal and  timestamp: ${e} is not valid`) : this.player.playback.isControlTypeSimple() && e > this.player.playback.totalDuration ? this.debug.warn("JbPro", `setPlaybackStartTime() control type is simple and timestamp: ${e} is more than ` + this.player.playback.totalDuration) : this.player.playing && (this.player.playback.isControlTypeNormal() && 10 === t && (e *= 1e3), this.player.playback.setStartTime(e), this.playbackClearCacheBuffer()) : this.debug.warn("JbPro", "setPlaybackStartTime() playType is not playback") : this.debug.warn("JbPro", "setPlaybackStartTime() player is null")
        }

        setPlaybackShowPrecision(e) {
            this.debug.log("JbPro", "setPlaybackShowPrecision() " + e), this.player ? this.player.isPlayback() ? this.player.playback.isControlTypeNormal() ? this.player.playback.setShowPrecision(e) : this.debug.warn("JbPro", "control type is not normal , not support!") : this.debug.warn("JbPro", "playType is not playback") : this.debug.warn("JbPro", "player is null")
        }

        playbackCurrentTimeScroll() {
            this.debug.log("JbPro", "playbackCurrentTimeScroll()"), this.player ? this.player.isPlayback() ? this.player.playback.isControlTypeNormal() ? this.player.playback.currentTimeScroll() : this.debug.warn("JbPro", "control type is not normal , not support!") : this.debug.warn("JbPro", "playType is not playback") : this.debug.warn("JbPro", "player is null")
        }

        playbackClearCacheBuffer() {
            this.debug.log("JbPro", "playbackClearCacheBuffer()"), this.player ? this.player.isPlayback() ? (this.player.video && this.player.video.clear(), this.player.audio && this.player.audio.clear(), this.player.decoderWorker.clearWorkBuffer(!0)) : this.debug.warn("JbPro", "playType is not playback") : this.debug.warn("JbPro", "player is null")
        }

        getPlaybackCurrentRate() {
            if (this.player) {
                if (this.player.isPlayback()) return this.player.getPlaybackRate();
                this.debug.warn("JbPro", "playType is not playback")
            } else this.debug.warn("JbPro", "player is null")
        }

        updatePlaybackLocalOneFrameTimestamp(e) {
            this.debug.log("JbPro", "updatePlaybackLocalOneFrameTimestamp() " + e), this.player ? this.player.isPlayback() ? this.player.playback.updateLocalOneFrameTimestamp(e) : this.debug.warn("JbPro", "playType is not playback") : this.debug.warn("JbPro", "player is null")
        }

        setStreamQuality(e) {
            this.debug.log("JbPro", "setStreamQuality() " + e), this.player ? this.player._opt.operateBtns.quality ? (this.player._opt.qualityConfig || []).includes(e) ? this.player.streamQuality = e : this.debug.warn("JbPro", `quality: ${e} is not in qualityList`) : this.debug.warn("JbPro", "player._opt.operateBtns.quality is false") : this.debug.warn("JbPro", "player is null")
        }

        _play() {
            let m = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
                g = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            return new Promise((e, t) => {
                if (!this.player) return t("player is null");
                let i = !1;
                this._opt.url && this._opt.url !== m && (i = !0), this._opt.url = m, this._opt.playOptions = g;
                var r = 0 === m.indexOf("http"), s = 0 === m.indexOf("webrtc"), a = 0 === m.indexOf("wt:"),
                    n = !s && -1 !== m.indexOf(".m3u8"), o = !s && -1 !== m.indexOf(".flv"),
                    l = !s && -1 !== m.indexOf(".fmp4") || !s && -1 !== m.indexOf(".mp4"),
                    d = !s && -1 !== m.indexOf(".mpeg4"),
                    h = !s && -1 !== m.indexOf(".h264") || !s && -1 !== m.indexOf(".h265");
                let c = this._opt.isWebrtcForZLM || !1, u = this._opt.isWebrtcForSRS || !1,
                    p = this._opt.isWebrtcForOthers || !1;
                s && (-1 !== m.indexOf("/index/api/webrtc") ? (c = !0, u = !1, p = !1) : -1 !== m.indexOf("/rtc/v1/play/") && (u = !0, c = !1, p = !1));
                if (o && !this._opt.isFlv && this._resetDemuxType("isFlv"), l && !this._opt.isFmp4 && this._resetDemuxType("isFmp4"), d && !this._opt.isMpeg4 && this._resetDemuxType("isMpeg4"), h && !this._opt.isNakedFlow && this._resetDemuxType("isNakedFlow"), l = r ? n ? 3 : 2 : a ? 5 : s ? 4 : 1, h = this._opt.isNakedFlow ? V : this._opt.isFmp4 ? K : this._opt.isMpeg4 ? $ : r && !n || o || this._opt.isFlv ? H : n ? "hls" : s ? "webrtc" : a ? W : "m7s", !l || !h) return t(`play protocol is ${l}, demuxType is ` + h);
                const f = () => {
                    this.player.once(S.webglAlignmentError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.webglAlignmentError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.webglAlignmentErrorReplay) {
                                this.debug.log("JbPro", "webglAlignmentError");
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer({openWebglAlignment: !0}).then(() => {
                                    this.play(e, t).then(() => {
                                        this.debug.log("JbPro", "webglAlignmentError and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.webglAlignmentError), this.debug.error("JbPro", "webglAlignmentError and play error", e)
                                    })
                                }).catch(e => {
                                    this.debug.error("JbPro", "webglAlignmentError and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.webglAlignmentError), this.debug.log("JbPro", "webglAlignmentError and webglAlignmentErrorReplay is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.webglAlignmentError), this.debug.error("JbPro", "webglAlignmentError and pause error", e)
                        })
                    }), this.player.once(S.webglContextLostError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.webglContextLostError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.webglContextLostErrorReplay) {
                                this.debug.log("JbPro", "webglContextLostError");
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "webglContextLostError and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.webglContextLostError), this.debug.error("JbPro", "webglContextLostError and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.webglContextLostError), this.debug.error("JbPro", "webglContextLostError and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.webglContextLostError), this.debug.log("JbPro", "webglContextLostError and webglContextLostErrorReplay is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.webglContextLostError), this.debug.error("JbPro", "webglAlignmentError and pause error", e)
                        })
                    }), this.player.once(S.mediaSourceH265NotSupport, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceH265NotSupport, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.autoWasm) {
                                this.debug.log("JbPro", "mediaSourceH265NotSupport auto wasm [mse-> wasm] reset player and play");
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer({useMSE: !1, useWCS: !1}).then(() => {
                                    this.play(e, t).then(() => {
                                        this.debug.log("JbPro", "mediaSourceH265NotSupport auto wasm [mse-> wasm] reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mediaSourceH265NotSupport), this.debug.error("JbPro", "mediaSourceH265NotSupport auto wasm [mse-> wasm] reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mediaSourceH265NotSupport), this.debug.error("JbPro", "mediaSourceH265NotSupport auto wasm [mse-> wasm] _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mediaSourceH265NotSupport), this.debug.log("JbPro", "mediaSourceH265NotSupport and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mediaSourceH265NotSupport), this.debug.error("JbPro", "mediaSourceH265NotSupport and pause error", e)
                        })
                    }), this.player.once(S.mediaSourceFull, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceFull, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.mseDecodeErrorReplay) {
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.autoWasm && (e = {
                                    useMSE: !1,
                                    useWCS: !1
                                }), this.debug.log("JbPro", `mediaSourceFull and auto wasm [mse-> ${this.player._opt.autoWasm ? "wasm" : "mse"}] reset player and play`), this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "mediaSourceFull and reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mediaSourceFull), this.debug.error("JbPro", "mediaSourceFull and reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mediaSourceFull), this.debug.error("JbPro", "mediaSourceFull and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mediaSourceFull), this.debug.log("JbPro", "mediaSourceFull and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mediaSourceFull), this.debug.error("JbPro", "mediaSourceFull and pause error", e)
                        })
                    }), this.player.once(S.mediaSourceAppendBufferError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceAppendBufferError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.mseDecodeErrorReplay) {
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.autoWasm && (e = {
                                    useMSE: !1,
                                    useWCS: !1
                                }), this.debug.log("JbPro", `mediaSourceAppendBufferError and auto wasm [mse-> ${this.player._opt.autoWasm ? "wasm" : "mse"}] reset player and play`), this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "mediaSourceAppendBufferError and reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferError), this.debug.error("JbPro", "mediaSourceAppendBufferError and reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferError), this.debug.error("JbPro", "mediaSourceAppendBufferError and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferError), this.debug.log("JbPro", "mediaSourceAppendBufferError and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferError), this.debug.error("JbPro", "mediaSourceAppendBufferError and pause error", e)
                        })
                    }), this.player.once(S.mediaSourceBufferListLarge, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceBufferListLarge, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.mseDecodeErrorReplay) {
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.autoWasm && (e = {
                                    useMSE: !1,
                                    useWCS: !1
                                }), this.debug.log("JbPro", `media source buffer list large and auto wasm [mse-> ${this.player._opt.autoWasm ? "wasm" : "mse"}] reset player and play`), this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "media source buffer list large and reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mediaSourceBufferListLarge), this.debug.error("JbPro", "media source buffer list large and reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mediaSourceBufferListLarge), this.debug.error("JbPro", "media source buffer list large and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mediaSourceBufferListLarge), this.debug.log("JbPro", "media source buffer list large and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mediaSourceBufferListLarge), this.debug.error("JbPro", "media source buffer list large and pause error", e)
                        })
                    }), this.player.once(S.mediaSourceAppendBufferEndTimeout, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceAppendBufferEndTimeout, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.mseDecodeErrorReplay) {
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.autoWasm && (e = {
                                    useMSE: !1,
                                    useWCS: !1
                                }), this.debug.log("JbPro", `media source append buffer end timeout and auto wasm [mse-> ${this.player._opt.autoWasm ? "wasm" : "mse"}] reset player and play`), this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "media source append buffer end timeout and reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferEndTimeout), this.debug.error("JbPro", "media source append buffer end timeout and reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferEndTimeout), this.debug.error("JbPro", "media source append buffer end timeout and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferEndTimeout), this.debug.log("JbPro", "media source append buffer end timeout and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mediaSourceAppendBufferEndTimeout), this.debug.error("JbPro", "media source append buffer end timeout and pause error", e)
                        })
                    }), this.player.once(S.mseSourceBufferError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mseSourceBufferError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.mseDecodeErrorReplay) {
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.autoWasm && (e = {
                                    useMSE: !1,
                                    useWCS: !1
                                }), this.debug.log("JbPro", `mseSourceBufferError auto wasm [mse-> ${this.player._opt.autoWasm ? "wasm" : "mse"}] reset player and play`), this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "mseSourceBufferError auto wasm [mse-> wasm] reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mseSourceBufferError), this.debug.error("JbPro", "mseSourceBufferError auto wasm [mse-> wasm] reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mseSourceBufferError), this.debug.error("JbPro", "mseSourceBufferError auto wasm [mse-> wasm] _resetPlayer and play error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mseSourceBufferError), this.debug.log("JbPro", "mseSourceBufferError and autoWasm is false")
                        }).catch(e => {
                            this.debug.error("JbPro", "mseSourceBufferError and pause error:", e)
                        })
                    }), this.player.once(S.mseAddSourceBufferError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mseAddSourceBufferError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.autoWasm) {
                                this.debug.log("JbPro", "mseAddSourceBufferError auto wasm [mse-> wasm] reset player and play");
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer({useMSE: !1, useWCS: !1}).then(() => {
                                    this.play(e, t).then(() => {
                                        this.debug.log("JbPro", "mseAddSourceBufferError auto wasm [mse-> wasm] reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mseAddSourceBufferError), this.debug.error("JbPro", "mseAddSourceBufferError auto wasm [mse-> wasm] reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mseAddSourceBufferError), this.debug.error("JbPro", "mseAddSourceBufferError auto wasm [mse-> wasm] _resetPlayer and play error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mseAddSourceBufferError), this.debug.log("JbPro", "mseAddSourceBufferError and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mseAddSourceBufferError), this.debug.error("JbPro", "mseAddSourceBufferError and pause error", e)
                        })
                    }), this.player.once(S.mediaSourceDecoderConfigurationError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceDecoderConfigurationError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.autoWasm) {
                                this.debug.log("JbPro", "mediaSourceDecoderConfigurationError auto wasm [mse-> wasm] reset player and play");
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer({useMSE: !1, useWCS: !1}).then(() => {
                                    this.play(e, t).then(() => {
                                        this.debug.log("JbPro", "mediaSourceDecoderConfigurationError auto wasm [mse-> wasm] reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mediaSourceDecoderConfigurationError), this.debug.error("JbPro", "mediaSourceDecoderConfigurationError auto wasm [mse-> wasm] reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mediaSourceDecoderConfigurationError), this.debug.error("JbPro", "mediaSourceDecoderConfigurationError auto wasm [mse-> wasm] _resetPlayer and play error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mediaSourceDecoderConfigurationError), this.debug.log("JbPro", "mediaSourceDecoderConfigurationError and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mediaSourceDecoderConfigurationError), this.debug.error("JbPro", "mediaSourceDecoderConfigurationError and pause error", e)
                        })
                    }), this.player.once(S.mediaSourceTsIsMaxDiff, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceTsIsMaxDiff, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.mediaSourceTsIsMaxDiffReplay) {
                                this.debug.log("JbPro", "mediaSourceTsIsMaxDiff reset player and play");
                                const i = this._opt.url, r = this._opt.playOptions;
                                var e = {}, t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t);
                                this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "mediaSourceTsIsMaxDiff replay success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.mediaSourceTsIsMaxDiff), this.debug.error("JbPro", "mediaSourceTsIsMaxDiff replay error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.mediaSourceTsIsMaxDiff), this.debug.error("JbPro", "mediaSourceTsIsMaxDiff _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.mediaSourceTsIsMaxDiff), this.debug.log("JbPro", "mediaSourceTsIsMaxDiff and replay is false")
                        }).catch(e => {
                            this.debug.error("JbPro", "mediaSourceTsIsMaxDiff and pause error", e)
                        })
                    }), this.player.once(S.mseWidthOrHeightChange, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mseWidthOrHeightChange, e)), this.debug.log("JbPro", "mseWidthOrHeightChange and reset player and play");
                        const t = this._opt.url, i = this._opt.playOptions;
                        var e = {}, r = this._getVideoLastIframeInfo(), e = Object.assign({}, e, r);
                        this._resetPlayer(e).then(() => {
                            this.play(t, i).then(() => {
                                this.debug.log("JbPro", "mseWidthOrHeightChange and reset player and play success")
                            }).catch(e => {
                                this.emit(w.playFailedAndPaused, S.mseWidthOrHeightChange), this.debug.error("JbPro", "mseWidthOrHeightChange and reset player and play error", e)
                            })
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mseWidthOrHeightChange), this.debug.error("JbPro", "mseWidthOrHeightChange and _resetPlayer error", e)
                        })
                    }), this.player.once(S.mediaSourceUseCanvasRenderPlayFailed, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.mediaSourceUseCanvasRenderPlayFailed, e)), this.debug.log("JbPro", "mediaSourceUseCanvasRenderPlayFailed and reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.debug.log("JbPro", "mediaSourceUseCanvasRenderPlayFailed and reset player success")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.mediaSourceUseCanvasRenderPlayFailed), this.debug.error("JbPro", "mediaSourceUseCanvasRenderPlayFailed and pause", e)
                        })
                    }), this.player.once(S.webcodecsH265NotSupport, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.webcodecsH265NotSupport, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.autoWasm) {
                                this.debug.log("JbPro", "webcodecsH265NotSupport auto wasm [wcs-> wasm] reset player and play");
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer({useMSE: !1, useWCS: !1}).then(() => {
                                    this.play(e, t).then(() => {
                                        this.debug.log("JbPro", "webcodecsH265NotSupport auto wasm [wcs-> wasm] reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.webcodecsH265NotSupport), this.debug.error("JbPro", "webcodecsH265NotSupport auto wasm [wcs-> wasm] reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.debug.error("JbPro", "webcodecsH265NotSupport auto wasm [wcs-> wasm] _resetPlayer and play error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.webcodecsH265NotSupport), this.debug.log("JbPro", "webcodecsH265NotSupport and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.webcodecsH265NotSupport), this.debug.error("JbPro", "webcodecsH265NotSupport and pause error", e)
                        })
                    }), this.player.once(S.webcodecsUnsupportedConfigurationError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.webcodecsUnsupportedConfigurationError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.autoWasm) {
                                this.debug.log("Jessibuca", "webcodecsUnsupportedConfigurationError auto wasm [wcs-> wasm] reset player and play");
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer({useMSE: !1, useWCS: !1}).then(() => {
                                    this.play(e, t).then(() => {
                                        this.debug.log("Jessibuca", "webcodecsUnsupportedConfigurationError auto wasm [wcs-> wasm] reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.webcodecsUnsupportedConfigurationError), this.debug.error("Jessibuca", "webcodecsUnsupportedConfigurationError auto wasm [wcs-> wasm] reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.webcodecsUnsupportedConfigurationError), this.debug.error("Jessibuca", "webcodecsUnsupportedConfigurationError auto wasm [wcs-> wasm] _resetPlayer and play error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.webcodecsUnsupportedConfigurationError), this.debug.log("Jessibuca", "webcodecsUnsupportedConfigurationError and autoWasm is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.webcodecsUnsupportedConfigurationError), this.debug.error("Jessibuca", "webcodecsUnsupportedConfigurationError and pause error", e)
                        })
                    }), this.player.once(S.webcodecsDecodeError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.webcodecsDecodeError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.wcsDecodeErrorReplay) {
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.autoWasm && (e = {
                                    useMSE: !1,
                                    useWCS: !1
                                }), this.debug.log("JbPro", `webcodecs decode error autoWasm [wcs-> ${this.player._opt.autoWasm ? "wasm" : "wcs"}] reset player and play`), this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "webcodecs decode error  reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.webcodecsDecodeError), this.debug.error("JbPro", "webcodecs decode error reset player and play error", e)
                                    })
                                }).catch(() => {
                                    this.emit(w.playFailedAndPaused, S.webcodecsDecodeError), this.debug.error("JbPro", "webcodecs decode error _resetPlayer error")
                                })
                            } else this.emit(w.playFailedAndPaused, S.webcodecsDecodeError), this.debug.log("JbPro", "webcodecs decode error and autoWasm is false")
                        }).catch(e => {
                            this.debug.error("JbPro", "webcodecs decode error and pause error", e)
                        })
                    }), this.player.once(S.wcsWidthOrHeightChange, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.wcsWidthOrHeightChange, e)), this.debug.log("JbPro", "wcsWidthOrHeightChange and reset player and play");
                        const t = this._opt.url, i = this._opt.playOptions;
                        var e = {}, r = this._getVideoLastIframeInfo(), e = Object.assign({}, e, r);
                        this._resetPlayer(e).then(() => {
                            this.play(t, i).then(() => {
                                this.debug.log("JbPro", "wcsWidthOrHeightChange and reset player and play success")
                            }).catch(e => {
                                this.emit(w.playFailedAndPaused, S.wcsWidthOrHeightChange), this.debug.error("JbPro", "wcsWidthOrHeightChange and reset player and play error", e)
                            })
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.wcsWidthOrHeightChange), this.debug.error("JbPro", "wcsWidthOrHeightChange and _resetPlayer error", e)
                        })
                    }), this.player.once(S.wasmDecodeError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.wasmDecodeError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.wasmDecodeErrorReplay) {
                                this.debug.log("JbPro", "wasm decode error and reset player and play");
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                this.player._opt.replayUseLastFrameShow && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "wasm decode error and reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.wasmDecodeError), this.debug.error("JbPro", "wasm decode error and reset player and play error", e)
                                    })
                                }).catch(() => {
                                    this.emit(w.playFailedAndPaused, S.wasmDecodeError), this.debug.error("JbPro", "wasm decode error and _resetPlayer error")
                                })
                            } else this.emit(w.playFailedAndPaused, S.wasmDecodeError), this.debug.log("JbPro", "wasm decode error and wasmDecodeErrorReplay is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.wasmDecodeError), this.debug.error("JbPro", "wasm decode error and pause error", e)
                        })
                    }), this.player.once(S.simdDecodeError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.simdDecodeError, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.simdDecodeErrorReplay) {
                                this.debug.log("JbPro", "simdDecodeError error and reset player and play");
                                const i = this._opt.url, r = this._opt.playOptions;
                                var e = {}, t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t);
                                this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                        this.debug.log("JbPro", "simdDecodeError and reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.simdDecodeError), this.debug.error("JbPro", "simdDecodeError and reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.simdDecodeError), this.debug.error("JbPro", "simdDecodeError and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.simdDecodeError), this.debug.error("JbPro", "simdDecodeError and simdDecodeErrorReplay is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.simdDecodeError), this.debug.error("JbPro", "simdDecodeError error and pause error", e)
                        })
                    }), this.player.once(S.wasmWidthOrHeightChange, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.wasmWidthOrHeightChange, e)), this.debug.log("JbPro", "wasmWidthOrHeightChange and reset player and play");
                        const t = this._opt.url, i = this._opt.playOptions;
                        var e = {}, r = this._getVideoLastIframeInfo(), e = Object.assign({}, e, r);
                        this._resetPlayer(e).then(() => {
                            this.play(t, i).then(() => {
                                this.debug.log("JbPro", "wasmWidthOrHeightChange and reset player and play success")
                            }).catch(e => {
                                this.emit(w.playFailedAndPaused, S.wasmWidthOrHeightChange), this.debug.error("JbPro", "wasmWidthOrHeightChange and reset player and play error", e)
                            })
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.wasmWidthOrHeightChange), this.debug.error("JbPro", "wasmWidthOrHeightChange and _resetPlayer error", e)
                        })
                    }), this.player.once(S.wasmUseVideoRenderError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.wasmUseVideoRenderError, e)), this.debug.log("JbPro", "wasmUseVideoRenderError and reset player and play");
                        const t = this._opt.url, i = this._opt.playOptions;
                        this._resetPlayer({useVideoRender: !1, useCanvasRender: !0}).then(() => {
                            this.play(t, i).then(() => {
                                this.debug.log("JbPro", "wasmUseVideoRenderError and reset player and play success")
                            }).catch(e => {
                                this.emit(w.playFailedAndPaused, S.wasmUseVideoRenderError), this.debug.error("JbPro", "wasmUseVideoRenderError and reset player and play error", e)
                            })
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.wasmUseVideoRenderError), this.debug.error("JbPro", "wasmUseVideoRenderError and _resetPlayer error", e)
                        })
                    }), this.player.once(S.videoElementPlayingFailed, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.videoElementPlayingFailed, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            if (this.player && this.player._opt.videoElementPlayingFailedReplay) {
                                this.debug.log("JbPro", `videoElementPlayingFailed and useMSE is ${this._opt.useMSE} and reset player and play`);
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer({useMSE: !1, useVideoRender: !1, useCanvasRender: !0}).then(() => {
                                    this.play(e, t).then(() => {
                                        this.debug.log("JbPro", "videoElementPlayingFailed and reset player and play success")
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, S.videoElementPlayingFailed), this.debug.error("JbPro", "videoElementPlayingFailed and reset player and play error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.videoElementPlayingFailed), this.debug.error("JbPro", "videoElementPlayingFailed and _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, S.videoElementPlayingFailed), this.debug.error("JbPro", "videoElementPlayingFailed and videoElementPlayingFailedReplay is false")
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.videoElementPlayingFailed), this.debug.error("JbPro", "videoElementPlayingFailed and _pause error", e)
                        })
                    }), this.player.once(S.simdH264DecodeVideoWidthIsTooLarge, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.simdH264DecodeVideoWidthIsTooLarge, e));
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.debug.log("JbPro", "simdH264DecodeVideoWidthIsTooLarge and reset player and play");
                            const e = this._opt.url, t = this._opt.playOptions;
                            this._resetPlayer({useSIMD: !1}).then(() => {
                                this.play(e, t).then(() => {
                                    this.debug.log("JbPro", "simdH264DecodeVideoWidthIsTooLarge and reset player and play success")
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, S.simdH264DecodeVideoWidthIsTooLarge), this.debug.error("JbPro", "simdH264DecodeVideoWidthIsTooLarge and reset player and play error", e)
                                })
                            }).catch(e => {
                                this.emit(w.playFailedAndPaused, S.simdH264DecodeVideoWidthIsTooLarge), this.debug.error("JbPro", "simdH264DecodeVideoWidthIsTooLarge and _resetPlayer error", e)
                            })
                        }).catch(e => {
                            this.debug.error("JbPro", "simdH264DecodeVideoWidthIsTooLarge and pause error", e)
                        })
                    }), this.player.once(w.networkDelayTimeout, t => {
                        if (this.player._opt.networkDelayTimeoutReplay) {
                            this.emit(w.crashLog, this.getCrashLog(w.networkDelayTimeout, t)), this.debug.log("JbPro", "network delay time out and reset player and play");
                            const i = this._opt.url, r = this._opt.playOptions;
                            let e = {};
                            if (this.player && this.player._opt.replayUseLastFrameShow) {
                                const t = this._getVideoLastIframeInfo();
                                e = Object.assign({}, e, t)
                            }
                            this._resetPlayer(e).then(() => {
                                this.play(i, r).then(() => {
                                    this.debug.log("JbPro", "wasm decode error and reset player and play success")
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, w.networkDelayTimeout), this.debug.error("JbPro", "wasm decode error and reset player and play error", e)
                                })
                            }).catch(() => {
                                this.emit(w.playFailedAndPaused, w.networkDelayTimeout), this.debug.error("JbPro", "wasm decode error and _resetPlayer error")
                            })
                        }
                    }), this.player.once(S.fetchError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.fetchError, e)), this.debug.log("JbPro", "fetch error and reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.emit(w.playFailedAndPaused, S.fetchError)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.fetchError), this.debug.error("JbPro", "fetch error and pause", e)
                        })
                    }), this.player.once(w.streamEnd, e => {
                        this.emit(w.crashLog, this.getCrashLog(w.streamEnd, e)), this.debug.log("JbPro", "streamEnd reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.emit(w.playFailedAndPaused, w.streamEnd)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, w.streamEnd), this.debug.error("JbPro", "streamEnd pause", e)
                        })
                    }), this.player.once(S.websocketError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.websocketError, e)), this.debug.log("JbPro", "websocketError and reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.emit(w.playFailedAndPaused, S.websocketError)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.websocketError), this.debug.error("JbPro", "websocketError and pause", e)
                        })
                    }), this.player.once(S.webrtcError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.webrtcError, e)), this.debug.log("JbPro", "webrtcError and reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.emit(w.playFailedAndPaused, S.webrtcError)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.webrtcError), this.debug.error("JbPro", "webrtcError and pause", e)
                        })
                    }), this.player.once(S.hlsError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.hlsError, e)), this.debug.log("JbPro", "hlsError and reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.emit(w.playFailedAndPaused, S.hlsError)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.hlsError), this.debug.error("JbPro", "hlsError and pause", e)
                        })
                    }), this.player.once(S.decoderWorkerInitError, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.decoderWorkerInitError, e)), this.debug.log("JbPro", "decoderWorkerInitError and reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.emit(w.playFailedAndPaused, S.decoderWorkerInitError)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.decoderWorkerInitError), this.debug.error("JbPro", "decoderWorkerInitError and pause", e)
                        })
                    }), this.player.once(S.videoElementPlayingFailedForWebrtc, e => {
                        this.emit(w.crashLog, this.getCrashLog(S.videoElementPlayingFailedForWebrtc, e)), this.debug.log("JbPro", "videoElementPlayingFailedForWebrtc and reset player");
                        e = !1 === this._opt.playFailedUseLastFrameShow;
                        this._pause(e).then(() => {
                            this.emit(w.playFailedAndPaused, S.videoElementPlayingFailedForWebrtc)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, S.videoElementPlayingFailedForWebrtc), this.debug.error("JbPro", "videoElementPlayingFailedForWebrtc and pause", e)
                        })
                    }), this.player.once(w.webrtcStreamH265, e => {
                        this.debug.log("JbPro", "webrtcStreamH265 and reset player and play");
                        const t = this._opt.url, i = this._opt.playOptions;
                        this._resetPlayer({isWebrtcH265: !0}).then(() => {
                            this.play(t, i).then(() => {
                                this.debug.log("JbPro", "webrtcStreamH265 and reset player and play success")
                            }).catch(e => {
                                this.emit(w.playFailedAndPaused, w.webrtcStreamH265), this.debug.error("JbPro", "webrtcStreamH265 and reset player and play error", e)
                            })
                        }).catch(() => {
                            this.emit(w.playFailedAndPaused, w.webrtcStreamH265), this.debug.error("JbPro", "webrtcStreamH265 and _resetPlayer error")
                        })
                    }), this.player.on(w.delayTimeout, e => {
                        this.emit(w.crashLog, this.getCrashLog(w.delayTimeout, e)), this.isDestroyed() ? this.debug.log("JbPro", "delay timeout but player is destroyed") : (e = !1 === this._opt.playFailedUseLastFrameShow, this._pause(e).then(() => {
                            if (this.player && this.player._opt.heartTimeoutReplay && (this._heartTimeoutReplayTimes < this.player._opt.heartTimeoutReplayTimes || -1 === this.player._opt.heartTimeoutReplayTimes)) if (this.debug.log("JbPro", `delay timeout replay time is ${this._heartTimeoutReplayTimes} and heartTimeoutReplayTimes is ` + this.player._opt.heartTimeoutReplayTimes), this.isDestroyed()) this.debug && this.debug.warn("JbPro", "delay timeout replay but player is destroyed"); else {
                                this._heartTimeoutReplayTimes += 1;
                                const i = this._opt.url, r = this._opt.playOptions;
                                let e = {};
                                var t;
                                (this.player._opt.heartTimeoutReplayUseLastFrameShow || this.player._opt.replayUseLastFrameShow) && (t = this._getVideoLastIframeInfo(), e = Object.assign({}, e, t)), this._resetPlayer(e).then(() => {
                                    this.play(i, r).then(() => {
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, w.delayTimeout), this.debug.error("JbPro", "delay timeout replay error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, w.delayTimeout), this.debug.error("JbPro", "delay timeout _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, w.delayTimeout), this.player && this.player.emit(w.delayTimeoutRetryEnd), this.debug.warn("JbPro", `delayTimeoutRetryEnd and
                            opt.heartTimeout is ${this.player && this.player._opt.heartTimeout} and
                            opt.heartTimeoutReplay is ${this.player && this.player._opt.heartTimeoutReplay} and
                            opt.heartTimeoutReplayTimes is ${this.player && this.player._opt.heartTimeoutReplayTimes},and
                            local._heartTimeoutReplayTimes is ` + this._heartTimeoutReplayTimes)
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, w.delayTimeout), this.debug.error("JbPro", "delay timeout and pause error", e)
                        }))
                    }), this.player.on(w.loadingTimeout, e => {
                        this.emit(w.crashLog, this.getCrashLog(w.loadingTimeout, e)), this.isDestroyed() ? this.debug.log("JbPro", "loading timeout but player is destroyed") : (e = !1 === this._opt.playFailedUseLastFrameShow, this._pause(e).then(() => {
                            if (this.player && this.player._opt.loadingTimeoutReplay && (this._loadingTimeoutReplayTimes < this.player._opt.loadingTimeoutReplayTimes || -1 === this.player._opt.loadingTimeoutReplayTimes)) if (this.debug.log("JbPro", `loading timeout and
                             replay time is ${this._loadingTimeoutReplayTimes} and
                             loadingTimeoutReplayTimes is ` + this.player._opt.loadingTimeoutReplayTimes), this.isDestroyed()) this.debug && this.debug.warn("JbPro", "delay timeout replay but player is destroyed"); else {
                                this._loadingTimeoutReplayTimes += 1;
                                const e = this._opt.url, t = this._opt.playOptions;
                                this._resetPlayer().then(() => {
                                    this.play(e, t).then(() => {
                                    }).catch(e => {
                                        this.emit(w.playFailedAndPaused, w.loadingTimeout), this.debug.error("JbPro", "loading timeout replay error", e)
                                    })
                                }).catch(e => {
                                    this.emit(w.playFailedAndPaused, w.loadingTimeout), this.debug.error("JbPro", "loading timeout _resetPlayer error", e)
                                })
                            } else this.emit(w.playFailedAndPaused, w.loadingTimeout), this.player && this.player.emit(w.loadingTimeoutRetryEnd), this.debug.log("JbPro", `loadingTimeoutRetryEnd and
                            opt.loadingTimeout is ${this.player && this.player._opt.loadingTimeout} and
                            opt.loadingTimeoutReplay is ${this.player && this.player._opt.loadingTimeoutReplay} and
                            local._loadingTimeoutReplayTimes time is ${this._loadingTimeoutReplayTimes} and
                            opt.loadingTimeoutReplayTimes is ` + (this.player && this.player._opt.loadingTimeoutReplayTimes))
                        }).catch(e => {
                            this.emit(w.playFailedAndPaused, w.loadingTimeout), this.debug.error("JbPro", "loading timeout and pause error", e)
                        }))
                    }), this._hasLoaded() ? this.player.play(m, g).then(() => {
                        e()
                    }).catch(e => {
                        this.debug.error("JbPro", "_hasLoaded() and play error", e), this.emit(w.crashLog, this.getCrashLog("_hasLoaded() and play error", e)), this.player.pause().then(() => {
                            t(e)
                        }).catch(e => {
                            t(e), this.debug.error("JbPro", "_hasLoaded() and play error and next pause error", e)
                        })
                    }) : this.player.once(w.decoderWorkerInit, () => {
                        this.player.play(m, g).then(() => {
                            e()
                        }).catch(e => {
                            this.debug.error("JbPro", "decoderWorkerInit and play error", e), this.emit(w.crashLog, this.getCrashLog("decoderWorkerInit and play error", e)), this.player && this.player.pause().then(() => {
                                t(e)
                            }).catch(e => {
                                t(e), this.debug.error("JbPro", "decoderWorkerInit and play error and next pause error", e)
                            })
                        })
                    })
                };
                n && C(this._opt.supportHls265) || s && C(this._opt.isWebrtcH265) || i || d ? (this.debug.log("JbPro", "need reset player"), this._resetPlayer({
                    protocol: l,
                    demuxType: h,
                    isHls: n,
                    isWebrtc: s,
                    isWebrtcForZLM: c,
                    isWebrtcForSRS: u,
                    isWebrtcForOthers: p,
                    url: m
                }).then(() => {
                    f()
                }).catch(e => {
                    t("reset player error")
                })) : (this.player.updateOption({
                    protocol: l,
                    demuxType: h,
                    isHls: n,
                    isWebrtc: s,
                    isFlv: this._opt.isFlv,
                    isFmp4: this._opt.isFmp4,
                    isMpeg4: this._opt.isMpeg4,
                    isNakedFlow: this._opt.isNakedFlow,
                    cryptoKey: g.cryptoKey || "",
                    cryptoIV: g.cryptoIV || ""
                }), g.cryptoKey && g.cryptoIV && (this.player.decoderWorker && this.player.decoderWorker.updateWorkConfig({
                    key: "cryptoKey",
                    value: g.cryptoKey
                }), this.player.decoderWorker && this.player.decoderWorker.updateWorkConfig({
                    key: "cryptoIV",
                    value: g.cryptoIV
                })), f())
            })
        }

        _resetDemuxType(e) {
            this._opt.isFlv = !1, this._opt.isFmp4 = !1, this._opt.isMpeg4 = !1, this._opt.isNakedFlow = !1, this._opt.isHls = !1, this._opt.isWebrtc = !1, this._opt.isWebrtcForZLM = !1, this._opt.isWebrtcForSRS = !1, e && (this._opt[e] = !0), "isFmp4" !== e && (this._opt.isFmp4Private = !1)
        }

        resize() {
            this.debug.log("JbPro", "resize()"), this.player && this.player.resize()
        }

        setBufferTime(e) {
            this.debug.log("JbPro", "setBufferTime() " + e), 10 < (e = Number(e)) && this.debug.warn("JbPro", `setBufferTime() buffer time is ${e} second, is too large, video will show blank screen until cache ${e} second buffer data`);
            e *= 1e3;
            this._opt.videoBuffer = e, this.player ? this.player.updateOption({videoBuffer: e}, !0) : this.debug.warn("JbPro", "setBufferTime() player is null")
        }

        setBufferDelayTime(e) {
            this.debug.log("JbPro", "setBufferDelayTime() " + e), (e = Number(e)) < .2 && this.debug.warn("JbPro", `setBufferDelayTime() buffer time delay is ${e} second, is too small`);
            e = 1e3 * (e = E(e, .2, 100));
            this._opt.videoBufferDelay = e, this.player ? this.player.updateOption({videoBufferDelay: e}, !0) : this.debug.warn("JbPro", "setBufferDelayTime() player is null")
        }

        setRotate(e) {
            this.debug.log("JbPro", "setRotate() " + e), e = parseInt(e, 10), this._opt.rotate !== e && -1 !== [0, 90, 180, 270].indexOf(e) ? (this._opt.rotate = e, this.player ? (this.player.updateOption({rotate: e}), this.resize()) : this.debug.warn("JbPro", "setRotate() player is null")) : this.debug.warn("JbPro", `setRotate() rotate is ${e} and this._opt.rotate is ` + this._opt.rotate)
        }

        setMirrorRotate(e) {
            this.debug.log("JbPro", "setMirrorRotate() " + e), this._opt.mirrorRotate !== (e = e || "none") && -1 !== ["none", "level", "vertical"].indexOf(e) ? (this._opt.mirrorRotate = e, this.player ? (this.player.updateOption({mirrorRotate: e}), this.resize()) : this.debug.warn("JbPro", "setMirrorRotate() player is null")) : this.debug.warn("JbPro", `setMirrorRotate() mirrorRotate is ${e} and this._opt.mirrorRotate is ` + this._opt.mirrorRotate)
        }

        setAspectRatio(e) {
            this.debug.log("JbPro", "setAspectRatio() " + e), this._opt.aspectRatio !== (e = e || "default") && -1 !== ["default", "4:3", "16:9"].indexOf(e) ? (this._opt.aspectRatio = e, this.player ? (this.player.updateOption({aspectRatio: e}), this.resize()) : this.debug.warn("JbPro", "setAspectRatio() player is null")) : this.debug.warn("JbPro", `setAspectRatio() aspectRatio is ${e} and this._opt.aspectRatio is ` + this._opt.mirrorRotate)
        }

        hasLoaded() {
            return !0
        }

        _hasLoaded() {
            return this.player && this.player.loaded || !1
        }

        setKeepScreenOn() {
            this.debug.log("JbPro", "setKeepScreenOn()"), this._opt.keepScreenOn = !0, this.player ? this.player.updateOption({keepScreenOn: !0}) : this.debug.warn("JbPro", "setKeepScreenOn() player is not ready")
        }

        setFullscreen(e) {
            this.debug.log("JbPro", "setFullscreen() " + e);
            e = !!e;
            this.player ? this.player.fullscreen !== e && (this.player.fullscreen = e) : this.debug.warn("JbPro", "setFullscreen() player is not ready")
        }

        screenshot(e, t, i, r) {
            return this.debug.log("JbPro", `screenshot() ${e} ${t} ${i} ` + r), this.player && this.player.video ? this.player.video.screenshot(e, t, i, r) : (this.debug.warn("JbPro", "screenshot() player is not ready"), null)
        }

        screenshotWatermark(e) {
            return new Promise((t, i) => {
                this.debug.log("JbPro", "screenshotWatermark()", e), this.player && this.player.video ? this.player.video.screenshotWatermark(e).then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                }) : (this.debug.warn("JbPro", "screenshotWatermark() player is not ready"), i("player is not ready"))
            })
        }

        startRecord(i, r) {
            return new Promise((e, t) => {
                if (this.debug.log("JbPro", `startRecord() ${i} ` + r), !this.player) return this.debug.warn("JbPro", "startRecord() player is not ready"), t("player is not ready");
                this.player.playing ? (this.player.startRecord(i, r), e()) : (this.debug.warn("JbPro", "startRecord() player is not playing"), t("not playing"))
            })
        }

        stopRecordAndSave(e, r) {
            return new Promise((t, i) => {
                this.debug.log("JbPro", `stopRecordAndSave() ${e} ` + r), this.player && this.player.recording ? this.player.stopRecordAndSave(e, r).then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                }) : i("not recording")
            })
        }

        isPlaying() {
            let e = !1;
            return this.player && (this._opt.playType === n ? e = this.player.playing : this._opt.playType === A && (e = C(this.player.playbackPause) && this.player.playing)), e
        }

        isLoading() {
            return !!this.player && this.player.loading
        }

        isPause() {
            let e = !1;
            return this._opt.playType === n ? e = !this.isPlaying() && !this.isLoading() : this._opt.playType === A && this.player && (e = this.player.playbackPause), e
        }

        isPaused() {
            return this.isPause()
        }

        isPlaybackPause() {
            let e = !1;
            return e = this._opt.playType === A && this.player ? this.player.playbackPause : e
        }

        isMute() {
            let e = !0;
            return e = this.player ? this.player.isAudioMute() : e
        }

        isRecording() {
            return this.player && this.player.recorder && this.player.recorder.recording || !1
        }

        clearBufferDelay() {
            this.debug.log("JbPro", "clearBufferDelay()"), this.player ? this.player.clearBufferDelay() : this.debug.warn("JbPro", "clearBufferDelay() player is not init")
        }

        setNetworkDelayTime(e) {
            this.debug.log("JbPro", "setNetworkDelayTime() " + e), (e = Number(e)) < 1 && this.debug.warn("JbPro", `setNetworkDelayTime() network delay is ${e} second, is too small`);
            e = 1e3 * (e = E(e, 1, 100));
            this._opt.networkDelay = e, this.player ? this.player.updateOption({networkDelay: e}, !0) : this.debug.warn("JbPro", "setNetworkDelayTime() player is null")
        }

        getDecodeType() {
            let e = "";
            return e = this.player ? this.player.getDecodeType() : e
        }

        getRenderType() {
            let e = "";
            return e = this.player ? this.player.getRenderType() : e
        }

        getAudioEngineType() {
            let e = "";
            return e = this.player ? this.player.getAudioEngineType() : e
        }

        getPlayingTimestamp() {
            let e = 0;
            return e = this.player ? this.player.getPlayingTimestamp() : e
        }

        getStatus() {
            let e = "destroy";
            return e = this.player ? this.player.loading ? "loading" : this.player.playing ? "playing" : "paused" : e
        }

        getPlayType() {
            return this.player ? this.player._opt.playType : n
        }

        togglePerformancePanel(e) {
            this.debug.log("JbPro", "togglePerformancePanel() " + e);
            var t = this.player._opt.showPerformance;
            let i = !t;
            (i = Ht(e) ? e : i) !== t ? this.player ? this.player.togglePerformancePanel(i) : this.debug.warn("JbPro", "togglePerformancePanel() failed, this.player is not init") : this.debug.warn("JbPro", `togglePerformancePanel() failed, showPerformance is prev: ${t} === now: ` + i)
        }

        openZoom() {
            this.debug.log("JbPro", "openZoom()"), this.player ? this.player.zooming = !0 : this.debug.warn("JbPro", "openZoom() failed, this.player is not init")
        }

        closeZoom() {
            this.debug.log("JbPro", "closeZoom()"), this.player ? this.player.zooming = !1 : this.debug.warn("JbPro", "closeZoom() failed, this.player is not init")
        }

        isZoomOpen() {
            let e = !1;
            return e = this.player ? this.player.zooming : e
        }

        expandZoom() {
            this.debug.log("JbPro", "expandZoom()"), this.player && this.player.zoom && this.player.zooming ? this.player.zoom.expandPrecision() : this.debug.warn("JbPro", "expandZoom() failed, zoom is not open or not init")
        }

        narrowZoom() {
            this.debug.log("JbPro", "narrowZoom()"), this.player && this.player.zoom && this.player.zooming ? this.player.zoom.narrowPrecision() : this.debug.warn("JbPro", "narrowZoom failed, zoom is not open or not init")
        }

        getCurrentZoomIndex() {
            let e = 1;
            return e = this.player && this.player.zoom ? this.player.zoom.currentZoom : e
        }

        startTalk(i) {
            let r = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
            return new Promise((e, t) => {
                this.debug.log("JbPro", "startTalk()", i, r), this._initTalk(r), this.talk.startTalk(i).then(() => {
                    e(), this.talk.once(w.talkStreamClose, () => {
                        this.debug.warn("JbPro", "talk stream close"), this.stopTalk().catch(e => {
                        })
                    }), this.talk.once(w.talkStreamError, e => {
                        this.debug.warn("JbPro", "talk stream error", e), this.stopTalk().catch(e => {
                        })
                    }), this.talk.once(w.talkStreamInactive, () => {
                        this.debug.warn("JbPro", "talk stream inactive"), this.stopTalk().catch(e => {
                        })
                    })
                }).catch(e => {
                    t(e)
                })
            })
        }

        stopTalk() {
            return new Promise((e, t) => {
                if (this.debug.log("JbPro", "stopTalk()"), !this.talk) return t("stopTalk() talk is not init");
                this.talk.destroy(), e()
            })
        }

        getTalkVolume() {
            return new Promise((e, t) => {
                if (!this.talk) return t("getTalkVolume() talk is not init");
                e(this.talk.volume)
            })
        }

        setTalkVolume(i) {
            return new Promise((e, t) => {
                if (this.debug.log("JbPro", "setTalkVolume()", i), !this.talk) return t("setTalkVolume() talk is not init");
                this.talk.setVolume(i / 100), e()
            })
        }

        setNakedFlowFps(i) {
            return new Promise((e, t) => {
                if (this.debug.log("JbPro", "setNakedFlowFps()", i), c(i)) return t("setNakedFlowFps() fps is empty");
                t = E(Number(i), 1, 100);
                this._opt.nakedFlowFps = t, this.player ? this.player.updateOption({nakedFlowFps: t}) : this.debug.warn("JbPro", "setNakedFlowFps() player is null"), e()
            })
        }

        getCrashLog(t) {
            var i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "";
            if (this.player) {
                const r = this.player.getAllStatsData(), s = this.player;
                let e = {
                    url: this._opt.url,
                    playType: s.isPlayback() ? "playback" : "live",
                    demuxType: s.getDemuxType(),
                    decoderType: s.getDecodeType(),
                    renderType: s.getRenderType(),
                    videoInfo: {encType: "", width: "", height: ""},
                    audioInfo: {encType: "", sampleRate: "", channels: ""},
                    audioEngine: s.getAudioEngineType(),
                    allTimes: r.pTs,
                    timestamp: p(),
                    type: t,
                    error: function (e) {
                        const t = Object.prototype.toString;
                        return function (e) {
                            switch (t.call(e)) {
                                case"[object Error]":
                                case"[object Exception]":
                                case"[object DOMException]":
                                    return 1;
                                default:
                                    try {
                                        return e instanceof Error
                                    } catch (e) {
                                        return
                                    }
                            }
                        }(e) ? e.message : null == e ? "" : "object" == typeof e ? JSON.stringify(e, null, 2) : String(e)
                    }(i) || t
                };
                if (s.video) {
                    const t = s.video.videoInfo || {};
                    e.videoInfo = {encType: t.encType || "", width: t.width || "", height: t.height || ""}
                }
                if (s.audio) {
                    const t = s.audio.audioInfo || {};
                    e.audioInfo = {encType: t.encType || "", sampleRate: t.sampleRate || "", channels: t.channels || ""}
                }
                return e
            }
        }

        updateDebugLevel(e) {
            this.debug.log("JbPro", "updateDebugLevel()", e), e === Q || e === X ? e !== this.player._opt.debugLevel ? (this._opt.debugLevel = e, this.player ? this.player.updateOption({debugLevel: e}, !0) : this.debug.warn("JbPro", "updateDebugLevel() player is null")) : this.debug.warn("JbPro", "updateDebugLevel() level is same, level: " + e) : this.debug.warn("JbPro", "updateDebugLevel() level is not valid, level: " + e)
        }

        updateWatermark(e) {
            this.debug.log("JbPro", "updateWatermark()", e), this.player ? this.player.updateWatermark(e) : this.debug.warn("JbPro", "updateWatermark() player is not init")
        }

        removeWatermark() {
            this.debug.log("JbPro", "removeWatermark()"), this.player ? this.player.removeWatermark() : this.debug.warn("JbPro", "removeWatermark() player is not init")
        }

        updateFullscreenWatermark(e) {
            var t;
            this.debug.log("JbPro", "updateFullscreenWatermark()", e), Qt(e) ? (this._opt.fullscreenWatermarkConfig = e, (t = Vt(this.$container, e)).watermark_txt ? this.watermark.load(t) : this.debug.warn("JbPro", "fullscreenWatermarkConfig text is empty")) : this.debug.warn("JbPro", "updateFullscreenWatermark() config is not valid, config: " + e)
        }

        removeFullscreenWatermark() {
            this.debug.log("JbPro", "removeFullscreenWatermark()"), this.watermark ? this.watermark.remove() : this.debug.warn("JbPro", "removeFullscreenWatermark() watermark is not init")
        }

        faceDetectOpen() {
            this.debug.log("JbPro", "faceDetectOpen()"), this.player ? this.player.faceDetect(!0) : this.debug.warn("JbPro", "faceDetectOpen() player is not init")
        }

        faceDetectClose() {
            this.debug.log("JbPro", "faceDetectClose()"), this.player ? this.player.faceDetect(!1) : this.debug.warn("JbPro", "faceDetectClose() player is not init")
        }

        objectDetectOpen() {
            this.debug.log("JbPro", "objectDetectOpen()"), this.player ? this.player.objectDetect(!0) : this.debug.warn("JbPro", "objectDetectOpen() player is not init")
        }

        objectDetectClose() {
            this.debug.log("JbPro", "objectDetectClose()"), this.player ? this.player.objectDetect(!1) : this.debug.warn("JbPro", "objectDetectClose() player is not init")
        }

        sendWebsocketMessage(e) {
            this.debug.log("JbPro", "sendWebsocketMessage()", e), this.player ? this.player.sendWebsocketMessage(e) : this.debug.warn("JbPro", "sendWebsocketMessage() player is not init")
        }

        addContentToCanvas(e) {
            this.debug.log("JbPro", "addContentToCanvas()", e), this.player ? this.player.addContentToCanvas(e) : this.debug.warn("JbPro", "addContentToCanvas() player is not init")
        }

        clearContentToCanvas() {
            this.debug.log("JbPro", "clearContentToCanvas()"), this.player ? this.player.addContentToCanvas([]) : this.debug.warn("JbPro", "clearContentToCanvas() player is not init")
        }

        setControlHtml(e) {
            this.debug.log("JbPro", "setControlHtml()", e), this.player ? this.player.setControlHtml(e) : this.debug.warn("JbPro", "setControlHtml() player is not init")
        }

        clearControlHtml() {
            this.debug.log("JbPro", "clearControlHtml()"), this.player ? this.player.clearControlHtml() : this.debug.warn("JbPro", "clearControlHtml() player is not init")
        }

        getVideoInfo() {
            let e = null;
            return e = this.player ? this.player.getVideoInfo() : e
        }

        getAudioInfo() {
            let e = null;
            return e = this.player ? this.player.getAudioInfo() : e
        }

        setSm4CryptoKey(e) {
            this.debug.log("JbPro", "setSm4CryptoKey()", e), 32 === (e = "" + e).length ? (this._opt.sm4CryptoKey = e, this.player ? this.player.updateOption({sm4CryptoKey: e}, !0) : this.debug.warn("JbPro", "setSm4CryptoKey() player is null")) : this.debug.warn("JbPro", `setSm4CryptoKey() key is invalid and length is ${e.length} !== 32`)
        }

        updateLoadingText(e) {
            this.debug.log("JbPro", "updateLoadingText()", e), this.player ? this.player.updateLoadingText(e) : this.debug.warn("JbPro", "updateLoadingText() player is null")
        }

        updateIsEmitSEI(e) {
            this.debug.log("JbPro", "updateIsEmitSEI()", e), this._opt.isEmitSEI = e, this.player ? this.player.updateOption({isEmitSEI: e}, !0) : this.debug.warn("JbPro", "updateIsEmitSEI() player is null")
        }

        getPTZCmd(a, n) {
            if (this.debug.log("JbPro", "getPTZCmd()", a), a) if (this.player) {
                a = {type: a, index: 0, speed: n};
                var e, {type: a, speed: o = 5, index: l = 0} = a, d = (n = o, On[(n || 5) - 1] || On[4]);
                let t, i, r, s;
                switch (t = Mn[a], a) {
                    case"up":
                    case"down":
                    case"apertureFar":
                    case"apertureNear":
                        r = d;
                        break;
                    case"right":
                    case"left":
                    case"focusFar":
                    case"focusNear":
                        i = d;
                        break;
                    case"leftUp":
                    case"leftDown":
                    case"rightUp":
                    case"rightDown":
                        i = d, r = d;
                        break;
                    case"zoomExpand":
                    case"zoomNarrow":
                        s = (e = o, jn[(e || 5) - 1] || jn[4]);
                        break;
                    case"calPos":
                    case"delPos":
                    case"setPos":
                        r = (e = l, Nn[e - 1]);
                        break;
                    case"wiperClose":
                    case"wiperOpen":
                        i = 1
                }
                {
                    var n = t, h = (a = i, r), c = s;
                    let e = Buffer.alloc(8);
                    e[0] = 165, e[1] = 15, e[2] = 1, n && (e[3] = n), a && (e[4] = a), h && (e[5] = h), c && (e[6] = c), e[7] = (e[0] + e[1] + e[2] + e[3] + e[4] + e[5] + e[6]) % 256;
                    {
                        var u = e;
                        let i = "";
                        for (let t = 0; t < u.length; t++) {
                            let e = u[t].toString(16);
                            1 === e.length && (e = "0" + e), i += e.toUpperCase()
                        }
                        return i
                    }
                }
                return
            } else return void this.debug.warn("JbPro", "getPTZCmd() player is null");
            this.debug.warn("JbPro", "getPTZCmd() ptz is null")
        }

        downloadTempNakedFlowFile() {
            return new Promise((e, t) => {
                this.player ? (this.player.downloadNakedFlowFile(), e()) : t("player is not init")
            })
        }

        downloadTempFmp4File() {
            return new Promise((e, t) => {
                this.player ? (this.player.downloadFmp4File(), e()) : t("player is not init")
            })
        }

        downloadTempMpeg4File() {
            return new Promise((e, t) => {
                this.player ? (this.player.downloadMpeg4File(), e()) : t("player is not init")
            })
        }

        downloadTempRtpFile() {
            return new Promise((e, t) => {
                this.talk ? (this.talk.downloadRtpFile(), e()) : t("talk is not init")
            })
        }

        downloadMemoryLog() {
            this.memoryLogger && this.memoryLogger.download()
        }

        _getVideoLastIframeInfo() {
            var e = this.getVideoInfo() || {};
            return {
                loadingBackground: this.screenshot("", "png", .92, "base64"),
                loadingBackgroundWidth: e.width || 0,
                loadingBackgroundHeight: e.height || 0
            }
        }

        getExtendBtnList() {
            this.debug.log("JbPro", "getExtendBtnList()");
            let e = [];
            return this.player ? e = this.player.getExtendBtnList() : this.debug.warn("JbPro", "getExtendBtnList() player is null"), e
        }

        getFlvMetaData() {
            this.debug.log("JbPro", "getFlvMetaData()");
            let e = null;
            return this.player ? e = this.player.getMetaData() : this.debug.warn("JbPro", "getFlvMetaData() player is null"), e
        }
    }

    Vn.ERROR = S, Vn.EVENTS = fe, window.JessibucaPro = Vn, window.WebPlayerPro = Vn;

    class Kn extends e {
        constructor() {
            let t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            super(), this._opt = {}, Object.keys(t).forEach(e => {
                if (void 0 === t[e]) throw new Error(`Jessibuca-pro-multi option "${e}" can not be undefined`)
            });
            var e = di(nt);
            this._opt = Object.assign({}, e, t), this.LOG_TAG = "jessibucaProMulti";
            let i = t.container;
            if (!(i = "string" == typeof t.container ? document.querySelector(t.container) : i)) throw new Error("Jessibuca-pro-multi need container option");
            if ("CANVAS" === i.nodeName || "VIDEO" === i.nodeName) throw new Error(`Jessibuca-pro-multi container type can not be ${i.nodeName} type`);
            i.classList.add("jessibuca-multi-container"), this.maxWindowSize = this._opt.maxSplit * this._opt.maxSplit, this.currentWindowIndex = -1, this.specialLayoutType = null, this.windowList = [], this.$container = i, this.debug = new ut(this), this.events = new gi(this), this._initWindows(), this._initEvents(), this._handleWindowSelect(0), this._listenFullscreenChange()
        }

        destroy() {
            return new Promise((e, t) => {
                if (this.debug.log(this.LOG_TAG, "destroy()"), this.off(), this.events && (this.events.destroy(), this.events = null), this.specialLayoutType = null, this.windowList) {
                    const i = [];
                    this.windowList.forEach(e => {
                        e.$playerContainerEvents.forEach(e => {
                            e()
                        }), e.player && i.push(e.player.destroy())
                    }), Promise.all(i).then(() => {
                        this.windowList.forEach(e => {
                            e.player = null
                        }), this.windowList = [], e()
                    }).catch(e => {
                        t(e)
                    })
                } else e();
                this.debug && this.debug.log(this.LOG_TAG, "destroy")
            })
        }

        _createPlayer(e) {
            const i = this._findWindowItemIndex(e), t = this._opt,
                r = (t.supportDblclickContainerFullscreen && (t.supportDblclickFullscreen = !1), new Vn({
                    ...t,
                    isMulti: !0,
                    multiIndex: i,
                    container: e.$player
                }));
            return Object.keys(fe).forEach(t => {
                r.on(fe[t], e => {
                    this.emit(t, i, e)
                })
            }), r.on(w.close, () => {
                this.emit(w.close, i), e.player = null
            }), r
        }

        _initWindows() {
            const e = this._getContainerRect(), t = e.width, i = e.height;
            let r = "";
            var s, a, n, o, l = this._opt.split, d = t % l, h = i % l, c = (t - d - 2 * l) / l, u = (i - h - 2 * l) / l,
                p = (t - d) / l, f = (i - h) / l;
            for (let e = 0; e < this.maxWindowSize; e++) s = c + (e % l == l - 1 ? d : 0), a = u + (e + l >= Math.pow(l, 2) ? h : 0), n = p + (e % l == l - 1 ? d : 0), o = f + (e + l >= Math.pow(l, 2) ? h : 0), r += `
             <div class="jessibuca-multi-player" wid="${e}" style='float: left;position:relative;overflow: hidden; background-color:${this._opt.style.background};width: ${n + "px"};height: ${o + "px"}'>
                <div class="jessibuca-multi-player-draw-window" wid="${e}" style='position:absolute; z-index: 1; width:${s + "px"}; height:${a + "px"};border: 1px solid ${this._opt.style.border}'></div>
                <div class="jessibuca-multi-player-video-window" wid="${e}" style='position:absolute;left: 1px;top:1px; z-index: 2; width:${s + "px"}; height:${a + "px"};'></div>
             </div>
            `;
            var m = `<div class="jessibuca-multi-player-container" style="overflow: hidden;width:100%; height:100%; position: relative;">${r}</div>`,
                g = (this.$container.innerHTML = m, this.$container.querySelectorAll(".jessibuca-multi-player"));
            for (let e = 0; e < this.maxWindowSize; e++) {
                const t = g[e], i = t.querySelector(".jessibuca-multi-player-draw-window"),
                    r = t.querySelector(".jessibuca-multi-player-video-window");
                this.windowList[e] = {
                    uuid: Ut(),
                    isContainerFullscreen: !1,
                    $playerContainer: t,
                    $playerBorder: i,
                    $player: r,
                    $playerContainerEvents: [],
                    player: null
                }
            }
            for (let e = this._getCurrentMaxSplit(); e < this.maxWindowSize; e++) {
                const t = this.windowList[e];
                t.$player.style.display = "none", t.$playerBorder.style.display = "none", t.$playerContainer.style.width = "0", t.$playerContainer.style.height = "0"
            }
        }

        _initEvents() {
            const o = this.events["proxy"];
            this.windowList.forEach((e, t) => {
                var i = e.$playerContainer, r = o(i, "click", () => {
                    this.emit(ot.selected, t), this.getSelectedWindowIndex() === t && this.windowList[t].isContainerFullscreen || 1 !== this._opt.split && this._handleWindowSelect(t)
                }), s = o(i, "dblclick", () => {
                    this.emit(ot.dblSelected, t), this._opt.supportDblclickContainerFullscreen && 1 !== this._opt.split && this._handleWindowContainerFullscreen(t)
                }), a = o(i, "mouseup", () => {
                    this.emit(ot.mouseUp, t)
                }), n = o(i, "mouseover", () => {
                    this.emit(ot.mouseOver, t)
                }), i = o(i, "mouseout", () => {
                    this.emit(ot.mouseOut, t)
                });
                e.$playerContainerEvents = [r, a, n, i, s]
            })
        }

        _getContainerRect() {
            var e = this.$container.getBoundingClientRect();
            return {width: parseInt(e.width), height: parseInt(e.height)}
        }

        _updateWindows() {
            const s = this._getContainerRect(), a = s.width, n = s.height, o = this._opt.split, l = a % o, d = n % o,
                h = (a - l - 2 * o) / o, c = (n - d - 2 * o) / o, t = (a - l) / o, i = (n - d) / o;
            let u = this._getCurrentMaxSplit();
            for (let e = 0; e < u; e++) {
                const a = this.windowList[e], n = (a.isContainerFullscreen = !1, a.$playerContainer),
                    u = (n.style.position = "relative", n.style.left = "auto", n.style.top = "auto", n.style.zIndex = "auto", a.$playerBorder),
                    r = a.$player, p = h + (e % o == o - 1 ? l : 0), f = c + (e + o >= Math.pow(o, 2) ? d : 0),
                    m = t + (e % o == o - 1 ? l : 0), g = i + (e + o >= Math.pow(o, 2) ? d : 0);
                n.style.width = m + "px", n.style.height = g + "px", n.style.display = "block", r.style.width = p + "px", r.style.height = f + "px", r.style.display = "block", u.style.width = p + "px", u.style.height = f + "px", u.style.display = "block", a.player && a.player.resize()
            }
            if (this.specialLayoutType) {
                const s = this.windowList[0], a = s.$playerContainer, n = s.$player, o = s.$playerBorder,
                    l = a.style.width.replace("px", ""), d = a.style.height.replace("px", ""),
                    h = n.style.width.replace("px", ""), c = n.style.height.replace("px", "");
                let e, t, i, r;
                this.specialLayoutType === lt ? (e = 2 * l, t = 2 * d, i = 2 * h + 2, r = 2 * c + 2) : this.specialLayoutType === dt && (e = 3 * l, t = 3 * d, i = 3 * h + 4, r = 3 * c + 4), a.style.width = e + "px", a.style.height = t + "px", n.style.width = i + "px", n.style.height = r + "px", o.style.width = i + "px", o.style.height = r + "px", s.player && s.player.resize(), u = this._getSpecialMaxSplit()
            }
            for (let e = u; e < this.maxWindowSize; e++) {
                const a = this.windowList[e];
                a.player && (a.player.destroy(), a.player = null), a.$playerContainer.style.display = "none", a.$playerContainer.style.width = "0", a.$playerContainer.style.height = "0", a.$player.style.display = "none", a.$playerBorder.style.display = "none"
            }
            1 === this._opt.split && (this.windowList[0].$playerBorder.style.display = "none")
        }

        _handleWindowSelect(e) {
            const t = this.windowList[e];
            t ? (this.currentWindowIndex = e, 1 < this.windowList.length && (this.windowList.forEach(e => {
                t.$playerBorder.style.display = "block", e.$playerBorder.style.border = "1px solid " + this._opt.style.border
            }), t.$playerBorder.style.border = "1px solid " + this._opt.style.borderSelect)) : this.debug.warn(this.LOG_TAG, `_handleWindowSelect() ${e} is not exist`), 1 === this._opt.split && (t.$playerBorder.style.display = "none")
        }

        _handleWindowContainerFullscreen(e) {
            const t = this.windowList[e];
            if (t) {
                if (t.isContainerFullscreen) t.$playerContainer.style.position = "relative", t.$playerContainer.style.left = "auto", t.$playerContainer.style.top = "auto", t.$playerContainer.style.zIndex = "auto", t.$playerContainer.style.width = t.prevInfo.playerContainerWidth, t.$playerContainer.style.height = t.prevInfo.playerContainerHeight, t.$player.style.width = t.prevInfo.playerWidth, t.$player.style.height = t.prevInfo.playerHeight, this.getSelectedWindowIndex() === e && (t.$playerBorder.style.display = "block"); else {
                    const e = this._getContainerRect(), i = e.width, r = e.height;
                    t.prevInfo = {
                        playerContainerWidth: t.$playerContainer.style.width,
                        playerContainerHeight: t.$playerContainer.style.height,
                        playerWidth: t.$player.style.width,
                        playerHeight: t.$player.style.height
                    }, t.$playerContainer.style.position = "absolute", t.$playerContainer.style.top = "0", t.$playerContainer.style.left = "0", t.$playerContainer.style.zIndex = "10", t.$playerContainer.style.width = i + "px", t.$playerContainer.style.height = r + "px", t.$player.style.width = i + "px", t.$player.style.height = r + "px", t.$playerBorder.style.display = "none"
                }
                t.isContainerFullscreen = !t.isContainerFullscreen, t.player && t.player.resize()
            } else this.debug.warn(this.LOG_TAG, `handleWindowContainerFullscreen() ${e} is not exist`)
        }

        _handleFullscreenResize() {
            let t = this._getContainerRect(), i = 0;
            const r = setInterval(() => {
                var e = this._getContainerRect();
                if (e.width === t.width && e.height === t.height && 4 < i) return this.resize(), void clearInterval(r);
                t = e, i++
            }, 300)
        }

        _listenFullscreenChange() {
            try {
                const e = e => {
                    ei(e) === this.$container && (this.emit(fe.multiFullscreen, g.isFullscreen), g.isFullscreen ? this._handleFullscreenResize() : this.resize())
                };
                g.on("change", e), this.events.destroys.push(() => {
                    g.off("change", e)
                })
            } catch (e) {
            }
        }

        play(a, n, o) {
            return new Promise((t, i) => {
                h(n) && (o = n, n = {});
                const e = () => {
                    const e = this._createPlayer(s);
                    (s.player = e).play(a, n).then(() => {
                        t()
                    }).catch(e => {
                        i(e)
                    })
                };
                var r = h(o) ? o : this.currentWindowIndex;
                const s = this.windowList[r];
                s ? s.player ? s.player.destroy().then(() => {
                    s.player = null, e()
                }).catch(() => {
                }) : e() : i(`play() windowIndex ${r} is not exist`)
            })
        }

        getOption(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getOption() : (this.debug.warn(this.LOG_TAG, `getOption() windowIndex ${e} is not exist`), {})
        }

        setDebug(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setDebug(e) : this.debug.warn(this.LOG_TAG, `setDebug() windowIndex ${t} is not exist`)
        }

        mute(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.mute() : this.debug.warn(this.LOG_TAG, `mute() windowIndex ${e} is not exist`)
        }

        cancelMute(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.cancelMute() : this.debug.warn(this.LOG_TAG, `cancelMute() windowIndex ${e} is not exist`)
        }

        setVolume(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setVolume(e) : this.debug.warn(this.LOG_TAG, `setVolume() windowIndex ${t} is not exist`)
        }

        audioResume(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.audioResume() : this.debug.warn(this.LOG_TAG, `audioResume() windowIndex ${e} is not exist`)
        }

        setTimeout(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setTimeout(e) : this.debug.warn(this.LOG_TAG, `setTimeout() windowIndex ${t} is not exist`)
        }

        setScaleMode(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setScaleMode(e) : this.debug.warn(this.LOG_TAG, `setScaleMode() windowIndex ${t} is not exist`)
        }

        pause() {
            let r = 0 < arguments.length && void 0 !== arguments[0] && arguments[0],
                s = 1 < arguments.length ? arguments[1] : void 0;
            return new Promise((e, t) => {
                s = h(s) ? s : this.currentWindowIndex;
                const i = this.windowList[s];
                i && i.player ? i.player.pause(r).then(() => {
                    e()
                }).catch(e => {
                    t(e)
                }) : t(`pause() windowIndex ${s} is not exist`)
            })
        }

        close(r) {
            return new Promise((e, t) => {
                r = h(r) ? r : this.currentWindowIndex;
                const i = this.windowList[r];
                i && i.player ? i.player.close().then(() => {
                    e()
                }).catch(e => {
                    t(e)
                }) : t(`close() windowIndex ${r} is not exist`)
            })
        }

        clearView(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.clearView() : this.debug.warn(this.LOG_TAG, `clearView() windowIndex ${e} is not exist`)
        }

        setStreamQuality(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setStreamQuality(e) : this.debug.warn(this.LOG_TAG, `setStreamQuality() windowIndex ${t} is not exist`)
        }

        resize() {
            this._updateWindows()
        }

        setBufferTime(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setBufferTime(e) : this.debug.warn(this.LOG_TAG, `setBufferTime() windowIndex ${t} is not exist`)
        }

        setBufferDelayTime(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setBufferDelayTime(e) : this.debug.warn(this.LOG_TAG, `setBufferDelayTime() windowIndex ${t} is not exist`)
        }

        setRotate(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setRotate(e) : this.debug.warn(this.LOG_TAG, `setRotate() windowIndex ${t} is not exist`)
        }

        setMirrorRotate(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setMirrorRotate(e) : this.debug.warn(this.LOG_TAG, `setMirrorRotate() windowIndex ${t} is not exist`)
        }

        updateIsEmitSEI(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.updateIsEmitSEI(e) : this.debug.warn(this.LOG_TAG, `updateIsEmitSEI() windowIndex ${t} is not exist`)
        }

        setAspectRatio(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setAspectRatio(e) : this.debug.warn(this.LOG_TAG, `setAspectRatio() windowIndex ${t} is not exist`)
        }

        hasLoaded(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return !(!t || !t.player) && t.player.hasLoaded()
        }

        setKeepScreenOn(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.setKeepScreenOn() : this.debug.warn(this.LOG_TAG, `setKeepScreenOn() windowIndex ${e} is not exist`)
        }

        setFullscreen(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setFullscreen(e) : this.debug.warn(this.LOG_TAG, `setFullscreen() windowIndex ${t} is not exist`)
        }

        screenshot(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            return i && i.player ? i.player.screenshot(e.filename, e.format, e.quality, e.type) : null
        }

        screenshotWatermark(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            return i && i.player ? i.player.screenshotWatermark(e) : null
        }

        startRecord(r, s, a) {
            return new Promise((e, t) => {
                a = h(a) ? a : this.currentWindowIndex;
                const i = this.windowList[a];
                i && i.player ? i.player.startRecord(r, s).then(() => {
                    e()
                }).catch(e => {
                    t(e)
                }) : (this.debug.warn(this.LOG_TAG, `startRecord() windowIndex ${a} is not exist`), t(`windowIndex ${a} is not exist`))
            })
        }

        stopRecordAndSave(r, s, a) {
            return new Promise((t, i) => {
                a = h(a) ? a : this.currentWindowIndex;
                const e = this.windowList[a];
                e && e.player ? e.player.stopRecordAndSave(r, s).then(e => {
                    t(e)
                }).catch(e => {
                    i(e)
                }) : (this.debug.warn(this.LOG_TAG, `stopRecordAndSave() windowIndex ${a} is not exist`), i(`windowIndex ${a} is not exist`))
            })
        }

        isPlaying(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.isPlaying() : (this.debug.warn(this.LOG_TAG, `isPlaying() windowIndex ${e} is not exist`), !1)
        }

        isLoading(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.isLoading() : (this.debug.warn(this.LOG_TAG, `isLoading() windowIndex ${e} is not exist`), !1)
        }

        isPaused(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.isPaused() : (this.debug.warn(this.LOG_TAG, `windowIndex ${e} is not exist`), !1)
        }

        isMute(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.isMute() : (this.debug.warn(this.LOG_TAG, `isMute() windowIndex ${e} is not exist`), !1)
        }

        isRecording(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.isRecording() : (this.debug.warn(this.LOG_TAG, `isRecording() windowIndex ${e} is not exist`), !1)
        }

        clearBufferDelay(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.clearBufferDelay() : this.debug.warn(this.LOG_TAG, `clearBufferDelay() windowIndex ${e} is not exist`)
        }

        setNetworkDelayTime(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setNetworkDelayTime(e) : this.debug.warn(this.LOG_TAG, `setNetworkDelayTime() windowIndex ${t} is not exist`)
        }

        getDecodeType(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getDecodeType() : (this.debug.warn(this.LOG_TAG, `getDecodeType() windowIndex ${e} is not exist`), null)
        }

        getRenderType(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getRenderType() : (this.debug.warn(this.LOG_TAG, `windowIndex ${e} is not exist`), null)
        }

        getAudioEngineType(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getAudioEngineType() : (this.debug.warn(this.LOG_TAG, `windowIndex ${e} is not exist`), null)
        }

        getPlayingTimestamp(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getPlayingTimestamp() : (this.debug.warn(this.LOG_TAG, `windowIndex ${e} is not exist`), null)
        }

        getStatus(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getStatus() : (this.debug.warn(this.LOG_TAG, `getStatus() windowIndex ${e} is not exist`), null)
        }

        getPlayType(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getPlayType() : (this.debug.warn(this.LOG_TAG, `getPlayType() windowIndex ${e} is not exist`), null)
        }

        togglePerformancePanel(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.togglePerformancePanel(e) : this.debug.warn(this.LOG_TAG, `togglePerformancePanel() windowIndex ${t} is not exist`)
        }

        openZoom(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.openZoom() : this.debug.warn(this.LOG_TAG, `openZoom() windowIndex ${e} is not exist`)
        }

        closeZoom(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.closeZoom() : this.debug.warn(this.LOG_TAG, `closeZoom() windowIndex ${e} is not exist`)
        }

        isZoomOpen(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.isZoomOpen() : (this.debug.warn(this.LOG_TAG, `isZoomOpen() windowIndex ${e} is not exist`), !1)
        }

        expandZoom(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.expandZoom() : this.debug.warn(this.LOG_TAG, `expandZoom() windowIndex ${e} is not exist`)
        }

        narrowZoom(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.narrowZoom() : this.debug.warn(this.LOG_TAG, `narrowZoom() windowIndex ${e} is not exist`)
        }

        getCurrentZoomIndex(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getCurrentZoomIndex() : (this.debug.warn(this.LOG_TAG, `getCurrentZoomIndex() windowIndex ${e} is not exist`), 0)
        }

        setNakedFlowFps(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setNakedFlowFps(e) : this.debug.warn(this.LOG_TAG, `setNakedFlowFps() windowIndex ${t} is not exist`)
        }

        updateDebugLevel(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.updateDebugLevel(e) : this.debug.warn(this.LOG_TAG, `updateDebugLevel() windowIndex ${t} is not exist`)
        }

        updateWatermark(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.updateWatermark(e) : this.debug.warn(this.LOG_TAG, `updateWatermark() windowIndex ${t} is not exist`)
        }

        removeWatermark(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.removeWatermark() : this.debug.warn(this.LOG_TAG, `removeWatermark() windowIndex ${e} is not exist`)
        }

        updateFullscreenWatermark(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.updateFullscreenWatermark(e) : this.debug.warn(this.LOG_TAG, `updateFullscreenWatermark() windowIndex ${t} is not exist`)
        }

        removeFullscreenWatermark(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.removeFullscreenWatermark() : this.debug.warn(this.LOG_TAG, `removeFullscreenWatermark() windowIndex ${e} is not exist`)
        }

        faceDetectOpen(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.faceDetectOpen() : this.debug.warn(this.LOG_TAG, `faceDetectOpen() windowIndex ${e} is not exist`)
        }

        faceDetectClose(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.faceDetectClose() : this.debug.warn(this.LOG_TAG, `faceDetectClose() windowIndex ${e} is not exist`)
        }

        objectDetectOpen(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.objectDetectOpen() : this.debug.warn(this.LOG_TAG, `objectDetectOpen() windowIndex ${e} is not exist`)
        }

        objectDetectClose(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.objectDetectClose() : this.debug.warn(this.LOG_TAG, `objectDetectClose() windowIndex ${e} is not exist`)
        }

        sendWebsocketMessage(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.sendWebsocketMessage(e) : this.debug.warn(this.LOG_TAG, `sendWebsocketMessage() windowIndex ${t} is not exist`)
        }

        addContentToCanvas(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.addContentToCanvas(e) : this.debug.warn(this.LOG_TAG, `addContentToCanvas() windowIndex ${t} is not exist`)
        }

        clearContentToCanvas(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.clearContentToCanvas() : this.debug.warn(this.LOG_TAG, `clearContentToCanvas() windowIndex ${e} is not exist`)
        }

        setControlHtml(e, t) {
            t = h(t) ? t : this.currentWindowIndex;
            const i = this.windowList[t];
            i && i.player ? i.player.setControlHtml(e) : this.debug.warn(this.LOG_TAG, `setControlHtml() windowIndex ${t} is not exist`)
        }

        clearControlHtml(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            t && t.player ? t.player.clearControlHtml() : this.debug.warn(this.LOG_TAG, `clearControlHtml() windowIndex ${e} is not exist`)
        }

        getFlvMetaData(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getFlvMetaData() : (this.debug.warn(this.LOG_TAG, `getFlvMetaData() windowIndex ${e} is not exist`), null)
        }

        getExtendBtnList(e) {
            e = h(e) ? e : this.currentWindowIndex;
            const t = this.windowList[e];
            return t && t.player ? t.player.getExtendBtnList() : (this.debug.warn(this.LOG_TAG, `getExtendBtnList() windowIndex ${e} is not exist`), null)
        }

        destroySingle(r) {
            return new Promise((e, t) => {
                r = h(r) ? r : this.currentWindowIndex;
                const i = this.windowList[r];
                i ? i.player && i.player.destroy().then(() => {
                    i.player = null, e()
                }).catch(e => {
                    t(e)
                }) : (t("windowIndex is not exist"), this.debug.warn(this.LOG_TAG, `destroySingle() windowIndex ${r} is not exist`))
            })
        }

        setFullscreenMulti(i) {
            return new Promise((e, t) => {
                if (this.debug.log(this.LOG_TAG, "setFullscreenMulti", i), i) try {
                    g.request(this.$container).then(() => {
                        e()
                    }).catch(e => {
                        this.debug.error(this.LOG_TAG, "fullscreen request inner error", e), t(e)
                    })
                } catch (e) {
                    this.debug.error(this.LOG_TAG, "fullscreen request error", e), t(e)
                } else try {
                    g.exit().then(() => {
                        e()
                    }).catch(e => {
                        this.debug.error(this.LOG_TAG, "fullscreen exit inner error", e), t(e)
                    })
                } catch (e) {
                    this.debug.error(this.LOG_TAG, "fullscreen exit error", e), t(e)
                }
            })
        }

        selectWindow(e) {
            this.debug.log(this.LOG_TAG, "selectWindow", e), this._handleWindowSelect(e)
        }

        arrangeWindow(e) {
            this.debug.log(this.LOG_TAG, "arrangeWindow", e), e ? [lt, dt].includes(e) ? this._arrangeSpecialWindow(e) : this._opt.split === e && null === this.specialLayoutType ? this.debug.warn(this.LOG_TAG, `arrangeWindow() split ${e} is not changed`) : (this.specialLayoutType = null, this._arrangeWindow(e)) : this.debug.warn(this.LOG_TAG, `arrangeWindow() split ${e} is not valid`)
        }

        _arrangeWindow(e) {
            (e = Bt(e)) < 1 || !h(e) ? this.debug.warn(this.LOG_TAG, `arrangeWindow() split ${e} is not valid`) : (e > this._opt.maxSplit && (e = this._opt.maxSplit), this._opt.split = e, this.currentWindowIndex = 0, this._updateWindows(), this._handleWindowSelect(this.currentWindowIndex))
        }

        _arrangeSpecialWindow(e) {
            this._opt.maxSplit <= 3 && e === dt || this._opt.maxSplit <= 2 && e === lt ? this.debug.warn(this.LOG_TAG, `_arrangeSpecialWindow() type ${e} is not valid because maxSplit is ` + this._opt.maxSplit) : this.specialLayoutType && this.specialLayoutType === e ? this.debug.warn(this.LOG_TAG, `_arrangeSpecialWindow() type ${e} is not changed`) : (this.specialLayoutType = e) === lt ? this._arrangeWindow(3) : e === dt ? this._arrangeWindow(4) : this.debug.warn(this.LOG_TAG, `_arrangeSpecialWindow() type ${e} is not valid`)
        }

        getCurrentSplit() {
            return this.specialLayoutType || this._opt.split
        }

        _getCurrentMaxSplit() {
            if (this.specialLayoutType) {
                let e = 0;
                return this.specialLayoutType === lt ? e = 9 : this.specialLayoutType === dt && (e = 16), e
            }
            return this._opt.split * this._opt.split
        }

        _getSpecialMaxSplit() {
            let e = 0;
            return this.specialLayoutType === lt ? e = 6 : this.specialLayoutType === dt && (e = 8), e
        }

        getSelectedWindowIndex() {
            return this.currentWindowIndex
        }

        _findWindowItemIndex(t) {
            return this.windowList.findIndex(e => e.uuid === t.uuid)
        }
    }

    Kn.MULTI_EVENTS = ot, Kn.EVENTS = w, Kn.ERROR = S, window.JessibucaProMulti = Kn, window.WebPlayerProMulti = Kn
});
